var p2 = Object.defineProperty;
var m2 = (e, t, r) => t in e ? p2(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r;
var b = (e, t, r) => (m2(e, typeof t != "symbol" ? t + "" : t, r),
r);
const g2 = "modulepreload"
  , _2 = function(e) {
    return "/" + e
}
  , P1 = {}
  , y2 = function(t, r, i) {
    if (!r || r.length === 0)
        return t();
    const n = document.getElementsByTagName("link");
    return Promise.all(r.map(s => {
        if (s = _2(s),
        s in P1)
            return;
        P1[s] = !0;
        const o = s.endsWith(".css")
          , a = o ? '[rel="stylesheet"]' : "";
        if (!!i)
            for (let u = n.length - 1; u >= 0; u--) {
                const c = n[u];
                if (c.href === s && (!o || c.rel === "stylesheet"))
                    return
            }
        else if (document.querySelector(`link[href="${s}"]${a}`))
            return;
        const h = document.createElement("link");
        if (h.rel = o ? "stylesheet" : g2,
        o || (h.as = "script",
        h.crossOrigin = ""),
        h.href = s,
        document.head.appendChild(h),
        o)
            return new Promise( (u, c) => {
                h.addEventListener("load", u),
                h.addEventListener("error", () => c(new Error(`Unable to preload CSS for ${s}`)))
            }
            )
    }
    )).then( () => t())
};
var v2 = typeof window < "u" ? window : typeof rh < "u" ? rh : typeof self < "u" ? self : {};
v2.SENTRY_RELEASE = {
    id: "18ea361f9e8d9fb5a9763cc0a257f43b1060e561"
};
var rh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function hl(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
function x2(e) {
    if (e.__esModule)
        return e;
    var t = e.default;
    if (typeof t == "function") {
        var r = function i() {
            if (this instanceof i) {
                var n = [null];
                n.push.apply(n, arguments);
                var s = Function.bind.apply(t, n);
                return new s
            }
            return t.apply(this, arguments)
        };
        r.prototype = t.prototype
    } else
        r = {};
    return Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    Object.keys(e).forEach(function(i) {
        var n = Object.getOwnPropertyDescriptor(e, i);
        Object.defineProperty(r, i, n.get ? n : {
            enumerable: !0,
            get: function() {
                return e[i]
            }
        })
    }),
    r
}
var iA = {
    exports: {}
}
  , pt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wu = Symbol.for("react.element")
  , E2 = Symbol.for("react.portal")
  , T2 = Symbol.for("react.fragment")
  , S2 = Symbol.for("react.strict_mode")
  , w2 = Symbol.for("react.profiler")
  , A2 = Symbol.for("react.provider")
  , b2 = Symbol.for("react.context")
  , C2 = Symbol.for("react.forward_ref")
  , P2 = Symbol.for("react.suspense")
  , I2 = Symbol.for("react.memo")
  , R2 = Symbol.for("react.lazy")
  , I1 = Symbol.iterator;
function M2(e) {
    return e === null || typeof e != "object" ? null : (e = I1 && e[I1] || e["@@iterator"],
    typeof e == "function" ? e : null)
}
var nA = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , sA = Object.assign
  , oA = {};
function ul(e, t, r) {
    this.props = e,
    this.context = t,
    this.refs = oA,
    this.updater = r || nA
}
ul.prototype.isReactComponent = {};
ul.prototype.setState = function(e, t) {
    if (typeof e != "object" && typeof e != "function" && e != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, e, t, "setState")
}
;
ul.prototype.forceUpdate = function(e) {
    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
}
;
function aA() {}
aA.prototype = ul.prototype;
function py(e, t, r) {
    this.props = e,
    this.context = t,
    this.refs = oA,
    this.updater = r || nA
}
var my = py.prototype = new aA;
my.constructor = py;
sA(my, ul.prototype);
my.isPureReactComponent = !0;
var R1 = Array.isArray
  , lA = Object.prototype.hasOwnProperty
  , gy = {
    current: null
}
  , hA = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function uA(e, t, r) {
    var i, n = {}, s = null, o = null;
    if (t != null)
        for (i in t.ref !== void 0 && (o = t.ref),
        t.key !== void 0 && (s = "" + t.key),
        t)
            lA.call(t, i) && !hA.hasOwnProperty(i) && (n[i] = t[i]);
    var a = arguments.length - 2;
    if (a === 1)
        n.children = r;
    else if (1 < a) {
        for (var l = Array(a), h = 0; h < a; h++)
            l[h] = arguments[h + 2];
        n.children = l
    }
    if (e && e.defaultProps)
        for (i in a = e.defaultProps,
        a)
            n[i] === void 0 && (n[i] = a[i]);
    return {
        $$typeof: wu,
        type: e,
        key: s,
        ref: o,
        props: n,
        _owner: gy.current
    }
}
function O2(e, t) {
    return {
        $$typeof: wu,
        type: e.type,
        key: t,
        ref: e.ref,
        props: e.props,
        _owner: e._owner
    }
}
function _y(e) {
    return typeof e == "object" && e !== null && e.$$typeof === wu
}
function N2(e) {
    var t = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + e.replace(/[=:]/g, function(r) {
        return t[r]
    })
}
var M1 = /\/+/g;
function Xp(e, t) {
    return typeof e == "object" && e !== null && e.key != null ? N2("" + e.key) : t.toString(36)
}
function Jc(e, t, r, i, n) {
    var s = typeof e;
    (s === "undefined" || s === "boolean") && (e = null);
    var o = !1;
    if (e === null)
        o = !0;
    else
        switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (e.$$typeof) {
            case wu:
            case E2:
                o = !0
            }
        }
    if (o)
        return o = e,
        n = n(o),
        e = i === "" ? "." + Xp(o, 0) : i,
        R1(n) ? (r = "",
        e != null && (r = e.replace(M1, "$&/") + "/"),
        Jc(n, t, r, "", function(h) {
            return h
        })) : n != null && (_y(n) && (n = O2(n, r + (!n.key || o && o.key === n.key ? "" : ("" + n.key).replace(M1, "$&/") + "/") + e)),
        t.push(n)),
        1;
    if (o = 0,
    i = i === "" ? "." : i + ":",
    R1(e))
        for (var a = 0; a < e.length; a++) {
            s = e[a];
            var l = i + Xp(s, a);
            o += Jc(s, t, r, l, n)
        }
    else if (l = M2(e),
    typeof l == "function")
        for (e = l.call(e),
        a = 0; !(s = e.next()).done; )
            s = s.value,
            l = i + Xp(s, a++),
            o += Jc(s, t, r, l, n);
    else if (s === "object")
        throw t = String(e),
        Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function Zu(e, t, r) {
    if (e == null)
        return e;
    var i = []
      , n = 0;
    return Jc(e, i, "", "", function(s) {
        return t.call(r, s, n++)
    }),
    i
}
function L2(e) {
    if (e._status === -1) {
        var t = e._result;
        t = t(),
        t.then(function(r) {
            (e._status === 0 || e._status === -1) && (e._status = 1,
            e._result = r)
        }, function(r) {
            (e._status === 0 || e._status === -1) && (e._status = 2,
            e._result = r)
        }),
        e._status === -1 && (e._status = 0,
        e._result = t)
    }
    if (e._status === 1)
        return e._result.default;
    throw e._result
}
var rr = {
    current: null
}
  , td = {
    transition: null
}
  , D2 = {
    ReactCurrentDispatcher: rr,
    ReactCurrentBatchConfig: td,
    ReactCurrentOwner: gy
};
pt.Children = {
    map: Zu,
    forEach: function(e, t, r) {
        Zu(e, function() {
            t.apply(this, arguments)
        }, r)
    },
    count: function(e) {
        var t = 0;
        return Zu(e, function() {
            t++
        }),
        t
    },
    toArray: function(e) {
        return Zu(e, function(t) {
            return t
        }) || []
    },
    only: function(e) {
        if (!_y(e))
            throw Error("React.Children.only expected to receive a single React element child.");
        return e
    }
};
pt.Component = ul;
pt.Fragment = T2;
pt.Profiler = w2;
pt.PureComponent = py;
pt.StrictMode = S2;
pt.Suspense = P2;
pt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = D2;
pt.cloneElement = function(e, t, r) {
    if (e == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
    var i = sA({}, e.props)
      , n = e.key
      , s = e.ref
      , o = e._owner;
    if (t != null) {
        if (t.ref !== void 0 && (s = t.ref,
        o = gy.current),
        t.key !== void 0 && (n = "" + t.key),
        e.type && e.type.defaultProps)
            var a = e.type.defaultProps;
        for (l in t)
            lA.call(t, l) && !hA.hasOwnProperty(l) && (i[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        i.children = r;
    else if (1 < l) {
        a = Array(l);
        for (var h = 0; h < l; h++)
            a[h] = arguments[h + 2];
        i.children = a
    }
    return {
        $$typeof: wu,
        type: e.type,
        key: n,
        ref: s,
        props: i,
        _owner: o
    }
}
;
pt.createContext = function(e) {
    return e = {
        $$typeof: b2,
        _currentValue: e,
        _currentValue2: e,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    e.Provider = {
        $$typeof: A2,
        _context: e
    },
    e.Consumer = e
}
;
pt.createElement = uA;
pt.createFactory = function(e) {
    var t = uA.bind(null, e);
    return t.type = e,
    t
}
;
pt.createRef = function() {
    return {
        current: null
    }
}
;
pt.forwardRef = function(e) {
    return {
        $$typeof: C2,
        render: e
    }
}
;
pt.isValidElement = _y;
pt.lazy = function(e) {
    return {
        $$typeof: R2,
        _payload: {
            _status: -1,
            _result: e
        },
        _init: L2
    }
}
;
pt.memo = function(e, t) {
    return {
        $$typeof: I2,
        type: e,
        compare: t === void 0 ? null : t
    }
}
;
pt.startTransition = function(e) {
    var t = td.transition;
    td.transition = {};
    try {
        e()
    } finally {
        td.transition = t
    }
}
;
pt.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
pt.useCallback = function(e, t) {
    return rr.current.useCallback(e, t)
}
;
pt.useContext = function(e) {
    return rr.current.useContext(e)
}
;
pt.useDebugValue = function() {}
;
pt.useDeferredValue = function(e) {
    return rr.current.useDeferredValue(e)
}
;
pt.useEffect = function(e, t) {
    return rr.current.useEffect(e, t)
}
;
pt.useId = function() {
    return rr.current.useId()
}
;
pt.useImperativeHandle = function(e, t, r) {
    return rr.current.useImperativeHandle(e, t, r)
}
;
pt.useInsertionEffect = function(e, t) {
    return rr.current.useInsertionEffect(e, t)
}
;
pt.useLayoutEffect = function(e, t) {
    return rr.current.useLayoutEffect(e, t)
}
;
pt.useMemo = function(e, t) {
    return rr.current.useMemo(e, t)
}
;
pt.useReducer = function(e, t, r) {
    return rr.current.useReducer(e, t, r)
}
;
pt.useRef = function(e) {
    return rr.current.useRef(e)
}
;
pt.useState = function(e) {
    return rr.current.useState(e)
}
;
pt.useSyncExternalStore = function(e, t, r) {
    return rr.current.useSyncExternalStore(e, t, r)
}
;
pt.useTransition = function() {
    return rr.current.useTransition()
}
;
pt.version = "18.2.0";
iA.exports = pt;
var ae = iA.exports;
const kX = hl(ae);
var Rd = {}
  , B2 = e => encodeURIComponent(e).replace(/[!'()*]/g, t => `%${t.charCodeAt(0).toString(16).toUpperCase()}`)
  , cA = "%[a-f0-9]{2}"
  , O1 = new RegExp("(" + cA + ")|([^%]+?)","gi")
  , N1 = new RegExp("(" + cA + ")+","gi");
function Og(e, t) {
    try {
        return [decodeURIComponent(e.join(""))]
    } catch {}
    if (e.length === 1)
        return e;
    t = t || 1;
    var r = e.slice(0, t)
      , i = e.slice(t);
    return Array.prototype.concat.call([], Og(r), Og(i))
}
function k2(e) {
    try {
        return decodeURIComponent(e)
    } catch {
        for (var t = e.match(O1) || [], r = 1; r < t.length; r++)
            e = Og(t, r).join(""),
            t = e.match(O1) || [];
        return e
    }
}
function F2(e) {
    for (var t = {
        "%FE%FF": "��",
        "%FF%FE": "��"
    }, r = N1.exec(e); r; ) {
        try {
            t[r[0]] = decodeURIComponent(r[0])
        } catch {
            var i = k2(r[0]);
            i !== r[0] && (t[r[0]] = i)
        }
        r = N1.exec(e)
    }
    t["%C2"] = "�";
    for (var n = Object.keys(t), s = 0; s < n.length; s++) {
        var o = n[s];
        e = e.replace(new RegExp(o,"g"), t[o])
    }
    return e
}
var U2 = function(e) {
    if (typeof e != "string")
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof e + "`");
    try {
        return e = e.replace(/\+/g, " "),
        decodeURIComponent(e)
    } catch {
        return F2(e)
    }
}
  , G2 = (e, t) => {
    if (!(typeof e == "string" && typeof t == "string"))
        throw new TypeError("Expected the arguments to be of type `string`");
    if (t === "")
        return [e];
    const r = e.indexOf(t);
    return r === -1 ? [e] : [e.slice(0, r), e.slice(r + t.length)]
}
  , H2 = function(e, t) {
    for (var r = {}, i = Object.keys(e), n = Array.isArray(t), s = 0; s < i.length; s++) {
        var o = i[s]
          , a = e[o];
        (n ? t.indexOf(o) !== -1 : t(o, a, e)) && (r[o] = a)
    }
    return r
};
(function(e) {
    const t = B2
      , r = U2
      , i = G2
      , n = H2
      , s = m => m == null
      , o = Symbol("encodeFragmentIdentifier");
    function a(m) {
        switch (m.arrayFormat) {
        case "index":
            return _ => (x, E) => {
                const S = x.length;
                return E === void 0 || m.skipNull && E === null || m.skipEmptyString && E === "" ? x : E === null ? [...x, [u(_, m), "[", S, "]"].join("")] : [...x, [u(_, m), "[", u(S, m), "]=", u(E, m)].join("")]
            }
            ;
        case "bracket":
            return _ => (x, E) => E === void 0 || m.skipNull && E === null || m.skipEmptyString && E === "" ? x : E === null ? [...x, [u(_, m), "[]"].join("")] : [...x, [u(_, m), "[]=", u(E, m)].join("")];
        case "colon-list-separator":
            return _ => (x, E) => E === void 0 || m.skipNull && E === null || m.skipEmptyString && E === "" ? x : E === null ? [...x, [u(_, m), ":list="].join("")] : [...x, [u(_, m), ":list=", u(E, m)].join("")];
        case "comma":
        case "separator":
        case "bracket-separator":
            {
                const _ = m.arrayFormat === "bracket-separator" ? "[]=" : "=";
                return x => (E, S) => S === void 0 || m.skipNull && S === null || m.skipEmptyString && S === "" ? E : (S = S === null ? "" : S,
                E.length === 0 ? [[u(x, m), _, u(S, m)].join("")] : [[E, u(S, m)].join(m.arrayFormatSeparator)])
            }
        default:
            return _ => (x, E) => E === void 0 || m.skipNull && E === null || m.skipEmptyString && E === "" ? x : E === null ? [...x, u(_, m)] : [...x, [u(_, m), "=", u(E, m)].join("")]
        }
    }
    function l(m) {
        let _;
        switch (m.arrayFormat) {
        case "index":
            return (x, E, S) => {
                if (_ = /\[(\d*)\]$/.exec(x),
                x = x.replace(/\[\d*\]$/, ""),
                !_) {
                    S[x] = E;
                    return
                }
                S[x] === void 0 && (S[x] = {}),
                S[x][_[1]] = E
            }
            ;
        case "bracket":
            return (x, E, S) => {
                if (_ = /(\[\])$/.exec(x),
                x = x.replace(/\[\]$/, ""),
                !_) {
                    S[x] = E;
                    return
                }
                if (S[x] === void 0) {
                    S[x] = [E];
                    return
                }
                S[x] = [].concat(S[x], E)
            }
            ;
        case "colon-list-separator":
            return (x, E, S) => {
                if (_ = /(:list)$/.exec(x),
                x = x.replace(/:list$/, ""),
                !_) {
                    S[x] = E;
                    return
                }
                if (S[x] === void 0) {
                    S[x] = [E];
                    return
                }
                S[x] = [].concat(S[x], E)
            }
            ;
        case "comma":
        case "separator":
            return (x, E, S) => {
                const w = typeof E == "string" && E.includes(m.arrayFormatSeparator)
                  , T = typeof E == "string" && !w && c(E, m).includes(m.arrayFormatSeparator);
                E = T ? c(E, m) : E;
                const C = w || T ? E.split(m.arrayFormatSeparator).map(R => c(R, m)) : E === null ? E : c(E, m);
                S[x] = C
            }
            ;
        case "bracket-separator":
            return (x, E, S) => {
                const w = /(\[\])$/.test(x);
                if (x = x.replace(/\[\]$/, ""),
                !w) {
                    S[x] = E && c(E, m);
                    return
                }
                const T = E === null ? [] : E.split(m.arrayFormatSeparator).map(C => c(C, m));
                if (S[x] === void 0) {
                    S[x] = T;
                    return
                }
                S[x] = [].concat(S[x], T)
            }
            ;
        default:
            return (x, E, S) => {
                if (S[x] === void 0) {
                    S[x] = E;
                    return
                }
                S[x] = [].concat(S[x], E)
            }
        }
    }
    function h(m) {
        if (typeof m != "string" || m.length !== 1)
            throw new TypeError("arrayFormatSeparator must be single character string")
    }
    function u(m, _) {
        return _.encode ? _.strict ? t(m) : encodeURIComponent(m) : m
    }
    function c(m, _) {
        return _.decode ? r(m) : m
    }
    function d(m) {
        return Array.isArray(m) ? m.sort() : typeof m == "object" ? d(Object.keys(m)).sort( (_, x) => Number(_) - Number(x)).map(_ => m[_]) : m
    }
    function f(m) {
        const _ = m.indexOf("#");
        return _ !== -1 && (m = m.slice(0, _)),
        m
    }
    function g(m) {
        let _ = "";
        const x = m.indexOf("#");
        return x !== -1 && (_ = m.slice(x)),
        _
    }
    function p(m) {
        m = f(m);
        const _ = m.indexOf("?");
        return _ === -1 ? "" : m.slice(_ + 1)
    }
    function v(m, _) {
        return _.parseNumbers && !Number.isNaN(Number(m)) && typeof m == "string" && m.trim() !== "" ? m = Number(m) : _.parseBooleans && m !== null && (m.toLowerCase() === "true" || m.toLowerCase() === "false") && (m = m.toLowerCase() === "true"),
        m
    }
    function y(m, _) {
        _ = Object.assign({
            decode: !0,
            sort: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ",",
            parseNumbers: !1,
            parseBooleans: !1
        }, _),
        h(_.arrayFormatSeparator);
        const x = l(_)
          , E = Object.create(null);
        if (typeof m != "string" || (m = m.trim().replace(/^[?#&]/, ""),
        !m))
            return E;
        for (const S of m.split("&")) {
            if (S === "")
                continue;
            let[w,T] = i(_.decode ? S.replace(/\+/g, " ") : S, "=");
            T = T === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(_.arrayFormat) ? T : c(T, _),
            x(c(w, _), T, E)
        }
        for (const S of Object.keys(E)) {
            const w = E[S];
            if (typeof w == "object" && w !== null)
                for (const T of Object.keys(w))
                    w[T] = v(w[T], _);
            else
                E[S] = v(w, _)
        }
        return _.sort === !1 ? E : (_.sort === !0 ? Object.keys(E).sort() : Object.keys(E).sort(_.sort)).reduce( (S, w) => {
            const T = E[w];
            return T && typeof T == "object" && !Array.isArray(T) ? S[w] = d(T) : S[w] = T,
            S
        }
        , Object.create(null))
    }
    e.extract = p,
    e.parse = y,
    e.stringify = (m, _) => {
        if (!m)
            return "";
        _ = Object.assign({
            encode: !0,
            strict: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ","
        }, _),
        h(_.arrayFormatSeparator);
        const x = T => _.skipNull && s(m[T]) || _.skipEmptyString && m[T] === ""
          , E = a(_)
          , S = {};
        for (const T of Object.keys(m))
            x(T) || (S[T] = m[T]);
        const w = Object.keys(S);
        return _.sort !== !1 && w.sort(_.sort),
        w.map(T => {
            const C = m[T];
            return C === void 0 ? "" : C === null ? u(T, _) : Array.isArray(C) ? C.length === 0 && _.arrayFormat === "bracket-separator" ? u(T, _) + "[]" : C.reduce(E(T), []).join("&") : u(T, _) + "=" + u(C, _)
        }
        ).filter(T => T.length > 0).join("&")
    }
    ,
    e.parseUrl = (m, _) => {
        _ = Object.assign({
            decode: !0
        }, _);
        const [x,E] = i(m, "#");
        return Object.assign({
            url: x.split("?")[0] || "",
            query: y(p(m), _)
        }, _ && _.parseFragmentIdentifier && E ? {
            fragmentIdentifier: c(E, _)
        } : {})
    }
    ,
    e.stringifyUrl = (m, _) => {
        _ = Object.assign({
            encode: !0,
            strict: !0,
            [o]: !0
        }, _);
        const x = f(m.url).split("?")[0] || ""
          , E = e.extract(m.url)
          , S = e.parse(E, {
            sort: !1
        })
          , w = Object.assign(S, m.query);
        let T = e.stringify(w, _);
        T && (T = `?${T}`);
        let C = g(m.url);
        return m.fragmentIdentifier && (C = `#${_[o] ? u(m.fragmentIdentifier, _) : m.fragmentIdentifier}`),
        `${x}${T}${C}`
    }
    ,
    e.pick = (m, _, x) => {
        x = Object.assign({
            parseFragmentIdentifier: !0,
            [o]: !1
        }, x);
        const {url: E, query: S, fragmentIdentifier: w} = e.parseUrl(m, x);
        return e.stringifyUrl({
            url: E,
            query: n(S, _),
            fragmentIdentifier: w
        }, x)
    }
    ,
    e.exclude = (m, _, x) => {
        const E = Array.isArray(_) ? S => !_.includes(S) : (S, w) => !_(S, w);
        return e.pick(m, E, x)
    }
}
)(Rd);
const Md = hl(Rd);
var dA = {
    exports: {}
}
  , kr = {}
  , fA = {
    exports: {}
}
  , pA = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(e) {
    function t(L, $) {
        var I = L.length;
        L.push($);
        t: for (; 0 < I; ) {
            var H = I - 1 >>> 1
              , K = L[H];
            if (0 < n(K, $))
                L[H] = $,
                L[I] = K,
                I = H;
            else
                break t
        }
    }
    function r(L) {
        return L.length === 0 ? null : L[0]
    }
    function i(L) {
        if (L.length === 0)
            return null;
        var $ = L[0]
          , I = L.pop();
        if (I !== $) {
            L[0] = I;
            t: for (var H = 0, K = L.length, ct = K >>> 1; H < ct; ) {
                var rt = 2 * (H + 1) - 1
                  , Et = L[rt]
                  , bt = rt + 1
                  , Wt = L[bt];
                if (0 > n(Et, I))
                    bt < K && 0 > n(Wt, Et) ? (L[H] = Wt,
                    L[bt] = I,
                    H = bt) : (L[H] = Et,
                    L[rt] = I,
                    H = rt);
                else if (bt < K && 0 > n(Wt, I))
                    L[H] = Wt,
                    L[bt] = I,
                    H = bt;
                else
                    break t
            }
        }
        return $
    }
    function n(L, $) {
        var I = L.sortIndex - $.sortIndex;
        return I !== 0 ? I : L.id - $.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        e.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        e.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , h = []
      , u = 1
      , c = null
      , d = 3
      , f = !1
      , g = !1
      , p = !1
      , v = typeof setTimeout == "function" ? setTimeout : null
      , y = typeof clearTimeout == "function" ? clearTimeout : null
      , m = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function _(L) {
        for (var $ = r(h); $ !== null; ) {
            if ($.callback === null)
                i(h);
            else if ($.startTime <= L)
                i(h),
                $.sortIndex = $.expirationTime,
                t(l, $);
            else
                break;
            $ = r(h)
        }
    }
    function x(L) {
        if (p = !1,
        _(L),
        !g)
            if (r(l) !== null)
                g = !0,
                X(E);
            else {
                var $ = r(h);
                $ !== null && k(x, $.startTime - L)
            }
    }
    function E(L, $) {
        g = !1,
        p && (p = !1,
        y(T),
        T = -1),
        f = !0;
        var I = d;
        try {
            for (_($),
            c = r(l); c !== null && (!(c.expirationTime > $) || L && !O()); ) {
                var H = c.callback;
                if (typeof H == "function") {
                    c.callback = null,
                    d = c.priorityLevel;
                    var K = H(c.expirationTime <= $);
                    $ = e.unstable_now(),
                    typeof K == "function" ? c.callback = K : c === r(l) && i(l),
                    _($)
                } else
                    i(l);
                c = r(l)
            }
            if (c !== null)
                var ct = !0;
            else {
                var rt = r(h);
                rt !== null && k(x, rt.startTime - $),
                ct = !1
            }
            return ct
        } finally {
            c = null,
            d = I,
            f = !1
        }
    }
    var S = !1
      , w = null
      , T = -1
      , C = 5
      , R = -1;
    function O() {
        return !(e.unstable_now() - R < C)
    }
    function N() {
        if (w !== null) {
            var L = e.unstable_now();
            R = L;
            var $ = !0;
            try {
                $ = w(!0, L)
            } finally {
                $ ? P() : (S = !1,
                w = null)
            }
        } else
            S = !1
    }
    var P;
    if (typeof m == "function")
        P = function() {
            m(N)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var M = new MessageChannel
          , V = M.port2;
        M.port1.onmessage = N,
        P = function() {
            V.postMessage(null)
        }
    } else
        P = function() {
            v(N, 0)
        }
        ;
    function X(L) {
        w = L,
        S || (S = !0,
        P())
    }
    function k(L, $) {
        T = v(function() {
            L(e.unstable_now())
        }, $)
    }
    e.unstable_IdlePriority = 5,
    e.unstable_ImmediatePriority = 1,
    e.unstable_LowPriority = 4,
    e.unstable_NormalPriority = 3,
    e.unstable_Profiling = null,
    e.unstable_UserBlockingPriority = 2,
    e.unstable_cancelCallback = function(L) {
        L.callback = null
    }
    ,
    e.unstable_continueExecution = function() {
        g || f || (g = !0,
        X(E))
    }
    ,
    e.unstable_forceFrameRate = function(L) {
        0 > L || 125 < L ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < L ? Math.floor(1e3 / L) : 5
    }
    ,
    e.unstable_getCurrentPriorityLevel = function() {
        return d
    }
    ,
    e.unstable_getFirstCallbackNode = function() {
        return r(l)
    }
    ,
    e.unstable_next = function(L) {
        switch (d) {
        case 1:
        case 2:
        case 3:
            var $ = 3;
            break;
        default:
            $ = d
        }
        var I = d;
        d = $;
        try {
            return L()
        } finally {
            d = I
        }
    }
    ,
    e.unstable_pauseExecution = function() {}
    ,
    e.unstable_requestPaint = function() {}
    ,
    e.unstable_runWithPriority = function(L, $) {
        switch (L) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            L = 3
        }
        var I = d;
        d = L;
        try {
            return $()
        } finally {
            d = I
        }
    }
    ,
    e.unstable_scheduleCallback = function(L, $, I) {
        var H = e.unstable_now();
        switch (typeof I == "object" && I !== null ? (I = I.delay,
        I = typeof I == "number" && 0 < I ? H + I : H) : I = H,
        L) {
        case 1:
            var K = -1;
            break;
        case 2:
            K = 250;
            break;
        case 5:
            K = 1073741823;
            break;
        case 4:
            K = 1e4;
            break;
        default:
            K = 5e3
        }
        return K = I + K,
        L = {
            id: u++,
            callback: $,
            priorityLevel: L,
            startTime: I,
            expirationTime: K,
            sortIndex: -1
        },
        I > H ? (L.sortIndex = I,
        t(h, L),
        r(l) === null && L === r(h) && (p ? (y(T),
        T = -1) : p = !0,
        k(x, I - H))) : (L.sortIndex = K,
        t(l, L),
        g || f || (g = !0,
        X(E))),
        L
    }
    ,
    e.unstable_shouldYield = O,
    e.unstable_wrapCallback = function(L) {
        var $ = d;
        return function() {
            var I = d;
            d = $;
            try {
                return L.apply(this, arguments)
            } finally {
                d = I
            }
        }
    }
}
)(pA);
fA.exports = pA;
var $2 = fA.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mA = ae
  , Dr = $2;
function D(e) {
    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 1; r < arguments.length; r++)
        t += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var gA = new Set
  , wh = {};
function Do(e, t) {
    Fa(e, t),
    Fa(e + "Capture", t)
}
function Fa(e, t) {
    for (wh[e] = t,
    e = 0; e < t.length; e++)
        gA.add(t[e])
}
var Ln = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , Ng = Object.prototype.hasOwnProperty
  , z2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , L1 = {}
  , D1 = {};
function W2(e) {
    return Ng.call(D1, e) ? !0 : Ng.call(L1, e) ? !1 : z2.test(e) ? D1[e] = !0 : (L1[e] = !0,
    !1)
}
function V2(e, t, r, i) {
    if (r !== null && r.type === 0)
        return !1;
    switch (typeof t) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return i ? !1 : r !== null ? !r.acceptsBooleans : (e = e.toLowerCase().slice(0, 5),
        e !== "data-" && e !== "aria-");
    default:
        return !1
    }
}
function j2(e, t, r, i) {
    if (t === null || typeof t > "u" || V2(e, t, r, i))
        return !0;
    if (i)
        return !1;
    if (r !== null)
        switch (r.type) {
        case 3:
            return !t;
        case 4:
            return t === !1;
        case 5:
            return isNaN(t);
        case 6:
            return isNaN(t) || 1 > t
        }
    return !1
}
function ir(e, t, r, i, n, s, o) {
    this.acceptsBooleans = t === 2 || t === 3 || t === 4,
    this.attributeName = i,
    this.attributeNamespace = n,
    this.mustUseProperty = r,
    this.propertyName = e,
    this.type = t,
    this.sanitizeURL = s,
    this.removeEmptyString = o
}
var De = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
    De[e] = new ir(e,0,!1,e,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
    var t = e[0];
    De[t] = new ir(t,1,!1,e[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
    De[e] = new ir(e,2,!1,e.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
    De[e] = new ir(e,2,!1,e,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
    De[e] = new ir(e,3,!1,e.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
    De[e] = new ir(e,3,!0,e,null,!1,!1)
});
["capture", "download"].forEach(function(e) {
    De[e] = new ir(e,4,!1,e,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(e) {
    De[e] = new ir(e,6,!1,e,null,!1,!1)
});
["rowSpan", "start"].forEach(function(e) {
    De[e] = new ir(e,5,!1,e.toLowerCase(),null,!1,!1)
});
var yy = /[\-:]([a-z])/g;
function vy(e) {
    return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
    var t = e.replace(yy, vy);
    De[t] = new ir(t,1,!1,e,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
    var t = e.replace(yy, vy);
    De[t] = new ir(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
    var t = e.replace(yy, vy);
    De[t] = new ir(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(e) {
    De[e] = new ir(e,1,!1,e.toLowerCase(),null,!1,!1)
});
De.xlinkHref = new ir("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(e) {
    De[e] = new ir(e,1,!1,e.toLowerCase(),null,!0,!0)
});
function xy(e, t, r, i) {
    var n = De.hasOwnProperty(t) ? De[t] : null;
    (n !== null ? n.type !== 0 : i || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (j2(t, r, n, i) && (r = null),
    i || n === null ? W2(t) && (r === null ? e.removeAttribute(t) : e.setAttribute(t, "" + r)) : n.mustUseProperty ? e[n.propertyName] = r === null ? n.type === 3 ? !1 : "" : r : (t = n.attributeName,
    i = n.attributeNamespace,
    r === null ? e.removeAttribute(t) : (n = n.type,
    r = n === 3 || n === 4 && r === !0 ? "" : "" + r,
    i ? e.setAttributeNS(i, t, r) : e.setAttribute(t, r))))
}
var Wn = mA.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Qu = Symbol.for("react.element")
  , ha = Symbol.for("react.portal")
  , ua = Symbol.for("react.fragment")
  , Ey = Symbol.for("react.strict_mode")
  , Lg = Symbol.for("react.profiler")
  , _A = Symbol.for("react.provider")
  , yA = Symbol.for("react.context")
  , Ty = Symbol.for("react.forward_ref")
  , Dg = Symbol.for("react.suspense")
  , Bg = Symbol.for("react.suspense_list")
  , Sy = Symbol.for("react.memo")
  , Qn = Symbol.for("react.lazy")
  , vA = Symbol.for("react.offscreen")
  , B1 = Symbol.iterator;
function xl(e) {
    return e === null || typeof e != "object" ? null : (e = B1 && e[B1] || e["@@iterator"],
    typeof e == "function" ? e : null)
}
var Zt = Object.assign, Yp;
function Ul(e) {
    if (Yp === void 0)
        try {
            throw Error()
        } catch (r) {
            var t = r.stack.trim().match(/\n( *(at )?)/);
            Yp = t && t[1] || ""
        }
    return `
` + Yp + e
}
var Kp = !1;
function qp(e, t) {
    if (!e || Kp)
        return "";
    Kp = !0;
    var r = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (t)
            if (t = function() {
                throw Error()
            }
            ,
            Object.defineProperty(t.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(t, [])
                } catch (h) {
                    var i = h
                }
                Reflect.construct(e, [], t)
            } else {
                try {
                    t.call()
                } catch (h) {
                    i = h
                }
                e.call(t.prototype)
            }
        else {
            try {
                throw Error()
            } catch (h) {
                i = h
            }
            e()
        }
    } catch (h) {
        if (h && i && typeof h.stack == "string") {
            for (var n = h.stack.split(`
`), s = i.stack.split(`
`), o = n.length - 1, a = s.length - 1; 1 <= o && 0 <= a && n[o] !== s[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (n[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || n[o] !== s[a]) {
                                var l = `
` + n[o].replace(" at new ", " at ");
                                return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        Kp = !1,
        Error.prepareStackTrace = r
    }
    return (e = e ? e.displayName || e.name : "") ? Ul(e) : ""
}
function X2(e) {
    switch (e.tag) {
    case 5:
        return Ul(e.type);
    case 16:
        return Ul("Lazy");
    case 13:
        return Ul("Suspense");
    case 19:
        return Ul("SuspenseList");
    case 0:
    case 2:
    case 15:
        return e = qp(e.type, !1),
        e;
    case 11:
        return e = qp(e.type.render, !1),
        e;
    case 1:
        return e = qp(e.type, !0),
        e;
    default:
        return ""
    }
}
function kg(e) {
    if (e == null)
        return null;
    if (typeof e == "function")
        return e.displayName || e.name || null;
    if (typeof e == "string")
        return e;
    switch (e) {
    case ua:
        return "Fragment";
    case ha:
        return "Portal";
    case Lg:
        return "Profiler";
    case Ey:
        return "StrictMode";
    case Dg:
        return "Suspense";
    case Bg:
        return "SuspenseList"
    }
    if (typeof e == "object")
        switch (e.$$typeof) {
        case yA:
            return (e.displayName || "Context") + ".Consumer";
        case _A:
            return (e._context.displayName || "Context") + ".Provider";
        case Ty:
            var t = e.render;
            return e = e.displayName,
            e || (e = t.displayName || t.name || "",
            e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"),
            e;
        case Sy:
            return t = e.displayName || null,
            t !== null ? t : kg(e.type) || "Memo";
        case Qn:
            t = e._payload,
            e = e._init;
            try {
                return kg(e(t))
            } catch {}
        }
    return null
}
function Y2(e) {
    var t = e.type;
    switch (e.tag) {
    case 24:
        return "Cache";
    case 9:
        return (t.displayName || "Context") + ".Consumer";
    case 10:
        return (t._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return e = t.render,
        e = e.displayName || e.name || "",
        t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return t;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return kg(t);
    case 8:
        return t === Ey ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof t == "function")
            return t.displayName || t.name || null;
        if (typeof t == "string")
            return t
    }
    return null
}
function bs(e) {
    switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return e;
    case "object":
        return e;
    default:
        return ""
    }
}
function xA(e) {
    var t = e.type;
    return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio")
}
function K2(e) {
    var t = xA(e) ? "checked" : "value"
      , r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t)
      , i = "" + e[t];
    if (!e.hasOwnProperty(t) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
        var n = r.get
          , s = r.set;
        return Object.defineProperty(e, t, {
            configurable: !0,
            get: function() {
                return n.call(this)
            },
            set: function(o) {
                i = "" + o,
                s.call(this, o)
            }
        }),
        Object.defineProperty(e, t, {
            enumerable: r.enumerable
        }),
        {
            getValue: function() {
                return i
            },
            setValue: function(o) {
                i = "" + o
            },
            stopTracking: function() {
                e._valueTracker = null,
                delete e[t]
            }
        }
    }
}
function Ju(e) {
    e._valueTracker || (e._valueTracker = K2(e))
}
function EA(e) {
    if (!e)
        return !1;
    var t = e._valueTracker;
    if (!t)
        return !0;
    var r = t.getValue()
      , i = "";
    return e && (i = xA(e) ? e.checked ? "true" : "false" : e.value),
    e = i,
    e !== r ? (t.setValue(e),
    !0) : !1
}
function Od(e) {
    if (e = e || (typeof document < "u" ? document : void 0),
    typeof e > "u")
        return null;
    try {
        return e.activeElement || e.body
    } catch {
        return e.body
    }
}
function Fg(e, t) {
    var r = t.checked;
    return Zt({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: r ?? e._wrapperState.initialChecked
    })
}
function k1(e, t) {
    var r = t.defaultValue == null ? "" : t.defaultValue
      , i = t.checked != null ? t.checked : t.defaultChecked;
    r = bs(t.value != null ? t.value : r),
    e._wrapperState = {
        initialChecked: i,
        initialValue: r,
        controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
    }
}
function TA(e, t) {
    t = t.checked,
    t != null && xy(e, "checked", t, !1)
}
function Ug(e, t) {
    TA(e, t);
    var r = bs(t.value)
      , i = t.type;
    if (r != null)
        i === "number" ? (r === 0 && e.value === "" || e.value != r) && (e.value = "" + r) : e.value !== "" + r && (e.value = "" + r);
    else if (i === "submit" || i === "reset") {
        e.removeAttribute("value");
        return
    }
    t.hasOwnProperty("value") ? Gg(e, t.type, r) : t.hasOwnProperty("defaultValue") && Gg(e, t.type, bs(t.defaultValue)),
    t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}
function F1(e, t, r) {
    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var i = t.type;
        if (!(i !== "submit" && i !== "reset" || t.value !== void 0 && t.value !== null))
            return;
        t = "" + e._wrapperState.initialValue,
        r || t === e.value || (e.value = t),
        e.defaultValue = t
    }
    r = e.name,
    r !== "" && (e.name = ""),
    e.defaultChecked = !!e._wrapperState.initialChecked,
    r !== "" && (e.name = r)
}
function Gg(e, t, r) {
    (t !== "number" || Od(e.ownerDocument) !== e) && (r == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + r && (e.defaultValue = "" + r))
}
var Gl = Array.isArray;
function wa(e, t, r, i) {
    if (e = e.options,
    t) {
        t = {};
        for (var n = 0; n < r.length; n++)
            t["$" + r[n]] = !0;
        for (r = 0; r < e.length; r++)
            n = t.hasOwnProperty("$" + e[r].value),
            e[r].selected !== n && (e[r].selected = n),
            n && i && (e[r].defaultSelected = !0)
    } else {
        for (r = "" + bs(r),
        t = null,
        n = 0; n < e.length; n++) {
            if (e[n].value === r) {
                e[n].selected = !0,
                i && (e[n].defaultSelected = !0);
                return
            }
            t !== null || e[n].disabled || (t = e[n])
        }
        t !== null && (t.selected = !0)
    }
}
function Hg(e, t) {
    if (t.dangerouslySetInnerHTML != null)
        throw Error(D(91));
    return Zt({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: "" + e._wrapperState.initialValue
    })
}
function U1(e, t) {
    var r = t.value;
    if (r == null) {
        if (r = t.children,
        t = t.defaultValue,
        r != null) {
            if (t != null)
                throw Error(D(92));
            if (Gl(r)) {
                if (1 < r.length)
                    throw Error(D(93));
                r = r[0]
            }
            t = r
        }
        t == null && (t = ""),
        r = t
    }
    e._wrapperState = {
        initialValue: bs(r)
    }
}
function SA(e, t) {
    var r = bs(t.value)
      , i = bs(t.defaultValue);
    r != null && (r = "" + r,
    r !== e.value && (e.value = r),
    t.defaultValue == null && e.defaultValue !== r && (e.defaultValue = r)),
    i != null && (e.defaultValue = "" + i)
}
function G1(e) {
    var t = e.textContent;
    t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}
function wA(e) {
    switch (e) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function $g(e, t) {
    return e == null || e === "http://www.w3.org/1999/xhtml" ? wA(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e
}
var tc, AA = function(e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, r, i, n) {
        MSApp.execUnsafeLocalFunction(function() {
            return e(t, r, i, n)
        })
    }
    : e
}(function(e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in e)
        e.innerHTML = t;
    else {
        for (tc = tc || document.createElement("div"),
        tc.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
        t = tc.firstChild; e.firstChild; )
            e.removeChild(e.firstChild);
        for (; t.firstChild; )
            e.appendChild(t.firstChild)
    }
});
function Ah(e, t) {
    if (t) {
        var r = e.firstChild;
        if (r && r === e.lastChild && r.nodeType === 3) {
            r.nodeValue = t;
            return
        }
    }
    e.textContent = t
}
var ih = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , q2 = ["Webkit", "ms", "Moz", "O"];
Object.keys(ih).forEach(function(e) {
    q2.forEach(function(t) {
        t = t + e.charAt(0).toUpperCase() + e.substring(1),
        ih[t] = ih[e]
    })
});
function bA(e, t, r) {
    return t == null || typeof t == "boolean" || t === "" ? "" : r || typeof t != "number" || t === 0 || ih.hasOwnProperty(e) && ih[e] ? ("" + t).trim() : t + "px"
}
function CA(e, t) {
    e = e.style;
    for (var r in t)
        if (t.hasOwnProperty(r)) {
            var i = r.indexOf("--") === 0
              , n = bA(r, t[r], i);
            r === "float" && (r = "cssFloat"),
            i ? e.setProperty(r, n) : e[r] = n
        }
}
var Z2 = Zt({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function zg(e, t) {
    if (t) {
        if (Z2[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
            throw Error(D(137, e));
        if (t.dangerouslySetInnerHTML != null) {
            if (t.children != null)
                throw Error(D(60));
            if (typeof t.dangerouslySetInnerHTML != "object" || !("__html"in t.dangerouslySetInnerHTML))
                throw Error(D(61))
        }
        if (t.style != null && typeof t.style != "object")
            throw Error(D(62))
    }
}
function Wg(e, t) {
    if (e.indexOf("-") === -1)
        return typeof t.is == "string";
    switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var Vg = null;
function wy(e) {
    return e = e.target || e.srcElement || window,
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
}
var jg = null
  , Aa = null
  , ba = null;
function H1(e) {
    if (e = Cu(e)) {
        if (typeof jg != "function")
            throw Error(D(280));
        var t = e.stateNode;
        t && (t = Yf(t),
        jg(e.stateNode, e.type, t))
    }
}
function PA(e) {
    Aa ? ba ? ba.push(e) : ba = [e] : Aa = e
}
function IA() {
    if (Aa) {
        var e = Aa
          , t = ba;
        if (ba = Aa = null,
        H1(e),
        t)
            for (e = 0; e < t.length; e++)
                H1(t[e])
    }
}
function RA(e, t) {
    return e(t)
}
function MA() {}
var Zp = !1;
function OA(e, t, r) {
    if (Zp)
        return e(t, r);
    Zp = !0;
    try {
        return RA(e, t, r)
    } finally {
        Zp = !1,
        (Aa !== null || ba !== null) && (MA(),
        IA())
    }
}
function bh(e, t) {
    var r = e.stateNode;
    if (r === null)
        return null;
    var i = Yf(r);
    if (i === null)
        return null;
    r = i[t];
    t: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (i = !i.disabled) || (e = e.type,
        i = !(e === "button" || e === "input" || e === "select" || e === "textarea")),
        e = !i;
        break t;
    default:
        e = !1
    }
    if (e)
        return null;
    if (r && typeof r != "function")
        throw Error(D(231, t, typeof r));
    return r
}
var Xg = !1;
if (Ln)
    try {
        var El = {};
        Object.defineProperty(El, "passive", {
            get: function() {
                Xg = !0
            }
        }),
        window.addEventListener("test", El, El),
        window.removeEventListener("test", El, El)
    } catch {
        Xg = !1
    }
function Q2(e, t, r, i, n, s, o, a, l) {
    var h = Array.prototype.slice.call(arguments, 3);
    try {
        t.apply(r, h)
    } catch (u) {
        this.onError(u)
    }
}
var nh = !1
  , Nd = null
  , Ld = !1
  , Yg = null
  , J2 = {
    onError: function(e) {
        nh = !0,
        Nd = e
    }
};
function tN(e, t, r, i, n, s, o, a, l) {
    nh = !1,
    Nd = null,
    Q2.apply(J2, arguments)
}
function eN(e, t, r, i, n, s, o, a, l) {
    if (tN.apply(this, arguments),
    nh) {
        if (nh) {
            var h = Nd;
            nh = !1,
            Nd = null
        } else
            throw Error(D(198));
        Ld || (Ld = !0,
        Yg = h)
    }
}
function Bo(e) {
    var t = e
      , r = e;
    if (e.alternate)
        for (; t.return; )
            t = t.return;
    else {
        e = t;
        do
            t = e,
            t.flags & 4098 && (r = t.return),
            e = t.return;
        while (e)
    }
    return t.tag === 3 ? r : null
}
function NA(e) {
    if (e.tag === 13) {
        var t = e.memoizedState;
        if (t === null && (e = e.alternate,
        e !== null && (t = e.memoizedState)),
        t !== null)
            return t.dehydrated
    }
    return null
}
function $1(e) {
    if (Bo(e) !== e)
        throw Error(D(188))
}
function rN(e) {
    var t = e.alternate;
    if (!t) {
        if (t = Bo(e),
        t === null)
            throw Error(D(188));
        return t !== e ? null : e
    }
    for (var r = e, i = t; ; ) {
        var n = r.return;
        if (n === null)
            break;
        var s = n.alternate;
        if (s === null) {
            if (i = n.return,
            i !== null) {
                r = i;
                continue
            }
            break
        }
        if (n.child === s.child) {
            for (s = n.child; s; ) {
                if (s === r)
                    return $1(n),
                    e;
                if (s === i)
                    return $1(n),
                    t;
                s = s.sibling
            }
            throw Error(D(188))
        }
        if (r.return !== i.return)
            r = n,
            i = s;
        else {
            for (var o = !1, a = n.child; a; ) {
                if (a === r) {
                    o = !0,
                    r = n,
                    i = s;
                    break
                }
                if (a === i) {
                    o = !0,
                    i = n,
                    r = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === r) {
                        o = !0,
                        r = s,
                        i = n;
                        break
                    }
                    if (a === i) {
                        o = !0,
                        i = s,
                        r = n;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(D(189))
            }
        }
        if (r.alternate !== i)
            throw Error(D(190))
    }
    if (r.tag !== 3)
        throw Error(D(188));
    return r.stateNode.current === r ? e : t
}
function LA(e) {
    return e = rN(e),
    e !== null ? DA(e) : null
}
function DA(e) {
    if (e.tag === 5 || e.tag === 6)
        return e;
    for (e = e.child; e !== null; ) {
        var t = DA(e);
        if (t !== null)
            return t;
        e = e.sibling
    }
    return null
}
var BA = Dr.unstable_scheduleCallback
  , z1 = Dr.unstable_cancelCallback
  , iN = Dr.unstable_shouldYield
  , nN = Dr.unstable_requestPaint
  , oe = Dr.unstable_now
  , sN = Dr.unstable_getCurrentPriorityLevel
  , Ay = Dr.unstable_ImmediatePriority
  , kA = Dr.unstable_UserBlockingPriority
  , Dd = Dr.unstable_NormalPriority
  , oN = Dr.unstable_LowPriority
  , FA = Dr.unstable_IdlePriority
  , Wf = null
  , nn = null;
function aN(e) {
    if (nn && typeof nn.onCommitFiberRoot == "function")
        try {
            nn.onCommitFiberRoot(Wf, e, void 0, (e.current.flags & 128) === 128)
        } catch {}
}
var Ai = Math.clz32 ? Math.clz32 : uN
  , lN = Math.log
  , hN = Math.LN2;
function uN(e) {
    return e >>>= 0,
    e === 0 ? 32 : 31 - (lN(e) / hN | 0) | 0
}
var ec = 64
  , rc = 4194304;
function Hl(e) {
    switch (e & -e) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return e & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return e
    }
}
function Bd(e, t) {
    var r = e.pendingLanes;
    if (r === 0)
        return 0;
    var i = 0
      , n = e.suspendedLanes
      , s = e.pingedLanes
      , o = r & 268435455;
    if (o !== 0) {
        var a = o & ~n;
        a !== 0 ? i = Hl(a) : (s &= o,
        s !== 0 && (i = Hl(s)))
    } else
        o = r & ~n,
        o !== 0 ? i = Hl(o) : s !== 0 && (i = Hl(s));
    if (i === 0)
        return 0;
    if (t !== 0 && t !== i && !(t & n) && (n = i & -i,
    s = t & -t,
    n >= s || n === 16 && (s & 4194240) !== 0))
        return t;
    if (i & 4 && (i |= r & 16),
    t = e.entangledLanes,
    t !== 0)
        for (e = e.entanglements,
        t &= i; 0 < t; )
            r = 31 - Ai(t),
            n = 1 << r,
            i |= e[r],
            t &= ~n;
    return i
}
function cN(e, t) {
    switch (e) {
    case 1:
    case 2:
    case 4:
        return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function dN(e, t) {
    for (var r = e.suspendedLanes, i = e.pingedLanes, n = e.expirationTimes, s = e.pendingLanes; 0 < s; ) {
        var o = 31 - Ai(s)
          , a = 1 << o
          , l = n[o];
        l === -1 ? (!(a & r) || a & i) && (n[o] = cN(a, t)) : l <= t && (e.expiredLanes |= a),
        s &= ~a
    }
}
function Kg(e) {
    return e = e.pendingLanes & -1073741825,
    e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
}
function UA() {
    var e = ec;
    return ec <<= 1,
    !(ec & 4194240) && (ec = 64),
    e
}
function Qp(e) {
    for (var t = [], r = 0; 31 > r; r++)
        t.push(e);
    return t
}
function Au(e, t, r) {
    e.pendingLanes |= t,
    t !== 536870912 && (e.suspendedLanes = 0,
    e.pingedLanes = 0),
    e = e.eventTimes,
    t = 31 - Ai(t),
    e[t] = r
}
function fN(e, t) {
    var r = e.pendingLanes & ~t;
    e.pendingLanes = t,
    e.suspendedLanes = 0,
    e.pingedLanes = 0,
    e.expiredLanes &= t,
    e.mutableReadLanes &= t,
    e.entangledLanes &= t,
    t = e.entanglements;
    var i = e.eventTimes;
    for (e = e.expirationTimes; 0 < r; ) {
        var n = 31 - Ai(r)
          , s = 1 << n;
        t[n] = 0,
        i[n] = -1,
        e[n] = -1,
        r &= ~s
    }
}
function by(e, t) {
    var r = e.entangledLanes |= t;
    for (e = e.entanglements; r; ) {
        var i = 31 - Ai(r)
          , n = 1 << i;
        n & t | e[i] & t && (e[i] |= t),
        r &= ~n
    }
}
var St = 0;
function GA(e) {
    return e &= -e,
    1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1
}
var HA, Cy, $A, zA, WA, qg = !1, ic = [], ps = null, ms = null, gs = null, Ch = new Map, Ph = new Map, is = [], pN = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function W1(e, t) {
    switch (e) {
    case "focusin":
    case "focusout":
        ps = null;
        break;
    case "dragenter":
    case "dragleave":
        ms = null;
        break;
    case "mouseover":
    case "mouseout":
        gs = null;
        break;
    case "pointerover":
    case "pointerout":
        Ch.delete(t.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Ph.delete(t.pointerId)
    }
}
function Tl(e, t, r, i, n, s) {
    return e === null || e.nativeEvent !== s ? (e = {
        blockedOn: t,
        domEventName: r,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [n]
    },
    t !== null && (t = Cu(t),
    t !== null && Cy(t)),
    e) : (e.eventSystemFlags |= i,
    t = e.targetContainers,
    n !== null && t.indexOf(n) === -1 && t.push(n),
    e)
}
function mN(e, t, r, i, n) {
    switch (t) {
    case "focusin":
        return ps = Tl(ps, e, t, r, i, n),
        !0;
    case "dragenter":
        return ms = Tl(ms, e, t, r, i, n),
        !0;
    case "mouseover":
        return gs = Tl(gs, e, t, r, i, n),
        !0;
    case "pointerover":
        var s = n.pointerId;
        return Ch.set(s, Tl(Ch.get(s) || null, e, t, r, i, n)),
        !0;
    case "gotpointercapture":
        return s = n.pointerId,
        Ph.set(s, Tl(Ph.get(s) || null, e, t, r, i, n)),
        !0
    }
    return !1
}
function VA(e) {
    var t = no(e.target);
    if (t !== null) {
        var r = Bo(t);
        if (r !== null) {
            if (t = r.tag,
            t === 13) {
                if (t = NA(r),
                t !== null) {
                    e.blockedOn = t,
                    WA(e.priority, function() {
                        $A(r)
                    });
                    return
                }
            } else if (t === 3 && r.stateNode.current.memoizedState.isDehydrated) {
                e.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
                return
            }
        }
    }
    e.blockedOn = null
}
function ed(e) {
    if (e.blockedOn !== null)
        return !1;
    for (var t = e.targetContainers; 0 < t.length; ) {
        var r = Zg(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
        if (r === null) {
            r = e.nativeEvent;
            var i = new r.constructor(r.type,r);
            Vg = i,
            r.target.dispatchEvent(i),
            Vg = null
        } else
            return t = Cu(r),
            t !== null && Cy(t),
            e.blockedOn = r,
            !1;
        t.shift()
    }
    return !0
}
function V1(e, t, r) {
    ed(e) && r.delete(t)
}
function gN() {
    qg = !1,
    ps !== null && ed(ps) && (ps = null),
    ms !== null && ed(ms) && (ms = null),
    gs !== null && ed(gs) && (gs = null),
    Ch.forEach(V1),
    Ph.forEach(V1)
}
function Sl(e, t) {
    e.blockedOn === t && (e.blockedOn = null,
    qg || (qg = !0,
    Dr.unstable_scheduleCallback(Dr.unstable_NormalPriority, gN)))
}
function Ih(e) {
    function t(n) {
        return Sl(n, e)
    }
    if (0 < ic.length) {
        Sl(ic[0], e);
        for (var r = 1; r < ic.length; r++) {
            var i = ic[r];
            i.blockedOn === e && (i.blockedOn = null)
        }
    }
    for (ps !== null && Sl(ps, e),
    ms !== null && Sl(ms, e),
    gs !== null && Sl(gs, e),
    Ch.forEach(t),
    Ph.forEach(t),
    r = 0; r < is.length; r++)
        i = is[r],
        i.blockedOn === e && (i.blockedOn = null);
    for (; 0 < is.length && (r = is[0],
    r.blockedOn === null); )
        VA(r),
        r.blockedOn === null && is.shift()
}
var Ca = Wn.ReactCurrentBatchConfig
  , kd = !0;
function _N(e, t, r, i) {
    var n = St
      , s = Ca.transition;
    Ca.transition = null;
    try {
        St = 1,
        Py(e, t, r, i)
    } finally {
        St = n,
        Ca.transition = s
    }
}
function yN(e, t, r, i) {
    var n = St
      , s = Ca.transition;
    Ca.transition = null;
    try {
        St = 4,
        Py(e, t, r, i)
    } finally {
        St = n,
        Ca.transition = s
    }
}
function Py(e, t, r, i) {
    if (kd) {
        var n = Zg(e, t, r, i);
        if (n === null)
            lm(e, t, i, Fd, r),
            W1(e, i);
        else if (mN(n, e, t, r, i))
            i.stopPropagation();
        else if (W1(e, i),
        t & 4 && -1 < pN.indexOf(e)) {
            for (; n !== null; ) {
                var s = Cu(n);
                if (s !== null && HA(s),
                s = Zg(e, t, r, i),
                s === null && lm(e, t, i, Fd, r),
                s === n)
                    break;
                n = s
            }
            n !== null && i.stopPropagation()
        } else
            lm(e, t, i, null, r)
    }
}
var Fd = null;
function Zg(e, t, r, i) {
    if (Fd = null,
    e = wy(i),
    e = no(e),
    e !== null)
        if (t = Bo(e),
        t === null)
            e = null;
        else if (r = t.tag,
        r === 13) {
            if (e = NA(t),
            e !== null)
                return e;
            e = null
        } else if (r === 3) {
            if (t.stateNode.current.memoizedState.isDehydrated)
                return t.tag === 3 ? t.stateNode.containerInfo : null;
            e = null
        } else
            t !== e && (e = null);
    return Fd = e,
    null
}
function jA(e) {
    switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (sN()) {
        case Ay:
            return 1;
        case kA:
            return 4;
        case Dd:
        case oN:
            return 16;
        case FA:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var as = null
  , Iy = null
  , rd = null;
function XA() {
    if (rd)
        return rd;
    var e, t = Iy, r = t.length, i, n = "value"in as ? as.value : as.textContent, s = n.length;
    for (e = 0; e < r && t[e] === n[e]; e++)
        ;
    var o = r - e;
    for (i = 1; i <= o && t[r - i] === n[s - i]; i++)
        ;
    return rd = n.slice(e, 1 < i ? 1 - i : void 0)
}
function id(e) {
    var t = e.keyCode;
    return "charCode"in e ? (e = e.charCode,
    e === 0 && t === 13 && (e = 13)) : e = t,
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
}
function nc() {
    return !0
}
function j1() {
    return !1
}
function Fr(e) {
    function t(r, i, n, s, o) {
        this._reactName = r,
        this._targetInst = n,
        this.type = i,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
        for (var a in e)
            e.hasOwnProperty(a) && (r = e[a],
            this[a] = r ? r(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? nc : j1,
        this.isPropagationStopped = j1,
        this
    }
    return Zt(t.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var r = this.nativeEvent;
            r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1),
            this.isDefaultPrevented = nc)
        },
        stopPropagation: function() {
            var r = this.nativeEvent;
            r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0),
            this.isPropagationStopped = nc)
        },
        persist: function() {},
        isPersistent: nc
    }),
    t
}
var cl = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(e) {
        return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, Ry = Fr(cl), bu = Zt({}, cl, {
    view: 0,
    detail: 0
}), vN = Fr(bu), Jp, tm, wl, Vf = Zt({}, bu, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: My,
    button: 0,
    buttons: 0,
    relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
    },
    movementX: function(e) {
        return "movementX"in e ? e.movementX : (e !== wl && (wl && e.type === "mousemove" ? (Jp = e.screenX - wl.screenX,
        tm = e.screenY - wl.screenY) : tm = Jp = 0,
        wl = e),
        Jp)
    },
    movementY: function(e) {
        return "movementY"in e ? e.movementY : tm
    }
}), X1 = Fr(Vf), xN = Zt({}, Vf, {
    dataTransfer: 0
}), EN = Fr(xN), TN = Zt({}, bu, {
    relatedTarget: 0
}), em = Fr(TN), SN = Zt({}, cl, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), wN = Fr(SN), AN = Zt({}, cl, {
    clipboardData: function(e) {
        return "clipboardData"in e ? e.clipboardData : window.clipboardData
    }
}), bN = Fr(AN), CN = Zt({}, cl, {
    data: 0
}), Y1 = Fr(CN), PN = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, IN = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, RN = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function MN(e) {
    var t = this.nativeEvent;
    return t.getModifierState ? t.getModifierState(e) : (e = RN[e]) ? !!t[e] : !1
}
function My() {
    return MN
}
var ON = Zt({}, bu, {
    key: function(e) {
        if (e.key) {
            var t = PN[e.key] || e.key;
            if (t !== "Unidentified")
                return t
        }
        return e.type === "keypress" ? (e = id(e),
        e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? IN[e.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: My,
    charCode: function(e) {
        return e.type === "keypress" ? id(e) : 0
    },
    keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    },
    which: function(e) {
        return e.type === "keypress" ? id(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    }
})
  , NN = Fr(ON)
  , LN = Zt({}, Vf, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , K1 = Fr(LN)
  , DN = Zt({}, bu, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: My
})
  , BN = Fr(DN)
  , kN = Zt({}, cl, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , FN = Fr(kN)
  , UN = Zt({}, Vf, {
    deltaX: function(e) {
        return "deltaX"in e ? e.deltaX : "wheelDeltaX"in e ? -e.wheelDeltaX : 0
    },
    deltaY: function(e) {
        return "deltaY"in e ? e.deltaY : "wheelDeltaY"in e ? -e.wheelDeltaY : "wheelDelta"in e ? -e.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , GN = Fr(UN)
  , HN = [9, 13, 27, 32]
  , Oy = Ln && "CompositionEvent"in window
  , sh = null;
Ln && "documentMode"in document && (sh = document.documentMode);
var $N = Ln && "TextEvent"in window && !sh
  , YA = Ln && (!Oy || sh && 8 < sh && 11 >= sh)
  , q1 = String.fromCharCode(32)
  , Z1 = !1;
function KA(e, t) {
    switch (e) {
    case "keyup":
        return HN.indexOf(t.keyCode) !== -1;
    case "keydown":
        return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function qA(e) {
    return e = e.detail,
    typeof e == "object" && "data"in e ? e.data : null
}
var ca = !1;
function zN(e, t) {
    switch (e) {
    case "compositionend":
        return qA(t);
    case "keypress":
        return t.which !== 32 ? null : (Z1 = !0,
        q1);
    case "textInput":
        return e = t.data,
        e === q1 && Z1 ? null : e;
    default:
        return null
    }
}
function WN(e, t) {
    if (ca)
        return e === "compositionend" || !Oy && KA(e, t) ? (e = XA(),
        rd = Iy = as = null,
        ca = !1,
        e) : null;
    switch (e) {
    case "paste":
        return null;
    case "keypress":
        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
            if (t.char && 1 < t.char.length)
                return t.char;
            if (t.which)
                return String.fromCharCode(t.which)
        }
        return null;
    case "compositionend":
        return YA && t.locale !== "ko" ? null : t.data;
    default:
        return null
    }
}
var VN = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function Q1(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t === "input" ? !!VN[e.type] : t === "textarea"
}
function ZA(e, t, r, i) {
    PA(i),
    t = Ud(t, "onChange"),
    0 < t.length && (r = new Ry("onChange","change",null,r,i),
    e.push({
        event: r,
        listeners: t
    }))
}
var oh = null
  , Rh = null;
function jN(e) {
    lb(e, 0)
}
function jf(e) {
    var t = pa(e);
    if (EA(t))
        return e
}
function XN(e, t) {
    if (e === "change")
        return t
}
var QA = !1;
if (Ln) {
    var rm;
    if (Ln) {
        var im = "oninput"in document;
        if (!im) {
            var J1 = document.createElement("div");
            J1.setAttribute("oninput", "return;"),
            im = typeof J1.oninput == "function"
        }
        rm = im
    } else
        rm = !1;
    QA = rm && (!document.documentMode || 9 < document.documentMode)
}
function tE() {
    oh && (oh.detachEvent("onpropertychange", JA),
    Rh = oh = null)
}
function JA(e) {
    if (e.propertyName === "value" && jf(Rh)) {
        var t = [];
        ZA(t, Rh, e, wy(e)),
        OA(jN, t)
    }
}
function YN(e, t, r) {
    e === "focusin" ? (tE(),
    oh = t,
    Rh = r,
    oh.attachEvent("onpropertychange", JA)) : e === "focusout" && tE()
}
function KN(e) {
    if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return jf(Rh)
}
function qN(e, t) {
    if (e === "click")
        return jf(t)
}
function ZN(e, t) {
    if (e === "input" || e === "change")
        return jf(t)
}
function QN(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var Oi = typeof Object.is == "function" ? Object.is : QN;
function Mh(e, t) {
    if (Oi(e, t))
        return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
    var r = Object.keys(e)
      , i = Object.keys(t);
    if (r.length !== i.length)
        return !1;
    for (i = 0; i < r.length; i++) {
        var n = r[i];
        if (!Ng.call(t, n) || !Oi(e[n], t[n]))
            return !1
    }
    return !0
}
function eE(e) {
    for (; e && e.firstChild; )
        e = e.firstChild;
    return e
}
function rE(e, t) {
    var r = eE(e);
    e = 0;
    for (var i; r; ) {
        if (r.nodeType === 3) {
            if (i = e + r.textContent.length,
            e <= t && i >= t)
                return {
                    node: r,
                    offset: t - e
                };
            e = i
        }
        t: {
            for (; r; ) {
                if (r.nextSibling) {
                    r = r.nextSibling;
                    break t
                }
                r = r.parentNode
            }
            r = void 0
        }
        r = eE(r)
    }
}
function tb(e, t) {
    return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? tb(e, t.parentNode) : "contains"in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1
}
function eb() {
    for (var e = window, t = Od(); t instanceof e.HTMLIFrameElement; ) {
        try {
            var r = typeof t.contentWindow.location.href == "string"
        } catch {
            r = !1
        }
        if (r)
            e = t.contentWindow;
        else
            break;
        t = Od(e.document)
    }
    return t
}
function Ny(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true")
}
function JN(e) {
    var t = eb()
      , r = e.focusedElem
      , i = e.selectionRange;
    if (t !== r && r && r.ownerDocument && tb(r.ownerDocument.documentElement, r)) {
        if (i !== null && Ny(r)) {
            if (t = i.start,
            e = i.end,
            e === void 0 && (e = t),
            "selectionStart"in r)
                r.selectionStart = t,
                r.selectionEnd = Math.min(e, r.value.length);
            else if (e = (t = r.ownerDocument || document) && t.defaultView || window,
            e.getSelection) {
                e = e.getSelection();
                var n = r.textContent.length
                  , s = Math.min(i.start, n);
                i = i.end === void 0 ? s : Math.min(i.end, n),
                !e.extend && s > i && (n = i,
                i = s,
                s = n),
                n = rE(r, s);
                var o = rE(r, i);
                n && o && (e.rangeCount !== 1 || e.anchorNode !== n.node || e.anchorOffset !== n.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(),
                t.setStart(n.node, n.offset),
                e.removeAllRanges(),
                s > i ? (e.addRange(t),
                e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset),
                e.addRange(t)))
            }
        }
        for (t = [],
        e = r; e = e.parentNode; )
            e.nodeType === 1 && t.push({
                element: e,
                left: e.scrollLeft,
                top: e.scrollTop
            });
        for (typeof r.focus == "function" && r.focus(),
        r = 0; r < t.length; r++)
            e = t[r],
            e.element.scrollLeft = e.left,
            e.element.scrollTop = e.top
    }
}
var tL = Ln && "documentMode"in document && 11 >= document.documentMode
  , da = null
  , Qg = null
  , ah = null
  , Jg = !1;
function iE(e, t, r) {
    var i = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
    Jg || da == null || da !== Od(i) || (i = da,
    "selectionStart"in i && Ny(i) ? i = {
        start: i.selectionStart,
        end: i.selectionEnd
    } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(),
    i = {
        anchorNode: i.anchorNode,
        anchorOffset: i.anchorOffset,
        focusNode: i.focusNode,
        focusOffset: i.focusOffset
    }),
    ah && Mh(ah, i) || (ah = i,
    i = Ud(Qg, "onSelect"),
    0 < i.length && (t = new Ry("onSelect","select",null,t,r),
    e.push({
        event: t,
        listeners: i
    }),
    t.target = da)))
}
function sc(e, t) {
    var r = {};
    return r[e.toLowerCase()] = t.toLowerCase(),
    r["Webkit" + e] = "webkit" + t,
    r["Moz" + e] = "moz" + t,
    r
}
var fa = {
    animationend: sc("Animation", "AnimationEnd"),
    animationiteration: sc("Animation", "AnimationIteration"),
    animationstart: sc("Animation", "AnimationStart"),
    transitionend: sc("Transition", "TransitionEnd")
}
  , nm = {}
  , rb = {};
Ln && (rb = document.createElement("div").style,
"AnimationEvent"in window || (delete fa.animationend.animation,
delete fa.animationiteration.animation,
delete fa.animationstart.animation),
"TransitionEvent"in window || delete fa.transitionend.transition);
function Xf(e) {
    if (nm[e])
        return nm[e];
    if (!fa[e])
        return e;
    var t = fa[e], r;
    for (r in t)
        if (t.hasOwnProperty(r) && r in rb)
            return nm[e] = t[r];
    return e
}
var ib = Xf("animationend")
  , nb = Xf("animationiteration")
  , sb = Xf("animationstart")
  , ob = Xf("transitionend")
  , ab = new Map
  , nE = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function Ns(e, t) {
    ab.set(e, t),
    Do(t, [e])
}
for (var sm = 0; sm < nE.length; sm++) {
    var om = nE[sm]
      , eL = om.toLowerCase()
      , rL = om[0].toUpperCase() + om.slice(1);
    Ns(eL, "on" + rL)
}
Ns(ib, "onAnimationEnd");
Ns(nb, "onAnimationIteration");
Ns(sb, "onAnimationStart");
Ns("dblclick", "onDoubleClick");
Ns("focusin", "onFocus");
Ns("focusout", "onBlur");
Ns(ob, "onTransitionEnd");
Fa("onMouseEnter", ["mouseout", "mouseover"]);
Fa("onMouseLeave", ["mouseout", "mouseover"]);
Fa("onPointerEnter", ["pointerout", "pointerover"]);
Fa("onPointerLeave", ["pointerout", "pointerover"]);
Do("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Do("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Do("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Do("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Do("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Do("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var $l = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , iL = new Set("cancel close invalid load scroll toggle".split(" ").concat($l));
function sE(e, t, r) {
    var i = e.type || "unknown-event";
    e.currentTarget = r,
    eN(i, t, void 0, e),
    e.currentTarget = null
}
function lb(e, t) {
    t = (t & 4) !== 0;
    for (var r = 0; r < e.length; r++) {
        var i = e[r]
          , n = i.event;
        i = i.listeners;
        t: {
            var s = void 0;
            if (t)
                for (var o = i.length - 1; 0 <= o; o--) {
                    var a = i[o]
                      , l = a.instance
                      , h = a.currentTarget;
                    if (a = a.listener,
                    l !== s && n.isPropagationStopped())
                        break t;
                    sE(n, a, h),
                    s = l
                }
            else
                for (o = 0; o < i.length; o++) {
                    if (a = i[o],
                    l = a.instance,
                    h = a.currentTarget,
                    a = a.listener,
                    l !== s && n.isPropagationStopped())
                        break t;
                    sE(n, a, h),
                    s = l
                }
        }
    }
    if (Ld)
        throw e = Yg,
        Ld = !1,
        Yg = null,
        e
}
function Nt(e, t) {
    var r = t[n0];
    r === void 0 && (r = t[n0] = new Set);
    var i = e + "__bubble";
    r.has(i) || (hb(t, e, 2, !1),
    r.add(i))
}
function am(e, t, r) {
    var i = 0;
    t && (i |= 4),
    hb(r, e, i, t)
}
var oc = "_reactListening" + Math.random().toString(36).slice(2);
function Oh(e) {
    if (!e[oc]) {
        e[oc] = !0,
        gA.forEach(function(r) {
            r !== "selectionchange" && (iL.has(r) || am(r, !1, e),
            am(r, !0, e))
        });
        var t = e.nodeType === 9 ? e : e.ownerDocument;
        t === null || t[oc] || (t[oc] = !0,
        am("selectionchange", !1, t))
    }
}
function hb(e, t, r, i) {
    switch (jA(t)) {
    case 1:
        var n = _N;
        break;
    case 4:
        n = yN;
        break;
    default:
        n = Py
    }
    r = n.bind(null, t, r, e),
    n = void 0,
    !Xg || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (n = !0),
    i ? n !== void 0 ? e.addEventListener(t, r, {
        capture: !0,
        passive: n
    }) : e.addEventListener(t, r, !0) : n !== void 0 ? e.addEventListener(t, r, {
        passive: n
    }) : e.addEventListener(t, r, !1)
}
function lm(e, t, r, i, n) {
    var s = i;
    if (!(t & 1) && !(t & 2) && i !== null)
        t: for (; ; ) {
            if (i === null)
                return;
            var o = i.tag;
            if (o === 3 || o === 4) {
                var a = i.stateNode.containerInfo;
                if (a === n || a.nodeType === 8 && a.parentNode === n)
                    break;
                if (o === 4)
                    for (o = i.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === n || l.nodeType === 8 && l.parentNode === n))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = no(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        i = s = o;
                        continue t
                    }
                    a = a.parentNode
                }
            }
            i = i.return
        }
    OA(function() {
        var h = s
          , u = wy(r)
          , c = [];
        t: {
            var d = ab.get(e);
            if (d !== void 0) {
                var f = Ry
                  , g = e;
                switch (e) {
                case "keypress":
                    if (id(r) === 0)
                        break t;
                case "keydown":
                case "keyup":
                    f = NN;
                    break;
                case "focusin":
                    g = "focus",
                    f = em;
                    break;
                case "focusout":
                    g = "blur",
                    f = em;
                    break;
                case "beforeblur":
                case "afterblur":
                    f = em;
                    break;
                case "click":
                    if (r.button === 2)
                        break t;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    f = X1;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    f = EN;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    f = BN;
                    break;
                case ib:
                case nb:
                case sb:
                    f = wN;
                    break;
                case ob:
                    f = FN;
                    break;
                case "scroll":
                    f = vN;
                    break;
                case "wheel":
                    f = GN;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    f = bN;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    f = K1
                }
                var p = (t & 4) !== 0
                  , v = !p && e === "scroll"
                  , y = p ? d !== null ? d + "Capture" : null : d;
                p = [];
                for (var m = h, _; m !== null; ) {
                    _ = m;
                    var x = _.stateNode;
                    if (_.tag === 5 && x !== null && (_ = x,
                    y !== null && (x = bh(m, y),
                    x != null && p.push(Nh(m, x, _)))),
                    v)
                        break;
                    m = m.return
                }
                0 < p.length && (d = new f(d,g,null,r,u),
                c.push({
                    event: d,
                    listeners: p
                }))
            }
        }
        if (!(t & 7)) {
            t: {
                if (d = e === "mouseover" || e === "pointerover",
                f = e === "mouseout" || e === "pointerout",
                d && r !== Vg && (g = r.relatedTarget || r.fromElement) && (no(g) || g[Dn]))
                    break t;
                if ((f || d) && (d = u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : window,
                f ? (g = r.relatedTarget || r.toElement,
                f = h,
                g = g ? no(g) : null,
                g !== null && (v = Bo(g),
                g !== v || g.tag !== 5 && g.tag !== 6) && (g = null)) : (f = null,
                g = h),
                f !== g)) {
                    if (p = X1,
                    x = "onMouseLeave",
                    y = "onMouseEnter",
                    m = "mouse",
                    (e === "pointerout" || e === "pointerover") && (p = K1,
                    x = "onPointerLeave",
                    y = "onPointerEnter",
                    m = "pointer"),
                    v = f == null ? d : pa(f),
                    _ = g == null ? d : pa(g),
                    d = new p(x,m + "leave",f,r,u),
                    d.target = v,
                    d.relatedTarget = _,
                    x = null,
                    no(u) === h && (p = new p(y,m + "enter",g,r,u),
                    p.target = _,
                    p.relatedTarget = v,
                    x = p),
                    v = x,
                    f && g)
                        e: {
                            for (p = f,
                            y = g,
                            m = 0,
                            _ = p; _; _ = Vo(_))
                                m++;
                            for (_ = 0,
                            x = y; x; x = Vo(x))
                                _++;
                            for (; 0 < m - _; )
                                p = Vo(p),
                                m--;
                            for (; 0 < _ - m; )
                                y = Vo(y),
                                _--;
                            for (; m--; ) {
                                if (p === y || y !== null && p === y.alternate)
                                    break e;
                                p = Vo(p),
                                y = Vo(y)
                            }
                            p = null
                        }
                    else
                        p = null;
                    f !== null && oE(c, d, f, p, !1),
                    g !== null && v !== null && oE(c, v, g, p, !0)
                }
            }
            t: {
                if (d = h ? pa(h) : window,
                f = d.nodeName && d.nodeName.toLowerCase(),
                f === "select" || f === "input" && d.type === "file")
                    var E = XN;
                else if (Q1(d))
                    if (QA)
                        E = ZN;
                    else {
                        E = KN;
                        var S = YN
                    }
                else
                    (f = d.nodeName) && f.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (E = qN);
                if (E && (E = E(e, h))) {
                    ZA(c, E, r, u);
                    break t
                }
                S && S(e, d, h),
                e === "focusout" && (S = d._wrapperState) && S.controlled && d.type === "number" && Gg(d, "number", d.value)
            }
            switch (S = h ? pa(h) : window,
            e) {
            case "focusin":
                (Q1(S) || S.contentEditable === "true") && (da = S,
                Qg = h,
                ah = null);
                break;
            case "focusout":
                ah = Qg = da = null;
                break;
            case "mousedown":
                Jg = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Jg = !1,
                iE(c, r, u);
                break;
            case "selectionchange":
                if (tL)
                    break;
            case "keydown":
            case "keyup":
                iE(c, r, u)
            }
            var w;
            if (Oy)
                t: {
                    switch (e) {
                    case "compositionstart":
                        var T = "onCompositionStart";
                        break t;
                    case "compositionend":
                        T = "onCompositionEnd";
                        break t;
                    case "compositionupdate":
                        T = "onCompositionUpdate";
                        break t
                    }
                    T = void 0
                }
            else
                ca ? KA(e, r) && (T = "onCompositionEnd") : e === "keydown" && r.keyCode === 229 && (T = "onCompositionStart");
            T && (YA && r.locale !== "ko" && (ca || T !== "onCompositionStart" ? T === "onCompositionEnd" && ca && (w = XA()) : (as = u,
            Iy = "value"in as ? as.value : as.textContent,
            ca = !0)),
            S = Ud(h, T),
            0 < S.length && (T = new Y1(T,e,null,r,u),
            c.push({
                event: T,
                listeners: S
            }),
            w ? T.data = w : (w = qA(r),
            w !== null && (T.data = w)))),
            (w = $N ? zN(e, r) : WN(e, r)) && (h = Ud(h, "onBeforeInput"),
            0 < h.length && (u = new Y1("onBeforeInput","beforeinput",null,r,u),
            c.push({
                event: u,
                listeners: h
            }),
            u.data = w))
        }
        lb(c, t)
    })
}
function Nh(e, t, r) {
    return {
        instance: e,
        listener: t,
        currentTarget: r
    }
}
function Ud(e, t) {
    for (var r = t + "Capture", i = []; e !== null; ) {
        var n = e
          , s = n.stateNode;
        n.tag === 5 && s !== null && (n = s,
        s = bh(e, r),
        s != null && i.unshift(Nh(e, s, n)),
        s = bh(e, t),
        s != null && i.push(Nh(e, s, n))),
        e = e.return
    }
    return i
}
function Vo(e) {
    if (e === null)
        return null;
    do
        e = e.return;
    while (e && e.tag !== 5);
    return e || null
}
function oE(e, t, r, i, n) {
    for (var s = t._reactName, o = []; r !== null && r !== i; ) {
        var a = r
          , l = a.alternate
          , h = a.stateNode;
        if (l !== null && l === i)
            break;
        a.tag === 5 && h !== null && (a = h,
        n ? (l = bh(r, s),
        l != null && o.unshift(Nh(r, l, a))) : n || (l = bh(r, s),
        l != null && o.push(Nh(r, l, a)))),
        r = r.return
    }
    o.length !== 0 && e.push({
        event: t,
        listeners: o
    })
}
var nL = /\r\n?/g
  , sL = /\u0000|\uFFFD/g;
function aE(e) {
    return (typeof e == "string" ? e : "" + e).replace(nL, `
`).replace(sL, "")
}
function ac(e, t, r) {
    if (t = aE(t),
    aE(e) !== t && r)
        throw Error(D(425))
}
function Gd() {}
var t0 = null
  , e0 = null;
function r0(e, t) {
    return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null
}
var i0 = typeof setTimeout == "function" ? setTimeout : void 0
  , oL = typeof clearTimeout == "function" ? clearTimeout : void 0
  , lE = typeof Promise == "function" ? Promise : void 0
  , aL = typeof queueMicrotask == "function" ? queueMicrotask : typeof lE < "u" ? function(e) {
    return lE.resolve(null).then(e).catch(lL)
}
: i0;
function lL(e) {
    setTimeout(function() {
        throw e
    })
}
function hm(e, t) {
    var r = t
      , i = 0;
    do {
        var n = r.nextSibling;
        if (e.removeChild(r),
        n && n.nodeType === 8)
            if (r = n.data,
            r === "/$") {
                if (i === 0) {
                    e.removeChild(n),
                    Ih(t);
                    return
                }
                i--
            } else
                r !== "$" && r !== "$?" && r !== "$!" || i++;
        r = n
    } while (r);
    Ih(t)
}
function _s(e) {
    for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === 1 || t === 3)
            break;
        if (t === 8) {
            if (t = e.data,
            t === "$" || t === "$!" || t === "$?")
                break;
            if (t === "/$")
                return null
        }
    }
    return e
}
function hE(e) {
    e = e.previousSibling;
    for (var t = 0; e; ) {
        if (e.nodeType === 8) {
            var r = e.data;
            if (r === "$" || r === "$!" || r === "$?") {
                if (t === 0)
                    return e;
                t--
            } else
                r === "/$" && t++
        }
        e = e.previousSibling
    }
    return null
}
var dl = Math.random().toString(36).slice(2)
  , Yi = "__reactFiber$" + dl
  , Lh = "__reactProps$" + dl
  , Dn = "__reactContainer$" + dl
  , n0 = "__reactEvents$" + dl
  , hL = "__reactListeners$" + dl
  , uL = "__reactHandles$" + dl;
function no(e) {
    var t = e[Yi];
    if (t)
        return t;
    for (var r = e.parentNode; r; ) {
        if (t = r[Dn] || r[Yi]) {
            if (r = t.alternate,
            t.child !== null || r !== null && r.child !== null)
                for (e = hE(e); e !== null; ) {
                    if (r = e[Yi])
                        return r;
                    e = hE(e)
                }
            return t
        }
        e = r,
        r = e.parentNode
    }
    return null
}
function Cu(e) {
    return e = e[Yi] || e[Dn],
    !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e
}
function pa(e) {
    if (e.tag === 5 || e.tag === 6)
        return e.stateNode;
    throw Error(D(33))
}
function Yf(e) {
    return e[Lh] || null
}
var s0 = []
  , ma = -1;
function Ls(e) {
    return {
        current: e
    }
}
function Bt(e) {
    0 > ma || (e.current = s0[ma],
    s0[ma] = null,
    ma--)
}
function Rt(e, t) {
    ma++,
    s0[ma] = e.current,
    e.current = t
}
var Cs = {}
  , je = Ls(Cs)
  , hr = Ls(!1)
  , So = Cs;
function Ua(e, t) {
    var r = e.type.contextTypes;
    if (!r)
        return Cs;
    var i = e.stateNode;
    if (i && i.__reactInternalMemoizedUnmaskedChildContext === t)
        return i.__reactInternalMemoizedMaskedChildContext;
    var n = {}, s;
    for (s in r)
        n[s] = t[s];
    return i && (e = e.stateNode,
    e.__reactInternalMemoizedUnmaskedChildContext = t,
    e.__reactInternalMemoizedMaskedChildContext = n),
    n
}
function ur(e) {
    return e = e.childContextTypes,
    e != null
}
function Hd() {
    Bt(hr),
    Bt(je)
}
function uE(e, t, r) {
    if (je.current !== Cs)
        throw Error(D(168));
    Rt(je, t),
    Rt(hr, r)
}
function ub(e, t, r) {
    var i = e.stateNode;
    if (t = t.childContextTypes,
    typeof i.getChildContext != "function")
        return r;
    i = i.getChildContext();
    for (var n in i)
        if (!(n in t))
            throw Error(D(108, Y2(e) || "Unknown", n));
    return Zt({}, r, i)
}
function $d(e) {
    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Cs,
    So = je.current,
    Rt(je, e),
    Rt(hr, hr.current),
    !0
}
function cE(e, t, r) {
    var i = e.stateNode;
    if (!i)
        throw Error(D(169));
    r ? (e = ub(e, t, So),
    i.__reactInternalMemoizedMergedChildContext = e,
    Bt(hr),
    Bt(je),
    Rt(je, e)) : Bt(hr),
    Rt(hr, r)
}
var En = null
  , Kf = !1
  , um = !1;
function cb(e) {
    En === null ? En = [e] : En.push(e)
}
function cL(e) {
    Kf = !0,
    cb(e)
}
function Ds() {
    if (!um && En !== null) {
        um = !0;
        var e = 0
          , t = St;
        try {
            var r = En;
            for (St = 1; e < r.length; e++) {
                var i = r[e];
                do
                    i = i(!0);
                while (i !== null)
            }
            En = null,
            Kf = !1
        } catch (n) {
            throw En !== null && (En = En.slice(e + 1)),
            BA(Ay, Ds),
            n
        } finally {
            St = t,
            um = !1
        }
    }
    return null
}
var ga = []
  , _a = 0
  , zd = null
  , Wd = 0
  , Xr = []
  , Yr = 0
  , wo = null
  , Cn = 1
  , Pn = "";
function Ks(e, t) {
    ga[_a++] = Wd,
    ga[_a++] = zd,
    zd = e,
    Wd = t
}
function db(e, t, r) {
    Xr[Yr++] = Cn,
    Xr[Yr++] = Pn,
    Xr[Yr++] = wo,
    wo = e;
    var i = Cn;
    e = Pn;
    var n = 32 - Ai(i) - 1;
    i &= ~(1 << n),
    r += 1;
    var s = 32 - Ai(t) + n;
    if (30 < s) {
        var o = n - n % 5;
        s = (i & (1 << o) - 1).toString(32),
        i >>= o,
        n -= o,
        Cn = 1 << 32 - Ai(t) + n | r << n | i,
        Pn = s + e
    } else
        Cn = 1 << s | r << n | i,
        Pn = e
}
function Ly(e) {
    e.return !== null && (Ks(e, 1),
    db(e, 1, 0))
}
function Dy(e) {
    for (; e === zd; )
        zd = ga[--_a],
        ga[_a] = null,
        Wd = ga[--_a],
        ga[_a] = null;
    for (; e === wo; )
        wo = Xr[--Yr],
        Xr[Yr] = null,
        Pn = Xr[--Yr],
        Xr[Yr] = null,
        Cn = Xr[--Yr],
        Xr[Yr] = null
}
var Or = null
  , Pr = null
  , Gt = !1
  , yi = null;
function fb(e, t) {
    var r = Zr(5, null, null, 0);
    r.elementType = "DELETED",
    r.stateNode = t,
    r.return = e,
    t = e.deletions,
    t === null ? (e.deletions = [r],
    e.flags |= 16) : t.push(r)
}
function dE(e, t) {
    switch (e.tag) {
    case 5:
        var r = e.type;
        return t = t.nodeType !== 1 || r.toLowerCase() !== t.nodeName.toLowerCase() ? null : t,
        t !== null ? (e.stateNode = t,
        Or = e,
        Pr = _s(t.firstChild),
        !0) : !1;
    case 6:
        return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t,
        t !== null ? (e.stateNode = t,
        Or = e,
        Pr = null,
        !0) : !1;
    case 13:
        return t = t.nodeType !== 8 ? null : t,
        t !== null ? (r = wo !== null ? {
            id: Cn,
            overflow: Pn
        } : null,
        e.memoizedState = {
            dehydrated: t,
            treeContext: r,
            retryLane: 1073741824
        },
        r = Zr(18, null, null, 0),
        r.stateNode = t,
        r.return = e,
        e.child = r,
        Or = e,
        Pr = null,
        !0) : !1;
    default:
        return !1
    }
}
function o0(e) {
    return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}
function a0(e) {
    if (Gt) {
        var t = Pr;
        if (t) {
            var r = t;
            if (!dE(e, t)) {
                if (o0(e))
                    throw Error(D(418));
                t = _s(r.nextSibling);
                var i = Or;
                t && dE(e, t) ? fb(i, r) : (e.flags = e.flags & -4097 | 2,
                Gt = !1,
                Or = e)
            }
        } else {
            if (o0(e))
                throw Error(D(418));
            e.flags = e.flags & -4097 | 2,
            Gt = !1,
            Or = e
        }
    }
}
function fE(e) {
    for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )
        e = e.return;
    Or = e
}
function lc(e) {
    if (e !== Or)
        return !1;
    if (!Gt)
        return fE(e),
        Gt = !0,
        !1;
    var t;
    if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type,
    t = t !== "head" && t !== "body" && !r0(e.type, e.memoizedProps)),
    t && (t = Pr)) {
        if (o0(e))
            throw pb(),
            Error(D(418));
        for (; t; )
            fb(e, t),
            t = _s(t.nextSibling)
    }
    if (fE(e),
    e.tag === 13) {
        if (e = e.memoizedState,
        e = e !== null ? e.dehydrated : null,
        !e)
            throw Error(D(317));
        t: {
            for (e = e.nextSibling,
            t = 0; e; ) {
                if (e.nodeType === 8) {
                    var r = e.data;
                    if (r === "/$") {
                        if (t === 0) {
                            Pr = _s(e.nextSibling);
                            break t
                        }
                        t--
                    } else
                        r !== "$" && r !== "$!" && r !== "$?" || t++
                }
                e = e.nextSibling
            }
            Pr = null
        }
    } else
        Pr = Or ? _s(e.stateNode.nextSibling) : null;
    return !0
}
function pb() {
    for (var e = Pr; e; )
        e = _s(e.nextSibling)
}
function Ga() {
    Pr = Or = null,
    Gt = !1
}
function By(e) {
    yi === null ? yi = [e] : yi.push(e)
}
var dL = Wn.ReactCurrentBatchConfig;
function gi(e, t) {
    if (e && e.defaultProps) {
        t = Zt({}, t),
        e = e.defaultProps;
        for (var r in e)
            t[r] === void 0 && (t[r] = e[r]);
        return t
    }
    return t
}
var Vd = Ls(null)
  , jd = null
  , ya = null
  , ky = null;
function Fy() {
    ky = ya = jd = null
}
function Uy(e) {
    var t = Vd.current;
    Bt(Vd),
    e._currentValue = t
}
function l0(e, t, r) {
    for (; e !== null; ) {
        var i = e.alternate;
        if ((e.childLanes & t) !== t ? (e.childLanes |= t,
        i !== null && (i.childLanes |= t)) : i !== null && (i.childLanes & t) !== t && (i.childLanes |= t),
        e === r)
            break;
        e = e.return
    }
}
function Pa(e, t) {
    jd = e,
    ky = ya = null,
    e = e.dependencies,
    e !== null && e.firstContext !== null && (e.lanes & t && (lr = !0),
    e.firstContext = null)
}
function si(e) {
    var t = e._currentValue;
    if (ky !== e)
        if (e = {
            context: e,
            memoizedValue: t,
            next: null
        },
        ya === null) {
            if (jd === null)
                throw Error(D(308));
            ya = e,
            jd.dependencies = {
                lanes: 0,
                firstContext: e
            }
        } else
            ya = ya.next = e;
    return t
}
var so = null;
function Gy(e) {
    so === null ? so = [e] : so.push(e)
}
function mb(e, t, r, i) {
    var n = t.interleaved;
    return n === null ? (r.next = r,
    Gy(t)) : (r.next = n.next,
    n.next = r),
    t.interleaved = r,
    Bn(e, i)
}
function Bn(e, t) {
    e.lanes |= t;
    var r = e.alternate;
    for (r !== null && (r.lanes |= t),
    r = e,
    e = e.return; e !== null; )
        e.childLanes |= t,
        r = e.alternate,
        r !== null && (r.childLanes |= t),
        r = e,
        e = e.return;
    return r.tag === 3 ? r.stateNode : null
}
var Jn = !1;
function Hy(e) {
    e.updateQueue = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function gb(e, t) {
    e = e.updateQueue,
    t.updateQueue === e && (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects
    })
}
function Mn(e, t) {
    return {
        eventTime: e,
        lane: t,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function ys(e, t, r) {
    var i = e.updateQueue;
    if (i === null)
        return null;
    if (i = i.shared,
    yt & 2) {
        var n = i.pending;
        return n === null ? t.next = t : (t.next = n.next,
        n.next = t),
        i.pending = t,
        Bn(e, r)
    }
    return n = i.interleaved,
    n === null ? (t.next = t,
    Gy(i)) : (t.next = n.next,
    n.next = t),
    i.interleaved = t,
    Bn(e, r)
}
function nd(e, t, r) {
    if (t = t.updateQueue,
    t !== null && (t = t.shared,
    (r & 4194240) !== 0)) {
        var i = t.lanes;
        i &= e.pendingLanes,
        r |= i,
        t.lanes = r,
        by(e, r)
    }
}
function pE(e, t) {
    var r = e.updateQueue
      , i = e.alternate;
    if (i !== null && (i = i.updateQueue,
    r === i)) {
        var n = null
          , s = null;
        if (r = r.firstBaseUpdate,
        r !== null) {
            do {
                var o = {
                    eventTime: r.eventTime,
                    lane: r.lane,
                    tag: r.tag,
                    payload: r.payload,
                    callback: r.callback,
                    next: null
                };
                s === null ? n = s = o : s = s.next = o,
                r = r.next
            } while (r !== null);
            s === null ? n = s = t : s = s.next = t
        } else
            n = s = t;
        r = {
            baseState: i.baseState,
            firstBaseUpdate: n,
            lastBaseUpdate: s,
            shared: i.shared,
            effects: i.effects
        },
        e.updateQueue = r;
        return
    }
    e = r.lastBaseUpdate,
    e === null ? r.firstBaseUpdate = t : e.next = t,
    r.lastBaseUpdate = t
}
function Xd(e, t, r, i) {
    var n = e.updateQueue;
    Jn = !1;
    var s = n.firstBaseUpdate
      , o = n.lastBaseUpdate
      , a = n.shared.pending;
    if (a !== null) {
        n.shared.pending = null;
        var l = a
          , h = l.next;
        l.next = null,
        o === null ? s = h : o.next = h,
        o = l;
        var u = e.alternate;
        u !== null && (u = u.updateQueue,
        a = u.lastBaseUpdate,
        a !== o && (a === null ? u.firstBaseUpdate = h : a.next = h,
        u.lastBaseUpdate = l))
    }
    if (s !== null) {
        var c = n.baseState;
        o = 0,
        u = h = l = null,
        a = s;
        do {
            var d = a.lane
              , f = a.eventTime;
            if ((i & d) === d) {
                u !== null && (u = u.next = {
                    eventTime: f,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                t: {
                    var g = e
                      , p = a;
                    switch (d = t,
                    f = r,
                    p.tag) {
                    case 1:
                        if (g = p.payload,
                        typeof g == "function") {
                            c = g.call(f, c, d);
                            break t
                        }
                        c = g;
                        break t;
                    case 3:
                        g.flags = g.flags & -65537 | 128;
                    case 0:
                        if (g = p.payload,
                        d = typeof g == "function" ? g.call(f, c, d) : g,
                        d == null)
                            break t;
                        c = Zt({}, c, d);
                        break t;
                    case 2:
                        Jn = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (e.flags |= 64,
                d = n.effects,
                d === null ? n.effects = [a] : d.push(a))
            } else
                f = {
                    eventTime: f,
                    lane: d,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                u === null ? (h = u = f,
                l = c) : u = u.next = f,
                o |= d;
            if (a = a.next,
            a === null) {
                if (a = n.shared.pending,
                a === null)
                    break;
                d = a,
                a = d.next,
                d.next = null,
                n.lastBaseUpdate = d,
                n.shared.pending = null
            }
        } while (1);
        if (u === null && (l = c),
        n.baseState = l,
        n.firstBaseUpdate = h,
        n.lastBaseUpdate = u,
        t = n.shared.interleaved,
        t !== null) {
            n = t;
            do
                o |= n.lane,
                n = n.next;
            while (n !== t)
        } else
            s === null && (n.shared.lanes = 0);
        bo |= o,
        e.lanes = o,
        e.memoizedState = c
    }
}
function mE(e, t, r) {
    if (e = t.effects,
    t.effects = null,
    e !== null)
        for (t = 0; t < e.length; t++) {
            var i = e[t]
              , n = i.callback;
            if (n !== null) {
                if (i.callback = null,
                i = r,
                typeof n != "function")
                    throw Error(D(191, n));
                n.call(i)
            }
        }
}
var _b = new mA.Component().refs;
function h0(e, t, r, i) {
    t = e.memoizedState,
    r = r(i, t),
    r = r == null ? t : Zt({}, t, r),
    e.memoizedState = r,
    e.lanes === 0 && (e.updateQueue.baseState = r)
}
var qf = {
    isMounted: function(e) {
        return (e = e._reactInternals) ? Bo(e) === e : !1
    },
    enqueueSetState: function(e, t, r) {
        e = e._reactInternals;
        var i = er()
          , n = xs(e)
          , s = Mn(i, n);
        s.payload = t,
        r != null && (s.callback = r),
        t = ys(e, s, n),
        t !== null && (bi(t, e, n, i),
        nd(t, e, n))
    },
    enqueueReplaceState: function(e, t, r) {
        e = e._reactInternals;
        var i = er()
          , n = xs(e)
          , s = Mn(i, n);
        s.tag = 1,
        s.payload = t,
        r != null && (s.callback = r),
        t = ys(e, s, n),
        t !== null && (bi(t, e, n, i),
        nd(t, e, n))
    },
    enqueueForceUpdate: function(e, t) {
        e = e._reactInternals;
        var r = er()
          , i = xs(e)
          , n = Mn(r, i);
        n.tag = 2,
        t != null && (n.callback = t),
        t = ys(e, n, i),
        t !== null && (bi(t, e, i, r),
        nd(t, e, i))
    }
};
function gE(e, t, r, i, n, s, o) {
    return e = e.stateNode,
    typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(i, s, o) : t.prototype && t.prototype.isPureReactComponent ? !Mh(r, i) || !Mh(n, s) : !0
}
function yb(e, t, r) {
    var i = !1
      , n = Cs
      , s = t.contextType;
    return typeof s == "object" && s !== null ? s = si(s) : (n = ur(t) ? So : je.current,
    i = t.contextTypes,
    s = (i = i != null) ? Ua(e, n) : Cs),
    t = new t(r,s),
    e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null,
    t.updater = qf,
    e.stateNode = t,
    t._reactInternals = e,
    i && (e = e.stateNode,
    e.__reactInternalMemoizedUnmaskedChildContext = n,
    e.__reactInternalMemoizedMaskedChildContext = s),
    t
}
function _E(e, t, r, i) {
    e = t.state,
    typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(r, i),
    typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(r, i),
    t.state !== e && qf.enqueueReplaceState(t, t.state, null)
}
function u0(e, t, r, i) {
    var n = e.stateNode;
    n.props = r,
    n.state = e.memoizedState,
    n.refs = _b,
    Hy(e);
    var s = t.contextType;
    typeof s == "object" && s !== null ? n.context = si(s) : (s = ur(t) ? So : je.current,
    n.context = Ua(e, s)),
    n.state = e.memoizedState,
    s = t.getDerivedStateFromProps,
    typeof s == "function" && (h0(e, t, s, r),
    n.state = e.memoizedState),
    typeof t.getDerivedStateFromProps == "function" || typeof n.getSnapshotBeforeUpdate == "function" || typeof n.UNSAFE_componentWillMount != "function" && typeof n.componentWillMount != "function" || (t = n.state,
    typeof n.componentWillMount == "function" && n.componentWillMount(),
    typeof n.UNSAFE_componentWillMount == "function" && n.UNSAFE_componentWillMount(),
    t !== n.state && qf.enqueueReplaceState(n, n.state, null),
    Xd(e, r, n, i),
    n.state = e.memoizedState),
    typeof n.componentDidMount == "function" && (e.flags |= 4194308)
}
function Al(e, t, r) {
    if (e = r.ref,
    e !== null && typeof e != "function" && typeof e != "object") {
        if (r._owner) {
            if (r = r._owner,
            r) {
                if (r.tag !== 1)
                    throw Error(D(309));
                var i = r.stateNode
            }
            if (!i)
                throw Error(D(147, e));
            var n = i
              , s = "" + e;
            return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === s ? t.ref : (t = function(o) {
                var a = n.refs;
                a === _b && (a = n.refs = {}),
                o === null ? delete a[s] : a[s] = o
            }
            ,
            t._stringRef = s,
            t)
        }
        if (typeof e != "string")
            throw Error(D(284));
        if (!r._owner)
            throw Error(D(290, e))
    }
    return e
}
function hc(e, t) {
    throw e = Object.prototype.toString.call(t),
    Error(D(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
}
function yE(e) {
    var t = e._init;
    return t(e._payload)
}
function vb(e) {
    function t(y, m) {
        if (e) {
            var _ = y.deletions;
            _ === null ? (y.deletions = [m],
            y.flags |= 16) : _.push(m)
        }
    }
    function r(y, m) {
        if (!e)
            return null;
        for (; m !== null; )
            t(y, m),
            m = m.sibling;
        return null
    }
    function i(y, m) {
        for (y = new Map; m !== null; )
            m.key !== null ? y.set(m.key, m) : y.set(m.index, m),
            m = m.sibling;
        return y
    }
    function n(y, m) {
        return y = Es(y, m),
        y.index = 0,
        y.sibling = null,
        y
    }
    function s(y, m, _) {
        return y.index = _,
        e ? (_ = y.alternate,
        _ !== null ? (_ = _.index,
        _ < m ? (y.flags |= 2,
        m) : _) : (y.flags |= 2,
        m)) : (y.flags |= 1048576,
        m)
    }
    function o(y) {
        return e && y.alternate === null && (y.flags |= 2),
        y
    }
    function a(y, m, _, x) {
        return m === null || m.tag !== 6 ? (m = _m(_, y.mode, x),
        m.return = y,
        m) : (m = n(m, _),
        m.return = y,
        m)
    }
    function l(y, m, _, x) {
        var E = _.type;
        return E === ua ? u(y, m, _.props.children, x, _.key) : m !== null && (m.elementType === E || typeof E == "object" && E !== null && E.$$typeof === Qn && yE(E) === m.type) ? (x = n(m, _.props),
        x.ref = Al(y, m, _),
        x.return = y,
        x) : (x = ud(_.type, _.key, _.props, null, y.mode, x),
        x.ref = Al(y, m, _),
        x.return = y,
        x)
    }
    function h(y, m, _, x) {
        return m === null || m.tag !== 4 || m.stateNode.containerInfo !== _.containerInfo || m.stateNode.implementation !== _.implementation ? (m = ym(_, y.mode, x),
        m.return = y,
        m) : (m = n(m, _.children || []),
        m.return = y,
        m)
    }
    function u(y, m, _, x, E) {
        return m === null || m.tag !== 7 ? (m = uo(_, y.mode, x, E),
        m.return = y,
        m) : (m = n(m, _),
        m.return = y,
        m)
    }
    function c(y, m, _) {
        if (typeof m == "string" && m !== "" || typeof m == "number")
            return m = _m("" + m, y.mode, _),
            m.return = y,
            m;
        if (typeof m == "object" && m !== null) {
            switch (m.$$typeof) {
            case Qu:
                return _ = ud(m.type, m.key, m.props, null, y.mode, _),
                _.ref = Al(y, null, m),
                _.return = y,
                _;
            case ha:
                return m = ym(m, y.mode, _),
                m.return = y,
                m;
            case Qn:
                var x = m._init;
                return c(y, x(m._payload), _)
            }
            if (Gl(m) || xl(m))
                return m = uo(m, y.mode, _, null),
                m.return = y,
                m;
            hc(y, m)
        }
        return null
    }
    function d(y, m, _, x) {
        var E = m !== null ? m.key : null;
        if (typeof _ == "string" && _ !== "" || typeof _ == "number")
            return E !== null ? null : a(y, m, "" + _, x);
        if (typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
            case Qu:
                return _.key === E ? l(y, m, _, x) : null;
            case ha:
                return _.key === E ? h(y, m, _, x) : null;
            case Qn:
                return E = _._init,
                d(y, m, E(_._payload), x)
            }
            if (Gl(_) || xl(_))
                return E !== null ? null : u(y, m, _, x, null);
            hc(y, _)
        }
        return null
    }
    function f(y, m, _, x, E) {
        if (typeof x == "string" && x !== "" || typeof x == "number")
            return y = y.get(_) || null,
            a(m, y, "" + x, E);
        if (typeof x == "object" && x !== null) {
            switch (x.$$typeof) {
            case Qu:
                return y = y.get(x.key === null ? _ : x.key) || null,
                l(m, y, x, E);
            case ha:
                return y = y.get(x.key === null ? _ : x.key) || null,
                h(m, y, x, E);
            case Qn:
                var S = x._init;
                return f(y, m, _, S(x._payload), E)
            }
            if (Gl(x) || xl(x))
                return y = y.get(_) || null,
                u(m, y, x, E, null);
            hc(m, x)
        }
        return null
    }
    function g(y, m, _, x) {
        for (var E = null, S = null, w = m, T = m = 0, C = null; w !== null && T < _.length; T++) {
            w.index > T ? (C = w,
            w = null) : C = w.sibling;
            var R = d(y, w, _[T], x);
            if (R === null) {
                w === null && (w = C);
                break
            }
            e && w && R.alternate === null && t(y, w),
            m = s(R, m, T),
            S === null ? E = R : S.sibling = R,
            S = R,
            w = C
        }
        if (T === _.length)
            return r(y, w),
            Gt && Ks(y, T),
            E;
        if (w === null) {
            for (; T < _.length; T++)
                w = c(y, _[T], x),
                w !== null && (m = s(w, m, T),
                S === null ? E = w : S.sibling = w,
                S = w);
            return Gt && Ks(y, T),
            E
        }
        for (w = i(y, w); T < _.length; T++)
            C = f(w, y, T, _[T], x),
            C !== null && (e && C.alternate !== null && w.delete(C.key === null ? T : C.key),
            m = s(C, m, T),
            S === null ? E = C : S.sibling = C,
            S = C);
        return e && w.forEach(function(O) {
            return t(y, O)
        }),
        Gt && Ks(y, T),
        E
    }
    function p(y, m, _, x) {
        var E = xl(_);
        if (typeof E != "function")
            throw Error(D(150));
        if (_ = E.call(_),
        _ == null)
            throw Error(D(151));
        for (var S = E = null, w = m, T = m = 0, C = null, R = _.next(); w !== null && !R.done; T++,
        R = _.next()) {
            w.index > T ? (C = w,
            w = null) : C = w.sibling;
            var O = d(y, w, R.value, x);
            if (O === null) {
                w === null && (w = C);
                break
            }
            e && w && O.alternate === null && t(y, w),
            m = s(O, m, T),
            S === null ? E = O : S.sibling = O,
            S = O,
            w = C
        }
        if (R.done)
            return r(y, w),
            Gt && Ks(y, T),
            E;
        if (w === null) {
            for (; !R.done; T++,
            R = _.next())
                R = c(y, R.value, x),
                R !== null && (m = s(R, m, T),
                S === null ? E = R : S.sibling = R,
                S = R);
            return Gt && Ks(y, T),
            E
        }
        for (w = i(y, w); !R.done; T++,
        R = _.next())
            R = f(w, y, T, R.value, x),
            R !== null && (e && R.alternate !== null && w.delete(R.key === null ? T : R.key),
            m = s(R, m, T),
            S === null ? E = R : S.sibling = R,
            S = R);
        return e && w.forEach(function(N) {
            return t(y, N)
        }),
        Gt && Ks(y, T),
        E
    }
    function v(y, m, _, x) {
        if (typeof _ == "object" && _ !== null && _.type === ua && _.key === null && (_ = _.props.children),
        typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
            case Qu:
                t: {
                    for (var E = _.key, S = m; S !== null; ) {
                        if (S.key === E) {
                            if (E = _.type,
                            E === ua) {
                                if (S.tag === 7) {
                                    r(y, S.sibling),
                                    m = n(S, _.props.children),
                                    m.return = y,
                                    y = m;
                                    break t
                                }
                            } else if (S.elementType === E || typeof E == "object" && E !== null && E.$$typeof === Qn && yE(E) === S.type) {
                                r(y, S.sibling),
                                m = n(S, _.props),
                                m.ref = Al(y, S, _),
                                m.return = y,
                                y = m;
                                break t
                            }
                            r(y, S);
                            break
                        } else
                            t(y, S);
                        S = S.sibling
                    }
                    _.type === ua ? (m = uo(_.props.children, y.mode, x, _.key),
                    m.return = y,
                    y = m) : (x = ud(_.type, _.key, _.props, null, y.mode, x),
                    x.ref = Al(y, m, _),
                    x.return = y,
                    y = x)
                }
                return o(y);
            case ha:
                t: {
                    for (S = _.key; m !== null; ) {
                        if (m.key === S)
                            if (m.tag === 4 && m.stateNode.containerInfo === _.containerInfo && m.stateNode.implementation === _.implementation) {
                                r(y, m.sibling),
                                m = n(m, _.children || []),
                                m.return = y,
                                y = m;
                                break t
                            } else {
                                r(y, m);
                                break
                            }
                        else
                            t(y, m);
                        m = m.sibling
                    }
                    m = ym(_, y.mode, x),
                    m.return = y,
                    y = m
                }
                return o(y);
            case Qn:
                return S = _._init,
                v(y, m, S(_._payload), x)
            }
            if (Gl(_))
                return g(y, m, _, x);
            if (xl(_))
                return p(y, m, _, x);
            hc(y, _)
        }
        return typeof _ == "string" && _ !== "" || typeof _ == "number" ? (_ = "" + _,
        m !== null && m.tag === 6 ? (r(y, m.sibling),
        m = n(m, _),
        m.return = y,
        y = m) : (r(y, m),
        m = _m(_, y.mode, x),
        m.return = y,
        y = m),
        o(y)) : r(y, m)
    }
    return v
}
var Ha = vb(!0)
  , xb = vb(!1)
  , Pu = {}
  , sn = Ls(Pu)
  , Dh = Ls(Pu)
  , Bh = Ls(Pu);
function oo(e) {
    if (e === Pu)
        throw Error(D(174));
    return e
}
function $y(e, t) {
    switch (Rt(Bh, t),
    Rt(Dh, e),
    Rt(sn, Pu),
    e = t.nodeType,
    e) {
    case 9:
    case 11:
        t = (t = t.documentElement) ? t.namespaceURI : $g(null, "");
        break;
    default:
        e = e === 8 ? t.parentNode : t,
        t = e.namespaceURI || null,
        e = e.tagName,
        t = $g(t, e)
    }
    Bt(sn),
    Rt(sn, t)
}
function $a() {
    Bt(sn),
    Bt(Dh),
    Bt(Bh)
}
function Eb(e) {
    oo(Bh.current);
    var t = oo(sn.current)
      , r = $g(t, e.type);
    t !== r && (Rt(Dh, e),
    Rt(sn, r))
}
function zy(e) {
    Dh.current === e && (Bt(sn),
    Bt(Dh))
}
var jt = Ls(0);
function Yd(e) {
    for (var t = e; t !== null; ) {
        if (t.tag === 13) {
            var r = t.memoizedState;
            if (r !== null && (r = r.dehydrated,
            r === null || r.data === "$?" || r.data === "$!"))
                return t
        } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
            if (t.flags & 128)
                return t
        } else if (t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return null;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
    return null
}
var cm = [];
function Wy() {
    for (var e = 0; e < cm.length; e++)
        cm[e]._workInProgressVersionPrimary = null;
    cm.length = 0
}
var sd = Wn.ReactCurrentDispatcher
  , dm = Wn.ReactCurrentBatchConfig
  , Ao = 0
  , qt = null
  , ge = null
  , Te = null
  , Kd = !1
  , lh = !1
  , kh = 0
  , fL = 0;
function ke() {
    throw Error(D(321))
}
function Vy(e, t) {
    if (t === null)
        return !1;
    for (var r = 0; r < t.length && r < e.length; r++)
        if (!Oi(e[r], t[r]))
            return !1;
    return !0
}
function jy(e, t, r, i, n, s) {
    if (Ao = s,
    qt = t,
    t.memoizedState = null,
    t.updateQueue = null,
    t.lanes = 0,
    sd.current = e === null || e.memoizedState === null ? _L : yL,
    e = r(i, n),
    lh) {
        s = 0;
        do {
            if (lh = !1,
            kh = 0,
            25 <= s)
                throw Error(D(301));
            s += 1,
            Te = ge = null,
            t.updateQueue = null,
            sd.current = vL,
            e = r(i, n)
        } while (lh)
    }
    if (sd.current = qd,
    t = ge !== null && ge.next !== null,
    Ao = 0,
    Te = ge = qt = null,
    Kd = !1,
    t)
        throw Error(D(300));
    return e
}
function Xy() {
    var e = kh !== 0;
    return kh = 0,
    e
}
function Wi() {
    var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Te === null ? qt.memoizedState = Te = e : Te = Te.next = e,
    Te
}
function oi() {
    if (ge === null) {
        var e = qt.alternate;
        e = e !== null ? e.memoizedState : null
    } else
        e = ge.next;
    var t = Te === null ? qt.memoizedState : Te.next;
    if (t !== null)
        Te = t,
        ge = e;
    else {
        if (e === null)
            throw Error(D(310));
        ge = e,
        e = {
            memoizedState: ge.memoizedState,
            baseState: ge.baseState,
            baseQueue: ge.baseQueue,
            queue: ge.queue,
            next: null
        },
        Te === null ? qt.memoizedState = Te = e : Te = Te.next = e
    }
    return Te
}
function Fh(e, t) {
    return typeof t == "function" ? t(e) : t
}
function fm(e) {
    var t = oi()
      , r = t.queue;
    if (r === null)
        throw Error(D(311));
    r.lastRenderedReducer = e;
    var i = ge
      , n = i.baseQueue
      , s = r.pending;
    if (s !== null) {
        if (n !== null) {
            var o = n.next;
            n.next = s.next,
            s.next = o
        }
        i.baseQueue = n = s,
        r.pending = null
    }
    if (n !== null) {
        s = n.next,
        i = i.baseState;
        var a = o = null
          , l = null
          , h = s;
        do {
            var u = h.lane;
            if ((Ao & u) === u)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: h.action,
                    hasEagerState: h.hasEagerState,
                    eagerState: h.eagerState,
                    next: null
                }),
                i = h.hasEagerState ? h.eagerState : e(i, h.action);
            else {
                var c = {
                    lane: u,
                    action: h.action,
                    hasEagerState: h.hasEagerState,
                    eagerState: h.eagerState,
                    next: null
                };
                l === null ? (a = l = c,
                o = i) : l = l.next = c,
                qt.lanes |= u,
                bo |= u
            }
            h = h.next
        } while (h !== null && h !== s);
        l === null ? o = i : l.next = a,
        Oi(i, t.memoizedState) || (lr = !0),
        t.memoizedState = i,
        t.baseState = o,
        t.baseQueue = l,
        r.lastRenderedState = i
    }
    if (e = r.interleaved,
    e !== null) {
        n = e;
        do
            s = n.lane,
            qt.lanes |= s,
            bo |= s,
            n = n.next;
        while (n !== e)
    } else
        n === null && (r.lanes = 0);
    return [t.memoizedState, r.dispatch]
}
function pm(e) {
    var t = oi()
      , r = t.queue;
    if (r === null)
        throw Error(D(311));
    r.lastRenderedReducer = e;
    var i = r.dispatch
      , n = r.pending
      , s = t.memoizedState;
    if (n !== null) {
        r.pending = null;
        var o = n = n.next;
        do
            s = e(s, o.action),
            o = o.next;
        while (o !== n);
        Oi(s, t.memoizedState) || (lr = !0),
        t.memoizedState = s,
        t.baseQueue === null && (t.baseState = s),
        r.lastRenderedState = s
    }
    return [s, i]
}
function Tb() {}
function Sb(e, t) {
    var r = qt
      , i = oi()
      , n = t()
      , s = !Oi(i.memoizedState, n);
    if (s && (i.memoizedState = n,
    lr = !0),
    i = i.queue,
    Yy(bb.bind(null, r, i, e), [e]),
    i.getSnapshot !== t || s || Te !== null && Te.memoizedState.tag & 1) {
        if (r.flags |= 2048,
        Uh(9, Ab.bind(null, r, i, n, t), void 0, null),
        Ae === null)
            throw Error(D(349));
        Ao & 30 || wb(r, t, n)
    }
    return n
}
function wb(e, t, r) {
    e.flags |= 16384,
    e = {
        getSnapshot: t,
        value: r
    },
    t = qt.updateQueue,
    t === null ? (t = {
        lastEffect: null,
        stores: null
    },
    qt.updateQueue = t,
    t.stores = [e]) : (r = t.stores,
    r === null ? t.stores = [e] : r.push(e))
}
function Ab(e, t, r, i) {
    t.value = r,
    t.getSnapshot = i,
    Cb(t) && Pb(e)
}
function bb(e, t, r) {
    return r(function() {
        Cb(t) && Pb(e)
    })
}
function Cb(e) {
    var t = e.getSnapshot;
    e = e.value;
    try {
        var r = t();
        return !Oi(e, r)
    } catch {
        return !0
    }
}
function Pb(e) {
    var t = Bn(e, 1);
    t !== null && bi(t, e, 1, -1)
}
function vE(e) {
    var t = Wi();
    return typeof e == "function" && (e = e()),
    t.memoizedState = t.baseState = e,
    e = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Fh,
        lastRenderedState: e
    },
    t.queue = e,
    e = e.dispatch = gL.bind(null, qt, e),
    [t.memoizedState, e]
}
function Uh(e, t, r, i) {
    return e = {
        tag: e,
        create: t,
        destroy: r,
        deps: i,
        next: null
    },
    t = qt.updateQueue,
    t === null ? (t = {
        lastEffect: null,
        stores: null
    },
    qt.updateQueue = t,
    t.lastEffect = e.next = e) : (r = t.lastEffect,
    r === null ? t.lastEffect = e.next = e : (i = r.next,
    r.next = e,
    e.next = i,
    t.lastEffect = e)),
    e
}
function Ib() {
    return oi().memoizedState
}
function od(e, t, r, i) {
    var n = Wi();
    qt.flags |= e,
    n.memoizedState = Uh(1 | t, r, void 0, i === void 0 ? null : i)
}
function Zf(e, t, r, i) {
    var n = oi();
    i = i === void 0 ? null : i;
    var s = void 0;
    if (ge !== null) {
        var o = ge.memoizedState;
        if (s = o.destroy,
        i !== null && Vy(i, o.deps)) {
            n.memoizedState = Uh(t, r, s, i);
            return
        }
    }
    qt.flags |= e,
    n.memoizedState = Uh(1 | t, r, s, i)
}
function xE(e, t) {
    return od(8390656, 8, e, t)
}
function Yy(e, t) {
    return Zf(2048, 8, e, t)
}
function Rb(e, t) {
    return Zf(4, 2, e, t)
}
function Mb(e, t) {
    return Zf(4, 4, e, t)
}
function Ob(e, t) {
    if (typeof t == "function")
        return e = e(),
        t(e),
        function() {
            t(null)
        }
        ;
    if (t != null)
        return e = e(),
        t.current = e,
        function() {
            t.current = null
        }
}
function Nb(e, t, r) {
    return r = r != null ? r.concat([e]) : null,
    Zf(4, 4, Ob.bind(null, t, e), r)
}
function Ky() {}
function Lb(e, t) {
    var r = oi();
    t = t === void 0 ? null : t;
    var i = r.memoizedState;
    return i !== null && t !== null && Vy(t, i[1]) ? i[0] : (r.memoizedState = [e, t],
    e)
}
function Db(e, t) {
    var r = oi();
    t = t === void 0 ? null : t;
    var i = r.memoizedState;
    return i !== null && t !== null && Vy(t, i[1]) ? i[0] : (e = e(),
    r.memoizedState = [e, t],
    e)
}
function Bb(e, t, r) {
    return Ao & 21 ? (Oi(r, t) || (r = UA(),
    qt.lanes |= r,
    bo |= r,
    e.baseState = !0),
    t) : (e.baseState && (e.baseState = !1,
    lr = !0),
    e.memoizedState = r)
}
function pL(e, t) {
    var r = St;
    St = r !== 0 && 4 > r ? r : 4,
    e(!0);
    var i = dm.transition;
    dm.transition = {};
    try {
        e(!1),
        t()
    } finally {
        St = r,
        dm.transition = i
    }
}
function kb() {
    return oi().memoizedState
}
function mL(e, t, r) {
    var i = xs(e);
    if (r = {
        lane: i,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    Fb(e))
        Ub(t, r);
    else if (r = mb(e, t, r, i),
    r !== null) {
        var n = er();
        bi(r, e, i, n),
        Gb(r, t, i)
    }
}
function gL(e, t, r) {
    var i = xs(e)
      , n = {
        lane: i,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (Fb(e))
        Ub(t, n);
    else {
        var s = e.alternate;
        if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer,
        s !== null))
            try {
                var o = t.lastRenderedState
                  , a = s(o, r);
                if (n.hasEagerState = !0,
                n.eagerState = a,
                Oi(a, o)) {
                    var l = t.interleaved;
                    l === null ? (n.next = n,
                    Gy(t)) : (n.next = l.next,
                    l.next = n),
                    t.interleaved = n;
                    return
                }
            } catch {} finally {}
        r = mb(e, t, n, i),
        r !== null && (n = er(),
        bi(r, e, i, n),
        Gb(r, t, i))
    }
}
function Fb(e) {
    var t = e.alternate;
    return e === qt || t !== null && t === qt
}
function Ub(e, t) {
    lh = Kd = !0;
    var r = e.pending;
    r === null ? t.next = t : (t.next = r.next,
    r.next = t),
    e.pending = t
}
function Gb(e, t, r) {
    if (r & 4194240) {
        var i = t.lanes;
        i &= e.pendingLanes,
        r |= i,
        t.lanes = r,
        by(e, r)
    }
}
var qd = {
    readContext: si,
    useCallback: ke,
    useContext: ke,
    useEffect: ke,
    useImperativeHandle: ke,
    useInsertionEffect: ke,
    useLayoutEffect: ke,
    useMemo: ke,
    useReducer: ke,
    useRef: ke,
    useState: ke,
    useDebugValue: ke,
    useDeferredValue: ke,
    useTransition: ke,
    useMutableSource: ke,
    useSyncExternalStore: ke,
    useId: ke,
    unstable_isNewReconciler: !1
}
  , _L = {
    readContext: si,
    useCallback: function(e, t) {
        return Wi().memoizedState = [e, t === void 0 ? null : t],
        e
    },
    useContext: si,
    useEffect: xE,
    useImperativeHandle: function(e, t, r) {
        return r = r != null ? r.concat([e]) : null,
        od(4194308, 4, Ob.bind(null, t, e), r)
    },
    useLayoutEffect: function(e, t) {
        return od(4194308, 4, e, t)
    },
    useInsertionEffect: function(e, t) {
        return od(4, 2, e, t)
    },
    useMemo: function(e, t) {
        var r = Wi();
        return t = t === void 0 ? null : t,
        e = e(),
        r.memoizedState = [e, t],
        e
    },
    useReducer: function(e, t, r) {
        var i = Wi();
        return t = r !== void 0 ? r(t) : t,
        i.memoizedState = i.baseState = t,
        e = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: e,
            lastRenderedState: t
        },
        i.queue = e,
        e = e.dispatch = mL.bind(null, qt, e),
        [i.memoizedState, e]
    },
    useRef: function(e) {
        var t = Wi();
        return e = {
            current: e
        },
        t.memoizedState = e
    },
    useState: vE,
    useDebugValue: Ky,
    useDeferredValue: function(e) {
        return Wi().memoizedState = e
    },
    useTransition: function() {
        var e = vE(!1)
          , t = e[0];
        return e = pL.bind(null, e[1]),
        Wi().memoizedState = e,
        [t, e]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(e, t, r) {
        var i = qt
          , n = Wi();
        if (Gt) {
            if (r === void 0)
                throw Error(D(407));
            r = r()
        } else {
            if (r = t(),
            Ae === null)
                throw Error(D(349));
            Ao & 30 || wb(i, t, r)
        }
        n.memoizedState = r;
        var s = {
            value: r,
            getSnapshot: t
        };
        return n.queue = s,
        xE(bb.bind(null, i, s, e), [e]),
        i.flags |= 2048,
        Uh(9, Ab.bind(null, i, s, r, t), void 0, null),
        r
    },
    useId: function() {
        var e = Wi()
          , t = Ae.identifierPrefix;
        if (Gt) {
            var r = Pn
              , i = Cn;
            r = (i & ~(1 << 32 - Ai(i) - 1)).toString(32) + r,
            t = ":" + t + "R" + r,
            r = kh++,
            0 < r && (t += "H" + r.toString(32)),
            t += ":"
        } else
            r = fL++,
            t = ":" + t + "r" + r.toString(32) + ":";
        return e.memoizedState = t
    },
    unstable_isNewReconciler: !1
}
  , yL = {
    readContext: si,
    useCallback: Lb,
    useContext: si,
    useEffect: Yy,
    useImperativeHandle: Nb,
    useInsertionEffect: Rb,
    useLayoutEffect: Mb,
    useMemo: Db,
    useReducer: fm,
    useRef: Ib,
    useState: function() {
        return fm(Fh)
    },
    useDebugValue: Ky,
    useDeferredValue: function(e) {
        var t = oi();
        return Bb(t, ge.memoizedState, e)
    },
    useTransition: function() {
        var e = fm(Fh)[0]
          , t = oi().memoizedState;
        return [e, t]
    },
    useMutableSource: Tb,
    useSyncExternalStore: Sb,
    useId: kb,
    unstable_isNewReconciler: !1
}
  , vL = {
    readContext: si,
    useCallback: Lb,
    useContext: si,
    useEffect: Yy,
    useImperativeHandle: Nb,
    useInsertionEffect: Rb,
    useLayoutEffect: Mb,
    useMemo: Db,
    useReducer: pm,
    useRef: Ib,
    useState: function() {
        return pm(Fh)
    },
    useDebugValue: Ky,
    useDeferredValue: function(e) {
        var t = oi();
        return ge === null ? t.memoizedState = e : Bb(t, ge.memoizedState, e)
    },
    useTransition: function() {
        var e = pm(Fh)[0]
          , t = oi().memoizedState;
        return [e, t]
    },
    useMutableSource: Tb,
    useSyncExternalStore: Sb,
    useId: kb,
    unstable_isNewReconciler: !1
};
function za(e, t) {
    try {
        var r = ""
          , i = t;
        do
            r += X2(i),
            i = i.return;
        while (i);
        var n = r
    } catch (s) {
        n = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: e,
        source: t,
        stack: n,
        digest: null
    }
}
function mm(e, t, r) {
    return {
        value: e,
        source: null,
        stack: r ?? null,
        digest: t ?? null
    }
}
function c0(e, t) {
    try {
        console.error(t.value)
    } catch (r) {
        setTimeout(function() {
            throw r
        })
    }
}
var xL = typeof WeakMap == "function" ? WeakMap : Map;
function Hb(e, t, r) {
    r = Mn(-1, r),
    r.tag = 3,
    r.payload = {
        element: null
    };
    var i = t.value;
    return r.callback = function() {
        Qd || (Qd = !0,
        E0 = i),
        c0(e, t)
    }
    ,
    r
}
function $b(e, t, r) {
    r = Mn(-1, r),
    r.tag = 3;
    var i = e.type.getDerivedStateFromError;
    if (typeof i == "function") {
        var n = t.value;
        r.payload = function() {
            return i(n)
        }
        ,
        r.callback = function() {
            c0(e, t)
        }
    }
    var s = e.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (r.callback = function() {
        c0(e, t),
        typeof i != "function" && (vs === null ? vs = new Set([this]) : vs.add(this));
        var o = t.stack;
        this.componentDidCatch(t.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    r
}
function EE(e, t, r) {
    var i = e.pingCache;
    if (i === null) {
        i = e.pingCache = new xL;
        var n = new Set;
        i.set(t, n)
    } else
        n = i.get(t),
        n === void 0 && (n = new Set,
        i.set(t, n));
    n.has(r) || (n.add(r),
    e = LL.bind(null, e, t, r),
    t.then(e, e))
}
function TE(e) {
    do {
        var t;
        if ((t = e.tag === 13) && (t = e.memoizedState,
        t = t !== null ? t.dehydrated !== null : !0),
        t)
            return e;
        e = e.return
    } while (e !== null);
    return null
}
function SE(e, t, r, i, n) {
    return e.mode & 1 ? (e.flags |= 65536,
    e.lanes = n,
    e) : (e === t ? e.flags |= 65536 : (e.flags |= 128,
    r.flags |= 131072,
    r.flags &= -52805,
    r.tag === 1 && (r.alternate === null ? r.tag = 17 : (t = Mn(-1, 1),
    t.tag = 2,
    ys(r, t, 1))),
    r.lanes |= 1),
    e)
}
var EL = Wn.ReactCurrentOwner
  , lr = !1;
function qe(e, t, r, i) {
    t.child = e === null ? xb(t, null, r, i) : Ha(t, e.child, r, i)
}
function wE(e, t, r, i, n) {
    r = r.render;
    var s = t.ref;
    return Pa(t, n),
    i = jy(e, t, r, i, s, n),
    r = Xy(),
    e !== null && !lr ? (t.updateQueue = e.updateQueue,
    t.flags &= -2053,
    e.lanes &= ~n,
    kn(e, t, n)) : (Gt && r && Ly(t),
    t.flags |= 1,
    qe(e, t, i, n),
    t.child)
}
function AE(e, t, r, i, n) {
    if (e === null) {
        var s = r.type;
        return typeof s == "function" && !iv(s) && s.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (t.tag = 15,
        t.type = s,
        zb(e, t, s, i, n)) : (e = ud(r.type, null, i, t, t.mode, n),
        e.ref = t.ref,
        e.return = t,
        t.child = e)
    }
    if (s = e.child,
    !(e.lanes & n)) {
        var o = s.memoizedProps;
        if (r = r.compare,
        r = r !== null ? r : Mh,
        r(o, i) && e.ref === t.ref)
            return kn(e, t, n)
    }
    return t.flags |= 1,
    e = Es(s, i),
    e.ref = t.ref,
    e.return = t,
    t.child = e
}
function zb(e, t, r, i, n) {
    if (e !== null) {
        var s = e.memoizedProps;
        if (Mh(s, i) && e.ref === t.ref)
            if (lr = !1,
            t.pendingProps = i = s,
            (e.lanes & n) !== 0)
                e.flags & 131072 && (lr = !0);
            else
                return t.lanes = e.lanes,
                kn(e, t, n)
    }
    return d0(e, t, r, i, n)
}
function Wb(e, t, r) {
    var i = t.pendingProps
      , n = i.children
      , s = e !== null ? e.memoizedState : null;
    if (i.mode === "hidden")
        if (!(t.mode & 1))
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            Rt(xa, Er),
            Er |= r;
        else {
            if (!(r & 1073741824))
                return e = s !== null ? s.baseLanes | r : r,
                t.lanes = t.childLanes = 1073741824,
                t.memoizedState = {
                    baseLanes: e,
                    cachePool: null,
                    transitions: null
                },
                t.updateQueue = null,
                Rt(xa, Er),
                Er |= e,
                null;
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            i = s !== null ? s.baseLanes : r,
            Rt(xa, Er),
            Er |= i
        }
    else
        s !== null ? (i = s.baseLanes | r,
        t.memoizedState = null) : i = r,
        Rt(xa, Er),
        Er |= i;
    return qe(e, t, n, r),
    t.child
}
function Vb(e, t) {
    var r = t.ref;
    (e === null && r !== null || e !== null && e.ref !== r) && (t.flags |= 512,
    t.flags |= 2097152)
}
function d0(e, t, r, i, n) {
    var s = ur(r) ? So : je.current;
    return s = Ua(t, s),
    Pa(t, n),
    r = jy(e, t, r, i, s, n),
    i = Xy(),
    e !== null && !lr ? (t.updateQueue = e.updateQueue,
    t.flags &= -2053,
    e.lanes &= ~n,
    kn(e, t, n)) : (Gt && i && Ly(t),
    t.flags |= 1,
    qe(e, t, r, n),
    t.child)
}
function bE(e, t, r, i, n) {
    if (ur(r)) {
        var s = !0;
        $d(t)
    } else
        s = !1;
    if (Pa(t, n),
    t.stateNode === null)
        ad(e, t),
        yb(t, r, i),
        u0(t, r, i, n),
        i = !0;
    else if (e === null) {
        var o = t.stateNode
          , a = t.memoizedProps;
        o.props = a;
        var l = o.context
          , h = r.contextType;
        typeof h == "object" && h !== null ? h = si(h) : (h = ur(r) ? So : je.current,
        h = Ua(t, h));
        var u = r.getDerivedStateFromProps
          , c = typeof u == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        c || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== h) && _E(t, o, i, h),
        Jn = !1;
        var d = t.memoizedState;
        o.state = d,
        Xd(t, i, o, n),
        l = t.memoizedState,
        a !== i || d !== l || hr.current || Jn ? (typeof u == "function" && (h0(t, r, u, i),
        l = t.memoizedState),
        (a = Jn || gE(t, r, a, i, d, l, h)) ? (c || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308),
        t.memoizedProps = i,
        t.memoizedState = l),
        o.props = i,
        o.state = l,
        o.context = h,
        i = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308),
        i = !1)
    } else {
        o = t.stateNode,
        gb(e, t),
        a = t.memoizedProps,
        h = t.type === t.elementType ? a : gi(t.type, a),
        o.props = h,
        c = t.pendingProps,
        d = o.context,
        l = r.contextType,
        typeof l == "object" && l !== null ? l = si(l) : (l = ur(r) ? So : je.current,
        l = Ua(t, l));
        var f = r.getDerivedStateFromProps;
        (u = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== c || d !== l) && _E(t, o, i, l),
        Jn = !1,
        d = t.memoizedState,
        o.state = d,
        Xd(t, i, o, n);
        var g = t.memoizedState;
        a !== c || d !== g || hr.current || Jn ? (typeof f == "function" && (h0(t, r, f, i),
        g = t.memoizedState),
        (h = Jn || gE(t, r, h, i, d, g, l) || !1) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, g, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, g, l)),
        typeof o.componentDidUpdate == "function" && (t.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024),
        t.memoizedProps = i,
        t.memoizedState = g),
        o.props = i,
        o.state = g,
        o.context = l,
        i = h) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024),
        i = !1)
    }
    return f0(e, t, r, i, s, n)
}
function f0(e, t, r, i, n, s) {
    Vb(e, t);
    var o = (t.flags & 128) !== 0;
    if (!i && !o)
        return n && cE(t, r, !1),
        kn(e, t, s);
    i = t.stateNode,
    EL.current = t;
    var a = o && typeof r.getDerivedStateFromError != "function" ? null : i.render();
    return t.flags |= 1,
    e !== null && o ? (t.child = Ha(t, e.child, null, s),
    t.child = Ha(t, null, a, s)) : qe(e, t, a, s),
    t.memoizedState = i.state,
    n && cE(t, r, !0),
    t.child
}
function jb(e) {
    var t = e.stateNode;
    t.pendingContext ? uE(e, t.pendingContext, t.pendingContext !== t.context) : t.context && uE(e, t.context, !1),
    $y(e, t.containerInfo)
}
function CE(e, t, r, i, n) {
    return Ga(),
    By(n),
    t.flags |= 256,
    qe(e, t, r, i),
    t.child
}
var p0 = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function m0(e) {
    return {
        baseLanes: e,
        cachePool: null,
        transitions: null
    }
}
function Xb(e, t, r) {
    var i = t.pendingProps, n = jt.current, s = !1, o = (t.flags & 128) !== 0, a;
    if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (n & 2) !== 0),
    a ? (s = !0,
    t.flags &= -129) : (e === null || e.memoizedState !== null) && (n |= 1),
    Rt(jt, n & 1),
    e === null)
        return a0(t),
        e = t.memoizedState,
        e !== null && (e = e.dehydrated,
        e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1,
        null) : (o = i.children,
        e = i.fallback,
        s ? (i = t.mode,
        s = t.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(i & 1) && s !== null ? (s.childLanes = 0,
        s.pendingProps = o) : s = tp(o, i, 0, null),
        e = uo(e, i, r, null),
        s.return = t,
        e.return = t,
        s.sibling = e,
        t.child = s,
        t.child.memoizedState = m0(r),
        t.memoizedState = p0,
        e) : qy(t, o));
    if (n = e.memoizedState,
    n !== null && (a = n.dehydrated,
    a !== null))
        return TL(e, t, o, i, a, n, r);
    if (s) {
        s = i.fallback,
        o = t.mode,
        n = e.child,
        a = n.sibling;
        var l = {
            mode: "hidden",
            children: i.children
        };
        return !(o & 1) && t.child !== n ? (i = t.child,
        i.childLanes = 0,
        i.pendingProps = l,
        t.deletions = null) : (i = Es(n, l),
        i.subtreeFlags = n.subtreeFlags & 14680064),
        a !== null ? s = Es(a, s) : (s = uo(s, o, r, null),
        s.flags |= 2),
        s.return = t,
        i.return = t,
        i.sibling = s,
        t.child = i,
        i = s,
        s = t.child,
        o = e.child.memoizedState,
        o = o === null ? m0(r) : {
            baseLanes: o.baseLanes | r,
            cachePool: null,
            transitions: o.transitions
        },
        s.memoizedState = o,
        s.childLanes = e.childLanes & ~r,
        t.memoizedState = p0,
        i
    }
    return s = e.child,
    e = s.sibling,
    i = Es(s, {
        mode: "visible",
        children: i.children
    }),
    !(t.mode & 1) && (i.lanes = r),
    i.return = t,
    i.sibling = null,
    e !== null && (r = t.deletions,
    r === null ? (t.deletions = [e],
    t.flags |= 16) : r.push(e)),
    t.child = i,
    t.memoizedState = null,
    i
}
function qy(e, t) {
    return t = tp({
        mode: "visible",
        children: t
    }, e.mode, 0, null),
    t.return = e,
    e.child = t
}
function uc(e, t, r, i) {
    return i !== null && By(i),
    Ha(t, e.child, null, r),
    e = qy(t, t.pendingProps.children),
    e.flags |= 2,
    t.memoizedState = null,
    e
}
function TL(e, t, r, i, n, s, o) {
    if (r)
        return t.flags & 256 ? (t.flags &= -257,
        i = mm(Error(D(422))),
        uc(e, t, o, i)) : t.memoizedState !== null ? (t.child = e.child,
        t.flags |= 128,
        null) : (s = i.fallback,
        n = t.mode,
        i = tp({
            mode: "visible",
            children: i.children
        }, n, 0, null),
        s = uo(s, n, o, null),
        s.flags |= 2,
        i.return = t,
        s.return = t,
        i.sibling = s,
        t.child = i,
        t.mode & 1 && Ha(t, e.child, null, o),
        t.child.memoizedState = m0(o),
        t.memoizedState = p0,
        s);
    if (!(t.mode & 1))
        return uc(e, t, o, null);
    if (n.data === "$!") {
        if (i = n.nextSibling && n.nextSibling.dataset,
        i)
            var a = i.dgst;
        return i = a,
        s = Error(D(419)),
        i = mm(s, i, void 0),
        uc(e, t, o, i)
    }
    if (a = (o & e.childLanes) !== 0,
    lr || a) {
        if (i = Ae,
        i !== null) {
            switch (o & -o) {
            case 4:
                n = 2;
                break;
            case 16:
                n = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                n = 32;
                break;
            case 536870912:
                n = 268435456;
                break;
            default:
                n = 0
            }
            n = n & (i.suspendedLanes | o) ? 0 : n,
            n !== 0 && n !== s.retryLane && (s.retryLane = n,
            Bn(e, n),
            bi(i, e, n, -1))
        }
        return rv(),
        i = mm(Error(D(421))),
        uc(e, t, o, i)
    }
    return n.data === "$?" ? (t.flags |= 128,
    t.child = e.child,
    t = DL.bind(null, e),
    n._reactRetry = t,
    null) : (e = s.treeContext,
    Pr = _s(n.nextSibling),
    Or = t,
    Gt = !0,
    yi = null,
    e !== null && (Xr[Yr++] = Cn,
    Xr[Yr++] = Pn,
    Xr[Yr++] = wo,
    Cn = e.id,
    Pn = e.overflow,
    wo = t),
    t = qy(t, i.children),
    t.flags |= 4096,
    t)
}
function PE(e, t, r) {
    e.lanes |= t;
    var i = e.alternate;
    i !== null && (i.lanes |= t),
    l0(e.return, t, r)
}
function gm(e, t, r, i, n) {
    var s = e.memoizedState;
    s === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: r,
        tailMode: n
    } : (s.isBackwards = t,
    s.rendering = null,
    s.renderingStartTime = 0,
    s.last = i,
    s.tail = r,
    s.tailMode = n)
}
function Yb(e, t, r) {
    var i = t.pendingProps
      , n = i.revealOrder
      , s = i.tail;
    if (qe(e, t, i.children, r),
    i = jt.current,
    i & 2)
        i = i & 1 | 2,
        t.flags |= 128;
    else {
        if (e !== null && e.flags & 128)
            t: for (e = t.child; e !== null; ) {
                if (e.tag === 13)
                    e.memoizedState !== null && PE(e, r, t);
                else if (e.tag === 19)
                    PE(e, r, t);
                else if (e.child !== null) {
                    e.child.return = e,
                    e = e.child;
                    continue
                }
                if (e === t)
                    break t;
                for (; e.sibling === null; ) {
                    if (e.return === null || e.return === t)
                        break t;
                    e = e.return
                }
                e.sibling.return = e.return,
                e = e.sibling
            }
        i &= 1
    }
    if (Rt(jt, i),
    !(t.mode & 1))
        t.memoizedState = null;
    else
        switch (n) {
        case "forwards":
            for (r = t.child,
            n = null; r !== null; )
                e = r.alternate,
                e !== null && Yd(e) === null && (n = r),
                r = r.sibling;
            r = n,
            r === null ? (n = t.child,
            t.child = null) : (n = r.sibling,
            r.sibling = null),
            gm(t, !1, n, r, s);
            break;
        case "backwards":
            for (r = null,
            n = t.child,
            t.child = null; n !== null; ) {
                if (e = n.alternate,
                e !== null && Yd(e) === null) {
                    t.child = n;
                    break
                }
                e = n.sibling,
                n.sibling = r,
                r = n,
                n = e
            }
            gm(t, !0, r, null, s);
            break;
        case "together":
            gm(t, !1, null, null, void 0);
            break;
        default:
            t.memoizedState = null
        }
    return t.child
}
function ad(e, t) {
    !(t.mode & 1) && e !== null && (e.alternate = null,
    t.alternate = null,
    t.flags |= 2)
}
function kn(e, t, r) {
    if (e !== null && (t.dependencies = e.dependencies),
    bo |= t.lanes,
    !(r & t.childLanes))
        return null;
    if (e !== null && t.child !== e.child)
        throw Error(D(153));
    if (t.child !== null) {
        for (e = t.child,
        r = Es(e, e.pendingProps),
        t.child = r,
        r.return = t; e.sibling !== null; )
            e = e.sibling,
            r = r.sibling = Es(e, e.pendingProps),
            r.return = t;
        r.sibling = null
    }
    return t.child
}
function SL(e, t, r) {
    switch (t.tag) {
    case 3:
        jb(t),
        Ga();
        break;
    case 5:
        Eb(t);
        break;
    case 1:
        ur(t.type) && $d(t);
        break;
    case 4:
        $y(t, t.stateNode.containerInfo);
        break;
    case 10:
        var i = t.type._context
          , n = t.memoizedProps.value;
        Rt(Vd, i._currentValue),
        i._currentValue = n;
        break;
    case 13:
        if (i = t.memoizedState,
        i !== null)
            return i.dehydrated !== null ? (Rt(jt, jt.current & 1),
            t.flags |= 128,
            null) : r & t.child.childLanes ? Xb(e, t, r) : (Rt(jt, jt.current & 1),
            e = kn(e, t, r),
            e !== null ? e.sibling : null);
        Rt(jt, jt.current & 1);
        break;
    case 19:
        if (i = (r & t.childLanes) !== 0,
        e.flags & 128) {
            if (i)
                return Yb(e, t, r);
            t.flags |= 128
        }
        if (n = t.memoizedState,
        n !== null && (n.rendering = null,
        n.tail = null,
        n.lastEffect = null),
        Rt(jt, jt.current),
        i)
            break;
        return null;
    case 22:
    case 23:
        return t.lanes = 0,
        Wb(e, t, r)
    }
    return kn(e, t, r)
}
var Kb, g0, qb, Zb;
Kb = function(e, t) {
    for (var r = t.child; r !== null; ) {
        if (r.tag === 5 || r.tag === 6)
            e.appendChild(r.stateNode);
        else if (r.tag !== 4 && r.child !== null) {
            r.child.return = r,
            r = r.child;
            continue
        }
        if (r === t)
            break;
        for (; r.sibling === null; ) {
            if (r.return === null || r.return === t)
                return;
            r = r.return
        }
        r.sibling.return = r.return,
        r = r.sibling
    }
}
;
g0 = function() {}
;
qb = function(e, t, r, i) {
    var n = e.memoizedProps;
    if (n !== i) {
        e = t.stateNode,
        oo(sn.current);
        var s = null;
        switch (r) {
        case "input":
            n = Fg(e, n),
            i = Fg(e, i),
            s = [];
            break;
        case "select":
            n = Zt({}, n, {
                value: void 0
            }),
            i = Zt({}, i, {
                value: void 0
            }),
            s = [];
            break;
        case "textarea":
            n = Hg(e, n),
            i = Hg(e, i),
            s = [];
            break;
        default:
            typeof n.onClick != "function" && typeof i.onClick == "function" && (e.onclick = Gd)
        }
        zg(r, i);
        var o;
        r = null;
        for (h in n)
            if (!i.hasOwnProperty(h) && n.hasOwnProperty(h) && n[h] != null)
                if (h === "style") {
                    var a = n[h];
                    for (o in a)
                        a.hasOwnProperty(o) && (r || (r = {}),
                        r[o] = "")
                } else
                    h !== "dangerouslySetInnerHTML" && h !== "children" && h !== "suppressContentEditableWarning" && h !== "suppressHydrationWarning" && h !== "autoFocus" && (wh.hasOwnProperty(h) ? s || (s = []) : (s = s || []).push(h, null));
        for (h in i) {
            var l = i[h];
            if (a = n?.[h],
            i.hasOwnProperty(h) && l !== a && (l != null || a != null))
                if (h === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (r || (r = {}),
                            r[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (r || (r = {}),
                            r[o] = l[o])
                    } else
                        r || (s || (s = []),
                        s.push(h, r)),
                        r = l;
                else
                    h === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (s = s || []).push(h, l)) : h === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(h, "" + l) : h !== "suppressContentEditableWarning" && h !== "suppressHydrationWarning" && (wh.hasOwnProperty(h) ? (l != null && h === "onScroll" && Nt("scroll", e),
                    s || a === l || (s = [])) : (s = s || []).push(h, l))
        }
        r && (s = s || []).push("style", r);
        var h = s;
        (t.updateQueue = h) && (t.flags |= 4)
    }
}
;
Zb = function(e, t, r, i) {
    r !== i && (t.flags |= 4)
}
;
function bl(e, t) {
    if (!Gt)
        switch (e.tailMode) {
        case "hidden":
            t = e.tail;
            for (var r = null; t !== null; )
                t.alternate !== null && (r = t),
                t = t.sibling;
            r === null ? e.tail = null : r.sibling = null;
            break;
        case "collapsed":
            r = e.tail;
            for (var i = null; r !== null; )
                r.alternate !== null && (i = r),
                r = r.sibling;
            i === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : i.sibling = null
        }
}
function Fe(e) {
    var t = e.alternate !== null && e.alternate.child === e.child
      , r = 0
      , i = 0;
    if (t)
        for (var n = e.child; n !== null; )
            r |= n.lanes | n.childLanes,
            i |= n.subtreeFlags & 14680064,
            i |= n.flags & 14680064,
            n.return = e,
            n = n.sibling;
    else
        for (n = e.child; n !== null; )
            r |= n.lanes | n.childLanes,
            i |= n.subtreeFlags,
            i |= n.flags,
            n.return = e,
            n = n.sibling;
    return e.subtreeFlags |= i,
    e.childLanes = r,
    t
}
function wL(e, t, r) {
    var i = t.pendingProps;
    switch (Dy(t),
    t.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return Fe(t),
        null;
    case 1:
        return ur(t.type) && Hd(),
        Fe(t),
        null;
    case 3:
        return i = t.stateNode,
        $a(),
        Bt(hr),
        Bt(je),
        Wy(),
        i.pendingContext && (i.context = i.pendingContext,
        i.pendingContext = null),
        (e === null || e.child === null) && (lc(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024,
        yi !== null && (w0(yi),
        yi = null))),
        g0(e, t),
        Fe(t),
        null;
    case 5:
        zy(t);
        var n = oo(Bh.current);
        if (r = t.type,
        e !== null && t.stateNode != null)
            qb(e, t, r, i, n),
            e.ref !== t.ref && (t.flags |= 512,
            t.flags |= 2097152);
        else {
            if (!i) {
                if (t.stateNode === null)
                    throw Error(D(166));
                return Fe(t),
                null
            }
            if (e = oo(sn.current),
            lc(t)) {
                i = t.stateNode,
                r = t.type;
                var s = t.memoizedProps;
                switch (i[Yi] = t,
                i[Lh] = s,
                e = (t.mode & 1) !== 0,
                r) {
                case "dialog":
                    Nt("cancel", i),
                    Nt("close", i);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Nt("load", i);
                    break;
                case "video":
                case "audio":
                    for (n = 0; n < $l.length; n++)
                        Nt($l[n], i);
                    break;
                case "source":
                    Nt("error", i);
                    break;
                case "img":
                case "image":
                case "link":
                    Nt("error", i),
                    Nt("load", i);
                    break;
                case "details":
                    Nt("toggle", i);
                    break;
                case "input":
                    k1(i, s),
                    Nt("invalid", i);
                    break;
                case "select":
                    i._wrapperState = {
                        wasMultiple: !!s.multiple
                    },
                    Nt("invalid", i);
                    break;
                case "textarea":
                    U1(i, s),
                    Nt("invalid", i)
                }
                zg(r, s),
                n = null;
                for (var o in s)
                    if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && ac(i.textContent, a, e),
                        n = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && ac(i.textContent, a, e),
                        n = ["children", "" + a]) : wh.hasOwnProperty(o) && a != null && o === "onScroll" && Nt("scroll", i)
                    }
                switch (r) {
                case "input":
                    Ju(i),
                    F1(i, s, !0);
                    break;
                case "textarea":
                    Ju(i),
                    G1(i);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof s.onClick == "function" && (i.onclick = Gd)
                }
                i = n,
                t.updateQueue = i,
                i !== null && (t.flags |= 4)
            } else {
                o = n.nodeType === 9 ? n : n.ownerDocument,
                e === "http://www.w3.org/1999/xhtml" && (e = wA(r)),
                e === "http://www.w3.org/1999/xhtml" ? r === "script" ? (e = o.createElement("div"),
                e.innerHTML = "<script><\/script>",
                e = e.removeChild(e.firstChild)) : typeof i.is == "string" ? e = o.createElement(r, {
                    is: i.is
                }) : (e = o.createElement(r),
                r === "select" && (o = e,
                i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : e = o.createElementNS(e, r),
                e[Yi] = t,
                e[Lh] = i,
                Kb(e, t, !1, !1),
                t.stateNode = e;
                t: {
                    switch (o = Wg(r, i),
                    r) {
                    case "dialog":
                        Nt("cancel", e),
                        Nt("close", e),
                        n = i;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Nt("load", e),
                        n = i;
                        break;
                    case "video":
                    case "audio":
                        for (n = 0; n < $l.length; n++)
                            Nt($l[n], e);
                        n = i;
                        break;
                    case "source":
                        Nt("error", e),
                        n = i;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Nt("error", e),
                        Nt("load", e),
                        n = i;
                        break;
                    case "details":
                        Nt("toggle", e),
                        n = i;
                        break;
                    case "input":
                        k1(e, i),
                        n = Fg(e, i),
                        Nt("invalid", e);
                        break;
                    case "option":
                        n = i;
                        break;
                    case "select":
                        e._wrapperState = {
                            wasMultiple: !!i.multiple
                        },
                        n = Zt({}, i, {
                            value: void 0
                        }),
                        Nt("invalid", e);
                        break;
                    case "textarea":
                        U1(e, i),
                        n = Hg(e, i),
                        Nt("invalid", e);
                        break;
                    default:
                        n = i
                    }
                    zg(r, n),
                    a = n;
                    for (s in a)
                        if (a.hasOwnProperty(s)) {
                            var l = a[s];
                            s === "style" ? CA(e, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && AA(e, l)) : s === "children" ? typeof l == "string" ? (r !== "textarea" || l !== "") && Ah(e, l) : typeof l == "number" && Ah(e, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (wh.hasOwnProperty(s) ? l != null && s === "onScroll" && Nt("scroll", e) : l != null && xy(e, s, l, o))
                        }
                    switch (r) {
                    case "input":
                        Ju(e),
                        F1(e, i, !1);
                        break;
                    case "textarea":
                        Ju(e),
                        G1(e);
                        break;
                    case "option":
                        i.value != null && e.setAttribute("value", "" + bs(i.value));
                        break;
                    case "select":
                        e.multiple = !!i.multiple,
                        s = i.value,
                        s != null ? wa(e, !!i.multiple, s, !1) : i.defaultValue != null && wa(e, !!i.multiple, i.defaultValue, !0);
                        break;
                    default:
                        typeof n.onClick == "function" && (e.onclick = Gd)
                    }
                    switch (r) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        i = !!i.autoFocus;
                        break t;
                    case "img":
                        i = !0;
                        break t;
                    default:
                        i = !1
                    }
                }
                i && (t.flags |= 4)
            }
            t.ref !== null && (t.flags |= 512,
            t.flags |= 2097152)
        }
        return Fe(t),
        null;
    case 6:
        if (e && t.stateNode != null)
            Zb(e, t, e.memoizedProps, i);
        else {
            if (typeof i != "string" && t.stateNode === null)
                throw Error(D(166));
            if (r = oo(Bh.current),
            oo(sn.current),
            lc(t)) {
                if (i = t.stateNode,
                r = t.memoizedProps,
                i[Yi] = t,
                (s = i.nodeValue !== r) && (e = Or,
                e !== null))
                    switch (e.tag) {
                    case 3:
                        ac(i.nodeValue, r, (e.mode & 1) !== 0);
                        break;
                    case 5:
                        e.memoizedProps.suppressHydrationWarning !== !0 && ac(i.nodeValue, r, (e.mode & 1) !== 0)
                    }
                s && (t.flags |= 4)
            } else
                i = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(i),
                i[Yi] = t,
                t.stateNode = i
        }
        return Fe(t),
        null;
    case 13:
        if (Bt(jt),
        i = t.memoizedState,
        e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            if (Gt && Pr !== null && t.mode & 1 && !(t.flags & 128))
                pb(),
                Ga(),
                t.flags |= 98560,
                s = !1;
            else if (s = lc(t),
            i !== null && i.dehydrated !== null) {
                if (e === null) {
                    if (!s)
                        throw Error(D(318));
                    if (s = t.memoizedState,
                    s = s !== null ? s.dehydrated : null,
                    !s)
                        throw Error(D(317));
                    s[Yi] = t
                } else
                    Ga(),
                    !(t.flags & 128) && (t.memoizedState = null),
                    t.flags |= 4;
                Fe(t),
                s = !1
            } else
                yi !== null && (w0(yi),
                yi = null),
                s = !0;
            if (!s)
                return t.flags & 65536 ? t : null
        }
        return t.flags & 128 ? (t.lanes = r,
        t) : (i = i !== null,
        i !== (e !== null && e.memoizedState !== null) && i && (t.child.flags |= 8192,
        t.mode & 1 && (e === null || jt.current & 1 ? _e === 0 && (_e = 3) : rv())),
        t.updateQueue !== null && (t.flags |= 4),
        Fe(t),
        null);
    case 4:
        return $a(),
        g0(e, t),
        e === null && Oh(t.stateNode.containerInfo),
        Fe(t),
        null;
    case 10:
        return Uy(t.type._context),
        Fe(t),
        null;
    case 17:
        return ur(t.type) && Hd(),
        Fe(t),
        null;
    case 19:
        if (Bt(jt),
        s = t.memoizedState,
        s === null)
            return Fe(t),
            null;
        if (i = (t.flags & 128) !== 0,
        o = s.rendering,
        o === null)
            if (i)
                bl(s, !1);
            else {
                if (_e !== 0 || e !== null && e.flags & 128)
                    for (e = t.child; e !== null; ) {
                        if (o = Yd(e),
                        o !== null) {
                            for (t.flags |= 128,
                            bl(s, !1),
                            i = o.updateQueue,
                            i !== null && (t.updateQueue = i,
                            t.flags |= 4),
                            t.subtreeFlags = 0,
                            i = r,
                            r = t.child; r !== null; )
                                s = r,
                                e = i,
                                s.flags &= 14680066,
                                o = s.alternate,
                                o === null ? (s.childLanes = 0,
                                s.lanes = e,
                                s.child = null,
                                s.subtreeFlags = 0,
                                s.memoizedProps = null,
                                s.memoizedState = null,
                                s.updateQueue = null,
                                s.dependencies = null,
                                s.stateNode = null) : (s.childLanes = o.childLanes,
                                s.lanes = o.lanes,
                                s.child = o.child,
                                s.subtreeFlags = 0,
                                s.deletions = null,
                                s.memoizedProps = o.memoizedProps,
                                s.memoizedState = o.memoizedState,
                                s.updateQueue = o.updateQueue,
                                s.type = o.type,
                                e = o.dependencies,
                                s.dependencies = e === null ? null : {
                                    lanes: e.lanes,
                                    firstContext: e.firstContext
                                }),
                                r = r.sibling;
                            return Rt(jt, jt.current & 1 | 2),
                            t.child
                        }
                        e = e.sibling
                    }
                s.tail !== null && oe() > Wa && (t.flags |= 128,
                i = !0,
                bl(s, !1),
                t.lanes = 4194304)
            }
        else {
            if (!i)
                if (e = Yd(o),
                e !== null) {
                    if (t.flags |= 128,
                    i = !0,
                    r = e.updateQueue,
                    r !== null && (t.updateQueue = r,
                    t.flags |= 4),
                    bl(s, !0),
                    s.tail === null && s.tailMode === "hidden" && !o.alternate && !Gt)
                        return Fe(t),
                        null
                } else
                    2 * oe() - s.renderingStartTime > Wa && r !== 1073741824 && (t.flags |= 128,
                    i = !0,
                    bl(s, !1),
                    t.lanes = 4194304);
            s.isBackwards ? (o.sibling = t.child,
            t.child = o) : (r = s.last,
            r !== null ? r.sibling = o : t.child = o,
            s.last = o)
        }
        return s.tail !== null ? (t = s.tail,
        s.rendering = t,
        s.tail = t.sibling,
        s.renderingStartTime = oe(),
        t.sibling = null,
        r = jt.current,
        Rt(jt, i ? r & 1 | 2 : r & 1),
        t) : (Fe(t),
        null);
    case 22:
    case 23:
        return ev(),
        i = t.memoizedState !== null,
        e !== null && e.memoizedState !== null !== i && (t.flags |= 8192),
        i && t.mode & 1 ? Er & 1073741824 && (Fe(t),
        t.subtreeFlags & 6 && (t.flags |= 8192)) : Fe(t),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(D(156, t.tag))
}
function AL(e, t) {
    switch (Dy(t),
    t.tag) {
    case 1:
        return ur(t.type) && Hd(),
        e = t.flags,
        e & 65536 ? (t.flags = e & -65537 | 128,
        t) : null;
    case 3:
        return $a(),
        Bt(hr),
        Bt(je),
        Wy(),
        e = t.flags,
        e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128,
        t) : null;
    case 5:
        return zy(t),
        null;
    case 13:
        if (Bt(jt),
        e = t.memoizedState,
        e !== null && e.dehydrated !== null) {
            if (t.alternate === null)
                throw Error(D(340));
            Ga()
        }
        return e = t.flags,
        e & 65536 ? (t.flags = e & -65537 | 128,
        t) : null;
    case 19:
        return Bt(jt),
        null;
    case 4:
        return $a(),
        null;
    case 10:
        return Uy(t.type._context),
        null;
    case 22:
    case 23:
        return ev(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var cc = !1
  , Ge = !1
  , bL = typeof WeakSet == "function" ? WeakSet : Set
  , j = null;
function va(e, t) {
    var r = e.ref;
    if (r !== null)
        if (typeof r == "function")
            try {
                r(null)
            } catch (i) {
                Jt(e, t, i)
            }
        else
            r.current = null
}
function _0(e, t, r) {
    try {
        r()
    } catch (i) {
        Jt(e, t, i)
    }
}
var IE = !1;
function CL(e, t) {
    if (t0 = kd,
    e = eb(),
    Ny(e)) {
        if ("selectionStart"in e)
            var r = {
                start: e.selectionStart,
                end: e.selectionEnd
            };
        else
            t: {
                r = (r = e.ownerDocument) && r.defaultView || window;
                var i = r.getSelection && r.getSelection();
                if (i && i.rangeCount !== 0) {
                    r = i.anchorNode;
                    var n = i.anchorOffset
                      , s = i.focusNode;
                    i = i.focusOffset;
                    try {
                        r.nodeType,
                        s.nodeType
                    } catch {
                        r = null;
                        break t
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , h = 0
                      , u = 0
                      , c = e
                      , d = null;
                    e: for (; ; ) {
                        for (var f; c !== r || n !== 0 && c.nodeType !== 3 || (a = o + n),
                        c !== s || i !== 0 && c.nodeType !== 3 || (l = o + i),
                        c.nodeType === 3 && (o += c.nodeValue.length),
                        (f = c.firstChild) !== null; )
                            d = c,
                            c = f;
                        for (; ; ) {
                            if (c === e)
                                break e;
                            if (d === r && ++h === n && (a = o),
                            d === s && ++u === i && (l = o),
                            (f = c.nextSibling) !== null)
                                break;
                            c = d,
                            d = c.parentNode
                        }
                        c = f
                    }
                    r = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    r = null
            }
        r = r || {
            start: 0,
            end: 0
        }
    } else
        r = null;
    for (e0 = {
        focusedElem: e,
        selectionRange: r
    },
    kd = !1,
    j = t; j !== null; )
        if (t = j,
        e = t.child,
        (t.subtreeFlags & 1028) !== 0 && e !== null)
            e.return = t,
            j = e;
        else
            for (; j !== null; ) {
                t = j;
                try {
                    var g = t.alternate;
                    if (t.flags & 1024)
                        switch (t.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (g !== null) {
                                var p = g.memoizedProps
                                  , v = g.memoizedState
                                  , y = t.stateNode
                                  , m = y.getSnapshotBeforeUpdate(t.elementType === t.type ? p : gi(t.type, p), v);
                                y.__reactInternalSnapshotBeforeUpdate = m
                            }
                            break;
                        case 3:
                            var _ = t.stateNode.containerInfo;
                            _.nodeType === 1 ? _.textContent = "" : _.nodeType === 9 && _.documentElement && _.removeChild(_.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(D(163))
                        }
                } catch (x) {
                    Jt(t, t.return, x)
                }
                if (e = t.sibling,
                e !== null) {
                    e.return = t.return,
                    j = e;
                    break
                }
                j = t.return
            }
    return g = IE,
    IE = !1,
    g
}
function hh(e, t, r) {
    var i = t.updateQueue;
    if (i = i !== null ? i.lastEffect : null,
    i !== null) {
        var n = i = i.next;
        do {
            if ((n.tag & e) === e) {
                var s = n.destroy;
                n.destroy = void 0,
                s !== void 0 && _0(t, r, s)
            }
            n = n.next
        } while (n !== i)
    }
}
function Qf(e, t) {
    if (t = t.updateQueue,
    t = t !== null ? t.lastEffect : null,
    t !== null) {
        var r = t = t.next;
        do {
            if ((r.tag & e) === e) {
                var i = r.create;
                r.destroy = i()
            }
            r = r.next
        } while (r !== t)
    }
}
function y0(e) {
    var t = e.ref;
    if (t !== null) {
        var r = e.stateNode;
        switch (e.tag) {
        case 5:
            e = r;
            break;
        default:
            e = r
        }
        typeof t == "function" ? t(e) : t.current = e
    }
}
function Qb(e) {
    var t = e.alternate;
    t !== null && (e.alternate = null,
    Qb(t)),
    e.child = null,
    e.deletions = null,
    e.sibling = null,
    e.tag === 5 && (t = e.stateNode,
    t !== null && (delete t[Yi],
    delete t[Lh],
    delete t[n0],
    delete t[hL],
    delete t[uL])),
    e.stateNode = null,
    e.return = null,
    e.dependencies = null,
    e.memoizedProps = null,
    e.memoizedState = null,
    e.pendingProps = null,
    e.stateNode = null,
    e.updateQueue = null
}
function Jb(e) {
    return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function RE(e) {
    t: for (; ; ) {
        for (; e.sibling === null; ) {
            if (e.return === null || Jb(e.return))
                return null;
            e = e.return
        }
        for (e.sibling.return = e.return,
        e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
            if (e.flags & 2 || e.child === null || e.tag === 4)
                continue t;
            e.child.return = e,
            e = e.child
        }
        if (!(e.flags & 2))
            return e.stateNode
    }
}
function v0(e, t, r) {
    var i = e.tag;
    if (i === 5 || i === 6)
        e = e.stateNode,
        t ? r.nodeType === 8 ? r.parentNode.insertBefore(e, t) : r.insertBefore(e, t) : (r.nodeType === 8 ? (t = r.parentNode,
        t.insertBefore(e, r)) : (t = r,
        t.appendChild(e)),
        r = r._reactRootContainer,
        r != null || t.onclick !== null || (t.onclick = Gd));
    else if (i !== 4 && (e = e.child,
    e !== null))
        for (v0(e, t, r),
        e = e.sibling; e !== null; )
            v0(e, t, r),
            e = e.sibling
}
function x0(e, t, r) {
    var i = e.tag;
    if (i === 5 || i === 6)
        e = e.stateNode,
        t ? r.insertBefore(e, t) : r.appendChild(e);
    else if (i !== 4 && (e = e.child,
    e !== null))
        for (x0(e, t, r),
        e = e.sibling; e !== null; )
            x0(e, t, r),
            e = e.sibling
}
var Me = null
  , _i = !1;
function Kn(e, t, r) {
    for (r = r.child; r !== null; )
        tC(e, t, r),
        r = r.sibling
}
function tC(e, t, r) {
    if (nn && typeof nn.onCommitFiberUnmount == "function")
        try {
            nn.onCommitFiberUnmount(Wf, r)
        } catch {}
    switch (r.tag) {
    case 5:
        Ge || va(r, t);
    case 6:
        var i = Me
          , n = _i;
        Me = null,
        Kn(e, t, r),
        Me = i,
        _i = n,
        Me !== null && (_i ? (e = Me,
        r = r.stateNode,
        e.nodeType === 8 ? e.parentNode.removeChild(r) : e.removeChild(r)) : Me.removeChild(r.stateNode));
        break;
    case 18:
        Me !== null && (_i ? (e = Me,
        r = r.stateNode,
        e.nodeType === 8 ? hm(e.parentNode, r) : e.nodeType === 1 && hm(e, r),
        Ih(e)) : hm(Me, r.stateNode));
        break;
    case 4:
        i = Me,
        n = _i,
        Me = r.stateNode.containerInfo,
        _i = !0,
        Kn(e, t, r),
        Me = i,
        _i = n;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!Ge && (i = r.updateQueue,
        i !== null && (i = i.lastEffect,
        i !== null))) {
            n = i = i.next;
            do {
                var s = n
                  , o = s.destroy;
                s = s.tag,
                o !== void 0 && (s & 2 || s & 4) && _0(r, t, o),
                n = n.next
            } while (n !== i)
        }
        Kn(e, t, r);
        break;
    case 1:
        if (!Ge && (va(r, t),
        i = r.stateNode,
        typeof i.componentWillUnmount == "function"))
            try {
                i.props = r.memoizedProps,
                i.state = r.memoizedState,
                i.componentWillUnmount()
            } catch (a) {
                Jt(r, t, a)
            }
        Kn(e, t, r);
        break;
    case 21:
        Kn(e, t, r);
        break;
    case 22:
        r.mode & 1 ? (Ge = (i = Ge) || r.memoizedState !== null,
        Kn(e, t, r),
        Ge = i) : Kn(e, t, r);
        break;
    default:
        Kn(e, t, r)
    }
}
function ME(e) {
    var t = e.updateQueue;
    if (t !== null) {
        e.updateQueue = null;
        var r = e.stateNode;
        r === null && (r = e.stateNode = new bL),
        t.forEach(function(i) {
            var n = BL.bind(null, e, i);
            r.has(i) || (r.add(i),
            i.then(n, n))
        })
    }
}
function di(e, t) {
    var r = t.deletions;
    if (r !== null)
        for (var i = 0; i < r.length; i++) {
            var n = r[i];
            try {
                var s = e
                  , o = t
                  , a = o;
                t: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        Me = a.stateNode,
                        _i = !1;
                        break t;
                    case 3:
                        Me = a.stateNode.containerInfo,
                        _i = !0;
                        break t;
                    case 4:
                        Me = a.stateNode.containerInfo,
                        _i = !0;
                        break t
                    }
                    a = a.return
                }
                if (Me === null)
                    throw Error(D(160));
                tC(s, o, n),
                Me = null,
                _i = !1;
                var l = n.alternate;
                l !== null && (l.return = null),
                n.return = null
            } catch (h) {
                Jt(n, t, h)
            }
        }
    if (t.subtreeFlags & 12854)
        for (t = t.child; t !== null; )
            eC(t, e),
            t = t.sibling
}
function eC(e, t) {
    var r = e.alternate
      , i = e.flags;
    switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (di(t, e),
        Ui(e),
        i & 4) {
            try {
                hh(3, e, e.return),
                Qf(3, e)
            } catch (p) {
                Jt(e, e.return, p)
            }
            try {
                hh(5, e, e.return)
            } catch (p) {
                Jt(e, e.return, p)
            }
        }
        break;
    case 1:
        di(t, e),
        Ui(e),
        i & 512 && r !== null && va(r, r.return);
        break;
    case 5:
        if (di(t, e),
        Ui(e),
        i & 512 && r !== null && va(r, r.return),
        e.flags & 32) {
            var n = e.stateNode;
            try {
                Ah(n, "")
            } catch (p) {
                Jt(e, e.return, p)
            }
        }
        if (i & 4 && (n = e.stateNode,
        n != null)) {
            var s = e.memoizedProps
              , o = r !== null ? r.memoizedProps : s
              , a = e.type
              , l = e.updateQueue;
            if (e.updateQueue = null,
            l !== null)
                try {
                    a === "input" && s.type === "radio" && s.name != null && TA(n, s),
                    Wg(a, o);
                    var h = Wg(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var u = l[o]
                          , c = l[o + 1];
                        u === "style" ? CA(n, c) : u === "dangerouslySetInnerHTML" ? AA(n, c) : u === "children" ? Ah(n, c) : xy(n, u, c, h)
                    }
                    switch (a) {
                    case "input":
                        Ug(n, s);
                        break;
                    case "textarea":
                        SA(n, s);
                        break;
                    case "select":
                        var d = n._wrapperState.wasMultiple;
                        n._wrapperState.wasMultiple = !!s.multiple;
                        var f = s.value;
                        f != null ? wa(n, !!s.multiple, f, !1) : d !== !!s.multiple && (s.defaultValue != null ? wa(n, !!s.multiple, s.defaultValue, !0) : wa(n, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    n[Lh] = s
                } catch (p) {
                    Jt(e, e.return, p)
                }
        }
        break;
    case 6:
        if (di(t, e),
        Ui(e),
        i & 4) {
            if (e.stateNode === null)
                throw Error(D(162));
            n = e.stateNode,
            s = e.memoizedProps;
            try {
                n.nodeValue = s
            } catch (p) {
                Jt(e, e.return, p)
            }
        }
        break;
    case 3:
        if (di(t, e),
        Ui(e),
        i & 4 && r !== null && r.memoizedState.isDehydrated)
            try {
                Ih(t.containerInfo)
            } catch (p) {
                Jt(e, e.return, p)
            }
        break;
    case 4:
        di(t, e),
        Ui(e);
        break;
    case 13:
        di(t, e),
        Ui(e),
        n = e.child,
        n.flags & 8192 && (s = n.memoizedState !== null,
        n.stateNode.isHidden = s,
        !s || n.alternate !== null && n.alternate.memoizedState !== null || (Jy = oe())),
        i & 4 && ME(e);
        break;
    case 22:
        if (u = r !== null && r.memoizedState !== null,
        e.mode & 1 ? (Ge = (h = Ge) || u,
        di(t, e),
        Ge = h) : di(t, e),
        Ui(e),
        i & 8192) {
            if (h = e.memoizedState !== null,
            (e.stateNode.isHidden = h) && !u && e.mode & 1)
                for (j = e,
                u = e.child; u !== null; ) {
                    for (c = j = u; j !== null; ) {
                        switch (d = j,
                        f = d.child,
                        d.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            hh(4, d, d.return);
                            break;
                        case 1:
                            va(d, d.return);
                            var g = d.stateNode;
                            if (typeof g.componentWillUnmount == "function") {
                                i = d,
                                r = d.return;
                                try {
                                    t = i,
                                    g.props = t.memoizedProps,
                                    g.state = t.memoizedState,
                                    g.componentWillUnmount()
                                } catch (p) {
                                    Jt(i, r, p)
                                }
                            }
                            break;
                        case 5:
                            va(d, d.return);
                            break;
                        case 22:
                            if (d.memoizedState !== null) {
                                NE(c);
                                continue
                            }
                        }
                        f !== null ? (f.return = d,
                        j = f) : NE(c)
                    }
                    u = u.sibling
                }
            t: for (u = null,
            c = e; ; ) {
                if (c.tag === 5) {
                    if (u === null) {
                        u = c;
                        try {
                            n = c.stateNode,
                            h ? (s = n.style,
                            typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = c.stateNode,
                            l = c.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = bA("display", o))
                        } catch (p) {
                            Jt(e, e.return, p)
                        }
                    }
                } else if (c.tag === 6) {
                    if (u === null)
                        try {
                            c.stateNode.nodeValue = h ? "" : c.memoizedProps
                        } catch (p) {
                            Jt(e, e.return, p)
                        }
                } else if ((c.tag !== 22 && c.tag !== 23 || c.memoizedState === null || c === e) && c.child !== null) {
                    c.child.return = c,
                    c = c.child;
                    continue
                }
                if (c === e)
                    break t;
                for (; c.sibling === null; ) {
                    if (c.return === null || c.return === e)
                        break t;
                    u === c && (u = null),
                    c = c.return
                }
                u === c && (u = null),
                c.sibling.return = c.return,
                c = c.sibling
            }
        }
        break;
    case 19:
        di(t, e),
        Ui(e),
        i & 4 && ME(e);
        break;
    case 21:
        break;
    default:
        di(t, e),
        Ui(e)
    }
}
function Ui(e) {
    var t = e.flags;
    if (t & 2) {
        try {
            t: {
                for (var r = e.return; r !== null; ) {
                    if (Jb(r)) {
                        var i = r;
                        break t
                    }
                    r = r.return
                }
                throw Error(D(160))
            }
            switch (i.tag) {
            case 5:
                var n = i.stateNode;
                i.flags & 32 && (Ah(n, ""),
                i.flags &= -33);
                var s = RE(e);
                x0(e, s, n);
                break;
            case 3:
            case 4:
                var o = i.stateNode.containerInfo
                  , a = RE(e);
                v0(e, a, o);
                break;
            default:
                throw Error(D(161))
            }
        } catch (l) {
            Jt(e, e.return, l)
        }
        e.flags &= -3
    }
    t & 4096 && (e.flags &= -4097)
}
function PL(e, t, r) {
    j = e,
    rC(e)
}
function rC(e, t, r) {
    for (var i = (e.mode & 1) !== 0; j !== null; ) {
        var n = j
          , s = n.child;
        if (n.tag === 22 && i) {
            var o = n.memoizedState !== null || cc;
            if (!o) {
                var a = n.alternate
                  , l = a !== null && a.memoizedState !== null || Ge;
                a = cc;
                var h = Ge;
                if (cc = o,
                (Ge = l) && !h)
                    for (j = n; j !== null; )
                        o = j,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? LE(n) : l !== null ? (l.return = o,
                        j = l) : LE(n);
                for (; s !== null; )
                    j = s,
                    rC(s),
                    s = s.sibling;
                j = n,
                cc = a,
                Ge = h
            }
            OE(e)
        } else
            n.subtreeFlags & 8772 && s !== null ? (s.return = n,
            j = s) : OE(e)
    }
}
function OE(e) {
    for (; j !== null; ) {
        var t = j;
        if (t.flags & 8772) {
            var r = t.alternate;
            try {
                if (t.flags & 8772)
                    switch (t.tag) {
                    case 0:
                    case 11:
                    case 15:
                        Ge || Qf(5, t);
                        break;
                    case 1:
                        var i = t.stateNode;
                        if (t.flags & 4 && !Ge)
                            if (r === null)
                                i.componentDidMount();
                            else {
                                var n = t.elementType === t.type ? r.memoizedProps : gi(t.type, r.memoizedProps);
                                i.componentDidUpdate(n, r.memoizedState, i.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = t.updateQueue;
                        s !== null && mE(t, s, i);
                        break;
                    case 3:
                        var o = t.updateQueue;
                        if (o !== null) {
                            if (r = null,
                            t.child !== null)
                                switch (t.child.tag) {
                                case 5:
                                    r = t.child.stateNode;
                                    break;
                                case 1:
                                    r = t.child.stateNode
                                }
                            mE(t, o, r)
                        }
                        break;
                    case 5:
                        var a = t.stateNode;
                        if (r === null && t.flags & 4) {
                            r = a;
                            var l = t.memoizedProps;
                            switch (t.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && r.focus();
                                break;
                            case "img":
                                l.src && (r.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (t.memoizedState === null) {
                            var h = t.alternate;
                            if (h !== null) {
                                var u = h.memoizedState;
                                if (u !== null) {
                                    var c = u.dehydrated;
                                    c !== null && Ih(c)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(D(163))
                    }
                Ge || t.flags & 512 && y0(t)
            } catch (d) {
                Jt(t, t.return, d)
            }
        }
        if (t === e) {
            j = null;
            break
        }
        if (r = t.sibling,
        r !== null) {
            r.return = t.return,
            j = r;
            break
        }
        j = t.return
    }
}
function NE(e) {
    for (; j !== null; ) {
        var t = j;
        if (t === e) {
            j = null;
            break
        }
        var r = t.sibling;
        if (r !== null) {
            r.return = t.return,
            j = r;
            break
        }
        j = t.return
    }
}
function LE(e) {
    for (; j !== null; ) {
        var t = j;
        try {
            switch (t.tag) {
            case 0:
            case 11:
            case 15:
                var r = t.return;
                try {
                    Qf(4, t)
                } catch (l) {
                    Jt(t, r, l)
                }
                break;
            case 1:
                var i = t.stateNode;
                if (typeof i.componentDidMount == "function") {
                    var n = t.return;
                    try {
                        i.componentDidMount()
                    } catch (l) {
                        Jt(t, n, l)
                    }
                }
                var s = t.return;
                try {
                    y0(t)
                } catch (l) {
                    Jt(t, s, l)
                }
                break;
            case 5:
                var o = t.return;
                try {
                    y0(t)
                } catch (l) {
                    Jt(t, o, l)
                }
            }
        } catch (l) {
            Jt(t, t.return, l)
        }
        if (t === e) {
            j = null;
            break
        }
        var a = t.sibling;
        if (a !== null) {
            a.return = t.return,
            j = a;
            break
        }
        j = t.return
    }
}
var IL = Math.ceil
  , Zd = Wn.ReactCurrentDispatcher
  , Zy = Wn.ReactCurrentOwner
  , ii = Wn.ReactCurrentBatchConfig
  , yt = 0
  , Ae = null
  , de = null
  , Ne = 0
  , Er = 0
  , xa = Ls(0)
  , _e = 0
  , Gh = null
  , bo = 0
  , Jf = 0
  , Qy = 0
  , uh = null
  , ar = null
  , Jy = 0
  , Wa = 1 / 0
  , yn = null
  , Qd = !1
  , E0 = null
  , vs = null
  , dc = !1
  , ls = null
  , Jd = 0
  , ch = 0
  , T0 = null
  , ld = -1
  , hd = 0;
function er() {
    return yt & 6 ? oe() : ld !== -1 ? ld : ld = oe()
}
function xs(e) {
    return e.mode & 1 ? yt & 2 && Ne !== 0 ? Ne & -Ne : dL.transition !== null ? (hd === 0 && (hd = UA()),
    hd) : (e = St,
    e !== 0 || (e = window.event,
    e = e === void 0 ? 16 : jA(e.type)),
    e) : 1
}
function bi(e, t, r, i) {
    if (50 < ch)
        throw ch = 0,
        T0 = null,
        Error(D(185));
    Au(e, r, i),
    (!(yt & 2) || e !== Ae) && (e === Ae && (!(yt & 2) && (Jf |= r),
    _e === 4 && ns(e, Ne)),
    cr(e, i),
    r === 1 && yt === 0 && !(t.mode & 1) && (Wa = oe() + 500,
    Kf && Ds()))
}
function cr(e, t) {
    var r = e.callbackNode;
    dN(e, t);
    var i = Bd(e, e === Ae ? Ne : 0);
    if (i === 0)
        r !== null && z1(r),
        e.callbackNode = null,
        e.callbackPriority = 0;
    else if (t = i & -i,
    e.callbackPriority !== t) {
        if (r != null && z1(r),
        t === 1)
            e.tag === 0 ? cL(DE.bind(null, e)) : cb(DE.bind(null, e)),
            aL(function() {
                !(yt & 6) && Ds()
            }),
            r = null;
        else {
            switch (GA(i)) {
            case 1:
                r = Ay;
                break;
            case 4:
                r = kA;
                break;
            case 16:
                r = Dd;
                break;
            case 536870912:
                r = FA;
                break;
            default:
                r = Dd
            }
            r = uC(r, iC.bind(null, e))
        }
        e.callbackPriority = t,
        e.callbackNode = r
    }
}
function iC(e, t) {
    if (ld = -1,
    hd = 0,
    yt & 6)
        throw Error(D(327));
    var r = e.callbackNode;
    if (Ia() && e.callbackNode !== r)
        return null;
    var i = Bd(e, e === Ae ? Ne : 0);
    if (i === 0)
        return null;
    if (i & 30 || i & e.expiredLanes || t)
        t = tf(e, i);
    else {
        t = i;
        var n = yt;
        yt |= 2;
        var s = sC();
        (Ae !== e || Ne !== t) && (yn = null,
        Wa = oe() + 500,
        ho(e, t));
        do
            try {
                OL();
                break
            } catch (a) {
                nC(e, a)
            }
        while (1);
        Fy(),
        Zd.current = s,
        yt = n,
        de !== null ? t = 0 : (Ae = null,
        Ne = 0,
        t = _e)
    }
    if (t !== 0) {
        if (t === 2 && (n = Kg(e),
        n !== 0 && (i = n,
        t = S0(e, n))),
        t === 1)
            throw r = Gh,
            ho(e, 0),
            ns(e, i),
            cr(e, oe()),
            r;
        if (t === 6)
            ns(e, i);
        else {
            if (n = e.current.alternate,
            !(i & 30) && !RL(n) && (t = tf(e, i),
            t === 2 && (s = Kg(e),
            s !== 0 && (i = s,
            t = S0(e, s))),
            t === 1))
                throw r = Gh,
                ho(e, 0),
                ns(e, i),
                cr(e, oe()),
                r;
            switch (e.finishedWork = n,
            e.finishedLanes = i,
            t) {
            case 0:
            case 1:
                throw Error(D(345));
            case 2:
                qs(e, ar, yn);
                break;
            case 3:
                if (ns(e, i),
                (i & 130023424) === i && (t = Jy + 500 - oe(),
                10 < t)) {
                    if (Bd(e, 0) !== 0)
                        break;
                    if (n = e.suspendedLanes,
                    (n & i) !== i) {
                        er(),
                        e.pingedLanes |= e.suspendedLanes & n;
                        break
                    }
                    e.timeoutHandle = i0(qs.bind(null, e, ar, yn), t);
                    break
                }
                qs(e, ar, yn);
                break;
            case 4:
                if (ns(e, i),
                (i & 4194240) === i)
                    break;
                for (t = e.eventTimes,
                n = -1; 0 < i; ) {
                    var o = 31 - Ai(i);
                    s = 1 << o,
                    o = t[o],
                    o > n && (n = o),
                    i &= ~s
                }
                if (i = n,
                i = oe() - i,
                i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * IL(i / 1960)) - i,
                10 < i) {
                    e.timeoutHandle = i0(qs.bind(null, e, ar, yn), i);
                    break
                }
                qs(e, ar, yn);
                break;
            case 5:
                qs(e, ar, yn);
                break;
            default:
                throw Error(D(329))
            }
        }
    }
    return cr(e, oe()),
    e.callbackNode === r ? iC.bind(null, e) : null
}
function S0(e, t) {
    var r = uh;
    return e.current.memoizedState.isDehydrated && (ho(e, t).flags |= 256),
    e = tf(e, t),
    e !== 2 && (t = ar,
    ar = r,
    t !== null && w0(t)),
    e
}
function w0(e) {
    ar === null ? ar = e : ar.push.apply(ar, e)
}
function RL(e) {
    for (var t = e; ; ) {
        if (t.flags & 16384) {
            var r = t.updateQueue;
            if (r !== null && (r = r.stores,
            r !== null))
                for (var i = 0; i < r.length; i++) {
                    var n = r[i]
                      , s = n.getSnapshot;
                    n = n.value;
                    try {
                        if (!Oi(s(), n))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (r = t.child,
        t.subtreeFlags & 16384 && r !== null)
            r.return = t,
            t = r;
        else {
            if (t === e)
                break;
            for (; t.sibling === null; ) {
                if (t.return === null || t.return === e)
                    return !0;
                t = t.return
            }
            t.sibling.return = t.return,
            t = t.sibling
        }
    }
    return !0
}
function ns(e, t) {
    for (t &= ~Qy,
    t &= ~Jf,
    e.suspendedLanes |= t,
    e.pingedLanes &= ~t,
    e = e.expirationTimes; 0 < t; ) {
        var r = 31 - Ai(t)
          , i = 1 << r;
        e[r] = -1,
        t &= ~i
    }
}
function DE(e) {
    if (yt & 6)
        throw Error(D(327));
    Ia();
    var t = Bd(e, 0);
    if (!(t & 1))
        return cr(e, oe()),
        null;
    var r = tf(e, t);
    if (e.tag !== 0 && r === 2) {
        var i = Kg(e);
        i !== 0 && (t = i,
        r = S0(e, i))
    }
    if (r === 1)
        throw r = Gh,
        ho(e, 0),
        ns(e, t),
        cr(e, oe()),
        r;
    if (r === 6)
        throw Error(D(345));
    return e.finishedWork = e.current.alternate,
    e.finishedLanes = t,
    qs(e, ar, yn),
    cr(e, oe()),
    null
}
function tv(e, t) {
    var r = yt;
    yt |= 1;
    try {
        return e(t)
    } finally {
        yt = r,
        yt === 0 && (Wa = oe() + 500,
        Kf && Ds())
    }
}
function Co(e) {
    ls !== null && ls.tag === 0 && !(yt & 6) && Ia();
    var t = yt;
    yt |= 1;
    var r = ii.transition
      , i = St;
    try {
        if (ii.transition = null,
        St = 1,
        e)
            return e()
    } finally {
        St = i,
        ii.transition = r,
        yt = t,
        !(yt & 6) && Ds()
    }
}
function ev() {
    Er = xa.current,
    Bt(xa)
}
function ho(e, t) {
    e.finishedWork = null,
    e.finishedLanes = 0;
    var r = e.timeoutHandle;
    if (r !== -1 && (e.timeoutHandle = -1,
    oL(r)),
    de !== null)
        for (r = de.return; r !== null; ) {
            var i = r;
            switch (Dy(i),
            i.tag) {
            case 1:
                i = i.type.childContextTypes,
                i != null && Hd();
                break;
            case 3:
                $a(),
                Bt(hr),
                Bt(je),
                Wy();
                break;
            case 5:
                zy(i);
                break;
            case 4:
                $a();
                break;
            case 13:
                Bt(jt);
                break;
            case 19:
                Bt(jt);
                break;
            case 10:
                Uy(i.type._context);
                break;
            case 22:
            case 23:
                ev()
            }
            r = r.return
        }
    if (Ae = e,
    de = e = Es(e.current, null),
    Ne = Er = t,
    _e = 0,
    Gh = null,
    Qy = Jf = bo = 0,
    ar = uh = null,
    so !== null) {
        for (t = 0; t < so.length; t++)
            if (r = so[t],
            i = r.interleaved,
            i !== null) {
                r.interleaved = null;
                var n = i.next
                  , s = r.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = n,
                    i.next = o
                }
                r.pending = i
            }
        so = null
    }
    return e
}
function nC(e, t) {
    do {
        var r = de;
        try {
            if (Fy(),
            sd.current = qd,
            Kd) {
                for (var i = qt.memoizedState; i !== null; ) {
                    var n = i.queue;
                    n !== null && (n.pending = null),
                    i = i.next
                }
                Kd = !1
            }
            if (Ao = 0,
            Te = ge = qt = null,
            lh = !1,
            kh = 0,
            Zy.current = null,
            r === null || r.return === null) {
                _e = 1,
                Gh = t,
                de = null;
                break
            }
            t: {
                var s = e
                  , o = r.return
                  , a = r
                  , l = t;
                if (t = Ne,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var h = l
                      , u = a
                      , c = u.tag;
                    if (!(u.mode & 1) && (c === 0 || c === 11 || c === 15)) {
                        var d = u.alternate;
                        d ? (u.updateQueue = d.updateQueue,
                        u.memoizedState = d.memoizedState,
                        u.lanes = d.lanes) : (u.updateQueue = null,
                        u.memoizedState = null)
                    }
                    var f = TE(o);
                    if (f !== null) {
                        f.flags &= -257,
                        SE(f, o, a, s, t),
                        f.mode & 1 && EE(s, h, t),
                        t = f,
                        l = h;
                        var g = t.updateQueue;
                        if (g === null) {
                            var p = new Set;
                            p.add(l),
                            t.updateQueue = p
                        } else
                            g.add(l);
                        break t
                    } else {
                        if (!(t & 1)) {
                            EE(s, h, t),
                            rv();
                            break t
                        }
                        l = Error(D(426))
                    }
                } else if (Gt && a.mode & 1) {
                    var v = TE(o);
                    if (v !== null) {
                        !(v.flags & 65536) && (v.flags |= 256),
                        SE(v, o, a, s, t),
                        By(za(l, a));
                        break t
                    }
                }
                s = l = za(l, a),
                _e !== 4 && (_e = 2),
                uh === null ? uh = [s] : uh.push(s),
                s = o;
                do {
                    switch (s.tag) {
                    case 3:
                        s.flags |= 65536,
                        t &= -t,
                        s.lanes |= t;
                        var y = Hb(s, l, t);
                        pE(s, y);
                        break t;
                    case 1:
                        a = l;
                        var m = s.type
                          , _ = s.stateNode;
                        if (!(s.flags & 128) && (typeof m.getDerivedStateFromError == "function" || _ !== null && typeof _.componentDidCatch == "function" && (vs === null || !vs.has(_)))) {
                            s.flags |= 65536,
                            t &= -t,
                            s.lanes |= t;
                            var x = $b(s, a, t);
                            pE(s, x);
                            break t
                        }
                    }
                    s = s.return
                } while (s !== null)
            }
            aC(r)
        } catch (E) {
            t = E,
            de === r && r !== null && (de = r = r.return);
            continue
        }
        break
    } while (1)
}
function sC() {
    var e = Zd.current;
    return Zd.current = qd,
    e === null ? qd : e
}
function rv() {
    (_e === 0 || _e === 3 || _e === 2) && (_e = 4),
    Ae === null || !(bo & 268435455) && !(Jf & 268435455) || ns(Ae, Ne)
}
function tf(e, t) {
    var r = yt;
    yt |= 2;
    var i = sC();
    (Ae !== e || Ne !== t) && (yn = null,
    ho(e, t));
    do
        try {
            ML();
            break
        } catch (n) {
            nC(e, n)
        }
    while (1);
    if (Fy(),
    yt = r,
    Zd.current = i,
    de !== null)
        throw Error(D(261));
    return Ae = null,
    Ne = 0,
    _e
}
function ML() {
    for (; de !== null; )
        oC(de)
}
function OL() {
    for (; de !== null && !iN(); )
        oC(de)
}
function oC(e) {
    var t = hC(e.alternate, e, Er);
    e.memoizedProps = e.pendingProps,
    t === null ? aC(e) : de = t,
    Zy.current = null
}
function aC(e) {
    var t = e;
    do {
        var r = t.alternate;
        if (e = t.return,
        t.flags & 32768) {
            if (r = AL(r, t),
            r !== null) {
                r.flags &= 32767,
                de = r;
                return
            }
            if (e !== null)
                e.flags |= 32768,
                e.subtreeFlags = 0,
                e.deletions = null;
            else {
                _e = 6,
                de = null;
                return
            }
        } else if (r = wL(r, t, Er),
        r !== null) {
            de = r;
            return
        }
        if (t = t.sibling,
        t !== null) {
            de = t;
            return
        }
        de = t = e
    } while (t !== null);
    _e === 0 && (_e = 5)
}
function qs(e, t, r) {
    var i = St
      , n = ii.transition;
    try {
        ii.transition = null,
        St = 1,
        NL(e, t, r, i)
    } finally {
        ii.transition = n,
        St = i
    }
    return null
}
function NL(e, t, r, i) {
    do
        Ia();
    while (ls !== null);
    if (yt & 6)
        throw Error(D(327));
    r = e.finishedWork;
    var n = e.finishedLanes;
    if (r === null)
        return null;
    if (e.finishedWork = null,
    e.finishedLanes = 0,
    r === e.current)
        throw Error(D(177));
    e.callbackNode = null,
    e.callbackPriority = 0;
    var s = r.lanes | r.childLanes;
    if (fN(e, s),
    e === Ae && (de = Ae = null,
    Ne = 0),
    !(r.subtreeFlags & 2064) && !(r.flags & 2064) || dc || (dc = !0,
    uC(Dd, function() {
        return Ia(),
        null
    })),
    s = (r.flags & 15990) !== 0,
    r.subtreeFlags & 15990 || s) {
        s = ii.transition,
        ii.transition = null;
        var o = St;
        St = 1;
        var a = yt;
        yt |= 4,
        Zy.current = null,
        CL(e, r),
        eC(r, e),
        JN(e0),
        kd = !!t0,
        e0 = t0 = null,
        e.current = r,
        PL(r),
        nN(),
        yt = a,
        St = o,
        ii.transition = s
    } else
        e.current = r;
    if (dc && (dc = !1,
    ls = e,
    Jd = n),
    s = e.pendingLanes,
    s === 0 && (vs = null),
    aN(r.stateNode),
    cr(e, oe()),
    t !== null)
        for (i = e.onRecoverableError,
        r = 0; r < t.length; r++)
            n = t[r],
            i(n.value, {
                componentStack: n.stack,
                digest: n.digest
            });
    if (Qd)
        throw Qd = !1,
        e = E0,
        E0 = null,
        e;
    return Jd & 1 && e.tag !== 0 && Ia(),
    s = e.pendingLanes,
    s & 1 ? e === T0 ? ch++ : (ch = 0,
    T0 = e) : ch = 0,
    Ds(),
    null
}
function Ia() {
    if (ls !== null) {
        var e = GA(Jd)
          , t = ii.transition
          , r = St;
        try {
            if (ii.transition = null,
            St = 16 > e ? 16 : e,
            ls === null)
                var i = !1;
            else {
                if (e = ls,
                ls = null,
                Jd = 0,
                yt & 6)
                    throw Error(D(331));
                var n = yt;
                for (yt |= 4,
                j = e.current; j !== null; ) {
                    var s = j
                      , o = s.child;
                    if (j.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var h = a[l];
                                for (j = h; j !== null; ) {
                                    var u = j;
                                    switch (u.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        hh(8, u, s)
                                    }
                                    var c = u.child;
                                    if (c !== null)
                                        c.return = u,
                                        j = c;
                                    else
                                        for (; j !== null; ) {
                                            u = j;
                                            var d = u.sibling
                                              , f = u.return;
                                            if (Qb(u),
                                            u === h) {
                                                j = null;
                                                break
                                            }
                                            if (d !== null) {
                                                d.return = f,
                                                j = d;
                                                break
                                            }
                                            j = f
                                        }
                                }
                            }
                            var g = s.alternate;
                            if (g !== null) {
                                var p = g.child;
                                if (p !== null) {
                                    g.child = null;
                                    do {
                                        var v = p.sibling;
                                        p.sibling = null,
                                        p = v
                                    } while (p !== null)
                                }
                            }
                            j = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null)
                        o.return = s,
                        j = o;
                    else
                        t: for (; j !== null; ) {
                            if (s = j,
                            s.flags & 2048)
                                switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    hh(9, s, s.return)
                                }
                            var y = s.sibling;
                            if (y !== null) {
                                y.return = s.return,
                                j = y;
                                break t
                            }
                            j = s.return
                        }
                }
                var m = e.current;
                for (j = m; j !== null; ) {
                    o = j;
                    var _ = o.child;
                    if (o.subtreeFlags & 2064 && _ !== null)
                        _.return = o,
                        j = _;
                    else
                        t: for (o = m; j !== null; ) {
                            if (a = j,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Qf(9, a)
                                    }
                                } catch (E) {
                                    Jt(a, a.return, E)
                                }
                            if (a === o) {
                                j = null;
                                break t
                            }
                            var x = a.sibling;
                            if (x !== null) {
                                x.return = a.return,
                                j = x;
                                break t
                            }
                            j = a.return
                        }
                }
                if (yt = n,
                Ds(),
                nn && typeof nn.onPostCommitFiberRoot == "function")
                    try {
                        nn.onPostCommitFiberRoot(Wf, e)
                    } catch {}
                i = !0
            }
            return i
        } finally {
            St = r,
            ii.transition = t
        }
    }
    return !1
}
function BE(e, t, r) {
    t = za(r, t),
    t = Hb(e, t, 1),
    e = ys(e, t, 1),
    t = er(),
    e !== null && (Au(e, 1, t),
    cr(e, t))
}
function Jt(e, t, r) {
    if (e.tag === 3)
        BE(e, e, r);
    else
        for (; t !== null; ) {
            if (t.tag === 3) {
                BE(t, e, r);
                break
            } else if (t.tag === 1) {
                var i = t.stateNode;
                if (typeof t.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (vs === null || !vs.has(i))) {
                    e = za(r, e),
                    e = $b(t, e, 1),
                    t = ys(t, e, 1),
                    e = er(),
                    t !== null && (Au(t, 1, e),
                    cr(t, e));
                    break
                }
            }
            t = t.return
        }
}
function LL(e, t, r) {
    var i = e.pingCache;
    i !== null && i.delete(t),
    t = er(),
    e.pingedLanes |= e.suspendedLanes & r,
    Ae === e && (Ne & r) === r && (_e === 4 || _e === 3 && (Ne & 130023424) === Ne && 500 > oe() - Jy ? ho(e, 0) : Qy |= r),
    cr(e, t)
}
function lC(e, t) {
    t === 0 && (e.mode & 1 ? (t = rc,
    rc <<= 1,
    !(rc & 130023424) && (rc = 4194304)) : t = 1);
    var r = er();
    e = Bn(e, t),
    e !== null && (Au(e, t, r),
    cr(e, r))
}
function DL(e) {
    var t = e.memoizedState
      , r = 0;
    t !== null && (r = t.retryLane),
    lC(e, r)
}
function BL(e, t) {
    var r = 0;
    switch (e.tag) {
    case 13:
        var i = e.stateNode
          , n = e.memoizedState;
        n !== null && (r = n.retryLane);
        break;
    case 19:
        i = e.stateNode;
        break;
    default:
        throw Error(D(314))
    }
    i !== null && i.delete(t),
    lC(e, r)
}
var hC;
hC = function(e, t, r) {
    if (e !== null)
        if (e.memoizedProps !== t.pendingProps || hr.current)
            lr = !0;
        else {
            if (!(e.lanes & r) && !(t.flags & 128))
                return lr = !1,
                SL(e, t, r);
            lr = !!(e.flags & 131072)
        }
    else
        lr = !1,
        Gt && t.flags & 1048576 && db(t, Wd, t.index);
    switch (t.lanes = 0,
    t.tag) {
    case 2:
        var i = t.type;
        ad(e, t),
        e = t.pendingProps;
        var n = Ua(t, je.current);
        Pa(t, r),
        n = jy(null, t, i, e, n, r);
        var s = Xy();
        return t.flags |= 1,
        typeof n == "object" && n !== null && typeof n.render == "function" && n.$$typeof === void 0 ? (t.tag = 1,
        t.memoizedState = null,
        t.updateQueue = null,
        ur(i) ? (s = !0,
        $d(t)) : s = !1,
        t.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null,
        Hy(t),
        n.updater = qf,
        t.stateNode = n,
        n._reactInternals = t,
        u0(t, i, e, r),
        t = f0(null, t, i, !0, s, r)) : (t.tag = 0,
        Gt && s && Ly(t),
        qe(null, t, n, r),
        t = t.child),
        t;
    case 16:
        i = t.elementType;
        t: {
            switch (ad(e, t),
            e = t.pendingProps,
            n = i._init,
            i = n(i._payload),
            t.type = i,
            n = t.tag = FL(i),
            e = gi(i, e),
            n) {
            case 0:
                t = d0(null, t, i, e, r);
                break t;
            case 1:
                t = bE(null, t, i, e, r);
                break t;
            case 11:
                t = wE(null, t, i, e, r);
                break t;
            case 14:
                t = AE(null, t, i, gi(i.type, e), r);
                break t
            }
            throw Error(D(306, i, ""))
        }
        return t;
    case 0:
        return i = t.type,
        n = t.pendingProps,
        n = t.elementType === i ? n : gi(i, n),
        d0(e, t, i, n, r);
    case 1:
        return i = t.type,
        n = t.pendingProps,
        n = t.elementType === i ? n : gi(i, n),
        bE(e, t, i, n, r);
    case 3:
        t: {
            if (jb(t),
            e === null)
                throw Error(D(387));
            i = t.pendingProps,
            s = t.memoizedState,
            n = s.element,
            gb(e, t),
            Xd(t, i, null, r);
            var o = t.memoizedState;
            if (i = o.element,
            s.isDehydrated)
                if (s = {
                    element: i,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                t.updateQueue.baseState = s,
                t.memoizedState = s,
                t.flags & 256) {
                    n = za(Error(D(423)), t),
                    t = CE(e, t, i, r, n);
                    break t
                } else if (i !== n) {
                    n = za(Error(D(424)), t),
                    t = CE(e, t, i, r, n);
                    break t
                } else
                    for (Pr = _s(t.stateNode.containerInfo.firstChild),
                    Or = t,
                    Gt = !0,
                    yi = null,
                    r = xb(t, null, i, r),
                    t.child = r; r; )
                        r.flags = r.flags & -3 | 4096,
                        r = r.sibling;
            else {
                if (Ga(),
                i === n) {
                    t = kn(e, t, r);
                    break t
                }
                qe(e, t, i, r)
            }
            t = t.child
        }
        return t;
    case 5:
        return Eb(t),
        e === null && a0(t),
        i = t.type,
        n = t.pendingProps,
        s = e !== null ? e.memoizedProps : null,
        o = n.children,
        r0(i, n) ? o = null : s !== null && r0(i, s) && (t.flags |= 32),
        Vb(e, t),
        qe(e, t, o, r),
        t.child;
    case 6:
        return e === null && a0(t),
        null;
    case 13:
        return Xb(e, t, r);
    case 4:
        return $y(t, t.stateNode.containerInfo),
        i = t.pendingProps,
        e === null ? t.child = Ha(t, null, i, r) : qe(e, t, i, r),
        t.child;
    case 11:
        return i = t.type,
        n = t.pendingProps,
        n = t.elementType === i ? n : gi(i, n),
        wE(e, t, i, n, r);
    case 7:
        return qe(e, t, t.pendingProps, r),
        t.child;
    case 8:
        return qe(e, t, t.pendingProps.children, r),
        t.child;
    case 12:
        return qe(e, t, t.pendingProps.children, r),
        t.child;
    case 10:
        t: {
            if (i = t.type._context,
            n = t.pendingProps,
            s = t.memoizedProps,
            o = n.value,
            Rt(Vd, i._currentValue),
            i._currentValue = o,
            s !== null)
                if (Oi(s.value, o)) {
                    if (s.children === n.children && !hr.current) {
                        t = kn(e, t, r);
                        break t
                    }
                } else
                    for (s = t.child,
                    s !== null && (s.return = t); s !== null; ) {
                        var a = s.dependencies;
                        if (a !== null) {
                            o = s.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === i) {
                                    if (s.tag === 1) {
                                        l = Mn(-1, r & -r),
                                        l.tag = 2;
                                        var h = s.updateQueue;
                                        if (h !== null) {
                                            h = h.shared;
                                            var u = h.pending;
                                            u === null ? l.next = l : (l.next = u.next,
                                            u.next = l),
                                            h.pending = l
                                        }
                                    }
                                    s.lanes |= r,
                                    l = s.alternate,
                                    l !== null && (l.lanes |= r),
                                    l0(s.return, r, t),
                                    a.lanes |= r;
                                    break
                                }
                                l = l.next
                            }
                        } else if (s.tag === 10)
                            o = s.type === t.type ? null : s.child;
                        else if (s.tag === 18) {
                            if (o = s.return,
                            o === null)
                                throw Error(D(341));
                            o.lanes |= r,
                            a = o.alternate,
                            a !== null && (a.lanes |= r),
                            l0(o, r, t),
                            o = s.sibling
                        } else
                            o = s.child;
                        if (o !== null)
                            o.return = s;
                        else
                            for (o = s; o !== null; ) {
                                if (o === t) {
                                    o = null;
                                    break
                                }
                                if (s = o.sibling,
                                s !== null) {
                                    s.return = o.return,
                                    o = s;
                                    break
                                }
                                o = o.return
                            }
                        s = o
                    }
            qe(e, t, n.children, r),
            t = t.child
        }
        return t;
    case 9:
        return n = t.type,
        i = t.pendingProps.children,
        Pa(t, r),
        n = si(n),
        i = i(n),
        t.flags |= 1,
        qe(e, t, i, r),
        t.child;
    case 14:
        return i = t.type,
        n = gi(i, t.pendingProps),
        n = gi(i.type, n),
        AE(e, t, i, n, r);
    case 15:
        return zb(e, t, t.type, t.pendingProps, r);
    case 17:
        return i = t.type,
        n = t.pendingProps,
        n = t.elementType === i ? n : gi(i, n),
        ad(e, t),
        t.tag = 1,
        ur(i) ? (e = !0,
        $d(t)) : e = !1,
        Pa(t, r),
        yb(t, i, n),
        u0(t, i, n, r),
        f0(null, t, i, !0, e, r);
    case 19:
        return Yb(e, t, r);
    case 22:
        return Wb(e, t, r)
    }
    throw Error(D(156, t.tag))
}
;
function uC(e, t) {
    return BA(e, t)
}
function kL(e, t, r, i) {
    this.tag = e,
    this.key = r,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = t,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = i,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Zr(e, t, r, i) {
    return new kL(e,t,r,i)
}
function iv(e) {
    return e = e.prototype,
    !(!e || !e.isReactComponent)
}
function FL(e) {
    if (typeof e == "function")
        return iv(e) ? 1 : 0;
    if (e != null) {
        if (e = e.$$typeof,
        e === Ty)
            return 11;
        if (e === Sy)
            return 14
    }
    return 2
}
function Es(e, t) {
    var r = e.alternate;
    return r === null ? (r = Zr(e.tag, t, e.key, e.mode),
    r.elementType = e.elementType,
    r.type = e.type,
    r.stateNode = e.stateNode,
    r.alternate = e,
    e.alternate = r) : (r.pendingProps = t,
    r.type = e.type,
    r.flags = 0,
    r.subtreeFlags = 0,
    r.deletions = null),
    r.flags = e.flags & 14680064,
    r.childLanes = e.childLanes,
    r.lanes = e.lanes,
    r.child = e.child,
    r.memoizedProps = e.memoizedProps,
    r.memoizedState = e.memoizedState,
    r.updateQueue = e.updateQueue,
    t = e.dependencies,
    r.dependencies = t === null ? null : {
        lanes: t.lanes,
        firstContext: t.firstContext
    },
    r.sibling = e.sibling,
    r.index = e.index,
    r.ref = e.ref,
    r
}
function ud(e, t, r, i, n, s) {
    var o = 2;
    if (i = e,
    typeof e == "function")
        iv(e) && (o = 1);
    else if (typeof e == "string")
        o = 5;
    else
        t: switch (e) {
        case ua:
            return uo(r.children, n, s, t);
        case Ey:
            o = 8,
            n |= 8;
            break;
        case Lg:
            return e = Zr(12, r, t, n | 2),
            e.elementType = Lg,
            e.lanes = s,
            e;
        case Dg:
            return e = Zr(13, r, t, n),
            e.elementType = Dg,
            e.lanes = s,
            e;
        case Bg:
            return e = Zr(19, r, t, n),
            e.elementType = Bg,
            e.lanes = s,
            e;
        case vA:
            return tp(r, n, s, t);
        default:
            if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                case _A:
                    o = 10;
                    break t;
                case yA:
                    o = 9;
                    break t;
                case Ty:
                    o = 11;
                    break t;
                case Sy:
                    o = 14;
                    break t;
                case Qn:
                    o = 16,
                    i = null;
                    break t
                }
            throw Error(D(130, e == null ? e : typeof e, ""))
        }
    return t = Zr(o, r, t, n),
    t.elementType = e,
    t.type = i,
    t.lanes = s,
    t
}
function uo(e, t, r, i) {
    return e = Zr(7, e, i, t),
    e.lanes = r,
    e
}
function tp(e, t, r, i) {
    return e = Zr(22, e, i, t),
    e.elementType = vA,
    e.lanes = r,
    e.stateNode = {
        isHidden: !1
    },
    e
}
function _m(e, t, r) {
    return e = Zr(6, e, null, t),
    e.lanes = r,
    e
}
function ym(e, t, r) {
    return t = Zr(4, e.children !== null ? e.children : [], e.key, t),
    t.lanes = r,
    t.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        implementation: e.implementation
    },
    t
}
function UL(e, t, r, i, n) {
    this.tag = t,
    this.containerInfo = e,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = Qp(0),
    this.expirationTimes = Qp(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Qp(0),
    this.identifierPrefix = i,
    this.onRecoverableError = n,
    this.mutableSourceEagerHydrationData = null
}
function nv(e, t, r, i, n, s, o, a, l) {
    return e = new UL(e,t,r,a,l),
    t === 1 ? (t = 1,
    s === !0 && (t |= 8)) : t = 0,
    s = Zr(3, null, null, t),
    e.current = s,
    s.stateNode = e,
    s.memoizedState = {
        element: i,
        isDehydrated: r,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    Hy(s),
    e
}
function GL(e, t, r) {
    var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: ha,
        key: i == null ? null : "" + i,
        children: e,
        containerInfo: t,
        implementation: r
    }
}
function cC(e) {
    if (!e)
        return Cs;
    e = e._reactInternals;
    t: {
        if (Bo(e) !== e || e.tag !== 1)
            throw Error(D(170));
        var t = e;
        do {
            switch (t.tag) {
            case 3:
                t = t.stateNode.context;
                break t;
            case 1:
                if (ur(t.type)) {
                    t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                    break t
                }
            }
            t = t.return
        } while (t !== null);
        throw Error(D(171))
    }
    if (e.tag === 1) {
        var r = e.type;
        if (ur(r))
            return ub(e, r, t)
    }
    return t
}
function dC(e, t, r, i, n, s, o, a, l) {
    return e = nv(r, i, !0, e, n, s, o, a, l),
    e.context = cC(null),
    r = e.current,
    i = er(),
    n = xs(r),
    s = Mn(i, n),
    s.callback = t ?? null,
    ys(r, s, n),
    e.current.lanes = n,
    Au(e, n, i),
    cr(e, i),
    e
}
function ep(e, t, r, i) {
    var n = t.current
      , s = er()
      , o = xs(n);
    return r = cC(r),
    t.context === null ? t.context = r : t.pendingContext = r,
    t = Mn(s, o),
    t.payload = {
        element: e
    },
    i = i === void 0 ? null : i,
    i !== null && (t.callback = i),
    e = ys(n, t, o),
    e !== null && (bi(e, n, o, s),
    nd(e, n, o)),
    o
}
function ef(e) {
    if (e = e.current,
    !e.child)
        return null;
    switch (e.child.tag) {
    case 5:
        return e.child.stateNode;
    default:
        return e.child.stateNode
    }
}
function kE(e, t) {
    if (e = e.memoizedState,
    e !== null && e.dehydrated !== null) {
        var r = e.retryLane;
        e.retryLane = r !== 0 && r < t ? r : t
    }
}
function sv(e, t) {
    kE(e, t),
    (e = e.alternate) && kE(e, t)
}
function HL() {
    return null
}
var fC = typeof reportError == "function" ? reportError : function(e) {
    console.error(e)
}
;
function ov(e) {
    this._internalRoot = e
}
rp.prototype.render = ov.prototype.render = function(e) {
    var t = this._internalRoot;
    if (t === null)
        throw Error(D(409));
    ep(e, t, null, null)
}
;
rp.prototype.unmount = ov.prototype.unmount = function() {
    var e = this._internalRoot;
    if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        Co(function() {
            ep(null, e, null, null)
        }),
        t[Dn] = null
    }
}
;
function rp(e) {
    this._internalRoot = e
}
rp.prototype.unstable_scheduleHydration = function(e) {
    if (e) {
        var t = zA();
        e = {
            blockedOn: null,
            target: e,
            priority: t
        };
        for (var r = 0; r < is.length && t !== 0 && t < is[r].priority; r++)
            ;
        is.splice(r, 0, e),
        r === 0 && VA(e)
    }
}
;
function av(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11)
}
function ip(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
}
function FE() {}
function $L(e, t, r, i, n) {
    if (n) {
        if (typeof i == "function") {
            var s = i;
            i = function() {
                var h = ef(o);
                s.call(h)
            }
        }
        var o = dC(t, i, e, 0, null, !1, !1, "", FE);
        return e._reactRootContainer = o,
        e[Dn] = o.current,
        Oh(e.nodeType === 8 ? e.parentNode : e),
        Co(),
        o
    }
    for (; n = e.lastChild; )
        e.removeChild(n);
    if (typeof i == "function") {
        var a = i;
        i = function() {
            var h = ef(l);
            a.call(h)
        }
    }
    var l = nv(e, 0, !1, null, null, !1, !1, "", FE);
    return e._reactRootContainer = l,
    e[Dn] = l.current,
    Oh(e.nodeType === 8 ? e.parentNode : e),
    Co(function() {
        ep(t, l, r, i)
    }),
    l
}
function np(e, t, r, i, n) {
    var s = r._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof n == "function") {
            var a = n;
            n = function() {
                var l = ef(o);
                a.call(l)
            }
        }
        ep(t, o, e, n)
    } else
        o = $L(r, t, e, n, i);
    return ef(o)
}
HA = function(e) {
    switch (e.tag) {
    case 3:
        var t = e.stateNode;
        if (t.current.memoizedState.isDehydrated) {
            var r = Hl(t.pendingLanes);
            r !== 0 && (by(t, r | 1),
            cr(t, oe()),
            !(yt & 6) && (Wa = oe() + 500,
            Ds()))
        }
        break;
    case 13:
        Co(function() {
            var i = Bn(e, 1);
            if (i !== null) {
                var n = er();
                bi(i, e, 1, n)
            }
        }),
        sv(e, 1)
    }
}
;
Cy = function(e) {
    if (e.tag === 13) {
        var t = Bn(e, 134217728);
        if (t !== null) {
            var r = er();
            bi(t, e, 134217728, r)
        }
        sv(e, 134217728)
    }
}
;
$A = function(e) {
    if (e.tag === 13) {
        var t = xs(e)
          , r = Bn(e, t);
        if (r !== null) {
            var i = er();
            bi(r, e, t, i)
        }
        sv(e, t)
    }
}
;
zA = function() {
    return St
}
;
WA = function(e, t) {
    var r = St;
    try {
        return St = e,
        t()
    } finally {
        St = r
    }
}
;
jg = function(e, t, r) {
    switch (t) {
    case "input":
        if (Ug(e, r),
        t = r.name,
        r.type === "radio" && t != null) {
            for (r = e; r.parentNode; )
                r = r.parentNode;
            for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'),
            t = 0; t < r.length; t++) {
                var i = r[t];
                if (i !== e && i.form === e.form) {
                    var n = Yf(i);
                    if (!n)
                        throw Error(D(90));
                    EA(i),
                    Ug(i, n)
                }
            }
        }
        break;
    case "textarea":
        SA(e, r);
        break;
    case "select":
        t = r.value,
        t != null && wa(e, !!r.multiple, t, !1)
    }
}
;
RA = tv;
MA = Co;
var zL = {
    usingClientEntryPoint: !1,
    Events: [Cu, pa, Yf, PA, IA, tv]
}
  , Cl = {
    findFiberByHostInstance: no,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
}
  , WL = {
    bundleType: Cl.bundleType,
    version: Cl.version,
    rendererPackageName: Cl.rendererPackageName,
    rendererConfig: Cl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Wn.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(e) {
        return e = LA(e),
        e === null ? null : e.stateNode
    },
    findFiberByHostInstance: Cl.findFiberByHostInstance || HL,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var fc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!fc.isDisabled && fc.supportsFiber)
        try {
            Wf = fc.inject(WL),
            nn = fc
        } catch {}
}
kr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = zL;
kr.createPortal = function(e, t) {
    var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!av(t))
        throw Error(D(200));
    return GL(e, t, null, r)
}
;
kr.createRoot = function(e, t) {
    if (!av(e))
        throw Error(D(299));
    var r = !1
      , i = ""
      , n = fC;
    return t != null && (t.unstable_strictMode === !0 && (r = !0),
    t.identifierPrefix !== void 0 && (i = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (n = t.onRecoverableError)),
    t = nv(e, 1, !1, null, null, r, !1, i, n),
    e[Dn] = t.current,
    Oh(e.nodeType === 8 ? e.parentNode : e),
    new ov(t)
}
;
kr.findDOMNode = function(e) {
    if (e == null)
        return null;
    if (e.nodeType === 1)
        return e;
    var t = e._reactInternals;
    if (t === void 0)
        throw typeof e.render == "function" ? Error(D(188)) : (e = Object.keys(e).join(","),
        Error(D(268, e)));
    return e = LA(t),
    e = e === null ? null : e.stateNode,
    e
}
;
kr.flushSync = function(e) {
    return Co(e)
}
;
kr.hydrate = function(e, t, r) {
    if (!ip(t))
        throw Error(D(200));
    return np(null, e, t, !0, r)
}
;
kr.hydrateRoot = function(e, t, r) {
    if (!av(e))
        throw Error(D(405));
    var i = r != null && r.hydratedSources || null
      , n = !1
      , s = ""
      , o = fC;
    if (r != null && (r.unstable_strictMode === !0 && (n = !0),
    r.identifierPrefix !== void 0 && (s = r.identifierPrefix),
    r.onRecoverableError !== void 0 && (o = r.onRecoverableError)),
    t = dC(t, null, e, 1, r ?? null, n, !1, s, o),
    e[Dn] = t.current,
    Oh(e),
    i)
        for (e = 0; e < i.length; e++)
            r = i[e],
            n = r._getVersion,
            n = n(r._source),
            t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [r, n] : t.mutableSourceEagerHydrationData.push(r, n);
    return new rp(t)
}
;
kr.render = function(e, t, r) {
    if (!ip(t))
        throw Error(D(200));
    return np(null, e, t, !1, r)
}
;
kr.unmountComponentAtNode = function(e) {
    if (!ip(e))
        throw Error(D(40));
    return e._reactRootContainer ? (Co(function() {
        np(null, null, e, !1, function() {
            e._reactRootContainer = null,
            e[Dn] = null
        })
    }),
    !0) : !1
}
;
kr.unstable_batchedUpdates = tv;
kr.unstable_renderSubtreeIntoContainer = function(e, t, r, i) {
    if (!ip(r))
        throw Error(D(200));
    if (e == null || e._reactInternals === void 0)
        throw Error(D(38));
    return np(e, t, r, !1, i)
}
;
kr.version = "18.2.0-next-9e3b772b8-20220608";
function pC() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(pC)
        } catch (e) {
            console.error(e)
        }
}
pC(),
dA.exports = kr;
var VL = dA.exports;
const FX = hl(VL);
var mC = {
    exports: {}
}
  , gC = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Va = ae;
function jL(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var XL = typeof Object.is == "function" ? Object.is : jL
  , YL = Va.useState
  , KL = Va.useEffect
  , qL = Va.useLayoutEffect
  , ZL = Va.useDebugValue;
function QL(e, t) {
    var r = t()
      , i = YL({
        inst: {
            value: r,
            getSnapshot: t
        }
    })
      , n = i[0].inst
      , s = i[1];
    return qL(function() {
        n.value = r,
        n.getSnapshot = t,
        vm(n) && s({
            inst: n
        })
    }, [e, r, t]),
    KL(function() {
        return vm(n) && s({
            inst: n
        }),
        e(function() {
            vm(n) && s({
                inst: n
            })
        })
    }, [e]),
    ZL(r),
    r
}
function vm(e) {
    var t = e.getSnapshot;
    e = e.value;
    try {
        var r = t();
        return !XL(e, r)
    } catch {
        return !0
    }
}
function JL(e, t) {
    return t()
}
var tD = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? JL : QL;
gC.useSyncExternalStore = Va.useSyncExternalStore !== void 0 ? Va.useSyncExternalStore : tD;
mC.exports = gC;
var eD = mC.exports
  , _C = {
    exports: {}
}
  , At = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Pe = typeof Symbol == "function" && Symbol.for
  , lv = Pe ? Symbol.for("react.element") : 60103
  , hv = Pe ? Symbol.for("react.portal") : 60106
  , sp = Pe ? Symbol.for("react.fragment") : 60107
  , op = Pe ? Symbol.for("react.strict_mode") : 60108
  , ap = Pe ? Symbol.for("react.profiler") : 60114
  , lp = Pe ? Symbol.for("react.provider") : 60109
  , hp = Pe ? Symbol.for("react.context") : 60110
  , uv = Pe ? Symbol.for("react.async_mode") : 60111
  , up = Pe ? Symbol.for("react.concurrent_mode") : 60111
  , cp = Pe ? Symbol.for("react.forward_ref") : 60112
  , dp = Pe ? Symbol.for("react.suspense") : 60113
  , rD = Pe ? Symbol.for("react.suspense_list") : 60120
  , fp = Pe ? Symbol.for("react.memo") : 60115
  , pp = Pe ? Symbol.for("react.lazy") : 60116
  , iD = Pe ? Symbol.for("react.block") : 60121
  , nD = Pe ? Symbol.for("react.fundamental") : 60117
  , sD = Pe ? Symbol.for("react.responder") : 60118
  , oD = Pe ? Symbol.for("react.scope") : 60119;
function Ur(e) {
    if (typeof e == "object" && e !== null) {
        var t = e.$$typeof;
        switch (t) {
        case lv:
            switch (e = e.type,
            e) {
            case uv:
            case up:
            case sp:
            case ap:
            case op:
            case dp:
                return e;
            default:
                switch (e = e && e.$$typeof,
                e) {
                case hp:
                case cp:
                case pp:
                case fp:
                case lp:
                    return e;
                default:
                    return t
                }
            }
        case hv:
            return t
        }
    }
}
function yC(e) {
    return Ur(e) === up
}
At.AsyncMode = uv;
At.ConcurrentMode = up;
At.ContextConsumer = hp;
At.ContextProvider = lp;
At.Element = lv;
At.ForwardRef = cp;
At.Fragment = sp;
At.Lazy = pp;
At.Memo = fp;
At.Portal = hv;
At.Profiler = ap;
At.StrictMode = op;
At.Suspense = dp;
At.isAsyncMode = function(e) {
    return yC(e) || Ur(e) === uv
}
;
At.isConcurrentMode = yC;
At.isContextConsumer = function(e) {
    return Ur(e) === hp
}
;
At.isContextProvider = function(e) {
    return Ur(e) === lp
}
;
At.isElement = function(e) {
    return typeof e == "object" && e !== null && e.$$typeof === lv
}
;
At.isForwardRef = function(e) {
    return Ur(e) === cp
}
;
At.isFragment = function(e) {
    return Ur(e) === sp
}
;
At.isLazy = function(e) {
    return Ur(e) === pp
}
;
At.isMemo = function(e) {
    return Ur(e) === fp
}
;
At.isPortal = function(e) {
    return Ur(e) === hv
}
;
At.isProfiler = function(e) {
    return Ur(e) === ap
}
;
At.isStrictMode = function(e) {
    return Ur(e) === op
}
;
At.isSuspense = function(e) {
    return Ur(e) === dp
}
;
At.isValidElementType = function(e) {
    return typeof e == "string" || typeof e == "function" || e === sp || e === up || e === ap || e === op || e === dp || e === rD || typeof e == "object" && e !== null && (e.$$typeof === pp || e.$$typeof === fp || e.$$typeof === lp || e.$$typeof === hp || e.$$typeof === cp || e.$$typeof === nD || e.$$typeof === sD || e.$$typeof === oD || e.$$typeof === iD)
}
;
At.typeOf = Ur;
_C.exports = At;
var aD = _C.exports
  , vC = aD
  , lD = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
}
  , hD = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
}
  , xC = {};
xC[vC.ForwardRef] = lD;
xC[vC.Memo] = hD;
var A0 = function(e, t) {
    return A0 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(r, i) {
        r.__proto__ = i
    }
    || function(r, i) {
        for (var n in i)
            Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n])
    }
    ,
    A0(e, t)
};
function uD(e, t) {
    if (typeof t != "function" && t !== null)
        throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    A0(e, t);
    function r() {
        this.constructor = e
    }
    e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype,
    new r)
}
var bn = function() {
    return bn = Object.assign || function(t) {
        for (var r, i = 1, n = arguments.length; i < n; i++) {
            r = arguments[i];
            for (var s in r)
                Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s])
        }
        return t
    }
    ,
    bn.apply(this, arguments)
};
function Hh(e, t) {
    var r = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (r[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var n = 0, i = Object.getOwnPropertySymbols(e); n < i.length; n++)
            t.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[n]) && (r[i[n]] = e[i[n]]);
    return r
}
function cD(e, t, r) {
    if (r || arguments.length === 2)
        for (var i = 0, n = t.length, s; i < n; i++)
            (s || !(i in t)) && (s || (s = Array.prototype.slice.call(t, 0, i)),
            s[i] = t[i]);
    return e.concat(s || Array.prototype.slice.call(t))
}
function EC(e, t, r) {
    if (r === void 0 && (r = Error),
    !e)
        throw new r(t)
}
var b0 = function(e, t) {
    return b0 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(r, i) {
        r.__proto__ = i
    }
    || function(r, i) {
        for (var n in i)
            Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n])
    }
    ,
    b0(e, t)
};
function ko(e, t) {
    if (typeof t != "function" && t !== null)
        throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    b0(e, t);
    function r() {
        this.constructor = e
    }
    e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype,
    new r)
}
var Ht = function() {
    return Ht = Object.assign || function(t) {
        for (var r, i = 1, n = arguments.length; i < n; i++) {
            r = arguments[i];
            for (var s in r)
                Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s])
        }
        return t
    }
    ,
    Ht.apply(this, arguments)
};
function jo(e, t, r) {
    if (r || arguments.length === 2)
        for (var i = 0, n = t.length, s; i < n; i++)
            (s || !(i in t)) && (s || (s = Array.prototype.slice.call(t, 0, i)),
            s[i] = t[i]);
    return e.concat(s || Array.prototype.slice.call(t))
}
var C0 = function(e, t) {
    return C0 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(r, i) {
        r.__proto__ = i
    }
    || function(r, i) {
        for (var n in i)
            Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n])
    }
    ,
    C0(e, t)
};
function mp(e, t) {
    if (typeof t != "function" && t !== null)
        throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    C0(e, t);
    function r() {
        this.constructor = e
    }
    e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype,
    new r)
}
var Ki = function() {
    return Ki = Object.assign || function(t) {
        for (var r, i = 1, n = arguments.length; i < n; i++) {
            r = arguments[i];
            for (var s in r)
                Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s])
        }
        return t
    }
    ,
    Ki.apply(this, arguments)
};
function dD(e, t) {
    var r = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (r[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var n = 0, i = Object.getOwnPropertySymbols(e); n < i.length; n++)
            t.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[n]) && (r[i[n]] = e[i[n]]);
    return r
}
function xm(e, t, r) {
    if (r || arguments.length === 2)
        for (var i = 0, n = t.length, s; i < n; i++)
            (s || !(i in t)) && (s || (s = Array.prototype.slice.call(t, 0, i)),
            s[i] = t[i]);
    return e.concat(s || Array.prototype.slice.call(t))
}
var rf = function() {
    return rf = Object.assign || function(t) {
        for (var r, i = 1, n = arguments.length; i < n; i++) {
            r = arguments[i];
            for (var s in r)
                Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s])
        }
        return t
    }
    ,
    rf.apply(this, arguments)
}, mt;
(function(e) {
    e[e.EXPECT_ARGUMENT_CLOSING_BRACE = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE",
    e[e.EMPTY_ARGUMENT = 2] = "EMPTY_ARGUMENT",
    e[e.MALFORMED_ARGUMENT = 3] = "MALFORMED_ARGUMENT",
    e[e.EXPECT_ARGUMENT_TYPE = 4] = "EXPECT_ARGUMENT_TYPE",
    e[e.INVALID_ARGUMENT_TYPE = 5] = "INVALID_ARGUMENT_TYPE",
    e[e.EXPECT_ARGUMENT_STYLE = 6] = "EXPECT_ARGUMENT_STYLE",
    e[e.INVALID_NUMBER_SKELETON = 7] = "INVALID_NUMBER_SKELETON",
    e[e.INVALID_DATE_TIME_SKELETON = 8] = "INVALID_DATE_TIME_SKELETON",
    e[e.EXPECT_NUMBER_SKELETON = 9] = "EXPECT_NUMBER_SKELETON",
    e[e.EXPECT_DATE_TIME_SKELETON = 10] = "EXPECT_DATE_TIME_SKELETON",
    e[e.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE",
    e[e.EXPECT_SELECT_ARGUMENT_OPTIONS = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS",
    e[e.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE",
    e[e.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE",
    e[e.EXPECT_SELECT_ARGUMENT_SELECTOR = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR",
    e[e.EXPECT_PLURAL_ARGUMENT_SELECTOR = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR",
    e[e.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT",
    e[e.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT",
    e[e.INVALID_PLURAL_ARGUMENT_SELECTOR = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR",
    e[e.DUPLICATE_PLURAL_ARGUMENT_SELECTOR = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR",
    e[e.DUPLICATE_SELECT_ARGUMENT_SELECTOR = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR",
    e[e.MISSING_OTHER_CLAUSE = 22] = "MISSING_OTHER_CLAUSE",
    e[e.INVALID_TAG = 23] = "INVALID_TAG",
    e[e.INVALID_TAG_NAME = 25] = "INVALID_TAG_NAME",
    e[e.UNMATCHED_CLOSING_TAG = 26] = "UNMATCHED_CLOSING_TAG",
    e[e.UNCLOSED_TAG = 27] = "UNCLOSED_TAG"
}
)(mt || (mt = {}));
var Dt;
(function(e) {
    e[e.literal = 0] = "literal",
    e[e.argument = 1] = "argument",
    e[e.number = 2] = "number",
    e[e.date = 3] = "date",
    e[e.time = 4] = "time",
    e[e.select = 5] = "select",
    e[e.plural = 6] = "plural",
    e[e.pound = 7] = "pound",
    e[e.tag = 8] = "tag"
}
)(Dt || (Dt = {}));
var ja;
(function(e) {
    e[e.number = 0] = "number",
    e[e.dateTime = 1] = "dateTime"
}
)(ja || (ja = {}));
function UE(e) {
    return e.type === Dt.literal
}
function fD(e) {
    return e.type === Dt.argument
}
function TC(e) {
    return e.type === Dt.number
}
function SC(e) {
    return e.type === Dt.date
}
function wC(e) {
    return e.type === Dt.time
}
function AC(e) {
    return e.type === Dt.select
}
function bC(e) {
    return e.type === Dt.plural
}
function pD(e) {
    return e.type === Dt.pound
}
function CC(e) {
    return e.type === Dt.tag
}
function PC(e) {
    return !!(e && typeof e == "object" && e.type === ja.number)
}
function P0(e) {
    return !!(e && typeof e == "object" && e.type === ja.dateTime)
}
var IC = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/
  , mD = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function gD(e) {
    var t = {};
    return e.replace(mD, function(r) {
        var i = r.length;
        switch (r[0]) {
        case "G":
            t.era = i === 4 ? "long" : i === 5 ? "narrow" : "short";
            break;
        case "y":
            t.year = i === 2 ? "2-digit" : "numeric";
            break;
        case "Y":
        case "u":
        case "U":
        case "r":
            throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
        case "q":
        case "Q":
            throw new RangeError("`q/Q` (quarter) patterns are not supported");
        case "M":
        case "L":
            t.month = ["numeric", "2-digit", "short", "long", "narrow"][i - 1];
            break;
        case "w":
        case "W":
            throw new RangeError("`w/W` (week) patterns are not supported");
        case "d":
            t.day = ["numeric", "2-digit"][i - 1];
            break;
        case "D":
        case "F":
        case "g":
            throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
        case "E":
            t.weekday = i === 4 ? "short" : i === 5 ? "narrow" : "short";
            break;
        case "e":
            if (i < 4)
                throw new RangeError("`e..eee` (weekday) patterns are not supported");
            t.weekday = ["short", "long", "narrow", "short"][i - 4];
            break;
        case "c":
            if (i < 4)
                throw new RangeError("`c..ccc` (weekday) patterns are not supported");
            t.weekday = ["short", "long", "narrow", "short"][i - 4];
            break;
        case "a":
            t.hour12 = !0;
            break;
        case "b":
        case "B":
            throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
        case "h":
            t.hourCycle = "h12",
            t.hour = ["numeric", "2-digit"][i - 1];
            break;
        case "H":
            t.hourCycle = "h23",
            t.hour = ["numeric", "2-digit"][i - 1];
            break;
        case "K":
            t.hourCycle = "h11",
            t.hour = ["numeric", "2-digit"][i - 1];
            break;
        case "k":
            t.hourCycle = "h24",
            t.hour = ["numeric", "2-digit"][i - 1];
            break;
        case "j":
        case "J":
        case "C":
            throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
        case "m":
            t.minute = ["numeric", "2-digit"][i - 1];
            break;
        case "s":
            t.second = ["numeric", "2-digit"][i - 1];
            break;
        case "S":
        case "A":
            throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
        case "z":
            t.timeZoneName = i < 4 ? "short" : "long";
            break;
        case "Z":
        case "O":
        case "v":
        case "V":
        case "X":
        case "x":
            throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead")
        }
        return ""
    }),
    t
}
var Qt = function() {
    return Qt = Object.assign || function(t) {
        for (var r, i = 1, n = arguments.length; i < n; i++) {
            r = arguments[i];
            for (var s in r)
                Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s])
        }
        return t
    }
    ,
    Qt.apply(this, arguments)
}
  , _D = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
function yD(e) {
    if (e.length === 0)
        throw new Error("Number skeleton cannot be empty");
    for (var t = e.split(_D).filter(function(d) {
        return d.length > 0
    }), r = [], i = 0, n = t; i < n.length; i++) {
        var s = n[i]
          , o = s.split("/");
        if (o.length === 0)
            throw new Error("Invalid number skeleton");
        for (var a = o[0], l = o.slice(1), h = 0, u = l; h < u.length; h++) {
            var c = u[h];
            if (c.length === 0)
                throw new Error("Invalid number skeleton")
        }
        r.push({
            stem: a,
            options: l
        })
    }
    return r
}
function vD(e) {
    return e.replace(/^(.*?)-/, "")
}
var GE = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g
  , RC = /^(@+)?(\+|#+)?[rs]?$/g
  , xD = /(\*)(0+)|(#+)(0+)|(0+)/g
  , MC = /^(0+)$/;
function HE(e) {
    var t = {};
    return e[e.length - 1] === "r" ? t.roundingPriority = "morePrecision" : e[e.length - 1] === "s" && (t.roundingPriority = "lessPrecision"),
    e.replace(RC, function(r, i, n) {
        return typeof n != "string" ? (t.minimumSignificantDigits = i.length,
        t.maximumSignificantDigits = i.length) : n === "+" ? t.minimumSignificantDigits = i.length : i[0] === "#" ? t.maximumSignificantDigits = i.length : (t.minimumSignificantDigits = i.length,
        t.maximumSignificantDigits = i.length + (typeof n == "string" ? n.length : 0)),
        ""
    }),
    t
}
function OC(e) {
    switch (e) {
    case "sign-auto":
        return {
            signDisplay: "auto"
        };
    case "sign-accounting":
    case "()":
        return {
            currencySign: "accounting"
        };
    case "sign-always":
    case "+!":
        return {
            signDisplay: "always"
        };
    case "sign-accounting-always":
    case "()!":
        return {
            signDisplay: "always",
            currencySign: "accounting"
        };
    case "sign-except-zero":
    case "+?":
        return {
            signDisplay: "exceptZero"
        };
    case "sign-accounting-except-zero":
    case "()?":
        return {
            signDisplay: "exceptZero",
            currencySign: "accounting"
        };
    case "sign-never":
    case "+_":
        return {
            signDisplay: "never"
        }
    }
}
function ED(e) {
    var t;
    if (e[0] === "E" && e[1] === "E" ? (t = {
        notation: "engineering"
    },
    e = e.slice(2)) : e[0] === "E" && (t = {
        notation: "scientific"
    },
    e = e.slice(1)),
    t) {
        var r = e.slice(0, 2);
        if (r === "+!" ? (t.signDisplay = "always",
        e = e.slice(2)) : r === "+?" && (t.signDisplay = "exceptZero",
        e = e.slice(2)),
        !MC.test(e))
            throw new Error("Malformed concise eng/scientific notation");
        t.minimumIntegerDigits = e.length
    }
    return t
}
function $E(e) {
    var t = {}
      , r = OC(e);
    return r || t
}
function TD(e) {
    for (var t = {}, r = 0, i = e; r < i.length; r++) {
        var n = i[r];
        switch (n.stem) {
        case "percent":
        case "%":
            t.style = "percent";
            continue;
        case "%x100":
            t.style = "percent",
            t.scale = 100;
            continue;
        case "currency":
            t.style = "currency",
            t.currency = n.options[0];
            continue;
        case "group-off":
        case ",_":
            t.useGrouping = !1;
            continue;
        case "precision-integer":
        case ".":
            t.maximumFractionDigits = 0;
            continue;
        case "measure-unit":
        case "unit":
            t.style = "unit",
            t.unit = vD(n.options[0]);
            continue;
        case "compact-short":
        case "K":
            t.notation = "compact",
            t.compactDisplay = "short";
            continue;
        case "compact-long":
        case "KK":
            t.notation = "compact",
            t.compactDisplay = "long";
            continue;
        case "scientific":
            t = Qt(Qt(Qt({}, t), {
                notation: "scientific"
            }), n.options.reduce(function(l, h) {
                return Qt(Qt({}, l), $E(h))
            }, {}));
            continue;
        case "engineering":
            t = Qt(Qt(Qt({}, t), {
                notation: "engineering"
            }), n.options.reduce(function(l, h) {
                return Qt(Qt({}, l), $E(h))
            }, {}));
            continue;
        case "notation-simple":
            t.notation = "standard";
            continue;
        case "unit-width-narrow":
            t.currencyDisplay = "narrowSymbol",
            t.unitDisplay = "narrow";
            continue;
        case "unit-width-short":
            t.currencyDisplay = "code",
            t.unitDisplay = "short";
            continue;
        case "unit-width-full-name":
            t.currencyDisplay = "name",
            t.unitDisplay = "long";
            continue;
        case "unit-width-iso-code":
            t.currencyDisplay = "symbol";
            continue;
        case "scale":
            t.scale = parseFloat(n.options[0]);
            continue;
        case "integer-width":
            if (n.options.length > 1)
                throw new RangeError("integer-width stems only accept a single optional option");
            n.options[0].replace(xD, function(l, h, u, c, d, f) {
                if (h)
                    t.minimumIntegerDigits = u.length;
                else {
                    if (c && d)
                        throw new Error("We currently do not support maximum integer digits");
                    if (f)
                        throw new Error("We currently do not support exact integer digits")
                }
                return ""
            });
            continue
        }
        if (MC.test(n.stem)) {
            t.minimumIntegerDigits = n.stem.length;
            continue
        }
        if (GE.test(n.stem)) {
            if (n.options.length > 1)
                throw new RangeError("Fraction-precision stems only accept a single optional option");
            n.stem.replace(GE, function(l, h, u, c, d, f) {
                return u === "*" ? t.minimumFractionDigits = h.length : c && c[0] === "#" ? t.maximumFractionDigits = c.length : d && f ? (t.minimumFractionDigits = d.length,
                t.maximumFractionDigits = d.length + f.length) : (t.minimumFractionDigits = h.length,
                t.maximumFractionDigits = h.length),
                ""
            });
            var s = n.options[0];
            s === "w" ? t = Qt(Qt({}, t), {
                trailingZeroDisplay: "stripIfInteger"
            }) : s && (t = Qt(Qt({}, t), HE(s)));
            continue
        }
        if (RC.test(n.stem)) {
            t = Qt(Qt({}, t), HE(n.stem));
            continue
        }
        var o = OC(n.stem);
        o && (t = Qt(Qt({}, t), o));
        var a = ED(n.stem);
        a && (t = Qt(Qt({}, t), a))
    }
    return t
}
var pc = {
    "001": ["H", "h"],
    AC: ["H", "h", "hb", "hB"],
    AD: ["H", "hB"],
    AE: ["h", "hB", "hb", "H"],
    AF: ["H", "hb", "hB", "h"],
    AG: ["h", "hb", "H", "hB"],
    AI: ["H", "h", "hb", "hB"],
    AL: ["h", "H", "hB"],
    AM: ["H", "hB"],
    AO: ["H", "hB"],
    AR: ["H", "h", "hB", "hb"],
    AS: ["h", "H"],
    AT: ["H", "hB"],
    AU: ["h", "hb", "H", "hB"],
    AW: ["H", "hB"],
    AX: ["H"],
    AZ: ["H", "hB", "h"],
    BA: ["H", "hB", "h"],
    BB: ["h", "hb", "H", "hB"],
    BD: ["h", "hB", "H"],
    BE: ["H", "hB"],
    BF: ["H", "hB"],
    BG: ["H", "hB", "h"],
    BH: ["h", "hB", "hb", "H"],
    BJ: ["H", "hB"],
    BL: ["H", "hB"],
    BM: ["h", "hb", "H", "hB"],
    BN: ["hb", "hB", "h", "H"],
    BO: ["H", "hB", "h", "hb"],
    BQ: ["H"],
    BR: ["H", "hB"],
    BS: ["h", "hb", "H", "hB"],
    BT: ["h", "H"],
    BW: ["H", "h", "hb", "hB"],
    BZ: ["H", "h", "hb", "hB"],
    CA: ["h", "hb", "H", "hB"],
    CC: ["H", "h", "hb", "hB"],
    CD: ["hB", "H"],
    CF: ["H", "h", "hB"],
    CG: ["H", "hB"],
    CH: ["H", "hB", "h"],
    CI: ["H", "hB"],
    CK: ["H", "h", "hb", "hB"],
    CL: ["H", "h", "hB", "hb"],
    CM: ["H", "h", "hB"],
    CN: ["H", "hB", "hb", "h"],
    CO: ["h", "H", "hB", "hb"],
    CP: ["H"],
    CR: ["H", "h", "hB", "hb"],
    CU: ["H", "h", "hB", "hb"],
    CV: ["H", "hB"],
    CX: ["H", "h", "hb", "hB"],
    CY: ["h", "H", "hb", "hB"],
    CZ: ["H"],
    DE: ["H", "hB"],
    DG: ["H", "h", "hb", "hB"],
    DJ: ["h", "H"],
    DK: ["H"],
    DM: ["h", "hb", "H", "hB"],
    DO: ["h", "H", "hB", "hb"],
    DZ: ["h", "hB", "hb", "H"],
    EA: ["H", "h", "hB", "hb"],
    EC: ["H", "hB", "h", "hb"],
    EE: ["H", "hB"],
    EG: ["h", "hB", "hb", "H"],
    EH: ["h", "hB", "hb", "H"],
    ER: ["h", "H"],
    ES: ["H", "hB", "h", "hb"],
    ET: ["hB", "hb", "h", "H"],
    FI: ["H"],
    FJ: ["h", "hb", "H", "hB"],
    FK: ["H", "h", "hb", "hB"],
    FM: ["h", "hb", "H", "hB"],
    FR: ["H", "hB"],
    GA: ["H", "hB"],
    GB: ["H", "h", "hb", "hB"],
    GD: ["h", "hb", "H", "hB"],
    GE: ["H", "hB", "h"],
    GF: ["H", "hB"],
    GG: ["H", "h", "hb", "hB"],
    GH: ["h", "H"],
    GI: ["H", "h", "hb", "hB"],
    GM: ["h", "hb", "H", "hB"],
    GN: ["H", "hB"],
    GP: ["H", "hB"],
    GQ: ["H", "hB", "h", "hb"],
    GR: ["h", "H", "hb", "hB"],
    GT: ["H", "h", "hB", "hb"],
    GU: ["h", "hb", "H", "hB"],
    GW: ["H", "hB"],
    GY: ["h", "hb", "H", "hB"],
    HK: ["h", "hB", "hb", "H"],
    HN: ["H", "h", "hB", "hb"],
    HR: ["H", "hB"],
    IC: ["H", "h", "hB", "hb"],
    ID: ["H"],
    IE: ["H", "h", "hb", "hB"],
    IL: ["H", "hB"],
    IM: ["H", "h", "hb", "hB"],
    IN: ["h", "H"],
    IO: ["H", "h", "hb", "hB"],
    IQ: ["h", "hB", "hb", "H"],
    IR: ["hB", "H"],
    IS: ["H"],
    IT: ["H", "hB"],
    JE: ["H", "h", "hb", "hB"],
    JM: ["h", "hb", "H", "hB"],
    JO: ["h", "hB", "hb", "H"],
    JP: ["H", "h", "K"],
    KE: ["hB", "hb", "H", "h"],
    KG: ["H", "h", "hB", "hb"],
    KH: ["hB", "h", "H", "hb"],
    KI: ["h", "hb", "H", "hB"],
    KM: ["H", "h", "hB", "hb"],
    KN: ["h", "hb", "H", "hB"],
    KP: ["h", "H", "hB", "hb"],
    KR: ["h", "H", "hB", "hb"],
    KW: ["h", "hB", "hb", "H"],
    KY: ["h", "hb", "H", "hB"],
    KZ: ["H", "hB"],
    LA: ["H", "hb", "hB", "h"],
    LB: ["h", "hB", "hb", "H"],
    LC: ["h", "hb", "H", "hB"],
    LI: ["H", "hB", "h"],
    LK: ["H", "h", "hB", "hb"],
    LR: ["h", "hb", "H", "hB"],
    LS: ["h", "H"],
    LT: ["H", "h", "hb", "hB"],
    LU: ["H", "h", "hB"],
    LV: ["H", "hB", "hb", "h"],
    LY: ["h", "hB", "hb", "H"],
    MA: ["H", "h", "hB", "hb"],
    MC: ["H", "hB"],
    MD: ["H", "hB"],
    ME: ["H", "hB", "h"],
    MF: ["H", "hB"],
    MH: ["h", "hb", "H", "hB"],
    MK: ["H", "h", "hb", "hB"],
    ML: ["H"],
    MM: ["hB", "hb", "H", "h"],
    MN: ["H", "h", "hb", "hB"],
    MO: ["h", "hB", "hb", "H"],
    MP: ["h", "hb", "H", "hB"],
    MQ: ["H", "hB"],
    MR: ["h", "hB", "hb", "H"],
    MS: ["H", "h", "hb", "hB"],
    MW: ["h", "hb", "H", "hB"],
    MX: ["H", "h", "hB", "hb"],
    MY: ["hb", "hB", "h", "H"],
    MZ: ["H", "hB"],
    NA: ["h", "H", "hB", "hb"],
    NC: ["H", "hB"],
    NE: ["H"],
    NF: ["H", "h", "hb", "hB"],
    NG: ["H", "h", "hb", "hB"],
    NI: ["H", "h", "hB", "hb"],
    NL: ["H", "hB"],
    NP: ["H", "h", "hB"],
    NR: ["H", "h", "hb", "hB"],
    NU: ["H", "h", "hb", "hB"],
    NZ: ["h", "hb", "H", "hB"],
    OM: ["h", "hB", "hb", "H"],
    PA: ["h", "H", "hB", "hb"],
    PE: ["H", "hB", "h", "hb"],
    PF: ["H", "h", "hB"],
    PG: ["h", "H"],
    PH: ["h", "hB", "hb", "H"],
    PK: ["h", "hB", "H"],
    PM: ["H", "hB"],
    PN: ["H", "h", "hb", "hB"],
    PR: ["h", "H", "hB", "hb"],
    PS: ["h", "hB", "hb", "H"],
    PT: ["H", "hB"],
    PW: ["h", "H"],
    PY: ["H", "h", "hB", "hb"],
    QA: ["h", "hB", "hb", "H"],
    RE: ["H", "hB"],
    RO: ["H", "hB"],
    RS: ["H", "hB", "h"],
    RU: ["H"],
    SA: ["h", "hB", "hb", "H"],
    SB: ["h", "hb", "H", "hB"],
    SC: ["H", "h", "hB"],
    SD: ["h", "hB", "hb", "H"],
    SE: ["H"],
    SG: ["h", "hb", "H", "hB"],
    SH: ["H", "h", "hb", "hB"],
    SI: ["H", "hB"],
    SJ: ["H"],
    SK: ["H"],
    SL: ["h", "hb", "H", "hB"],
    SM: ["H", "h", "hB"],
    SN: ["H", "h", "hB"],
    SO: ["h", "H"],
    SR: ["H", "hB"],
    SS: ["h", "hb", "H", "hB"],
    ST: ["H", "hB"],
    SV: ["H", "h", "hB", "hb"],
    SX: ["H", "h", "hb", "hB"],
    SY: ["h", "hB", "hb", "H"],
    SZ: ["h", "hb", "H", "hB"],
    TA: ["H", "h", "hb", "hB"],
    TC: ["h", "hb", "H", "hB"],
    TD: ["h", "H", "hB"],
    TF: ["H", "h", "hB"],
    TG: ["H", "hB"],
    TL: ["H", "hB", "hb", "h"],
    TN: ["h", "hB", "hb", "H"],
    TO: ["h", "H"],
    TR: ["H", "hB"],
    TT: ["h", "hb", "H", "hB"],
    TW: ["hB", "hb", "h", "H"],
    TZ: ["hB", "hb", "H", "h"],
    UA: ["H", "hB", "h"],
    UG: ["hB", "hb", "H", "h"],
    UM: ["h", "hb", "H", "hB"],
    US: ["h", "hb", "H", "hB"],
    UY: ["H", "h", "hB", "hb"],
    UZ: ["H", "hB", "h"],
    VA: ["H", "h", "hB"],
    VC: ["h", "hb", "H", "hB"],
    VE: ["h", "H", "hB", "hb"],
    VG: ["h", "hb", "H", "hB"],
    VI: ["h", "hb", "H", "hB"],
    VU: ["h", "H"],
    WF: ["H", "hB"],
    WS: ["h", "H"],
    XK: ["H", "hB", "h"],
    YE: ["h", "hB", "hb", "H"],
    YT: ["H", "hB"],
    ZA: ["H", "h", "hb", "hB"],
    ZM: ["h", "hb", "H", "hB"],
    "af-ZA": ["H", "h", "hB", "hb"],
    "ar-001": ["h", "hB", "hb", "H"],
    "ca-ES": ["H", "h", "hB"],
    "en-001": ["h", "hb", "H", "hB"],
    "es-BO": ["H", "h", "hB", "hb"],
    "es-BR": ["H", "h", "hB", "hb"],
    "es-EC": ["H", "h", "hB", "hb"],
    "es-ES": ["H", "h", "hB", "hb"],
    "es-GQ": ["H", "h", "hB", "hb"],
    "es-PE": ["H", "h", "hB", "hb"],
    "fr-CA": ["H", "h", "hB"],
    "gl-ES": ["H", "h", "hB"],
    "gu-IN": ["hB", "hb", "h", "H"],
    "hi-IN": ["hB", "h", "H"],
    "it-CH": ["H", "h", "hB"],
    "it-IT": ["H", "h", "hB"],
    "kn-IN": ["hB", "h", "H"],
    "ml-IN": ["hB", "h", "H"],
    "mr-IN": ["hB", "hb", "h", "H"],
    "pa-IN": ["hB", "hb", "h", "H"],
    "ta-IN": ["hB", "h", "hb", "H"],
    "te-IN": ["hB", "h", "H"],
    "zu-ZA": ["H", "hB", "hb", "h"]
};
function SD(e, t) {
    for (var r = "", i = 0; i < e.length; i++) {
        var n = e.charAt(i);
        if (n === "j") {
            for (var s = 0; i + 1 < e.length && e.charAt(i + 1) === n; )
                s++,
                i++;
            var o = 1 + (s & 1)
              , a = s < 2 ? 1 : 3 + (s >> 1)
              , l = "a"
              , h = wD(t);
            for ((h == "H" || h == "k") && (a = 0); a-- > 0; )
                r += l;
            for (; o-- > 0; )
                r = h + r
        } else
            n === "J" ? r += "H" : r += n
    }
    return r
}
function wD(e) {
    var t = e.hourCycle;
    if (t === void 0 && e.hourCycles && e.hourCycles.length && (t = e.hourCycles[0]),
    t)
        switch (t) {
        case "h24":
            return "k";
        case "h23":
            return "H";
        case "h12":
            return "h";
        case "h11":
            return "K";
        default:
            throw new Error("Invalid hourCycle")
        }
    var r = e.language, i;
    r !== "root" && (i = e.maximize().region);
    var n = pc[i || ""] || pc[r || ""] || pc["".concat(r, "-001")] || pc["001"];
    return n[0]
}
var Em, AD = new RegExp("^".concat(IC.source, "*")), bD = new RegExp("".concat(IC.source, "*$"));
function _t(e, t) {
    return {
        start: e,
        end: t
    }
}
var CD = !!String.prototype.startsWith
  , PD = !!String.fromCodePoint
  , ID = !!Object.fromEntries
  , RD = !!String.prototype.codePointAt
  , MD = !!String.prototype.trimStart
  , OD = !!String.prototype.trimEnd
  , ND = !!Number.isSafeInteger
  , LD = ND ? Number.isSafeInteger : function(e) {
    return typeof e == "number" && isFinite(e) && Math.floor(e) === e && Math.abs(e) <= 9007199254740991
}
  , I0 = !0;
try {
    var DD = LC("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
    I0 = ((Em = DD.exec("a")) === null || Em === void 0 ? void 0 : Em[0]) === "a"
} catch {
    I0 = !1
}
var zE = CD ? function(t, r, i) {
    return t.startsWith(r, i)
}
: function(t, r, i) {
    return t.slice(i, i + r.length) === r
}
  , R0 = PD ? String.fromCodePoint : function() {
    for (var t = [], r = 0; r < arguments.length; r++)
        t[r] = arguments[r];
    for (var i = "", n = t.length, s = 0, o; n > s; ) {
        if (o = t[s++],
        o > 1114111)
            throw RangeError(o + " is not a valid code point");
        i += o < 65536 ? String.fromCharCode(o) : String.fromCharCode(((o -= 65536) >> 10) + 55296, o % 1024 + 56320)
    }
    return i
}
  , WE = ID ? Object.fromEntries : function(t) {
    for (var r = {}, i = 0, n = t; i < n.length; i++) {
        var s = n[i]
          , o = s[0]
          , a = s[1];
        r[o] = a
    }
    return r
}
  , NC = RD ? function(t, r) {
    return t.codePointAt(r)
}
: function(t, r) {
    var i = t.length;
    if (!(r < 0 || r >= i)) {
        var n = t.charCodeAt(r), s;
        return n < 55296 || n > 56319 || r + 1 === i || (s = t.charCodeAt(r + 1)) < 56320 || s > 57343 ? n : (n - 55296 << 10) + (s - 56320) + 65536
    }
}
  , BD = MD ? function(t) {
    return t.trimStart()
}
: function(t) {
    return t.replace(AD, "")
}
  , kD = OD ? function(t) {
    return t.trimEnd()
}
: function(t) {
    return t.replace(bD, "")
}
;
function LC(e, t) {
    return new RegExp(e,t)
}
var M0;
if (I0) {
    var VE = LC("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
    M0 = function(t, r) {
        var i;
        VE.lastIndex = r;
        var n = VE.exec(t);
        return (i = n[1]) !== null && i !== void 0 ? i : ""
    }
} else
    M0 = function(t, r) {
        for (var i = []; ; ) {
            var n = NC(t, r);
            if (n === void 0 || DC(n) || HD(n))
                break;
            i.push(n),
            r += n >= 65536 ? 2 : 1
        }
        return R0.apply(void 0, i)
    }
    ;
var FD = function() {
    function e(t, r) {
        r === void 0 && (r = {}),
        this.message = t,
        this.position = {
            offset: 0,
            line: 1,
            column: 1
        },
        this.ignoreTag = !!r.ignoreTag,
        this.locale = r.locale,
        this.requiresOtherClause = !!r.requiresOtherClause,
        this.shouldParseSkeletons = !!r.shouldParseSkeletons
    }
    return e.prototype.parse = function() {
        if (this.offset() !== 0)
            throw Error("parser can only be used once");
        return this.parseMessage(0, "", !1)
    }
    ,
    e.prototype.parseMessage = function(t, r, i) {
        for (var n = []; !this.isEOF(); ) {
            var s = this.char();
            if (s === 123) {
                var o = this.parseArgument(t, i);
                if (o.err)
                    return o;
                n.push(o.val)
            } else {
                if (s === 125 && t > 0)
                    break;
                if (s === 35 && (r === "plural" || r === "selectordinal")) {
                    var a = this.clonePosition();
                    this.bump(),
                    n.push({
                        type: Dt.pound,
                        location: _t(a, this.clonePosition())
                    })
                } else if (s === 60 && !this.ignoreTag && this.peek() === 47) {
                    if (i)
                        break;
                    return this.error(mt.UNMATCHED_CLOSING_TAG, _t(this.clonePosition(), this.clonePosition()))
                } else if (s === 60 && !this.ignoreTag && O0(this.peek() || 0)) {
                    var o = this.parseTag(t, r);
                    if (o.err)
                        return o;
                    n.push(o.val)
                } else {
                    var o = this.parseLiteral(t, r);
                    if (o.err)
                        return o;
                    n.push(o.val)
                }
            }
        }
        return {
            val: n,
            err: null
        }
    }
    ,
    e.prototype.parseTag = function(t, r) {
        var i = this.clonePosition();
        this.bump();
        var n = this.parseTagName();
        if (this.bumpSpace(),
        this.bumpIf("/>"))
            return {
                val: {
                    type: Dt.literal,
                    value: "<".concat(n, "/>"),
                    location: _t(i, this.clonePosition())
                },
                err: null
            };
        if (this.bumpIf(">")) {
            var s = this.parseMessage(t + 1, r, !0);
            if (s.err)
                return s;
            var o = s.val
              , a = this.clonePosition();
            if (this.bumpIf("</")) {
                if (this.isEOF() || !O0(this.char()))
                    return this.error(mt.INVALID_TAG, _t(a, this.clonePosition()));
                var l = this.clonePosition()
                  , h = this.parseTagName();
                return n !== h ? this.error(mt.UNMATCHED_CLOSING_TAG, _t(l, this.clonePosition())) : (this.bumpSpace(),
                this.bumpIf(">") ? {
                    val: {
                        type: Dt.tag,
                        value: n,
                        children: o,
                        location: _t(i, this.clonePosition())
                    },
                    err: null
                } : this.error(mt.INVALID_TAG, _t(a, this.clonePosition())))
            } else
                return this.error(mt.UNCLOSED_TAG, _t(i, this.clonePosition()))
        } else
            return this.error(mt.INVALID_TAG, _t(i, this.clonePosition()))
    }
    ,
    e.prototype.parseTagName = function() {
        var t = this.offset();
        for (this.bump(); !this.isEOF() && GD(this.char()); )
            this.bump();
        return this.message.slice(t, this.offset())
    }
    ,
    e.prototype.parseLiteral = function(t, r) {
        for (var i = this.clonePosition(), n = ""; ; ) {
            var s = this.tryParseQuote(r);
            if (s) {
                n += s;
                continue
            }
            var o = this.tryParseUnquoted(t, r);
            if (o) {
                n += o;
                continue
            }
            var a = this.tryParseLeftAngleBracket();
            if (a) {
                n += a;
                continue
            }
            break
        }
        var l = _t(i, this.clonePosition());
        return {
            val: {
                type: Dt.literal,
                value: n,
                location: l
            },
            err: null
        }
    }
    ,
    e.prototype.tryParseLeftAngleBracket = function() {
        return !this.isEOF() && this.char() === 60 && (this.ignoreTag || !UD(this.peek() || 0)) ? (this.bump(),
        "<") : null
    }
    ,
    e.prototype.tryParseQuote = function(t) {
        if (this.isEOF() || this.char() !== 39)
            return null;
        switch (this.peek()) {
        case 39:
            return this.bump(),
            this.bump(),
            "'";
        case 123:
        case 60:
        case 62:
        case 125:
            break;
        case 35:
            if (t === "plural" || t === "selectordinal")
                break;
            return null;
        default:
            return null
        }
        this.bump();
        var r = [this.char()];
        for (this.bump(); !this.isEOF(); ) {
            var i = this.char();
            if (i === 39)
                if (this.peek() === 39)
                    r.push(39),
                    this.bump();
                else {
                    this.bump();
                    break
                }
            else
                r.push(i);
            this.bump()
        }
        return R0.apply(void 0, r)
    }
    ,
    e.prototype.tryParseUnquoted = function(t, r) {
        if (this.isEOF())
            return null;
        var i = this.char();
        return i === 60 || i === 123 || i === 35 && (r === "plural" || r === "selectordinal") || i === 125 && t > 0 ? null : (this.bump(),
        R0(i))
    }
    ,
    e.prototype.parseArgument = function(t, r) {
        var i = this.clonePosition();
        if (this.bump(),
        this.bumpSpace(),
        this.isEOF())
            return this.error(mt.EXPECT_ARGUMENT_CLOSING_BRACE, _t(i, this.clonePosition()));
        if (this.char() === 125)
            return this.bump(),
            this.error(mt.EMPTY_ARGUMENT, _t(i, this.clonePosition()));
        var n = this.parseIdentifierIfPossible().value;
        if (!n)
            return this.error(mt.MALFORMED_ARGUMENT, _t(i, this.clonePosition()));
        if (this.bumpSpace(),
        this.isEOF())
            return this.error(mt.EXPECT_ARGUMENT_CLOSING_BRACE, _t(i, this.clonePosition()));
        switch (this.char()) {
        case 125:
            return this.bump(),
            {
                val: {
                    type: Dt.argument,
                    value: n,
                    location: _t(i, this.clonePosition())
                },
                err: null
            };
        case 44:
            return this.bump(),
            this.bumpSpace(),
            this.isEOF() ? this.error(mt.EXPECT_ARGUMENT_CLOSING_BRACE, _t(i, this.clonePosition())) : this.parseArgumentOptions(t, r, n, i);
        default:
            return this.error(mt.MALFORMED_ARGUMENT, _t(i, this.clonePosition()))
        }
    }
    ,
    e.prototype.parseIdentifierIfPossible = function() {
        var t = this.clonePosition()
          , r = this.offset()
          , i = M0(this.message, r)
          , n = r + i.length;
        this.bumpTo(n);
        var s = this.clonePosition()
          , o = _t(t, s);
        return {
            value: i,
            location: o
        }
    }
    ,
    e.prototype.parseArgumentOptions = function(t, r, i, n) {
        var s, o = this.clonePosition(), a = this.parseIdentifierIfPossible().value, l = this.clonePosition();
        switch (a) {
        case "":
            return this.error(mt.EXPECT_ARGUMENT_TYPE, _t(o, l));
        case "number":
        case "date":
        case "time":
            {
                this.bumpSpace();
                var h = null;
                if (this.bumpIf(",")) {
                    this.bumpSpace();
                    var u = this.clonePosition()
                      , c = this.parseSimpleArgStyleIfPossible();
                    if (c.err)
                        return c;
                    var d = kD(c.val);
                    if (d.length === 0)
                        return this.error(mt.EXPECT_ARGUMENT_STYLE, _t(this.clonePosition(), this.clonePosition()));
                    var f = _t(u, this.clonePosition());
                    h = {
                        style: d,
                        styleLocation: f
                    }
                }
                var g = this.tryParseArgumentClose(n);
                if (g.err)
                    return g;
                var p = _t(n, this.clonePosition());
                if (h && zE(h?.style, "::", 0)) {
                    var v = BD(h.style.slice(2));
                    if (a === "number") {
                        var c = this.parseNumberSkeletonFromString(v, h.styleLocation);
                        return c.err ? c : {
                            val: {
                                type: Dt.number,
                                value: i,
                                location: p,
                                style: c.val
                            },
                            err: null
                        }
                    } else {
                        if (v.length === 0)
                            return this.error(mt.EXPECT_DATE_TIME_SKELETON, p);
                        var y = v;
                        this.locale && (y = SD(v, this.locale));
                        var d = {
                            type: ja.dateTime,
                            pattern: y,
                            location: h.styleLocation,
                            parsedOptions: this.shouldParseSkeletons ? gD(y) : {}
                        }
                          , m = a === "date" ? Dt.date : Dt.time;
                        return {
                            val: {
                                type: m,
                                value: i,
                                location: p,
                                style: d
                            },
                            err: null
                        }
                    }
                }
                return {
                    val: {
                        type: a === "number" ? Dt.number : a === "date" ? Dt.date : Dt.time,
                        value: i,
                        location: p,
                        style: (s = h?.style) !== null && s !== void 0 ? s : null
                    },
                    err: null
                }
            }
        case "plural":
        case "selectordinal":
        case "select":
            {
                var _ = this.clonePosition();
                if (this.bumpSpace(),
                !this.bumpIf(","))
                    return this.error(mt.EXPECT_SELECT_ARGUMENT_OPTIONS, _t(_, rf({}, _)));
                this.bumpSpace();
                var x = this.parseIdentifierIfPossible()
                  , E = 0;
                if (a !== "select" && x.value === "offset") {
                    if (!this.bumpIf(":"))
                        return this.error(mt.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, _t(this.clonePosition(), this.clonePosition()));
                    this.bumpSpace();
                    var c = this.tryParseDecimalInteger(mt.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, mt.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
                    if (c.err)
                        return c;
                    this.bumpSpace(),
                    x = this.parseIdentifierIfPossible(),
                    E = c.val
                }
                var S = this.tryParsePluralOrSelectOptions(t, a, r, x);
                if (S.err)
                    return S;
                var g = this.tryParseArgumentClose(n);
                if (g.err)
                    return g;
                var w = _t(n, this.clonePosition());
                return a === "select" ? {
                    val: {
                        type: Dt.select,
                        value: i,
                        options: WE(S.val),
                        location: w
                    },
                    err: null
                } : {
                    val: {
                        type: Dt.plural,
                        value: i,
                        options: WE(S.val),
                        offset: E,
                        pluralType: a === "plural" ? "cardinal" : "ordinal",
                        location: w
                    },
                    err: null
                }
            }
        default:
            return this.error(mt.INVALID_ARGUMENT_TYPE, _t(o, l))
        }
    }
    ,
    e.prototype.tryParseArgumentClose = function(t) {
        return this.isEOF() || this.char() !== 125 ? this.error(mt.EXPECT_ARGUMENT_CLOSING_BRACE, _t(t, this.clonePosition())) : (this.bump(),
        {
            val: !0,
            err: null
        })
    }
    ,
    e.prototype.parseSimpleArgStyleIfPossible = function() {
        for (var t = 0, r = this.clonePosition(); !this.isEOF(); ) {
            var i = this.char();
            switch (i) {
            case 39:
                {
                    this.bump();
                    var n = this.clonePosition();
                    if (!this.bumpUntil("'"))
                        return this.error(mt.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, _t(n, this.clonePosition()));
                    this.bump();
                    break
                }
            case 123:
                {
                    t += 1,
                    this.bump();
                    break
                }
            case 125:
                {
                    if (t > 0)
                        t -= 1;
                    else
                        return {
                            val: this.message.slice(r.offset, this.offset()),
                            err: null
                        };
                    break
                }
            default:
                this.bump();
                break
            }
        }
        return {
            val: this.message.slice(r.offset, this.offset()),
            err: null
        }
    }
    ,
    e.prototype.parseNumberSkeletonFromString = function(t, r) {
        var i = [];
        try {
            i = yD(t)
        } catch {
            return this.error(mt.INVALID_NUMBER_SKELETON, r)
        }
        return {
            val: {
                type: ja.number,
                tokens: i,
                location: r,
                parsedOptions: this.shouldParseSkeletons ? TD(i) : {}
            },
            err: null
        }
    }
    ,
    e.prototype.tryParsePluralOrSelectOptions = function(t, r, i, n) {
        for (var s, o = !1, a = [], l = new Set, h = n.value, u = n.location; ; ) {
            if (h.length === 0) {
                var c = this.clonePosition();
                if (r !== "select" && this.bumpIf("=")) {
                    var d = this.tryParseDecimalInteger(mt.EXPECT_PLURAL_ARGUMENT_SELECTOR, mt.INVALID_PLURAL_ARGUMENT_SELECTOR);
                    if (d.err)
                        return d;
                    u = _t(c, this.clonePosition()),
                    h = this.message.slice(c.offset, this.offset())
                } else
                    break
            }
            if (l.has(h))
                return this.error(r === "select" ? mt.DUPLICATE_SELECT_ARGUMENT_SELECTOR : mt.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, u);
            h === "other" && (o = !0),
            this.bumpSpace();
            var f = this.clonePosition();
            if (!this.bumpIf("{"))
                return this.error(r === "select" ? mt.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : mt.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, _t(this.clonePosition(), this.clonePosition()));
            var g = this.parseMessage(t + 1, r, i);
            if (g.err)
                return g;
            var p = this.tryParseArgumentClose(f);
            if (p.err)
                return p;
            a.push([h, {
                value: g.val,
                location: _t(f, this.clonePosition())
            }]),
            l.add(h),
            this.bumpSpace(),
            s = this.parseIdentifierIfPossible(),
            h = s.value,
            u = s.location
        }
        return a.length === 0 ? this.error(r === "select" ? mt.EXPECT_SELECT_ARGUMENT_SELECTOR : mt.EXPECT_PLURAL_ARGUMENT_SELECTOR, _t(this.clonePosition(), this.clonePosition())) : this.requiresOtherClause && !o ? this.error(mt.MISSING_OTHER_CLAUSE, _t(this.clonePosition(), this.clonePosition())) : {
            val: a,
            err: null
        }
    }
    ,
    e.prototype.tryParseDecimalInteger = function(t, r) {
        var i = 1
          , n = this.clonePosition();
        this.bumpIf("+") || this.bumpIf("-") && (i = -1);
        for (var s = !1, o = 0; !this.isEOF(); ) {
            var a = this.char();
            if (a >= 48 && a <= 57)
                s = !0,
                o = o * 10 + (a - 48),
                this.bump();
            else
                break
        }
        var l = _t(n, this.clonePosition());
        return s ? (o *= i,
        LD(o) ? {
            val: o,
            err: null
        } : this.error(r, l)) : this.error(t, l)
    }
    ,
    e.prototype.offset = function() {
        return this.position.offset
    }
    ,
    e.prototype.isEOF = function() {
        return this.offset() === this.message.length
    }
    ,
    e.prototype.clonePosition = function() {
        return {
            offset: this.position.offset,
            line: this.position.line,
            column: this.position.column
        }
    }
    ,
    e.prototype.char = function() {
        var t = this.position.offset;
        if (t >= this.message.length)
            throw Error("out of bound");
        var r = NC(this.message, t);
        if (r === void 0)
            throw Error("Offset ".concat(t, " is at invalid UTF-16 code unit boundary"));
        return r
    }
    ,
    e.prototype.error = function(t, r) {
        return {
            val: null,
            err: {
                kind: t,
                message: this.message,
                location: r
            }
        }
    }
    ,
    e.prototype.bump = function() {
        if (!this.isEOF()) {
            var t = this.char();
            t === 10 ? (this.position.line += 1,
            this.position.column = 1,
            this.position.offset += 1) : (this.position.column += 1,
            this.position.offset += t < 65536 ? 1 : 2)
        }
    }
    ,
    e.prototype.bumpIf = function(t) {
        if (zE(this.message, t, this.offset())) {
            for (var r = 0; r < t.length; r++)
                this.bump();
            return !0
        }
        return !1
    }
    ,
    e.prototype.bumpUntil = function(t) {
        var r = this.offset()
          , i = this.message.indexOf(t, r);
        return i >= 0 ? (this.bumpTo(i),
        !0) : (this.bumpTo(this.message.length),
        !1)
    }
    ,
    e.prototype.bumpTo = function(t) {
        if (this.offset() > t)
            throw Error("targetOffset ".concat(t, " must be greater than or equal to the current offset ").concat(this.offset()));
        for (t = Math.min(t, this.message.length); ; ) {
            var r = this.offset();
            if (r === t)
                break;
            if (r > t)
                throw Error("targetOffset ".concat(t, " is at invalid UTF-16 code unit boundary"));
            if (this.bump(),
            this.isEOF())
                break
        }
    }
    ,
    e.prototype.bumpSpace = function() {
        for (; !this.isEOF() && DC(this.char()); )
            this.bump()
    }
    ,
    e.prototype.peek = function() {
        if (this.isEOF())
            return null;
        var t = this.char()
          , r = this.offset()
          , i = this.message.charCodeAt(r + (t >= 65536 ? 2 : 1));
        return i ?? null
    }
    ,
    e
}();
function O0(e) {
    return e >= 97 && e <= 122 || e >= 65 && e <= 90
}
function UD(e) {
    return O0(e) || e === 47
}
function GD(e) {
    return e === 45 || e === 46 || e >= 48 && e <= 57 || e === 95 || e >= 97 && e <= 122 || e >= 65 && e <= 90 || e == 183 || e >= 192 && e <= 214 || e >= 216 && e <= 246 || e >= 248 && e <= 893 || e >= 895 && e <= 8191 || e >= 8204 && e <= 8205 || e >= 8255 && e <= 8256 || e >= 8304 && e <= 8591 || e >= 11264 && e <= 12271 || e >= 12289 && e <= 55295 || e >= 63744 && e <= 64975 || e >= 65008 && e <= 65533 || e >= 65536 && e <= 983039
}
function DC(e) {
    return e >= 9 && e <= 13 || e === 32 || e === 133 || e >= 8206 && e <= 8207 || e === 8232 || e === 8233
}
function HD(e) {
    return e >= 33 && e <= 35 || e === 36 || e >= 37 && e <= 39 || e === 40 || e === 41 || e === 42 || e === 43 || e === 44 || e === 45 || e >= 46 && e <= 47 || e >= 58 && e <= 59 || e >= 60 && e <= 62 || e >= 63 && e <= 64 || e === 91 || e === 92 || e === 93 || e === 94 || e === 96 || e === 123 || e === 124 || e === 125 || e === 126 || e === 161 || e >= 162 && e <= 165 || e === 166 || e === 167 || e === 169 || e === 171 || e === 172 || e === 174 || e === 176 || e === 177 || e === 182 || e === 187 || e === 191 || e === 215 || e === 247 || e >= 8208 && e <= 8213 || e >= 8214 && e <= 8215 || e === 8216 || e === 8217 || e === 8218 || e >= 8219 && e <= 8220 || e === 8221 || e === 8222 || e === 8223 || e >= 8224 && e <= 8231 || e >= 8240 && e <= 8248 || e === 8249 || e === 8250 || e >= 8251 && e <= 8254 || e >= 8257 && e <= 8259 || e === 8260 || e === 8261 || e === 8262 || e >= 8263 && e <= 8273 || e === 8274 || e === 8275 || e >= 8277 && e <= 8286 || e >= 8592 && e <= 8596 || e >= 8597 && e <= 8601 || e >= 8602 && e <= 8603 || e >= 8604 && e <= 8607 || e === 8608 || e >= 8609 && e <= 8610 || e === 8611 || e >= 8612 && e <= 8613 || e === 8614 || e >= 8615 && e <= 8621 || e === 8622 || e >= 8623 && e <= 8653 || e >= 8654 && e <= 8655 || e >= 8656 && e <= 8657 || e === 8658 || e === 8659 || e === 8660 || e >= 8661 && e <= 8691 || e >= 8692 && e <= 8959 || e >= 8960 && e <= 8967 || e === 8968 || e === 8969 || e === 8970 || e === 8971 || e >= 8972 && e <= 8991 || e >= 8992 && e <= 8993 || e >= 8994 && e <= 9e3 || e === 9001 || e === 9002 || e >= 9003 && e <= 9083 || e === 9084 || e >= 9085 && e <= 9114 || e >= 9115 && e <= 9139 || e >= 9140 && e <= 9179 || e >= 9180 && e <= 9185 || e >= 9186 && e <= 9254 || e >= 9255 && e <= 9279 || e >= 9280 && e <= 9290 || e >= 9291 && e <= 9311 || e >= 9472 && e <= 9654 || e === 9655 || e >= 9656 && e <= 9664 || e === 9665 || e >= 9666 && e <= 9719 || e >= 9720 && e <= 9727 || e >= 9728 && e <= 9838 || e === 9839 || e >= 9840 && e <= 10087 || e === 10088 || e === 10089 || e === 10090 || e === 10091 || e === 10092 || e === 10093 || e === 10094 || e === 10095 || e === 10096 || e === 10097 || e === 10098 || e === 10099 || e === 10100 || e === 10101 || e >= 10132 && e <= 10175 || e >= 10176 && e <= 10180 || e === 10181 || e === 10182 || e >= 10183 && e <= 10213 || e === 10214 || e === 10215 || e === 10216 || e === 10217 || e === 10218 || e === 10219 || e === 10220 || e === 10221 || e === 10222 || e === 10223 || e >= 10224 && e <= 10239 || e >= 10240 && e <= 10495 || e >= 10496 && e <= 10626 || e === 10627 || e === 10628 || e === 10629 || e === 10630 || e === 10631 || e === 10632 || e === 10633 || e === 10634 || e === 10635 || e === 10636 || e === 10637 || e === 10638 || e === 10639 || e === 10640 || e === 10641 || e === 10642 || e === 10643 || e === 10644 || e === 10645 || e === 10646 || e === 10647 || e === 10648 || e >= 10649 && e <= 10711 || e === 10712 || e === 10713 || e === 10714 || e === 10715 || e >= 10716 && e <= 10747 || e === 10748 || e === 10749 || e >= 10750 && e <= 11007 || e >= 11008 && e <= 11055 || e >= 11056 && e <= 11076 || e >= 11077 && e <= 11078 || e >= 11079 && e <= 11084 || e >= 11085 && e <= 11123 || e >= 11124 && e <= 11125 || e >= 11126 && e <= 11157 || e === 11158 || e >= 11159 && e <= 11263 || e >= 11776 && e <= 11777 || e === 11778 || e === 11779 || e === 11780 || e === 11781 || e >= 11782 && e <= 11784 || e === 11785 || e === 11786 || e === 11787 || e === 11788 || e === 11789 || e >= 11790 && e <= 11798 || e === 11799 || e >= 11800 && e <= 11801 || e === 11802 || e === 11803 || e === 11804 || e === 11805 || e >= 11806 && e <= 11807 || e === 11808 || e === 11809 || e === 11810 || e === 11811 || e === 11812 || e === 11813 || e === 11814 || e === 11815 || e === 11816 || e === 11817 || e >= 11818 && e <= 11822 || e === 11823 || e >= 11824 && e <= 11833 || e >= 11834 && e <= 11835 || e >= 11836 && e <= 11839 || e === 11840 || e === 11841 || e === 11842 || e >= 11843 && e <= 11855 || e >= 11856 && e <= 11857 || e === 11858 || e >= 11859 && e <= 11903 || e >= 12289 && e <= 12291 || e === 12296 || e === 12297 || e === 12298 || e === 12299 || e === 12300 || e === 12301 || e === 12302 || e === 12303 || e === 12304 || e === 12305 || e >= 12306 && e <= 12307 || e === 12308 || e === 12309 || e === 12310 || e === 12311 || e === 12312 || e === 12313 || e === 12314 || e === 12315 || e === 12316 || e === 12317 || e >= 12318 && e <= 12319 || e === 12320 || e === 12336 || e === 64830 || e === 64831 || e >= 65093 && e <= 65094
}
function N0(e) {
    e.forEach(function(t) {
        if (delete t.location,
        AC(t) || bC(t))
            for (var r in t.options)
                delete t.options[r].location,
                N0(t.options[r].value);
        else
            TC(t) && PC(t.style) || (SC(t) || wC(t)) && P0(t.style) ? delete t.style.location : CC(t) && N0(t.children)
    })
}
function $D(e, t) {
    t === void 0 && (t = {}),
    t = rf({
        shouldParseSkeletons: !0,
        requiresOtherClause: !0
    }, t);
    var r = new FD(e,t).parse();
    if (r.err) {
        var i = SyntaxError(mt[r.err.kind]);
        throw i.location = r.err.location,
        i.originalMessage = r.err.message,
        i
    }
    return t?.captureLocation || N0(r.val),
    r.val
}
function Vi(e, t) {
    var r = t && t.cache ? t.cache : YD
      , i = t && t.serializer ? t.serializer : XD
      , n = t && t.strategy ? t.strategy : WD;
    return n(e, {
        cache: r,
        serializer: i
    })
}
function zD(e) {
    return e == null || typeof e == "number" || typeof e == "boolean"
}
function BC(e, t, r, i) {
    var n = zD(i) ? i : r(i)
      , s = t.get(n);
    return typeof s > "u" && (s = e.call(this, i),
    t.set(n, s)),
    s
}
function kC(e, t, r) {
    var i = Array.prototype.slice.call(arguments, 3)
      , n = r(i)
      , s = t.get(n);
    return typeof s > "u" && (s = e.apply(this, i),
    t.set(n, s)),
    s
}
function cv(e, t, r, i, n) {
    return r.bind(t, e, i, n)
}
function WD(e, t) {
    var r = e.length === 1 ? BC : kC;
    return cv(e, this, r, t.cache.create(), t.serializer)
}
function VD(e, t) {
    return cv(e, this, kC, t.cache.create(), t.serializer)
}
function jD(e, t) {
    return cv(e, this, BC, t.cache.create(), t.serializer)
}
var XD = function() {
    return JSON.stringify(arguments)
};
function dv() {
    this.cache = Object.create(null)
}
dv.prototype.get = function(e) {
    return this.cache[e]
}
;
dv.prototype.set = function(e, t) {
    this.cache[e] = t
}
;
var YD = {
    create: function() {
        return new dv
    }
}, ji = {
    variadic: VD,
    monadic: jD
}, hn;
(function(e) {
    e.MISSING_VALUE = "MISSING_VALUE",
    e.INVALID_VALUE = "INVALID_VALUE",
    e.MISSING_INTL_API = "MISSING_INTL_API"
}
)(hn || (hn = {}));
var Bs = function(e) {
    mp(t, e);
    function t(r, i, n) {
        var s = e.call(this, r) || this;
        return s.code = i,
        s.originalMessage = n,
        s
    }
    return t.prototype.toString = function() {
        return "[formatjs Error: ".concat(this.code, "] ").concat(this.message)
    }
    ,
    t
}(Error), jE = function(e) {
    mp(t, e);
    function t(r, i, n, s) {
        return e.call(this, 'Invalid values for "'.concat(r, '": "').concat(i, '". Options are "').concat(Object.keys(n).join('", "'), '"'), hn.INVALID_VALUE, s) || this
    }
    return t
}(Bs), KD = function(e) {
    mp(t, e);
    function t(r, i, n) {
        return e.call(this, 'Value for "'.concat(r, '" must be of type ').concat(i), hn.INVALID_VALUE, n) || this
    }
    return t
}(Bs), qD = function(e) {
    mp(t, e);
    function t(r, i) {
        return e.call(this, 'The intl string context variable "'.concat(r, '" was not provided to the string "').concat(i, '"'), hn.MISSING_VALUE, i) || this
    }
    return t
}(Bs), Ke;
(function(e) {
    e[e.literal = 0] = "literal",
    e[e.object = 1] = "object"
}
)(Ke || (Ke = {}));
function ZD(e) {
    return e.length < 2 ? e : e.reduce(function(t, r) {
        var i = t[t.length - 1];
        return !i || i.type !== Ke.literal || r.type !== Ke.literal ? t.push(r) : i.value += r.value,
        t
    }, [])
}
function FC(e) {
    return typeof e == "function"
}
function cd(e, t, r, i, n, s, o) {
    if (e.length === 1 && UE(e[0]))
        return [{
            type: Ke.literal,
            value: e[0].value
        }];
    for (var a = [], l = 0, h = e; l < h.length; l++) {
        var u = h[l];
        if (UE(u)) {
            a.push({
                type: Ke.literal,
                value: u.value
            });
            continue
        }
        if (pD(u)) {
            typeof s == "number" && a.push({
                type: Ke.literal,
                value: r.getNumberFormat(t).format(s)
            });
            continue
        }
        var c = u.value;
        if (!(n && c in n))
            throw new qD(c,o);
        var d = n[c];
        if (fD(u)) {
            (!d || typeof d == "string" || typeof d == "number") && (d = typeof d == "string" || typeof d == "number" ? String(d) : ""),
            a.push({
                type: typeof d == "string" ? Ke.literal : Ke.object,
                value: d
            });
            continue
        }
        if (SC(u)) {
            var f = typeof u.style == "string" ? i.date[u.style] : P0(u.style) ? u.style.parsedOptions : void 0;
            a.push({
                type: Ke.literal,
                value: r.getDateTimeFormat(t, f).format(d)
            });
            continue
        }
        if (wC(u)) {
            var f = typeof u.style == "string" ? i.time[u.style] : P0(u.style) ? u.style.parsedOptions : i.time.medium;
            a.push({
                type: Ke.literal,
                value: r.getDateTimeFormat(t, f).format(d)
            });
            continue
        }
        if (TC(u)) {
            var f = typeof u.style == "string" ? i.number[u.style] : PC(u.style) ? u.style.parsedOptions : void 0;
            f && f.scale && (d = d * (f.scale || 1)),
            a.push({
                type: Ke.literal,
                value: r.getNumberFormat(t, f).format(d)
            });
            continue
        }
        if (CC(u)) {
            var g = u.children
              , p = u.value
              , v = n[p];
            if (!FC(v))
                throw new KD(p,"function",o);
            var y = cd(g, t, r, i, n, s)
              , m = v(y.map(function(E) {
                return E.value
            }));
            Array.isArray(m) || (m = [m]),
            a.push.apply(a, m.map(function(E) {
                return {
                    type: typeof E == "string" ? Ke.literal : Ke.object,
                    value: E
                }
            }))
        }
        if (AC(u)) {
            var _ = u.options[d] || u.options.other;
            if (!_)
                throw new jE(u.value,d,Object.keys(u.options),o);
            a.push.apply(a, cd(_.value, t, r, i, n));
            continue
        }
        if (bC(u)) {
            var _ = u.options["=".concat(d)];
            if (!_) {
                if (!Intl.PluralRules)
                    throw new Bs(`Intl.PluralRules is not available in this environment.
Try polyfilling it using "@formatjs/intl-pluralrules"
`,hn.MISSING_INTL_API,o);
                var x = r.getPluralRules(t, {
                    type: u.pluralType
                }).select(d - (u.offset || 0));
                _ = u.options[x] || u.options.other
            }
            if (!_)
                throw new jE(u.value,d,Object.keys(u.options),o);
            a.push.apply(a, cd(_.value, t, r, i, n, d - (u.offset || 0)));
            continue
        }
    }
    return ZD(a)
}
function QD(e, t) {
    return t ? Ki(Ki(Ki({}, e || {}), t || {}), Object.keys(e).reduce(function(r, i) {
        return r[i] = Ki(Ki({}, e[i]), t[i] || {}),
        r
    }, {})) : e
}
function JD(e, t) {
    return t ? Object.keys(e).reduce(function(r, i) {
        return r[i] = QD(e[i], t[i]),
        r
    }, Ki({}, e)) : e
}
function Tm(e) {
    return {
        create: function() {
            return {
                get: function(t) {
                    return e[t]
                },
                set: function(t, r) {
                    e[t] = r
                }
            }
        }
    }
}
function tB(e) {
    return e === void 0 && (e = {
        number: {},
        dateTime: {},
        pluralRules: {}
    }),
    {
        getNumberFormat: Vi(function() {
            for (var t, r = [], i = 0; i < arguments.length; i++)
                r[i] = arguments[i];
            return new ((t = Intl.NumberFormat).bind.apply(t, xm([void 0], r, !1)))
        }, {
            cache: Tm(e.number),
            strategy: ji.variadic
        }),
        getDateTimeFormat: Vi(function() {
            for (var t, r = [], i = 0; i < arguments.length; i++)
                r[i] = arguments[i];
            return new ((t = Intl.DateTimeFormat).bind.apply(t, xm([void 0], r, !1)))
        }, {
            cache: Tm(e.dateTime),
            strategy: ji.variadic
        }),
        getPluralRules: Vi(function() {
            for (var t, r = [], i = 0; i < arguments.length; i++)
                r[i] = arguments[i];
            return new ((t = Intl.PluralRules).bind.apply(t, xm([void 0], r, !1)))
        }, {
            cache: Tm(e.pluralRules),
            strategy: ji.variadic
        })
    }
}
var UC = function() {
    function e(t, r, i, n) {
        r === void 0 && (r = e.defaultLocale);
        var s = this;
        if (this.formatterCache = {
            number: {},
            dateTime: {},
            pluralRules: {}
        },
        this.format = function(l) {
            var h = s.formatToParts(l);
            if (h.length === 1)
                return h[0].value;
            var u = h.reduce(function(c, d) {
                return !c.length || d.type !== Ke.literal || typeof c[c.length - 1] != "string" ? c.push(d.value) : c[c.length - 1] += d.value,
                c
            }, []);
            return u.length <= 1 ? u[0] || "" : u
        }
        ,
        this.formatToParts = function(l) {
            return cd(s.ast, s.locales, s.formatters, s.formats, l, void 0, s.message)
        }
        ,
        this.resolvedOptions = function() {
            var l;
            return {
                locale: ((l = s.resolvedLocale) === null || l === void 0 ? void 0 : l.toString()) || Intl.NumberFormat.supportedLocalesOf(s.locales)[0]
            }
        }
        ,
        this.getAst = function() {
            return s.ast
        }
        ,
        this.locales = r,
        this.resolvedLocale = e.resolveLocale(r),
        typeof t == "string") {
            if (this.message = t,
            !e.__parse)
                throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
            var o = n || {};
            o.formatters;
            var a = dD(o, ["formatters"]);
            this.ast = e.__parse(t, Ki(Ki({}, a), {
                locale: this.resolvedLocale
            }))
        } else
            this.ast = t;
        if (!Array.isArray(this.ast))
            throw new TypeError("A message must be provided as a String or AST.");
        this.formats = JD(e.formats, i),
        this.formatters = n && n.formatters || tB(this.formatterCache)
    }
    return Object.defineProperty(e, "defaultLocale", {
        get: function() {
            return e.memoizedDefaultLocale || (e.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale),
            e.memoizedDefaultLocale
        },
        enumerable: !1,
        configurable: !0
    }),
    e.memoizedDefaultLocale = null,
    e.resolveLocale = function(t) {
        if (!(typeof Intl.Locale > "u")) {
            var r = Intl.NumberFormat.supportedLocalesOf(t);
            return r.length > 0 ? new Intl.Locale(r[0]) : new Intl.Locale(typeof t == "string" ? t : t[0])
        }
    }
    ,
    e.__parse = $D,
    e.formats = {
        number: {
            integer: {
                maximumFractionDigits: 0
            },
            currency: {
                style: "currency"
            },
            percent: {
                style: "percent"
            }
        },
        date: {
            short: {
                month: "numeric",
                day: "numeric",
                year: "2-digit"
            },
            medium: {
                month: "short",
                day: "numeric",
                year: "numeric"
            },
            long: {
                month: "long",
                day: "numeric",
                year: "numeric"
            },
            full: {
                weekday: "long",
                month: "long",
                day: "numeric",
                year: "numeric"
            }
        },
        time: {
            short: {
                hour: "numeric",
                minute: "numeric"
            },
            medium: {
                hour: "numeric",
                minute: "numeric",
                second: "numeric"
            },
            long: {
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                timeZoneName: "short"
            },
            full: {
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                timeZoneName: "short"
            }
        }
    },
    e
}(), Po;
(function(e) {
    e.FORMAT_ERROR = "FORMAT_ERROR",
    e.UNSUPPORTED_FORMATTER = "UNSUPPORTED_FORMATTER",
    e.INVALID_CONFIG = "INVALID_CONFIG",
    e.MISSING_DATA = "MISSING_DATA",
    e.MISSING_TRANSLATION = "MISSING_TRANSLATION"
}
)(Po || (Po = {}));
var Iu = function(e) {
    ko(t, e);
    function t(r, i, n) {
        var s = this
          , o = n ? n instanceof Error ? n : new Error(String(n)) : void 0;
        return s = e.call(this, "[@formatjs/intl Error ".concat(r, "] ").concat(i, `
`).concat(o ? `
`.concat(o.message, `
`).concat(o.stack) : "")) || this,
        s.code = r,
        typeof Error.captureStackTrace == "function" && Error.captureStackTrace(s, t),
        s
    }
    return t
}(Error)
  , eB = function(e) {
    ko(t, e);
    function t(r, i) {
        return e.call(this, Po.UNSUPPORTED_FORMATTER, r, i) || this
    }
    return t
}(Iu)
  , rB = function(e) {
    ko(t, e);
    function t(r, i) {
        return e.call(this, Po.INVALID_CONFIG, r, i) || this
    }
    return t
}(Iu)
  , XE = function(e) {
    ko(t, e);
    function t(r, i) {
        return e.call(this, Po.MISSING_DATA, r, i) || this
    }
    return t
}(Iu)
  , ui = function(e) {
    ko(t, e);
    function t(r, i, n) {
        var s = e.call(this, Po.FORMAT_ERROR, "".concat(r, `
Locale: `).concat(i, `
`), n) || this;
        return s.locale = i,
        s
    }
    return t
}(Iu)
  , Sm = function(e) {
    ko(t, e);
    function t(r, i, n, s) {
        var o = e.call(this, "".concat(r, `
MessageID: `).concat(n?.id, `
Default Message: `).concat(n?.defaultMessage, `
Description: `).concat(n?.description, `
`), i, s) || this;
        return o.descriptor = n,
        o.locale = i,
        o
    }
    return t
}(ui)
  , iB = function(e) {
    ko(t, e);
    function t(r, i) {
        var n = e.call(this, Po.MISSING_TRANSLATION, 'Missing message: "'.concat(r.id, '" for locale "').concat(i, '", using ').concat(r.defaultMessage ? "default message (".concat(typeof r.defaultMessage == "string" ? r.defaultMessage : r.defaultMessage.map(function(s) {
            var o;
            return (o = s.value) !== null && o !== void 0 ? o : JSON.stringify(s)
        }).join(), ")") : "id", " as fallback.")) || this;
        return n.descriptor = r,
        n
    }
    return t
}(Iu);
function Fo(e, t, r) {
    return r === void 0 && (r = {}),
    t.reduce(function(i, n) {
        return n in e ? i[n] = e[n] : n in r && (i[n] = r[n]),
        i
    }, {})
}
var nB = function(e) {}
  , sB = function(e) {}
  , GC = {
    formats: {},
    messages: {},
    timeZone: void 0,
    defaultLocale: "en",
    defaultFormats: {},
    fallbackOnEmptyString: !0,
    onError: nB,
    onWarn: sB
};
function fv() {
    return {
        dateTime: {},
        number: {},
        message: {},
        relativeTime: {},
        pluralRules: {},
        list: {},
        displayNames: {}
    }
}
function $s(e) {
    return {
        create: function() {
            return {
                get: function(t) {
                    return e[t]
                },
                set: function(t, r) {
                    e[t] = r
                }
            }
        }
    }
}
function oB(e) {
    e === void 0 && (e = fv());
    var t = Intl.RelativeTimeFormat
      , r = Intl.ListFormat
      , i = Intl.DisplayNames
      , n = Vi(function() {
        for (var a, l = [], h = 0; h < arguments.length; h++)
            l[h] = arguments[h];
        return new ((a = Intl.DateTimeFormat).bind.apply(a, jo([void 0], l, !1)))
    }, {
        cache: $s(e.dateTime),
        strategy: ji.variadic
    })
      , s = Vi(function() {
        for (var a, l = [], h = 0; h < arguments.length; h++)
            l[h] = arguments[h];
        return new ((a = Intl.NumberFormat).bind.apply(a, jo([void 0], l, !1)))
    }, {
        cache: $s(e.number),
        strategy: ji.variadic
    })
      , o = Vi(function() {
        for (var a, l = [], h = 0; h < arguments.length; h++)
            l[h] = arguments[h];
        return new ((a = Intl.PluralRules).bind.apply(a, jo([void 0], l, !1)))
    }, {
        cache: $s(e.pluralRules),
        strategy: ji.variadic
    });
    return {
        getDateTimeFormat: n,
        getNumberFormat: s,
        getMessageFormat: Vi(function(a, l, h, u) {
            return new UC(a,l,h,Ht({
                formatters: {
                    getNumberFormat: s,
                    getDateTimeFormat: n,
                    getPluralRules: o
                }
            }, u || {}))
        }, {
            cache: $s(e.message),
            strategy: ji.variadic
        }),
        getRelativeTimeFormat: Vi(function() {
            for (var a = [], l = 0; l < arguments.length; l++)
                a[l] = arguments[l];
            return new (t.bind.apply(t, jo([void 0], a, !1)))
        }, {
            cache: $s(e.relativeTime),
            strategy: ji.variadic
        }),
        getPluralRules: o,
        getListFormat: Vi(function() {
            for (var a = [], l = 0; l < arguments.length; l++)
                a[l] = arguments[l];
            return new (r.bind.apply(r, jo([void 0], a, !1)))
        }, {
            cache: $s(e.list),
            strategy: ji.variadic
        }),
        getDisplayNames: Vi(function() {
            for (var a = [], l = 0; l < arguments.length; l++)
                a[l] = arguments[l];
            return new (i.bind.apply(i, jo([void 0], a, !1)))
        }, {
            cache: $s(e.displayNames),
            strategy: ji.variadic
        })
    }
}
function pv(e, t, r, i) {
    var n = e && e[t], s;
    if (n && (s = n[r]),
    s)
        return s;
    i(new eB("No ".concat(t, " format named: ").concat(r)))
}
function mc(e, t) {
    return Object.keys(e).reduce(function(r, i) {
        return r[i] = Ht({
            timeZone: t
        }, e[i]),
        r
    }, {})
}
function YE(e, t) {
    var r = Object.keys(Ht(Ht({}, e), t));
    return r.reduce(function(i, n) {
        return i[n] = Ht(Ht({}, e[n] || {}), t[n] || {}),
        i
    }, {})
}
function KE(e, t) {
    if (!t)
        return e;
    var r = UC.formats;
    return Ht(Ht(Ht({}, r), e), {
        date: YE(mc(r.date, t), mc(e.date || {}, t)),
        time: YE(mc(r.time, t), mc(e.time || {}, t))
    })
}
var L0 = function(e, t, r, i, n) {
    var s = e.locale
      , o = e.formats
      , a = e.messages
      , l = e.defaultLocale
      , h = e.defaultFormats
      , u = e.fallbackOnEmptyString
      , c = e.onError
      , d = e.timeZone
      , f = e.defaultRichTextElements;
    r === void 0 && (r = {
        id: ""
    });
    var g = r.id
      , p = r.defaultMessage;
    EC(!!g, "[@formatjs/intl] An `id` must be provided to format a message. You can either:\n1. Configure your build toolchain with [babel-plugin-formatjs](https://formatjs.io/docs/tooling/babel-plugin)\nor [@formatjs/ts-transformer](https://formatjs.io/docs/tooling/ts-transformer) OR\n2. Configure your `eslint` config to include [eslint-plugin-formatjs](https://formatjs.io/docs/tooling/linter#enforce-id)\nto autofix this issue");
    var v = String(g)
      , y = a && Object.prototype.hasOwnProperty.call(a, v) && a[v];
    if (Array.isArray(y) && y.length === 1 && y[0].type === Dt.literal)
        return y[0].value;
    if (!i && y && typeof y == "string" && !f)
        return y.replace(/'\{(.*?)\}'/gi, "{$1}");
    if (i = Ht(Ht({}, f), i || {}),
    o = KE(o, d),
    h = KE(h, d),
    !y) {
        if (u === !1 && y === "")
            return y;
        if ((!p || s && s.toLowerCase() !== l.toLowerCase()) && c(new iB(r,s)),
        p)
            try {
                var m = t.getMessageFormat(p, l, h, n);
                return m.format(i)
            } catch (_) {
                return c(new Sm('Error formatting default message for: "'.concat(v, '", rendering default message verbatim'),s,r,_)),
                typeof p == "string" ? p : v
            }
        return v
    }
    try {
        var m = t.getMessageFormat(y, s, o, Ht({
            formatters: t
        }, n || {}));
        return m.format(i)
    } catch (_) {
        c(new Sm('Error formatting message: "'.concat(v, '", using ').concat(p ? "default message" : "id", " as fallback."),s,r,_))
    }
    if (p)
        try {
            var m = t.getMessageFormat(p, l, h, n);
            return m.format(i)
        } catch (_) {
            c(new Sm('Error formatting the default message for: "'.concat(v, '", rendering message verbatim'),s,r,_))
        }
    return typeof y == "string" ? y : typeof p == "string" ? p : v
}
  , HC = ["formatMatcher", "timeZone", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hourCycle", "dateStyle", "timeStyle", "calendar", "numberingSystem", "fractionalSecondDigits"];
function gp(e, t, r, i) {
    var n = e.locale
      , s = e.formats
      , o = e.onError
      , a = e.timeZone;
    i === void 0 && (i = {});
    var l = i.format
      , h = Ht(Ht({}, a && {
        timeZone: a
    }), l && pv(s, t, l, o))
      , u = Fo(i, HC, h);
    return t === "time" && !u.hour && !u.minute && !u.second && !u.timeStyle && !u.dateStyle && (u = Ht(Ht({}, u), {
        hour: "numeric",
        minute: "numeric"
    })),
    r(n, u)
}
function aB(e, t) {
    for (var r = [], i = 2; i < arguments.length; i++)
        r[i - 2] = arguments[i];
    var n = r[0]
      , s = r[1]
      , o = s === void 0 ? {} : s
      , a = typeof n == "string" ? new Date(n || 0) : n;
    try {
        return gp(e, "date", t, o).format(a)
    } catch (l) {
        e.onError(new ui("Error formatting date.",e.locale,l))
    }
    return String(a)
}
function lB(e, t) {
    for (var r = [], i = 2; i < arguments.length; i++)
        r[i - 2] = arguments[i];
    var n = r[0]
      , s = r[1]
      , o = s === void 0 ? {} : s
      , a = typeof n == "string" ? new Date(n || 0) : n;
    try {
        return gp(e, "time", t, o).format(a)
    } catch (l) {
        e.onError(new ui("Error formatting time.",e.locale,l))
    }
    return String(a)
}
function hB(e, t) {
    for (var r = [], i = 2; i < arguments.length; i++)
        r[i - 2] = arguments[i];
    var n = r[0]
      , s = r[1]
      , o = r[2]
      , a = o === void 0 ? {} : o
      , l = e.timeZone
      , h = e.locale
      , u = e.onError
      , c = Fo(a, HC, l ? {
        timeZone: l
    } : {});
    try {
        return t(h, c).formatRange(n, s)
    } catch (d) {
        u(new ui("Error formatting date time range.",e.locale,d))
    }
    return String(n)
}
function uB(e, t) {
    for (var r = [], i = 2; i < arguments.length; i++)
        r[i - 2] = arguments[i];
    var n = r[0]
      , s = r[1]
      , o = s === void 0 ? {} : s
      , a = typeof n == "string" ? new Date(n || 0) : n;
    try {
        return gp(e, "date", t, o).formatToParts(a)
    } catch (l) {
        e.onError(new ui("Error formatting date.",e.locale,l))
    }
    return []
}
function cB(e, t) {
    for (var r = [], i = 2; i < arguments.length; i++)
        r[i - 2] = arguments[i];
    var n = r[0]
      , s = r[1]
      , o = s === void 0 ? {} : s
      , a = typeof n == "string" ? new Date(n || 0) : n;
    try {
        return gp(e, "time", t, o).formatToParts(a)
    } catch (l) {
        e.onError(new ui("Error formatting time.",e.locale,l))
    }
    return []
}
var dB = ["style", "type", "fallback", "languageDisplay"];
function fB(e, t, r, i) {
    var n = e.locale
      , s = e.onError
      , o = Intl.DisplayNames;
    o || s(new Bs(`Intl.DisplayNames is not available in this environment.
Try polyfilling it using "@formatjs/intl-displaynames"
`,hn.MISSING_INTL_API));
    var a = Fo(i, dB);
    try {
        return t(n, a).of(r)
    } catch (l) {
        s(new ui("Error formatting display name.",n,l))
    }
}
var pB = ["type", "style"]
  , qE = Date.now();
function mB(e) {
    return "".concat(qE, "_").concat(e, "_").concat(qE)
}
function gB(e, t, r, i) {
    i === void 0 && (i = {});
    var n = $C(e, t, r, i).reduce(function(s, o) {
        var a = o.value;
        return typeof a != "string" ? s.push(a) : typeof s[s.length - 1] == "string" ? s[s.length - 1] += a : s.push(a),
        s
    }, []);
    return n.length === 1 ? n[0] : n.length === 0 ? "" : n
}
function $C(e, t, r, i) {
    var n = e.locale
      , s = e.onError;
    i === void 0 && (i = {});
    var o = Intl.ListFormat;
    o || s(new Bs(`Intl.ListFormat is not available in this environment.
Try polyfilling it using "@formatjs/intl-listformat"
`,hn.MISSING_INTL_API));
    var a = Fo(i, pB);
    try {
        var l = {}
          , h = r.map(function(u, c) {
            if (typeof u == "object") {
                var d = mB(c);
                return l[d] = u,
                d
            }
            return String(u)
        });
        return t(n, a).formatToParts(h).map(function(u) {
            return u.type === "literal" ? u : Ht(Ht({}, u), {
                value: l[u.value] || u.value
            })
        })
    } catch (u) {
        s(new ui("Error formatting list.",n,u))
    }
    return r
}
var _B = ["type"];
function yB(e, t, r, i) {
    var n = e.locale
      , s = e.onError;
    i === void 0 && (i = {}),
    Intl.PluralRules || s(new Bs(`Intl.PluralRules is not available in this environment.
Try polyfilling it using "@formatjs/intl-pluralrules"
`,hn.MISSING_INTL_API));
    var o = Fo(i, _B);
    try {
        return t(n, o).select(r)
    } catch (a) {
        s(new ui("Error formatting plural.",n,a))
    }
    return "other"
}
var vB = ["numeric", "style"];
function xB(e, t, r) {
    var i = e.locale
      , n = e.formats
      , s = e.onError;
    r === void 0 && (r = {});
    var o = r.format
      , a = !!o && pv(n, "relative", o, s) || {}
      , l = Fo(r, vB, a);
    return t(i, l)
}
function EB(e, t, r, i, n) {
    n === void 0 && (n = {}),
    i || (i = "second");
    var s = Intl.RelativeTimeFormat;
    s || e.onError(new Bs(`Intl.RelativeTimeFormat is not available in this environment.
Try polyfilling it using "@formatjs/intl-relativetimeformat"
`,hn.MISSING_INTL_API));
    try {
        return xB(e, t, n).format(r, i)
    } catch (o) {
        e.onError(new ui("Error formatting relative time.",e.locale,o))
    }
    return String(r)
}
var TB = ["style", "currency", "currencyDisplay", "unit", "unitDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "currencyDisplay", "currencySign", "notation", "signDisplay", "unit", "unitDisplay", "numberingSystem"];
function zC(e, t, r) {
    var i = e.locale
      , n = e.formats
      , s = e.onError;
    r === void 0 && (r = {});
    var o = r.format
      , a = o && pv(n, "number", o, s) || {}
      , l = Fo(r, TB, a);
    return t(i, l)
}
function SB(e, t, r, i) {
    i === void 0 && (i = {});
    try {
        return zC(e, t, i).format(r)
    } catch (n) {
        e.onError(new ui("Error formatting number.",e.locale,n))
    }
    return String(r)
}
function wB(e, t, r, i) {
    i === void 0 && (i = {});
    try {
        return zC(e, t, i).formatToParts(r)
    } catch (n) {
        e.onError(new ui("Error formatting number.",e.locale,n))
    }
    return []
}
function AB(e) {
    var t = e ? e[Object.keys(e)[0]] : void 0;
    return typeof t == "string"
}
function bB(e) {
    e.onWarn && e.defaultRichTextElements && AB(e.messages || {}) && e.onWarn(`[@formatjs/intl] "defaultRichTextElements" was specified but "message" was not pre-compiled. 
Please consider using "@formatjs/cli" to pre-compile your messages for performance.
For more details see https://formatjs.io/docs/getting-started/message-distribution`)
}
function CB(e, t) {
    var r = oB(t)
      , i = Ht(Ht({}, GC), e)
      , n = i.locale
      , s = i.defaultLocale
      , o = i.onError;
    return n ? !Intl.NumberFormat.supportedLocalesOf(n).length && o ? o(new XE('Missing locale data for locale: "'.concat(n, '" in Intl.NumberFormat. Using default locale: "').concat(s, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details'))) : !Intl.DateTimeFormat.supportedLocalesOf(n).length && o && o(new XE('Missing locale data for locale: "'.concat(n, '" in Intl.DateTimeFormat. Using default locale: "').concat(s, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details'))) : (o && o(new rB('"locale" was not configured, using "'.concat(s, '" as fallback. See https://formatjs.io/docs/react-intl/api#intlshape for more details'))),
    i.locale = i.defaultLocale || "en"),
    bB(i),
    Ht(Ht({}, i), {
        formatters: r,
        formatNumber: SB.bind(null, i, r.getNumberFormat),
        formatNumberToParts: wB.bind(null, i, r.getNumberFormat),
        formatRelativeTime: EB.bind(null, i, r.getRelativeTimeFormat),
        formatDate: aB.bind(null, i, r.getDateTimeFormat),
        formatDateToParts: uB.bind(null, i, r.getDateTimeFormat),
        formatTime: lB.bind(null, i, r.getDateTimeFormat),
        formatDateTimeRange: hB.bind(null, i, r.getDateTimeFormat),
        formatTimeToParts: cB.bind(null, i, r.getDateTimeFormat),
        formatPlural: yB.bind(null, i, r.getPluralRules),
        formatMessage: L0.bind(null, i, r),
        $t: L0.bind(null, i, r),
        formatList: gB.bind(null, i, r.getListFormat),
        formatListToParts: $C.bind(null, i, r.getListFormat),
        formatDisplayName: fB.bind(null, i, r.getDisplayNames)
    })
}
function WC(e) {
    EC(e, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.")
}
var VC = bn(bn({}, GC), {
    textComponent: ae.Fragment
});
function PB(e) {
    return function(t) {
        return e(ae.Children.toArray(t))
    }
}
function D0(e, t) {
    if (e === t)
        return !0;
    if (!e || !t)
        return !1;
    var r = Object.keys(e)
      , i = Object.keys(t)
      , n = r.length;
    if (i.length !== n)
        return !1;
    for (var s = 0; s < n; s++) {
        var o = r[s];
        if (e[o] !== t[o] || !Object.prototype.hasOwnProperty.call(t, o))
            return !1
    }
    return !0
}
var mv = typeof window < "u" && !window.__REACT_INTL_BYPASS_GLOBAL_CONTEXT__ ? window.__REACT_INTL_CONTEXT__ || (window.__REACT_INTL_CONTEXT__ = ae.createContext(null)) : ae.createContext(null);
mv.Consumer;
var IB = mv.Provider
  , RB = IB
  , MB = mv;
function gv() {
    var e = ae.useContext(MB);
    return WC(e),
    e
}
var B0;
(function(e) {
    e.formatDate = "FormattedDate",
    e.formatTime = "FormattedTime",
    e.formatNumber = "FormattedNumber",
    e.formatList = "FormattedList",
    e.formatDisplayName = "FormattedDisplayName"
}
)(B0 || (B0 = {}));
var k0;
(function(e) {
    e.formatDate = "FormattedDateParts",
    e.formatTime = "FormattedTimeParts",
    e.formatNumber = "FormattedNumberParts",
    e.formatList = "FormattedListParts"
}
)(k0 || (k0 = {}));
function jC(e) {
    var t = function(r) {
        var i = gv()
          , n = r.value
          , s = r.children
          , o = Hh(r, ["value", "children"])
          , a = typeof n == "string" ? new Date(n || 0) : n
          , l = e === "formatDate" ? i.formatDateToParts(a, o) : i.formatTimeToParts(a, o);
        return s(l)
    };
    return t.displayName = k0[e],
    t
}
function Ru(e) {
    var t = function(r) {
        var i = gv()
          , n = r.value
          , s = r.children
          , o = Hh(r, ["value", "children"])
          , a = i[e](n, o);
        if (typeof s == "function")
            return s(a);
        var l = i.textComponent || ae.Fragment;
        return ae.createElement(l, null, a)
    };
    return t.displayName = B0[e],
    t
}
function wm(e) {
    return {
        locale: e.locale,
        timeZone: e.timeZone,
        fallbackOnEmptyString: e.fallbackOnEmptyString,
        formats: e.formats,
        textComponent: e.textComponent,
        messages: e.messages,
        defaultLocale: e.defaultLocale,
        defaultFormats: e.defaultFormats,
        onError: e.onError,
        onWarn: e.onWarn,
        wrapRichTextChunksInFragment: e.wrapRichTextChunksInFragment,
        defaultRichTextElements: e.defaultRichTextElements
    }
}
function XC(e) {
    return e && Object.keys(e).reduce(function(t, r) {
        var i = e[r];
        return t[r] = FC(i) ? PB(i) : i,
        t
    }, {})
}
var ZE = function(e, t, r, i) {
    for (var n = [], s = 4; s < arguments.length; s++)
        n[s - 4] = arguments[s];
    var o = XC(i)
      , a = L0.apply(void 0, cD([e, t, r, o], n, !1));
    return Array.isArray(a) ? ae.Children.toArray(a) : a
}
  , F0 = function(e, t) {
    var r = e.defaultRichTextElements
      , i = Hh(e, ["defaultRichTextElements"])
      , n = XC(r)
      , s = CB(bn(bn(bn({}, VC), i), {
        defaultRichTextElements: n
    }), t)
      , o = {
        locale: s.locale,
        timeZone: s.timeZone,
        fallbackOnEmptyString: s.fallbackOnEmptyString,
        formats: s.formats,
        defaultLocale: s.defaultLocale,
        defaultFormats: s.defaultFormats,
        messages: s.messages,
        onError: s.onError,
        defaultRichTextElements: n
    };
    return bn(bn({}, s), {
        formatMessage: ZE.bind(null, o, s.formatters),
        $t: ZE.bind(null, o, s.formatters)
    })
};
(function(e) {
    uD(t, e);
    function t() {
        var r = e !== null && e.apply(this, arguments) || this;
        return r.cache = fv(),
        r.state = {
            cache: r.cache,
            intl: F0(wm(r.props), r.cache),
            prevConfig: wm(r.props)
        },
        r
    }
    return t.getDerivedStateFromProps = function(r, i) {
        var n = i.prevConfig
          , s = i.cache
          , o = wm(r);
        return D0(n, o) ? null : {
            intl: F0(o, s),
            prevConfig: o
        }
    }
    ,
    t.prototype.render = function() {
        return WC(this.state.intl),
        ae.createElement(RB, {
            value: this.state.intl
        }, this.props.children)
    }
    ,
    t.displayName = "IntlProvider",
    t.defaultProps = VC,
    t
}
)(ae.PureComponent);
function OB(e, t) {
    var r = e.values
      , i = Hh(e, ["values"])
      , n = t.values
      , s = Hh(t, ["values"]);
    return D0(n, r) && D0(i, s)
}
function YC(e) {
    var t = gv()
      , r = t.formatMessage
      , i = t.textComponent
      , n = i === void 0 ? ae.Fragment : i
      , s = e.id
      , o = e.description
      , a = e.defaultMessage
      , l = e.values
      , h = e.children
      , u = e.tagName
      , c = u === void 0 ? n : u
      , d = e.ignoreTag
      , f = {
        id: s,
        description: o,
        defaultMessage: a
    }
      , g = r(f, l, {
        ignoreTag: d
    });
    return typeof h == "function" ? h(Array.isArray(g) ? g : [g]) : c ? ae.createElement(c, null, ae.Children.toArray(g)) : ae.createElement(ae.Fragment, null, g)
}
YC.displayName = "FormattedMessage";
var KC = ae.memo(YC, OB);
KC.displayName = "MemoizedFormattedMessage";
const UX = KC;
Ru("formatDate");
Ru("formatTime");
Ru("formatNumber");
Ru("formatList");
Ru("formatDisplayName");
jC("formatDate");
jC("formatTime");
const GX = 3e3
  , HX = 10
  , $X = {
    LOGIN_TO_PLAY: "login-to-play",
    WIN: "win",
    BETS_ACCEPTED: "bets-accepted",
    INSUFFICIENT_FUNDS: "insufficient-funds",
    MIN_STAKE_LIMIT: "min-stake-limit",
    MAX_STAKE_LIMIT: "max-stake-limit",
    SP_NOT_ENOUGH: "sp-not-enough",
    PLANE_BUILDED: "plane-builded",
    SOMETHING_WENT_WRONG: "something-went-wrong",
    CHECK_INTERNET_CONNECTION: "check-internet-connection",
    MAX_WIN_LIMIT: "max-win-limit",
    MAX_WIN_ERROR: "max-win-error",
    BET_LIMIT_EXCEEDED: "bet-limit-exceeded",
    PLACE_BET_ERROR: "place-bet-error",
    ROUND_STARTED: "round-started",
    CANCEL_BET_ERROR: "cancel-bet-failed",
    BONUS_CLAIMED: "bonus-claimed",
    NEW_BONUS_FLOW_BONUS_CLAIMED: "new-bonus-flow.bonus-claimed",
    NEW_BONUS_FLOW_MAX_BONUS_CLAIMED: "new-bonus-flow.max-bonus-claimed",
    WALLET_WITHDRAW: "wallet-withdraw",
    WALLET_DEPOSITED: "wallet-deposited",
    OPEN_WALLET_APP: "open-wallet",
    FREE_BET: "free-bet",
    BONUS_ACTIVATED: "bonus-activated",
    CLAIM_BONUS_FAILED: "claim-bonus-failed",
    BONUS_DISCARDED: "bonus-discarded",
    BONUS_REVOKED: "bonus-revoked",
    DISCARD_BONUS_FAILED: "discard-bonus-failed",
    CURRENT_PLANE_SELECTED: "current-plane-selected",
    PLANE_SELECTED: "plane-selected",
    PLANE_HAS_APPLIED: "plane-has-applied",
    UNSTABLE_CONNECTION: "unstable-connection",
    AUTOCASHOUTED_BET: "autocashouted-bet",
    AUTOCASHOUTED_BET_BY_KEEP_ALIVE: "autocashouted-bet-by-keep-alive",
    BET_ALREADY_CACHED_OUT: "bet-already-cached-out",
    NFT_CREATION_FAILED: "nft-creation-failed",
    REWARD_CLAIMED: "reward-claimed",
    NEW_SKIN: "new-skin"
}
  , zX = {
    ERROR: "error",
    DEFAULT: "default",
    BETS_ACCEPTED: "bets-accepted",
    WIN: "win",
    FREE_BET: "free-bet",
    SAFE_FLIGHT: "safe-flight",
    SECOND_CHANCE: "second-chance",
    CONNECTION_ERROR: "connection-error"
}
  , QE = {
    CANCELLED: "CANCELLED",
    PENDING: "PENDING",
    CASHOUT: "CASHOUT",
    REJECTED: "REJECTED",
    PENDING_CASHOUT: "PENDING_CASHOUT",
    LOST: "LOST"
}
  , WX = {
    UNSPECIFIED: "CASHOUT_TYPE_UNSPECIFIED",
    AUTO: "CASHOUT_TYPE_AUTO",
    MANUAL: "CASHOUT_TYPE_MANUAL",
    KEEPALIVE: "CASHOUT_TYPE_KEEPALIVE"
}
  , NB = {
    MANUAL: "MANUAL",
    AUTO: "AUTO"
}
  , LB = {
    PLACE: "PLACE",
    CASHOUT: "CASHOUT",
    CANCEL: "CANCEL"
}
  , JE = {
    DEFAULT: "DEFAULT",
    FREE_BET: "FREE_BET"
}
  , VX = {
    [JE.DEFAULT]: "BET_TYPE_DEFAULT",
    [JE.FREE_BET]: "BET_TYPE_FREE_BET"
}
  , jX = {
    betId: null,
    isNextRound: !1,
    activeMode: NB.MANUAL,
    state: LB.PLACE,
    placedBetId: null,
    placedCashoutOdds: null,
    cashoutOddsValue: "",
    totalLooseAmount: 0,
    totalWinAmount: 0,
    roundsCount: null,
    looseMoreAmount: 0,
    winMoreAmount: 0,
    singleWinAmount: 0
}
  , XX = [10, 100, 1e3, 1e4, 1e5, 1e6, 1e7]
  , YX = 1e3
  , KX = 5e3
  , Xo = {
    UNKNOWN: "UNKNOWN",
    START: "START",
    CREATE: "CREATE",
    RUN: "RUN",
    FINISH: "FINISH",
    CANCEL: "CANCEL"
}
  , Yo = {
    STATE_UNSPECIFIED: "STATE_UNSPECIFIED",
    STATE_CREATED: "STATE_CREATED",
    STATE_STARTED: "STATE_STARTED",
    STATE_RUNNING: "STATE_RUNNING",
    STATE_FINISHED: "STATE_FINISHED",
    STATE_CANCELED: "STATE_CANCELED"
}
  , qX = {
    [Xo.UNKNOWN]: Yo.STATE_UNSPECIFIED,
    [Xo.START]: Yo.STATE_STARTED,
    [Xo.CREATE]: Yo.STATE_CREATED,
    [Xo.RUN]: Yo.STATE_RUNNING,
    [Xo.FINISH]: Yo.STATE_FINISHED,
    [Xo.CANCEL]: Yo.STATE_CANCELED
}
  , DB = 1e4
  , ZX = Math.log(DB) * 12
  , QX = {
    PLAYING: "RUN",
    START: "START",
    FINISH: "FINISH",
    CREATE: "CREATE"
}
  , JX = {
    CASHOUT: "cashOutEvent",
    PLACE_BET: "placeBetEvent",
    CANCEL: "cancelEvent",
    ERROR: "errorEvent",
    TOP_PLACE_BET: "topPlaceBetEvents",
    ACTIVE_BETS: "activeBetsEvent",
    LOST_BET: "lostEvent",
    BONUS_CHANGE_EVENT: "bonusChangeEvent",
    ACTIVATION_ACCEPTED: "activationAccepted",
    ACTIVATION_REJECTED: "activationRejected",
    ACHIEVEMENT_UNLOCKED: "achievementUnlocked",
    SKIN_ASSET_CREATED: "skinAssetCreated"
}
  , tY = {
    INSUFFICIENT_BALANCE: "InsufficientBalance",
    INVALID_SESSION: "InvalidSession",
    BET_LIMIT_EXCEEDED: "BetLimitExceeded",
    PLACE_BET_ERROR: "PlaceBetError",
    PLACE_BET_REQUEST_VALIDATION_FAILED: "PlaceBetRequestValidationFailed",
    BRAND_NOT_FOUND: "BrandNotFound"
}
  , eY = {
    CASHOUT_TYPE_KEEPALIVE: "CASHOUT_TYPE_KEEPALIVE"
}
  , rY = "public:aviatrix"
  , iY = "public:participants"
  , nY = "public:anonymized-participants"
  , sY = "assets"
  , oY = {
    "name validate: min length is not reached: nameLength=1 nameMinLength=3": "name-min-length",
    "name validate: min length is not reached: nameLength=2 nameMinLength=3": "name-min-length",
    "name validate: segment min length is not reached: segmentMinLength=3": "name-segment-min-length",
    "name validate: segment should starts with letter": "name-first-letter",
    "name validate: segment should ends with letter or digit": "name-last-letter-or-digit",
    "name validate: segment should contain letter, digit or dash": "name-contain-symbols",
    "name validate: should be spelled lower case": "name-spelled-in-lower",
    "nft_name NFT name should not contain leading and trailing white space": "name-not-contain-white-space",
    "NftName value length must be between 3 and 255 runes, inclusive": "name-min-characters",
    "nft name already exists": "name-already-exist",
    "nft_name this name is forbidden": "forbidden-name"
}
  , aY = {
    STATUS_ACTIVE: "STATUS_ACTIVE",
    STATUS_PENDING: "STATUS_PENDING",
    STATUS_EXPIRED: "STATUS_EXPIRED",
    STATUS_REVOKED: "STATUS_REVOKED"
}
  , Am = {
    STATE_FREE_BET_UNSPECIFIED: "STATE_FREE_BET_UNSPECIFIED",
    STATE_BETTING_IN_PROGRESS: "STATE_BETTING_IN_PROGRESS",
    STATE_WAGERING_IN_PROGRESS: "STATE_WAGERING_IN_PROGRESS",
    STATE_PAYOUT_READY: "STATE_PAYOUT_READY",
    STATE_PAYOUT_SENT: "STATE_PAYOUT_SENT",
    STATE_PAYOUT_COMPLETED: "STATE_PAYOUT_COMPLETED"
}
  , lY = [Am.STATE_PAYOUT_READY, Am.STATE_PAYOUT_SENT, Am.STATE_PAYOUT_COMPLETED]
  , hY = {
    TRIGGER_UNSPECIFIED: "TRIGGER_UNSPECIFIED",
    TRIGGER_MANUAL: "TRIGGER_MANUAL",
    TRIGGER_AUTO: "TRIGGER_AUTO",
    TRIGGER_PROMOCODE: "TRIGGER_PROMOCODE"
}
  , tT = {
    red: {
        colorCode: "#E43120",
        detailsColors: [{
            primary: "yellow",
            secondary: "lightGray"
        }, {
            primary: "darkBlue",
            secondary: "marsh"
        }, {
            primary: "mint",
            secondary: "blue"
        }]
    },
    yellow: {
        colorCode: "#FDA015",
        detailsColors: [{
            primary: "white",
            secondary: "violet"
        }, {
            primary: "blue",
            secondary: "orange"
        }, {
            primary: "lightGreen",
            secondary: "blue"
        }]
    },
    brown: {
        colorCode: "#AA6E54",
        detailsColors: [{
            primary: "yellow",
            secondary: "marsh"
        }, {
            primary: "mint",
            secondary: "darkRed"
        }, {
            primary: "lightBlue",
            secondary: "lightGray"
        }]
    },
    purple: {
        colorCode: "#A32CCD",
        detailsColors: [{
            primary: "lightGreen",
            secondary: "gray"
        }, {
            primary: "lightBlue",
            secondary: "grayBlue"
        }, {
            primary: "yellow",
            secondary: "brick"
        }]
    },
    blue: {
        colorCode: "#1734CB",
        detailsColors: [{
            primary: "turquoise",
            secondary: "brightPurple"
        }, {
            primary: "red",
            secondary: "darkGray"
        }, {
            primary: "yellow",
            secondary: "darkGreen"
        }]
    },
    lightBlue: {
        colorCode: "#24A3DF",
        detailsColors: [{
            primary: "red",
            secondary: "lightBrown"
        }, {
            primary: "mint",
            secondary: "darkGray"
        }, {
            primary: "brown",
            secondary: "marsh"
        }]
    },
    mint: {
        colorCode: "#00A793",
        detailsColors: [{
            primary: "darkGreen",
            secondary: "brick"
        }, {
            primary: "purple",
            secondary: "fenny"
        }, {
            primary: "lightRose",
            secondary: "mustard"
        }]
    },
    green: {
        colorCode: "#45BF19",
        detailsColors: [{
            primary: "lightBlue",
            secondary: "violet"
        }, {
            primary: "lightOrange",
            secondary: "darkRose"
        }, {
            primary: "lightRose",
            secondary: "darkGreen"
        }]
    },
    lightGreen: {
        colorCode: "#B7E208",
        detailsColors: [{
            primary: "rose",
            secondary: "violet"
        }, {
            primary: "turquoise",
            secondary: "lightViolet"
        }, {
            primary: "yellow",
            secondary: "brick"
        }]
    },
    white: {
        colorCode: "#E4DED8",
        detailsColors: [{
            primary: "lightOrange",
            secondary: "fenny"
        }, {
            primary: "blue",
            secondary: "orange"
        }, {
            primary: "lightRose",
            secondary: "blueGray"
        }]
    },
    lightGray: {
        colorCode: "#7B7E7B",
        detailsColors: [{
            primary: "red",
            secondary: "fenny"
        }, {
            primary: "mint",
            secondary: "brick"
        }, {
            primary: "violet",
            secondary: "mustard"
        }]
    },
    black: {
        colorCode: "#252830",
        detailsColors: [{
            primary: "brown",
            secondary: "darkGray"
        }, {
            primary: "yellow",
            secondary: "lightGray"
        }, {
            primary: "red",
            secondary: "lightBrown"
        }]
    }
}
  , uY = "promocode.error.invalid"
  , gc = {
    REJECT_REASON_UNSPECIFIED: "REJECT_REASON_UNSPECIFIED",
    REJECT_REASON_BONUS_EXISTS: "REJECT_REASON_BONUS_EXISTS",
    REJECT_REASON_BONUS_MISS_CONDITIONS: "REJECT_REASON_BONUS_MISS_CONDITIONS",
    REJECT_REASON_SKIN_DOES_NOT_EXIST: "REJECT_REASON_SKIN_DOES_NOT_EXIST"
}
  , cY = {
    API_ERROR_REQUEST_QUOTA_REACHED: "promocode.error.request-quota-reached",
    API_ERROR_MISS_APPLY_CONDITIONS: "promocode.error.invalid",
    API_ERROR_ACTIVATION_LIMIT_REACHED: "promocode.error.expired",
    API_ERROR_ALREADY_ACTIVATED: "promocode.error.already-activated",
    API_ERROR_PROMOCODE_NOT_FOUND: "promocode.error.invalid",
    API_ERROR_PROMOCODE_DISABLED: "promocode.error.not-active",
    API_ERROR_PROMOCODE_EXPIRED: "promocode.error.expired",
    API_ERROR_PROMOCODE_NOT_STARTED: "promocode.error.not-active",
    API_ERROR_UNSUPPORTED_BRAND: "promocode.error.invalid",
    [gc.REJECT_REASON_UNSPECIFIED]: "promocode.error.unspecified",
    [gc.REJECT_REASON_BONUS_EXISTS]: "promocode.error.exists",
    [gc.REJECT_REASON_BONUS_MISS_CONDITIONS]: "promocode.error.miss-conditions",
    [gc.REJECT_REASON_SKIN_DOES_NOT_EXIST]: "promocode.error.skin-does-not-exist"
}
  , eT = {
    EXPIRED: "expired",
    ALREADY_ACTIVATED: "already-activated"
}
  , dY = {
    [eT.EXPIRED]: "promocode.error.expired",
    [eT.ALREADY_ACTIVATED]: "promocode.error.already-activated"
}
  , Ar = {
    SKIN_RARITY_UNSPECIFIED: "SKIN_RARITY_UNSPECIFIED",
    SKIN_RARITY_STANDARD: "SKIN_RARITY_STANDARD",
    SKIN_RARITY_CLASSIC: "SKIN_RARITY_CLASSIC",
    SKIN_RARITY_RARE: "SKIN_RARITY_RARE",
    SKIN_RARITY_EPIC: "SKIN_RARITY_EPIC",
    SKIN_RARITY_LEGENDARY: "SKIN_RARITY_LEGENDARY"
}
  , fY = {
    [Ar.SKIN_RARITY_STANDARD]: "skin.rarity.standard",
    [Ar.SKIN_RARITY_CLASSIC]: "skin.rarity.classic",
    [Ar.SKIN_RARITY_RARE]: "skin.rarity.rare",
    [Ar.SKIN_RARITY_EPIC]: "skin.rarity.epic",
    [Ar.SKIN_RARITY_LEGENDARY]: "skin.rarity.legendary"
}
  , pY = {
    UPDATE_BALANCE: "updateBalance",
    OPEN_CHANGE_CHAIN: "openChangeChain",
    WALLET_CONNECTED: "walletConnected",
    WALLET_DEPOSITED: "walletDeposited",
    WALLET_WITHDRAW: "walletWithdraw",
    WALLET_BALANCE: "walletBalance",
    NEW_CHAIN: "newChain",
    ERROR_NOTIFICATION: "errorNotification",
    OPEN_WALLET_APP: "openWalletApp",
    BALANCE_UPDATE: "balanceUpdate"
}
  , BB = {
    OPEN_WALLET_CONNECT: "openWalletConnect",
    OPEN_DEPOSIT_WITHDRAW: "openDepositWithdraw",
    OPEN_TRANSACTION_HISTORY: "openTransactionHistory",
    CHANGE_CHAIN: "changeChain",
    SESSION_EXPIRED: "sessionExpired",
    APP_READY: "appReady",
    GET_BALANCE: "getBalance",
    CASHIER: "cashier",
    QUIT: "quit",
    GAME_DATA_LOADED: "gameDataLoaded",
    MUTE_HAS_CHANGED: "muteHasChanged",
    ROUND_START: "roundStart",
    ROUND_STARTED: "roundStarted",
    ROUND_ENDED: "roundEnded"
};
var kB = (e => (e.LOCAL = "local",
e.DEVELOPMENT = "development",
e.STAGING = "staging",
e.PREPROD = "preprod",
e.PRODUCTION = "production",
e))(kB || {});
const qC = "production".includes("production")
  , mY = "production".includes("preprod");
var FB = (e => (e.TABLET = "tablet",
e.MOBILE = "mobile",
e))(FB || {})
  , UB = (e => (e.IOS = "ios",
e.ANDROID = "android",
e))(UB || {});
const GB = {
    "scorum-aviatrix-ig": "pmcom",
    "scorum-aviatrix-ig-nomad": "pmnomad",
    "scorum-aviatrix-ig-gls": "pmgls",
    "scorum-aviatrix-ig-br": "pmbr"
}
  , gY = {
    BONUS_REWARD: "bonus-reward-popover",
    REWARD: "reward-popover",
    REWARD_READY: "reward-ready-popover",
    BONUS: "bonus-popover",
    SWITCH_CHAIN: "switch-chain-popover",
    NEW_ACHIEVEMENT: "new-achievement"
};
var HB = (e => (e.MENU = "menu",
e.REWARD_DETAILS = "reward-details",
e.REWARD_CASE = "reward-case",
e.MY_BETS = "my-bets",
e.ABOUT = "about",
e.HOW_TO_PLAY = "how-to-play",
e.RULES = "rules",
e.LEADERBOARD = "leaderboard",
e.SIGN_IN = "sign-in",
e.SIGN_OUT = "sign-out",
e.PLANE = "plane",
e.MY_PLANE = "my-plane",
e.SETTINGS = "settings",
e.SETTINGS_PROFILE = "settings-profile",
e.AUTOBET_SETTINGS = "autobet-settings",
e.BUILD_PLANE = "build-plane",
e.NEW_LEVEL = "new-level",
e.MULTIPLE_DEVICES = "multiple-devices",
e.PLAYERS = "players",
e.PLAYERS_BAR = "players-bar",
e.PROVABLE_FAIR = "provable-fair",
e.PROVABLE_FAIR_BET = "provable-fair-bet",
e.PROVABLE_FAIR_INFO = "provable-fair-info",
e.BONUS_FREE_BET_TERMS = "bonus-freebet-terms",
e.BONUS_DISABLED_CLAIM = "bonus-disabled-claim",
e.PROMOCODE = "promocode",
e.PROMOCODE_STATUS = "promocode-status",
e.PROMOS = "promos",
e.PROMOS_SLIDER = "promos-slider",
e.WALLET_ASSETS = "wallet-assets",
e.ACHIEVEMENT = "achievement",
e.SKIN = "SKIN",
e.SKINS = "SKINS",
e.SKINS_ONBOARDING = "skins-onboarding",
e.UGLY_PROMO_WIN = "ugly-promo-win",
e))(HB || {});
const _Y = {
    AUTO_CASHOUT_1: "autocashout-1",
    AUTO_CASHOUT_2: "autocashout-2",
    MORE_PLANES: "more-planes",
    EXPERIENCE_CHANGES: "experience-changes",
    BONUSES_FREE_BET_COUNT: "bonuses-free-bet-count",
    BONUSES_FREE_BET_COUNT_ONCE: "bonuses-free-bet-count-once",
    BONUSES_FREE_BET_PENDING: "bonuses-free-bet-pending",
    BONUSES_BALANCE: "bonuses-balance",
    PROMOCODE: "promocode"
}
  , me = {
    RESKIN_WINTER: "RESKIN_WINTER",
    RESKIN_CNY: "RESKIN_CNY",
    PROMOCODE: "PROMOCODE",
    RESKIN_HALLOWEEN: "RESKIN_HALLOWEEN",
    RESKIN_F1: "RESKIN_F1",
    RESKIN_NY: "RESKIN_NY",
    RESKIN_NY_SUMMER: "RESKIN_NY_SUMMER",
    RESKIN_VALENTINE: "RESKIN_VALENTINE",
    RESKIN_BRAZIL_CARNIVAL: "RESKIN_BRAZIL_CARNIVAL",
    RESKIN_PATRICK: "RESKIN_PATRICK",
    RESKIN_WOMENS_DAY: "RESKIN_WOMENS_DAY",
    RESKIN_CRICKET: "RESKIN_CRICKET",
    RESKIN_SOCCER: "RESKIN_SLOT4",
    RESKIN_OLYMPIC: "RESKIN_SLOT6",
    RESKIN_SAO_JOAO: "RESKIN_SAO_JOAO",
    RESKIN_DIWALI: "RESKIN_DIWALI",
    RESKIN_LOS_MUERTOS: "RESKIN_LOS_MUERTOS",
    RESKIN_ICE_HOCKEY: "RESKIN_ICE_HOCKEY",
    RESKIN_UEFA: "RESKIN_UEFA",
    RESKIN_FIFA: "RESKIN_FIFA",
    RESKIN_1W: "RESKIN_1W",
    RESKIN_1X: "RESKIN_1X",
    HIDE_RULES: "HIDE_RULES",
    IMAGES_MIGRATION: "IMAGES_MIGRATION",
    HIDE_BETS_HISTORY: "HIDE_BETS_HISTORY",
    SOCIAL_MODE: "SOCIAL_MODE",
    NEW_SOUNDS: "NEW_SOUNDS",
    UGLY_PROMO_WIN: "UGLY_PROMO_WIN",
    DISABLE_OLIMP_DECIMAL_BET_AMOUNT: "DISABLE_OLIMP_DECIMAL_BET_AMOUNT",
    NEW_BONUS_FLOW: "NEW_BONUS_FLOW",
    NEW_PROMOCODE_FLOW: "NEW_PROMOCODE_FLOW",
    PINUP_PIXEL_SCRIPT: "PINUP_PIXEL_SCRIPT",
    MIN_AUTO_CASHOUT_1_05: "MIN_AUTO_CASHOUT_1_05",
    DISABLE_NEW_ACHIEVEMENT_POPOVER: "DISABLE_NEW_ACHIEVEMENT_POPOVER"
}
  , $B = [me.RESKIN_CNY, me.RESKIN_WINTER, me.RESKIN_WOMENS_DAY, me.RESKIN_PATRICK, me.RESKIN_CRICKET, me.RESKIN_SOCCER]
  , yY = {
    PARTICIPANTS_TAB: 1,
    MY_BETS_TAB: 2,
    PROMOS_TAB: 3,
    MENU_TAB: 4,
    HOW_TO_PLAY: 5,
    LEADERBOARD: 7,
    SETTINGS: 8,
    PROVABLE_FAIR: 9,
    REWARD_DETAILS_TAB: 10,
    SKINS: 11
}
  , vY = {
    PROFILE: "PROFILE",
    SKINS: "SKINS",
    EDIT: "EDIT"
}
  , zB = {
    KEY: "key",
    HOW_TO_PLAY: "how-to-play",
    SOUND: "sound",
    ACTIVE_PLANE: "active-plane",
    COACHMARKS: "coachmarks",
    DEMO_TOKEN: "demo-token",
    NEW_LVL: "new-level",
    LAST_BETS: "last-bets",
    IS_FRAME_SIZE_SENT: "is-frame-size-sent",
    MODALS: "modals",
    REWARDS: "rewards",
    SELECTED_CHAIN: "selected-chain",
    PROMOCODES: "promocodes",
    SETTINGS: "settings",
    SKIN_COLLECTIONS: "skin-collections",
    SKINS: "skins"
}
  , Z = {
    RU: "ru",
    EN: "en",
    UK: "uk",
    UA: "ua",
    KZ: "kz",
    KK: "kk",
    IT: "it",
    ES: "es",
    KG: "kg",
    RO: "ro",
    FR: "fr",
    PT: "pt",
    TR: "tr",
    UZ: "uz",
    EL: "el",
    EE: "ee",
    GR: "gr",
    CN: "cn",
    AZ: "az",
    DE: "de",
    HI: "hi",
    PL: "pl",
    PE: "pe",
    GE: "ge",
    ID: "id",
    TH: "th",
    VT: "vt",
    VI: "vi",
    MY: "my",
    TG: "tg",
    BE: "be",
    KO: "ko",
    KR: "kr",
    FA: "fa",
    IR: "ir",
    LV: "lv",
    HY: "hy",
    AM: "am",
    AR: "ar",
    FI: "fi",
    HU: "hu",
    NB: "nb",
    NL: "nl",
    CS: "cs",
    CHS: "chs",
    ZH: "zh",
    JA: "ja",
    MD: "md",
    AF: "af",
    BN: "bn",
    BG: "bg",
    SW: "sw",
    SV: "sv",
    SK: "sk",
    SR: "sr",
    CNR: "cnr",
    TW: "tw"
}
  , xY = {
    [Z.RU]: "ru-ru",
    [Z.EN]: "en-us",
    [Z.UK]: "uk-ua",
    [Z.UA]: "uk-ua",
    [Z.KZ]: "kk-kz",
    [Z.KK]: "kk-kz",
    [Z.IT]: "it-it",
    [Z.ES]: "es-es",
    [Z.KG]: "ky-kz",
    [Z.RO]: "ro-ro",
    [Z.FR]: "fr-fr",
    [Z.PT]: "pt-br",
    [Z.TR]: "tr-tr",
    [Z.UZ]: "lt-uz-uz",
    [Z.EL]: "el-gr",
    [Z.EE]: "et-ee",
    [Z.GR]: "el-gr",
    [Z.CN]: "zh-cn",
    [Z.AZ]: "lt-az-az",
    [Z.DE]: "de-de",
    [Z.HI]: "hi-in",
    [Z.PL]: "pl-pl",
    [Z.PE]: "es-pe",
    [Z.GE]: "ka-ge",
    [Z.ID]: "id-id",
    [Z.TH]: "th-th",
    [Z.TW]: "zh-tw",
    [Z.VT]: "vi-vn",
    [Z.VI]: "vi-vn",
    [Z.MY]: "ms-my",
    [Z.TG]: "tg-tj",
    [Z.BE]: "be-by",
    [Z.KO]: "ko-kr",
    [Z.KR]: "ko-kr",
    [Z.FA]: "fa-ir",
    [Z.IR]: "fa-ir",
    [Z.LV]: "lv-lv",
    [Z.HY]: "hy-am",
    [Z.AM]: "hy-am",
    [Z.AR]: "ar-qa",
    [Z.FI]: "fi-fi",
    [Z.HU]: "hu-hu",
    [Z.NB]: "nb-no",
    [Z.NL]: "nl-nl",
    [Z.CS]: "cs-cz",
    [Z.CHS]: "zh-chs",
    [Z.ZH]: "zh-chs",
    [Z.JA]: "ja-jp",
    [Z.MD]: "ro-md",
    [Z.AF]: "af-za",
    [Z.BN]: "bn-bd",
    [Z.BG]: "bg-bg",
    [Z.SW]: "sw-ke",
    [Z.SV]: "sv-se",
    [Z.SR]: "sr-me",
    [Z.CNR]: "cnr-me",
    [Z.SK]: "sk-sk"
}
  , EY = {
    lightGray: "#8893C1",
    grayBlue: "#7E88D1",
    darkBlue: "#735AF4",
    purple: "#A64EED",
    marsh: "#B5BE4A",
    mint: "#76C99F",
    blue: "#6977F8",
    yellow: "#FFDA16",
    white: "#E4DED8",
    violet: "#8D5DD1",
    orange: "#F47A35",
    lightOrange: "#FF8E3C",
    lightGreen: "#AFDA04",
    darkRed: "#EA5161",
    red: "#EB4D4D",
    lightBlue: "#75EDF9",
    gray: "#9D8999",
    brick: "#C17D75",
    turquoise: "#4FD9CA",
    brightPurple: "#8A3CB6",
    darkGray: "#6B968E",
    darkGreen: "#ACA84D",
    lightBrown: "#AF8A65",
    brown: "#C27755",
    fenny: "#899E5F",
    lightRose: "#F18DA4",
    mustard: "#DCA92A",
    darkRose: "#D66BDD",
    lightViolet: "#AF7BB5",
    rose: "#F6487C",
    blueGray: "#8196A7"
}
  , ZC = Z.EN
  , ce = {
    USD: "USD",
    EUR: "EUR",
    TRY: "TRY",
    RUB: "RUB",
    USJ: "USJ",
    KGS: "KGS",
    DOGE: "DOGE",
    mETH: "mETH",
    KES: "KES",
    KZT: "KZT",
    UAH: "UAH",
    UZS: "UZS"
}
  , WB = {
    [ce.EUR]: "€",
    [ce.USD]: "$",
    [ce.USJ]: "$",
    [ce.TRY]: "₺",
    [ce.RUB]: "₽"
}
  , bm = {
    [ce.USJ]: "$"
}
  , Cm = {
    [ce.USJ]: "USD",
    [ce.KGS]: "KGS",
    [ce.DOGE]: "DOGE",
    [ce.mETH]: "mETH"
}
  , TY = [ce.KES, ce.KGS, ce.KZT, ce.RUB, ce.UAH, ce.UZS]
  , _p = ce.EUR
  , SY = WB[_p];
var QC = (e => (e.CID = "cid",
e.CONSUMER_ID = "consumerId",
e.SESSION_TOKEN = "sessionToken",
e.LANG = "lang",
e.IS_DEMO = "isDemo",
e.DEVTOOLS = "devtools",
e.PIXI_DEVTOOLS = "pixiDevtools",
e.FLAGS = "flags",
e.MODE = "mode",
e.WALLET = "wallet",
e.DISABLE_EXPLOSION = "disableExplosion",
e.DEV_PLANE_LEVEL = "devPlaneLevel",
e.DEV_START_ODDS = "devStartOdds",
e.DEBUG_PARAMS = "debugParams",
e.FEAT_FLAGS = "featFlags",
e.X2_DATES = "x2Dates",
e.ENABLE_RANDOM_PLANE = "enableRandomPlane",
e.STATS_TOOLS = "statstools",
e.CODE = "code",
e.DEMO_SESSION_TTL = "demoSessionTtl",
e.DEMO_SESSION_BALANCE = "demoSessionBalance",
e.DEMO_STAND = "demoStand",
e.HIDE_EXIT_BUTTON = "hideExitButton",
e.AGGREGATOR = "aggregator",
e))(QC || {});
const VB = Object.values(QC)
  , Xa = 2
  , wY = 5
  , jB = "en-US"
  , AY = 16
  , bY = 15
  , CY = 5
  , PY = 8
  , IY = 1e6
  , RY = {
    DAY: "LEADERBOARD_INTERVAL_DAY",
    WEEK: "LEADERBOARD_INTERVAL_WEEK",
    MONTH: "LEADERBOARD_INTERVAL_MONTH",
    ALL_TIME: "LEADERBOARD_INTERVAL_ALL_TIME"
}
  , MY = {
    RANDOM: "RANDOM",
    MANUAL: "MANUAL"
}
  , OY = "nft-aviatrix"
  , NY = "demo"
  , LY = {
    xs: 0,
    sm: 360,
    md: 720,
    lg: 1024,
    xl: 1280
}
  , Je = {
    FULL: "full",
    LIGHT: "light"
}
  , $h = {
    CALM: "calm",
    DYNAMIC: "dynamic"
}
  , DY = {
    ACCESS_DENIED: "ACCESS_DENIED",
    ACCOUNT_BLOCKED: "ACCOUNT_BLOCKED",
    SESSION_EXPIRED: "SESSION_EXPIRED",
    PLATFORM_SESSION_EXPIRED: "PLATFORM_SESSION_EXPIRED",
    MAINTENANCE: "MAINTENANCE",
    ERROR: "ERROR"
}
  , XB = {
    NOT_ROUND: "not_round",
    ROUND_TO_NEAREST: "round_to_nearest",
    ROUND_DOWN: "round_down",
    ROUND_UP: "round_up"
}
  , BY = {
    pinco: "8y6frq",
    pinup: "9y2fqx"
}
  , YB = fv();
let U0;
const kY = ({locale: e=ZC, messages: t}) => (U0 = F0({
    locale: e,
    messages: t,
    onError: r => {
        r?.message.substring(0, 60) !== "[@formatjs/intl Error FORMAT_ERROR] Error formatting number." && logger.warn(r)
    }
}, YB),
U0)
  , _v = () => U0;
function KB(e, t, r) {
    var i = r || {}, n = i.noTrailing, s = n === void 0 ? !1 : n, o = i.noLeading, a = o === void 0 ? !1 : o, l = i.debounceMode, h = l === void 0 ? void 0 : l, u, c = !1, d = 0;
    function f() {
        u && clearTimeout(u)
    }
    function g(v) {
        var y = v || {}
          , m = y.upcomingOnly
          , _ = m === void 0 ? !1 : m;
        f(),
        c = !_
    }
    function p() {
        for (var v = arguments.length, y = new Array(v), m = 0; m < v; m++)
            y[m] = arguments[m];
        var _ = this
          , x = Date.now() - d;
        if (c)
            return;
        function E() {
            d = Date.now(),
            t.apply(_, y)
        }
        function S() {
            u = void 0
        }
        !a && h && !u && E(),
        f(),
        h === void 0 && x > e ? a ? (d = Date.now(),
        s || (u = setTimeout(h ? S : E, e))) : E() : s !== !0 && (u = setTimeout(h ? S : E, h === void 0 ? e - x : e))
    }
    return p.cancel = g,
    p
}
function qB(e, t, r) {
    var i = r || {}
      , n = i.atBegin
      , s = n === void 0 ? !1 : n;
    return KB(e, t, {
        debounceMode: s !== !1
    })
}
const _c = (e, {payload: t=null, isNewPayload: r=!1, ...i}={}) => {
    const {lang: n=ZC} = Mu();
    let s = {
        action: e,
        payload: t
    };
    r && (s = {
        ...i,
        type: e,
        sender: "aviatrix",
        lang: String(n)
    },
    t && (s = {
        ...s,
        data: t
    })),
    window.parent.postMessage(s, "*"),
    logger.info(s, {
        prefix: "[POST_MESSAGE] event"
    })
}
  , FY = () => {
    const {clientHeight: e} = document.documentElement;
    document.documentElement.style.setProperty("--vh", `${e / 100}px`)
}
  , rT = () => window.orientation || window.screen?.orientation?.angle
  , UY = () => {
    const {classList: e} = document.documentElement;
    try {
        rT() === 90 ? (e.add("landscape", "landscape-left"),
        e.remove("landscape-right")) : rT() === -90 ? (e.add("landscape", "landscape-right"),
        e.remove("landscape-left")) : e.remove("landscape", "landscape-right", "landscape-left")
    } catch (t) {
        logger.warn(t)
    }
}
  , GY = e => {
    const [t] = document.styleSheets
      , r = Object.entries(e).map( ([i,n]) => `${i}:${n}px`).join(";");
    t?.insertRule(`:root {${r}}`)
}
  , ZB = () => {
    const {lobbyUrl: e} = Md.parse(window.location.search);
    return e
}
  , QB = () => {
    const {consumerId: e="", cid: t=""} = yv(window.location.search);
    return String(GB[e] || t)
}
  , yv = e => Md.parse(Md.pick(e, VB), {
    parseBooleans: !0
})
  , JB = () => window.self !== window.top && !!window.parent
  , tk = () => window.top !== window.self
  , HY = e => {
    const t = ZB() || "";
    _c("game.exit"),
    _c(BB.QUIT, {
        isNewPayload: !0
    }),
    e?.(),
    tk() || JB() ? window.top && t && (_c("game.location", {
        payload: t
    }),
    window.top.location.href = t) : t && (_c("game.location", {
        payload: t
    }),
    window.location.href = t)
}
  , $Y = () => {
    const e = window.location.href.split("?")[0]
      , t = {
        ...yv(window.location.search),
        isDemo: !0,
        sessionToken: ""
    };
    window.location.href = `${e}?${Md.stringify(t)}`
}
;
let zh = {};
const ek = async () => {
    const e = yv(window.location.search)
      , t = QB()
      , r = window.location.host.split(".")?.[0] === "demo"
      , i = e.isDemo || r;
    rk({
        ...e,
        isDemo: i,
        cid: t
    })
}
  , Mu = () => (Object.values(zh).length || ek(),
zh)
  , rk = e => {
    zh = {
        ...e
    }
}
  , zY = e => {
    zh = {
        ...zh,
        ...e
    }
}
;
var ik = typeof global == "object" && global && global.Object === Object && global;
const JC = ik;
var nk = typeof self == "object" && self && self.Object === Object && self
  , sk = JC || nk || Function("return this")();
const fn = sk;
var ok = fn.Symbol;
const ai = ok;
var tP = Object.prototype
  , ak = tP.hasOwnProperty
  , lk = tP.toString
  , Pl = ai ? ai.toStringTag : void 0;
function hk(e) {
    var t = ak.call(e, Pl)
      , r = e[Pl];
    try {
        e[Pl] = void 0;
        var i = !0
    } catch {}
    var n = lk.call(e);
    return i && (t ? e[Pl] = r : delete e[Pl]),
    n
}
var uk = Object.prototype
  , ck = uk.toString;
function dk(e) {
    return ck.call(e)
}
var fk = "[object Null]"
  , pk = "[object Undefined]"
  , iT = ai ? ai.toStringTag : void 0;
function ks(e) {
    return e == null ? e === void 0 ? pk : fk : iT && iT in Object(e) ? hk(e) : dk(e)
}
function li(e) {
    return e != null && typeof e == "object"
}
var mk = "[object Symbol]";
function yp(e) {
    return typeof e == "symbol" || li(e) && ks(e) == mk
}
function Ou(e, t) {
    for (var r = -1, i = e == null ? 0 : e.length, n = Array(i); ++r < i; )
        n[r] = t(e[r], r, e);
    return n
}
var gk = Array.isArray;
const be = gk;
var _k = 1 / 0
  , nT = ai ? ai.prototype : void 0
  , sT = nT ? nT.toString : void 0;
function eP(e) {
    if (typeof e == "string")
        return e;
    if (be(e))
        return Ou(e, eP) + "";
    if (yp(e))
        return sT ? sT.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -_k ? "-0" : t
}
var yk = /\s/;
function vk(e) {
    for (var t = e.length; t-- && yk.test(e.charAt(t)); )
        ;
    return t
}
var xk = /^\s+/;
function Ek(e) {
    return e && e.slice(0, vk(e) + 1).replace(xk, "")
}
function Fn(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function")
}
var oT = 0 / 0
  , Tk = /^[-+]0x[0-9a-f]+$/i
  , Sk = /^0b[01]+$/i
  , wk = /^0o[0-7]+$/i
  , Ak = parseInt;
function bk(e) {
    if (typeof e == "number")
        return e;
    if (yp(e))
        return oT;
    if (Fn(e)) {
        var t = typeof e.valueOf == "function" ? e.valueOf() : e;
        e = Fn(t) ? t + "" : t
    }
    if (typeof e != "string")
        return e === 0 ? e : +e;
    e = Ek(e);
    var r = Sk.test(e);
    return r || wk.test(e) ? Ak(e.slice(2), r ? 2 : 8) : Tk.test(e) ? oT : +e
}
var aT = 1 / 0
  , Ck = 17976931348623157e292;
function Pk(e) {
    if (!e)
        return e === 0 ? e : 0;
    if (e = bk(e),
    e === aT || e === -aT) {
        var t = e < 0 ? -1 : 1;
        return t * Ck
    }
    return e === e ? e : 0
}
function rP(e) {
    var t = Pk(e)
      , r = t % 1;
    return t === t ? r ? t - r : t : 0
}
function vv(e) {
    return e
}
var Ik = "[object AsyncFunction]"
  , Rk = "[object Function]"
  , Mk = "[object GeneratorFunction]"
  , Ok = "[object Proxy]";
function iP(e) {
    if (!Fn(e))
        return !1;
    var t = ks(e);
    return t == Rk || t == Mk || t == Ik || t == Ok
}
var Nk = fn["__core-js_shared__"];
const Pm = Nk;
var lT = function() {
    var e = /[^.]+$/.exec(Pm && Pm.keys && Pm.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : ""
}();
function Lk(e) {
    return !!lT && lT in e
}
var Dk = Function.prototype
  , Bk = Dk.toString;
function Uo(e) {
    if (e != null) {
        try {
            return Bk.call(e)
        } catch {}
        try {
            return e + ""
        } catch {}
    }
    return ""
}
var kk = /[\\^$.*+?()[\]{}|]/g
  , Fk = /^\[object .+?Constructor\]$/
  , Uk = Function.prototype
  , Gk = Object.prototype
  , Hk = Uk.toString
  , $k = Gk.hasOwnProperty
  , zk = RegExp("^" + Hk.call($k).replace(kk, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function Wk(e) {
    if (!Fn(e) || Lk(e))
        return !1;
    var t = iP(e) ? zk : Fk;
    return t.test(Uo(e))
}
function Vk(e, t) {
    return e?.[t]
}
function Go(e, t) {
    var r = Vk(e, t);
    return Wk(r) ? r : void 0
}
var jk = Go(fn, "WeakMap");
const Wh = jk;
var Xk = Wh && new Wh;
const hT = Xk;
var uT = Object.create
  , Yk = function() {
    function e() {}
    return function(t) {
        if (!Fn(t))
            return {};
        if (uT)
            return uT(t);
        e.prototype = t;
        var r = new e;
        return e.prototype = void 0,
        r
    }
}();
const xv = Yk;
function Kk(e, t, r) {
    switch (r.length) {
    case 0:
        return e.call(t);
    case 1:
        return e.call(t, r[0]);
    case 2:
        return e.call(t, r[0], r[1]);
    case 3:
        return e.call(t, r[0], r[1], r[2])
    }
    return e.apply(t, r)
}
function Ev() {}
var qk = 4294967295;
function Ya(e) {
    this.__wrapped__ = e,
    this.__actions__ = [],
    this.__dir__ = 1,
    this.__filtered__ = !1,
    this.__iteratees__ = [],
    this.__takeCount__ = qk,
    this.__views__ = []
}
Ya.prototype = xv(Ev.prototype);
Ya.prototype.constructor = Ya;
function nP() {}
var Zk = hT ? function(e) {
    return hT.get(e)
}
: nP;
const sP = Zk;
var Qk = {};
const cT = Qk;
var Jk = Object.prototype
  , tF = Jk.hasOwnProperty;
function dd(e) {
    for (var t = e.name + "", r = cT[t], i = tF.call(cT, t) ? r.length : 0; i--; ) {
        var n = r[i]
          , s = n.func;
        if (s == null || s == e)
            return n.name
    }
    return t
}
function Ps(e, t) {
    this.__wrapped__ = e,
    this.__actions__ = [],
    this.__chain__ = !!t,
    this.__index__ = 0,
    this.__values__ = void 0
}
Ps.prototype = xv(Ev.prototype);
Ps.prototype.constructor = Ps;
function Tv(e, t) {
    var r = -1
      , i = e.length;
    for (t || (t = Array(i)); ++r < i; )
        t[r] = e[r];
    return t
}
function eF(e) {
    if (e instanceof Ya)
        return e.clone();
    var t = new Ps(e.__wrapped__,e.__chain__);
    return t.__actions__ = Tv(e.__actions__),
    t.__index__ = e.__index__,
    t.__values__ = e.__values__,
    t
}
var rF = Object.prototype
  , iF = rF.hasOwnProperty;
function nf(e) {
    if (li(e) && !be(e) && !(e instanceof Ya)) {
        if (e instanceof Ps)
            return e;
        if (iF.call(e, "__wrapped__"))
            return eF(e)
    }
    return new Ps(e)
}
nf.prototype = Ev.prototype;
nf.prototype.constructor = nf;
function dT(e) {
    var t = dd(e)
      , r = nf[t];
    if (typeof r != "function" || !(t in Ya.prototype))
        return !1;
    if (e === r)
        return !0;
    var i = sP(r);
    return !!i && e === i[0]
}
var nF = 800
  , sF = 16
  , oF = Date.now;
function aF(e) {
    var t = 0
      , r = 0;
    return function() {
        var i = oF()
          , n = sF - (i - r);
        if (r = i,
        n > 0) {
            if (++t >= nF)
                return arguments[0]
        } else
            t = 0;
        return e.apply(void 0, arguments)
    }
}
function lF(e) {
    return function() {
        return e
    }
}
var hF = function() {
    try {
        var e = Go(Object, "defineProperty");
        return e({}, "", {}),
        e
    } catch {}
}();
const sf = hF;
var uF = sf ? function(e, t) {
    return sf(e, "toString", {
        configurable: !0,
        enumerable: !1,
        value: lF(t),
        writable: !0
    })
}
: vv;
const cF = uF;
var dF = aF(cF);
const oP = dF;
function fF(e, t) {
    for (var r = -1, i = e == null ? 0 : e.length; ++r < i && t(e[r], r, e) !== !1; )
        ;
    return e
}
function pF(e, t, r, i) {
    for (var n = e.length, s = r + (i ? 1 : -1); i ? s-- : ++s < n; )
        if (t(e[s], s, e))
            return s;
    return -1
}
function mF(e) {
    return e !== e
}
function gF(e, t, r) {
    for (var i = r - 1, n = e.length; ++i < n; )
        if (e[i] === t)
            return i;
    return -1
}
function aP(e, t, r) {
    return t === t ? gF(e, t, r) : pF(e, mF, r)
}
function lP(e, t) {
    var r = e == null ? 0 : e.length;
    return !!r && aP(e, t, 0) > -1
}
var _F = 9007199254740991
  , yF = /^(?:0|[1-9]\d*)$/;
function hP(e, t) {
    var r = typeof e;
    return t = t ?? _F,
    !!t && (r == "number" || r != "symbol" && yF.test(e)) && e > -1 && e % 1 == 0 && e < t
}
function Sv(e, t, r) {
    t == "__proto__" && sf ? sf(e, t, {
        configurable: !0,
        enumerable: !0,
        value: r,
        writable: !0
    }) : e[t] = r
}
function wv(e, t) {
    return e === t || e !== e && t !== t
}
var vF = Object.prototype
  , xF = vF.hasOwnProperty;
function uP(e, t, r) {
    var i = e[t];
    (!(xF.call(e, t) && wv(i, r)) || r === void 0 && !(t in e)) && Sv(e, t, r)
}
function Nu(e, t, r, i) {
    var n = !r;
    r || (r = {});
    for (var s = -1, o = t.length; ++s < o; ) {
        var a = t[s]
          , l = i ? i(r[a], e[a], a, r, e) : void 0;
        l === void 0 && (l = e[a]),
        n ? Sv(r, a, l) : uP(r, a, l)
    }
    return r
}
var fT = Math.max;
function cP(e, t, r) {
    return t = fT(t === void 0 ? e.length - 1 : t, 0),
    function() {
        for (var i = arguments, n = -1, s = fT(i.length - t, 0), o = Array(s); ++n < s; )
            o[n] = i[t + n];
        n = -1;
        for (var a = Array(t + 1); ++n < t; )
            a[n] = i[n];
        return a[t] = r(o),
        Kk(e, this, a)
    }
}
function EF(e, t) {
    return oP(cP(e, t, vv), e + "")
}
var TF = 9007199254740991;
function Av(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= TF
}
function fl(e) {
    return e != null && Av(e.length) && !iP(e)
}
var SF = Object.prototype;
function bv(e) {
    var t = e && e.constructor
      , r = typeof t == "function" && t.prototype || SF;
    return e === r
}
function wF(e, t) {
    for (var r = -1, i = Array(e); ++r < e; )
        i[r] = t(r);
    return i
}
var AF = "[object Arguments]";
function pT(e) {
    return li(e) && ks(e) == AF
}
var dP = Object.prototype
  , bF = dP.hasOwnProperty
  , CF = dP.propertyIsEnumerable
  , PF = pT(function() {
    return arguments
}()) ? pT : function(e) {
    return li(e) && bF.call(e, "callee") && !CF.call(e, "callee")
}
;
const Cv = PF;
function IF() {
    return !1
}
var fP = typeof exports == "object" && exports && !exports.nodeType && exports
  , mT = fP && typeof module == "object" && module && !module.nodeType && module
  , RF = mT && mT.exports === fP
  , gT = RF ? fn.Buffer : void 0
  , MF = gT ? gT.isBuffer : void 0
  , OF = MF || IF;
const of = OF;
var NF = "[object Arguments]"
  , LF = "[object Array]"
  , DF = "[object Boolean]"
  , BF = "[object Date]"
  , kF = "[object Error]"
  , FF = "[object Function]"
  , UF = "[object Map]"
  , GF = "[object Number]"
  , HF = "[object Object]"
  , $F = "[object RegExp]"
  , zF = "[object Set]"
  , WF = "[object String]"
  , VF = "[object WeakMap]"
  , jF = "[object ArrayBuffer]"
  , XF = "[object DataView]"
  , YF = "[object Float32Array]"
  , KF = "[object Float64Array]"
  , qF = "[object Int8Array]"
  , ZF = "[object Int16Array]"
  , QF = "[object Int32Array]"
  , JF = "[object Uint8Array]"
  , t3 = "[object Uint8ClampedArray]"
  , e3 = "[object Uint16Array]"
  , r3 = "[object Uint32Array]"
  , Lt = {};
Lt[YF] = Lt[KF] = Lt[qF] = Lt[ZF] = Lt[QF] = Lt[JF] = Lt[t3] = Lt[e3] = Lt[r3] = !0;
Lt[NF] = Lt[LF] = Lt[jF] = Lt[DF] = Lt[XF] = Lt[BF] = Lt[kF] = Lt[FF] = Lt[UF] = Lt[GF] = Lt[HF] = Lt[$F] = Lt[zF] = Lt[WF] = Lt[VF] = !1;
function i3(e) {
    return li(e) && Av(e.length) && !!Lt[ks(e)]
}
function vp(e) {
    return function(t) {
        return e(t)
    }
}
var pP = typeof exports == "object" && exports && !exports.nodeType && exports
  , dh = pP && typeof module == "object" && module && !module.nodeType && module
  , n3 = dh && dh.exports === pP
  , Im = n3 && JC.process
  , s3 = function() {
    try {
        var e = dh && dh.require && dh.require("util").types;
        return e || Im && Im.binding && Im.binding("util")
    } catch {}
}();
const Ka = s3;
var _T = Ka && Ka.isTypedArray
  , o3 = _T ? vp(_T) : i3;
const mP = o3;
var a3 = Object.prototype
  , l3 = a3.hasOwnProperty;
function gP(e, t) {
    var r = be(e)
      , i = !r && Cv(e)
      , n = !r && !i && of(e)
      , s = !r && !i && !n && mP(e)
      , o = r || i || n || s
      , a = o ? wF(e.length, String) : []
      , l = a.length;
    for (var h in e)
        (t || l3.call(e, h)) && !(o && (h == "length" || n && (h == "offset" || h == "parent") || s && (h == "buffer" || h == "byteLength" || h == "byteOffset") || hP(h, l))) && a.push(h);
    return a
}
function _P(e, t) {
    return function(r) {
        return e(t(r))
    }
}
var h3 = _P(Object.keys, Object);
const u3 = h3;
var c3 = Object.prototype
  , d3 = c3.hasOwnProperty;
function f3(e) {
    if (!bv(e))
        return u3(e);
    var t = [];
    for (var r in Object(e))
        d3.call(e, r) && r != "constructor" && t.push(r);
    return t
}
function pl(e) {
    return fl(e) ? gP(e) : f3(e)
}
function p3(e) {
    var t = [];
    if (e != null)
        for (var r in Object(e))
            t.push(r);
    return t
}
var m3 = Object.prototype
  , g3 = m3.hasOwnProperty;
function _3(e) {
    if (!Fn(e))
        return p3(e);
    var t = bv(e)
      , r = [];
    for (var i in e)
        i == "constructor" && (t || !g3.call(e, i)) || r.push(i);
    return r
}
function Pv(e) {
    return fl(e) ? gP(e, !0) : _3(e)
}
var y3 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
  , v3 = /^\w*$/;
function Iv(e, t) {
    if (be(e))
        return !1;
    var r = typeof e;
    return r == "number" || r == "symbol" || r == "boolean" || e == null || yp(e) ? !0 : v3.test(e) || !y3.test(e) || t != null && e in Object(t)
}
var x3 = Go(Object, "create");
const Vh = x3;
function E3() {
    this.__data__ = Vh ? Vh(null) : {},
    this.size = 0
}
function T3(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0,
    t
}
var S3 = "__lodash_hash_undefined__"
  , w3 = Object.prototype
  , A3 = w3.hasOwnProperty;
function b3(e) {
    var t = this.__data__;
    if (Vh) {
        var r = t[e];
        return r === S3 ? void 0 : r
    }
    return A3.call(t, e) ? t[e] : void 0
}
var C3 = Object.prototype
  , P3 = C3.hasOwnProperty;
function I3(e) {
    var t = this.__data__;
    return Vh ? t[e] !== void 0 : P3.call(t, e)
}
var R3 = "__lodash_hash_undefined__";
function M3(e, t) {
    var r = this.__data__;
    return this.size += this.has(e) ? 0 : 1,
    r[e] = Vh && t === void 0 ? R3 : t,
    this
}
function Io(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
        var i = e[t];
        this.set(i[0], i[1])
    }
}
Io.prototype.clear = E3;
Io.prototype.delete = T3;
Io.prototype.get = b3;
Io.prototype.has = I3;
Io.prototype.set = M3;
function O3() {
    this.__data__ = [],
    this.size = 0
}
function xp(e, t) {
    for (var r = e.length; r--; )
        if (wv(e[r][0], t))
            return r;
    return -1
}
var N3 = Array.prototype
  , L3 = N3.splice;
function D3(e) {
    var t = this.__data__
      , r = xp(t, e);
    if (r < 0)
        return !1;
    var i = t.length - 1;
    return r == i ? t.pop() : L3.call(t, r, 1),
    --this.size,
    !0
}
function B3(e) {
    var t = this.__data__
      , r = xp(t, e);
    return r < 0 ? void 0 : t[r][1]
}
function k3(e) {
    return xp(this.__data__, e) > -1
}
function F3(e, t) {
    var r = this.__data__
      , i = xp(r, e);
    return i < 0 ? (++this.size,
    r.push([e, t])) : r[i][1] = t,
    this
}
function Vn(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
        var i = e[t];
        this.set(i[0], i[1])
    }
}
Vn.prototype.clear = O3;
Vn.prototype.delete = D3;
Vn.prototype.get = B3;
Vn.prototype.has = k3;
Vn.prototype.set = F3;
var U3 = Go(fn, "Map");
const jh = U3;
function G3() {
    this.size = 0,
    this.__data__ = {
        hash: new Io,
        map: new (jh || Vn),
        string: new Io
    }
}
function H3(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null
}
function Ep(e, t) {
    var r = e.__data__;
    return H3(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map
}
function $3(e) {
    var t = Ep(this, e).delete(e);
    return this.size -= t ? 1 : 0,
    t
}
function z3(e) {
    return Ep(this, e).get(e)
}
function W3(e) {
    return Ep(this, e).has(e)
}
function V3(e, t) {
    var r = Ep(this, e)
      , i = r.size;
    return r.set(e, t),
    this.size += r.size == i ? 0 : 1,
    this
}
function jn(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
        var i = e[t];
        this.set(i[0], i[1])
    }
}
jn.prototype.clear = G3;
jn.prototype.delete = $3;
jn.prototype.get = z3;
jn.prototype.has = W3;
jn.prototype.set = V3;
var j3 = "Expected a function";
function Rv(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
        throw new TypeError(j3);
    var r = function() {
        var i = arguments
          , n = t ? t.apply(this, i) : i[0]
          , s = r.cache;
        if (s.has(n))
            return s.get(n);
        var o = e.apply(this, i);
        return r.cache = s.set(n, o) || s,
        o
    };
    return r.cache = new (Rv.Cache || jn),
    r
}
Rv.Cache = jn;
var X3 = 500;
function Y3(e) {
    var t = Rv(e, function(i) {
        return r.size === X3 && r.clear(),
        i
    })
      , r = t.cache;
    return t
}
var K3 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
  , q3 = /\\(\\)?/g
  , Z3 = Y3(function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""),
    e.replace(K3, function(r, i, n, s) {
        t.push(n ? s.replace(q3, "$1") : i || r)
    }),
    t
});
const Q3 = Z3;
function Mv(e) {
    return e == null ? "" : eP(e)
}
function Tp(e, t) {
    return be(e) ? e : Iv(e, t) ? [e] : Q3(Mv(e))
}
var J3 = 1 / 0;
function Lu(e) {
    if (typeof e == "string" || yp(e))
        return e;
    var t = e + "";
    return t == "0" && 1 / e == -J3 ? "-0" : t
}
function Ov(e, t) {
    t = Tp(t, e);
    for (var r = 0, i = t.length; e != null && r < i; )
        e = e[Lu(t[r++])];
    return r && r == i ? e : void 0
}
function tU(e, t, r) {
    var i = e == null ? void 0 : Ov(e, t);
    return i === void 0 ? r : i
}
function Nv(e, t) {
    for (var r = -1, i = t.length, n = e.length; ++r < i; )
        e[n + r] = t[r];
    return e
}
var yT = ai ? ai.isConcatSpreadable : void 0;
function eU(e) {
    return be(e) || Cv(e) || !!(yT && e && e[yT])
}
function Lv(e, t, r, i, n) {
    var s = -1
      , o = e.length;
    for (r || (r = eU),
    n || (n = []); ++s < o; ) {
        var a = e[s];
        t > 0 && r(a) ? t > 1 ? Lv(a, t - 1, r, i, n) : Nv(n, a) : i || (n[n.length] = a)
    }
    return n
}
function rU(e) {
    var t = e == null ? 0 : e.length;
    return t ? Lv(e, 1) : []
}
function yP(e) {
    return oP(cP(e, void 0, rU), e + "")
}
var iU = _P(Object.getPrototypeOf, Object);
const Dv = iU;
var nU = "[object Object]"
  , sU = Function.prototype
  , oU = Object.prototype
  , vP = sU.toString
  , aU = oU.hasOwnProperty
  , lU = vP.call(Object);
function hU(e) {
    if (!li(e) || ks(e) != nU)
        return !1;
    var t = Dv(e);
    if (t === null)
        return !0;
    var r = aU.call(t, "constructor") && t.constructor;
    return typeof r == "function" && r instanceof r && vP.call(r) == lU
}
function Bv(e, t, r) {
    var i = -1
      , n = e.length;
    t < 0 && (t = -t > n ? 0 : n + t),
    r = r > n ? n : r,
    r < 0 && (r += n),
    n = t > r ? 0 : r - t >>> 0,
    t >>>= 0;
    for (var s = Array(n); ++i < n; )
        s[i] = e[i + t];
    return s
}
function uU(e, t, r) {
    var i = e.length;
    return r = r === void 0 ? i : r,
    !t && r >= i ? e : Bv(e, t, r)
}
var cU = "\\ud800-\\udfff"
  , dU = "\\u0300-\\u036f"
  , fU = "\\ufe20-\\ufe2f"
  , pU = "\\u20d0-\\u20ff"
  , mU = dU + fU + pU
  , gU = "\\ufe0e\\ufe0f"
  , _U = "\\u200d"
  , yU = RegExp("[" + _U + cU + mU + gU + "]");
function xP(e) {
    return yU.test(e)
}
function vU(e) {
    return e.split("")
}
var EP = "\\ud800-\\udfff"
  , xU = "\\u0300-\\u036f"
  , EU = "\\ufe20-\\ufe2f"
  , TU = "\\u20d0-\\u20ff"
  , SU = xU + EU + TU
  , wU = "\\ufe0e\\ufe0f"
  , AU = "[" + EP + "]"
  , G0 = "[" + SU + "]"
  , H0 = "\\ud83c[\\udffb-\\udfff]"
  , bU = "(?:" + G0 + "|" + H0 + ")"
  , TP = "[^" + EP + "]"
  , SP = "(?:\\ud83c[\\udde6-\\uddff]){2}"
  , wP = "[\\ud800-\\udbff][\\udc00-\\udfff]"
  , CU = "\\u200d"
  , AP = bU + "?"
  , bP = "[" + wU + "]?"
  , PU = "(?:" + CU + "(?:" + [TP, SP, wP].join("|") + ")" + bP + AP + ")*"
  , IU = bP + AP + PU
  , RU = "(?:" + [TP + G0 + "?", G0, SP, wP, AU].join("|") + ")"
  , MU = RegExp(H0 + "(?=" + H0 + ")|" + RU + IU, "g");
function OU(e) {
    return e.match(MU) || []
}
function NU(e) {
    return xP(e) ? OU(e) : vU(e)
}
function LU(e) {
    return function(t) {
        t = Mv(t);
        var r = xP(t) ? NU(t) : void 0
          , i = r ? r[0] : t.charAt(0)
          , n = r ? uU(r, 1).join("") : t.slice(1);
        return i[e]() + n
    }
}
var DU = LU("toUpperCase");
const BU = DU;
function kU(e) {
    return BU(Mv(e).toLowerCase())
}
function FU() {
    this.__data__ = new Vn,
    this.size = 0
}
function UU(e) {
    var t = this.__data__
      , r = t.delete(e);
    return this.size = t.size,
    r
}
function GU(e) {
    return this.__data__.get(e)
}
function HU(e) {
    return this.__data__.has(e)
}
var $U = 200;
function zU(e, t) {
    var r = this.__data__;
    if (r instanceof Vn) {
        var i = r.__data__;
        if (!jh || i.length < $U - 1)
            return i.push([e, t]),
            this.size = ++r.size,
            this;
        r = this.__data__ = new jn(i)
    }
    return r.set(e, t),
    this.size = r.size,
    this
}
function on(e) {
    var t = this.__data__ = new Vn(e);
    this.size = t.size
}
on.prototype.clear = FU;
on.prototype.delete = UU;
on.prototype.get = GU;
on.prototype.has = HU;
on.prototype.set = zU;
function WU(e, t) {
    return e && Nu(t, pl(t), e)
}
function VU(e, t) {
    return e && Nu(t, Pv(t), e)
}
var CP = typeof exports == "object" && exports && !exports.nodeType && exports
  , vT = CP && typeof module == "object" && module && !module.nodeType && module
  , jU = vT && vT.exports === CP
  , xT = jU ? fn.Buffer : void 0
  , ET = xT ? xT.allocUnsafe : void 0;
function XU(e, t) {
    if (t)
        return e.slice();
    var r = e.length
      , i = ET ? ET(r) : new e.constructor(r);
    return e.copy(i),
    i
}
function PP(e, t) {
    for (var r = -1, i = e == null ? 0 : e.length, n = 0, s = []; ++r < i; ) {
        var o = e[r];
        t(o, r, e) && (s[n++] = o)
    }
    return s
}
function IP() {
    return []
}
var YU = Object.prototype
  , KU = YU.propertyIsEnumerable
  , TT = Object.getOwnPropertySymbols
  , qU = TT ? function(e) {
    return e == null ? [] : (e = Object(e),
    PP(TT(e), function(t) {
        return KU.call(e, t)
    }))
}
: IP;
const kv = qU;
function ZU(e, t) {
    return Nu(e, kv(e), t)
}
var QU = Object.getOwnPropertySymbols
  , JU = QU ? function(e) {
    for (var t = []; e; )
        Nv(t, kv(e)),
        e = Dv(e);
    return t
}
: IP;
const RP = JU;
function t4(e, t) {
    return Nu(e, RP(e), t)
}
function MP(e, t, r) {
    var i = t(e);
    return be(e) ? i : Nv(i, r(e))
}
function $0(e) {
    return MP(e, pl, kv)
}
function OP(e) {
    return MP(e, Pv, RP)
}
var e4 = Go(fn, "DataView");
const z0 = e4;
var r4 = Go(fn, "Promise");
const W0 = r4;
var i4 = Go(fn, "Set");
const Ra = i4;
var ST = "[object Map]"
  , n4 = "[object Object]"
  , wT = "[object Promise]"
  , AT = "[object Set]"
  , bT = "[object WeakMap]"
  , CT = "[object DataView]"
  , s4 = Uo(z0)
  , o4 = Uo(jh)
  , a4 = Uo(W0)
  , l4 = Uo(Ra)
  , h4 = Uo(Wh)
  , Zs = ks;
(z0 && Zs(new z0(new ArrayBuffer(1))) != CT || jh && Zs(new jh) != ST || W0 && Zs(W0.resolve()) != wT || Ra && Zs(new Ra) != AT || Wh && Zs(new Wh) != bT) && (Zs = function(e) {
    var t = ks(e)
      , r = t == n4 ? e.constructor : void 0
      , i = r ? Uo(r) : "";
    if (i)
        switch (i) {
        case s4:
            return CT;
        case o4:
            return ST;
        case a4:
            return wT;
        case l4:
            return AT;
        case h4:
            return bT
        }
    return t
}
);
const Xh = Zs;
var u4 = Object.prototype
  , c4 = u4.hasOwnProperty;
function d4(e) {
    var t = e.length
      , r = new e.constructor(t);
    return t && typeof e[0] == "string" && c4.call(e, "index") && (r.index = e.index,
    r.input = e.input),
    r
}
var f4 = fn.Uint8Array;
const af = f4;
function Fv(e) {
    var t = new e.constructor(e.byteLength);
    return new af(t).set(new af(e)),
    t
}
function p4(e, t) {
    var r = t ? Fv(e.buffer) : e.buffer;
    return new e.constructor(r,e.byteOffset,e.byteLength)
}
var m4 = /\w*$/;
function g4(e) {
    var t = new e.constructor(e.source,m4.exec(e));
    return t.lastIndex = e.lastIndex,
    t
}
var PT = ai ? ai.prototype : void 0
  , IT = PT ? PT.valueOf : void 0;
function _4(e) {
    return IT ? Object(IT.call(e)) : {}
}
function y4(e, t) {
    var r = t ? Fv(e.buffer) : e.buffer;
    return new e.constructor(r,e.byteOffset,e.length)
}
var v4 = "[object Boolean]"
  , x4 = "[object Date]"
  , E4 = "[object Map]"
  , T4 = "[object Number]"
  , S4 = "[object RegExp]"
  , w4 = "[object Set]"
  , A4 = "[object String]"
  , b4 = "[object Symbol]"
  , C4 = "[object ArrayBuffer]"
  , P4 = "[object DataView]"
  , I4 = "[object Float32Array]"
  , R4 = "[object Float64Array]"
  , M4 = "[object Int8Array]"
  , O4 = "[object Int16Array]"
  , N4 = "[object Int32Array]"
  , L4 = "[object Uint8Array]"
  , D4 = "[object Uint8ClampedArray]"
  , B4 = "[object Uint16Array]"
  , k4 = "[object Uint32Array]";
function F4(e, t, r) {
    var i = e.constructor;
    switch (t) {
    case C4:
        return Fv(e);
    case v4:
    case x4:
        return new i(+e);
    case P4:
        return p4(e, r);
    case I4:
    case R4:
    case M4:
    case O4:
    case N4:
    case L4:
    case D4:
    case B4:
    case k4:
        return y4(e, r);
    case E4:
        return new i;
    case T4:
    case A4:
        return new i(e);
    case S4:
        return g4(e);
    case w4:
        return new i;
    case b4:
        return _4(e)
    }
}
function U4(e) {
    return typeof e.constructor == "function" && !bv(e) ? xv(Dv(e)) : {}
}
var G4 = "[object Map]";
function H4(e) {
    return li(e) && Xh(e) == G4
}
var RT = Ka && Ka.isMap
  , $4 = RT ? vp(RT) : H4;
const z4 = $4;
var W4 = "[object Set]";
function V4(e) {
    return li(e) && Xh(e) == W4
}
var MT = Ka && Ka.isSet
  , j4 = MT ? vp(MT) : V4;
const X4 = j4;
var Y4 = 1
  , K4 = 2
  , q4 = 4
  , NP = "[object Arguments]"
  , Z4 = "[object Array]"
  , Q4 = "[object Boolean]"
  , J4 = "[object Date]"
  , tG = "[object Error]"
  , LP = "[object Function]"
  , eG = "[object GeneratorFunction]"
  , rG = "[object Map]"
  , iG = "[object Number]"
  , DP = "[object Object]"
  , nG = "[object RegExp]"
  , sG = "[object Set]"
  , oG = "[object String]"
  , aG = "[object Symbol]"
  , lG = "[object WeakMap]"
  , hG = "[object ArrayBuffer]"
  , uG = "[object DataView]"
  , cG = "[object Float32Array]"
  , dG = "[object Float64Array]"
  , fG = "[object Int8Array]"
  , pG = "[object Int16Array]"
  , mG = "[object Int32Array]"
  , gG = "[object Uint8Array]"
  , _G = "[object Uint8ClampedArray]"
  , yG = "[object Uint16Array]"
  , vG = "[object Uint32Array]"
  , It = {};
It[NP] = It[Z4] = It[hG] = It[uG] = It[Q4] = It[J4] = It[cG] = It[dG] = It[fG] = It[pG] = It[mG] = It[rG] = It[iG] = It[DP] = It[nG] = It[sG] = It[oG] = It[aG] = It[gG] = It[_G] = It[yG] = It[vG] = !0;
It[tG] = It[LP] = It[lG] = !1;
function fd(e, t, r, i, n, s) {
    var o, a = t & Y4, l = t & K4, h = t & q4;
    if (r && (o = n ? r(e, i, n, s) : r(e)),
    o !== void 0)
        return o;
    if (!Fn(e))
        return e;
    var u = be(e);
    if (u) {
        if (o = d4(e),
        !a)
            return Tv(e, o)
    } else {
        var c = Xh(e)
          , d = c == LP || c == eG;
        if (of(e))
            return XU(e, a);
        if (c == DP || c == NP || d && !n) {
            if (o = l || d ? {} : U4(e),
            !a)
                return l ? t4(e, VU(o, e)) : ZU(e, WU(o, e))
        } else {
            if (!It[c])
                return n ? e : {};
            o = F4(e, c, a)
        }
    }
    s || (s = new on);
    var f = s.get(e);
    if (f)
        return f;
    s.set(e, o),
    X4(e) ? e.forEach(function(v) {
        o.add(fd(v, t, r, v, e, s))
    }) : z4(e) && e.forEach(function(v, y) {
        o.set(y, fd(v, t, r, y, e, s))
    });
    var g = h ? l ? OP : $0 : l ? Pv : pl
      , p = u ? void 0 : g(e);
    return fF(p || e, function(v, y) {
        p && (y = v,
        v = e[y]),
        uP(o, y, fd(v, t, r, y, e, s))
    }),
    o
}
var xG = "__lodash_hash_undefined__";
function EG(e) {
    return this.__data__.set(e, xG),
    this
}
function TG(e) {
    return this.__data__.has(e)
}
function qa(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.__data__ = new jn; ++t < r; )
        this.add(e[t])
}
qa.prototype.add = qa.prototype.push = EG;
qa.prototype.has = TG;
function SG(e, t) {
    for (var r = -1, i = e == null ? 0 : e.length; ++r < i; )
        if (t(e[r], r, e))
            return !0;
    return !1
}
function Uv(e, t) {
    return e.has(t)
}
var wG = 1
  , AG = 2;
function BP(e, t, r, i, n, s) {
    var o = r & wG
      , a = e.length
      , l = t.length;
    if (a != l && !(o && l > a))
        return !1;
    var h = s.get(e)
      , u = s.get(t);
    if (h && u)
        return h == t && u == e;
    var c = -1
      , d = !0
      , f = r & AG ? new qa : void 0;
    for (s.set(e, t),
    s.set(t, e); ++c < a; ) {
        var g = e[c]
          , p = t[c];
        if (i)
            var v = o ? i(p, g, c, t, e, s) : i(g, p, c, e, t, s);
        if (v !== void 0) {
            if (v)
                continue;
            d = !1;
            break
        }
        if (f) {
            if (!SG(t, function(y, m) {
                if (!Uv(f, m) && (g === y || n(g, y, r, i, s)))
                    return f.push(m)
            })) {
                d = !1;
                break
            }
        } else if (!(g === p || n(g, p, r, i, s))) {
            d = !1;
            break
        }
    }
    return s.delete(e),
    s.delete(t),
    d
}
function bG(e) {
    var t = -1
      , r = Array(e.size);
    return e.forEach(function(i, n) {
        r[++t] = [n, i]
    }),
    r
}
function Gv(e) {
    var t = -1
      , r = Array(e.size);
    return e.forEach(function(i) {
        r[++t] = i
    }),
    r
}
var CG = 1
  , PG = 2
  , IG = "[object Boolean]"
  , RG = "[object Date]"
  , MG = "[object Error]"
  , OG = "[object Map]"
  , NG = "[object Number]"
  , LG = "[object RegExp]"
  , DG = "[object Set]"
  , BG = "[object String]"
  , kG = "[object Symbol]"
  , FG = "[object ArrayBuffer]"
  , UG = "[object DataView]"
  , OT = ai ? ai.prototype : void 0
  , Rm = OT ? OT.valueOf : void 0;
function GG(e, t, r, i, n, s, o) {
    switch (r) {
    case UG:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
            return !1;
        e = e.buffer,
        t = t.buffer;
    case FG:
        return !(e.byteLength != t.byteLength || !s(new af(e), new af(t)));
    case IG:
    case RG:
    case NG:
        return wv(+e, +t);
    case MG:
        return e.name == t.name && e.message == t.message;
    case LG:
    case BG:
        return e == t + "";
    case OG:
        var a = bG;
    case DG:
        var l = i & CG;
        if (a || (a = Gv),
        e.size != t.size && !l)
            return !1;
        var h = o.get(e);
        if (h)
            return h == t;
        i |= PG,
        o.set(e, t);
        var u = BP(a(e), a(t), i, n, s, o);
        return o.delete(e),
        u;
    case kG:
        if (Rm)
            return Rm.call(e) == Rm.call(t)
    }
    return !1
}
var HG = 1
  , $G = Object.prototype
  , zG = $G.hasOwnProperty;
function WG(e, t, r, i, n, s) {
    var o = r & HG
      , a = $0(e)
      , l = a.length
      , h = $0(t)
      , u = h.length;
    if (l != u && !o)
        return !1;
    for (var c = l; c--; ) {
        var d = a[c];
        if (!(o ? d in t : zG.call(t, d)))
            return !1
    }
    var f = s.get(e)
      , g = s.get(t);
    if (f && g)
        return f == t && g == e;
    var p = !0;
    s.set(e, t),
    s.set(t, e);
    for (var v = o; ++c < l; ) {
        d = a[c];
        var y = e[d]
          , m = t[d];
        if (i)
            var _ = o ? i(m, y, d, t, e, s) : i(y, m, d, e, t, s);
        if (!(_ === void 0 ? y === m || n(y, m, r, i, s) : _)) {
            p = !1;
            break
        }
        v || (v = d == "constructor")
    }
    if (p && !v) {
        var x = e.constructor
          , E = t.constructor;
        x != E && "constructor"in e && "constructor"in t && !(typeof x == "function" && x instanceof x && typeof E == "function" && E instanceof E) && (p = !1)
    }
    return s.delete(e),
    s.delete(t),
    p
}
var VG = 1
  , NT = "[object Arguments]"
  , LT = "[object Array]"
  , yc = "[object Object]"
  , jG = Object.prototype
  , DT = jG.hasOwnProperty;
function XG(e, t, r, i, n, s) {
    var o = be(e)
      , a = be(t)
      , l = o ? LT : Xh(e)
      , h = a ? LT : Xh(t);
    l = l == NT ? yc : l,
    h = h == NT ? yc : h;
    var u = l == yc
      , c = h == yc
      , d = l == h;
    if (d && of(e)) {
        if (!of(t))
            return !1;
        o = !0,
        u = !1
    }
    if (d && !u)
        return s || (s = new on),
        o || mP(e) ? BP(e, t, r, i, n, s) : GG(e, t, l, r, i, n, s);
    if (!(r & VG)) {
        var f = u && DT.call(e, "__wrapped__")
          , g = c && DT.call(t, "__wrapped__");
        if (f || g) {
            var p = f ? e.value() : e
              , v = g ? t.value() : t;
            return s || (s = new on),
            n(p, v, r, i, s)
        }
    }
    return d ? (s || (s = new on),
    WG(e, t, r, i, n, s)) : !1
}
function Sp(e, t, r, i, n) {
    return e === t ? !0 : e == null || t == null || !li(e) && !li(t) ? e !== e && t !== t : XG(e, t, r, i, Sp, n)
}
var YG = 1
  , KG = 2;
function qG(e, t, r, i) {
    var n = r.length
      , s = n
      , o = !i;
    if (e == null)
        return !s;
    for (e = Object(e); n--; ) {
        var a = r[n];
        if (o && a[2] ? a[1] !== e[a[0]] : !(a[0]in e))
            return !1
    }
    for (; ++n < s; ) {
        a = r[n];
        var l = a[0]
          , h = e[l]
          , u = a[1];
        if (o && a[2]) {
            if (h === void 0 && !(l in e))
                return !1
        } else {
            var c = new on;
            if (i)
                var d = i(h, u, l, e, t, c);
            if (!(d === void 0 ? Sp(u, h, YG | KG, i, c) : d))
                return !1
        }
    }
    return !0
}
function kP(e) {
    return e === e && !Fn(e)
}
function ZG(e) {
    for (var t = pl(e), r = t.length; r--; ) {
        var i = t[r]
          , n = e[i];
        t[r] = [i, n, kP(n)]
    }
    return t
}
function FP(e, t) {
    return function(r) {
        return r == null ? !1 : r[e] === t && (t !== void 0 || e in Object(r))
    }
}
function QG(e) {
    var t = ZG(e);
    return t.length == 1 && t[0][2] ? FP(t[0][0], t[0][1]) : function(r) {
        return r === e || qG(r, e, t)
    }
}
function JG(e, t) {
    return e != null && t in Object(e)
}
function t5(e, t, r) {
    t = Tp(t, e);
    for (var i = -1, n = t.length, s = !1; ++i < n; ) {
        var o = Lu(t[i]);
        if (!(s = e != null && r(e, o)))
            break;
        e = e[o]
    }
    return s || ++i != n ? s : (n = e == null ? 0 : e.length,
    !!n && Av(n) && hP(o, n) && (be(e) || Cv(e)))
}
function e5(e, t) {
    return e != null && t5(e, t, JG)
}
var r5 = 1
  , i5 = 2;
function n5(e, t) {
    return Iv(e) && kP(t) ? FP(Lu(e), t) : function(r) {
        var i = tU(r, e);
        return i === void 0 && i === t ? e5(r, e) : Sp(t, i, r5 | i5)
    }
}
function s5(e) {
    return function(t) {
        return t?.[e]
    }
}
function o5(e) {
    return function(t) {
        return Ov(t, e)
    }
}
function a5(e) {
    return Iv(e) ? s5(Lu(e)) : o5(e)
}
function wp(e) {
    return typeof e == "function" ? e : e == null ? vv : typeof e == "object" ? be(e) ? n5(e[0], e[1]) : QG(e) : a5(e)
}
function l5(e, t, r, i) {
    for (var n = -1, s = e == null ? 0 : e.length; ++n < s; ) {
        var o = e[n];
        t(i, o, r(o), e)
    }
    return i
}
function h5(e) {
    return function(t, r, i) {
        for (var n = -1, s = Object(t), o = i(t), a = o.length; a--; ) {
            var l = o[e ? a : ++n];
            if (r(s[l], l, s) === !1)
                break
        }
        return t
    }
}
var u5 = h5();
const c5 = u5;
function d5(e, t) {
    return e && c5(e, t, pl)
}
function f5(e, t) {
    return function(r, i) {
        if (r == null)
            return r;
        if (!fl(r))
            return e(r, i);
        for (var n = r.length, s = t ? n : -1, o = Object(r); (t ? s-- : ++s < n) && i(o[s], s, o) !== !1; )
            ;
        return r
    }
}
var p5 = f5(d5);
const Hv = p5;
function m5(e, t, r, i) {
    return Hv(e, function(n, s, o) {
        t(i, n, r(n), o)
    }),
    i
}
function g5(e, t) {
    return function(r, i) {
        var n = be(r) ? l5 : m5
          , s = t ? t() : {};
        return n(r, e, wp(i), s)
    }
}
function Mm(e) {
    return li(e) && fl(e)
}
function UP(e, t, r) {
    for (var i = -1, n = e == null ? 0 : e.length; ++i < n; )
        if (r(t, e[i]))
            return !0;
    return !1
}
var _5 = 200;
function y5(e, t, r, i) {
    var n = -1
      , s = lP
      , o = !0
      , a = e.length
      , l = []
      , h = t.length;
    if (!a)
        return l;
    r && (t = Ou(t, vp(r))),
    i ? (s = UP,
    o = !1) : t.length >= _5 && (s = Uv,
    o = !1,
    t = new qa(t));
    t: for (; ++n < a; ) {
        var u = e[n]
          , c = r == null ? u : r(u);
        if (u = i || u !== 0 ? u : 0,
        o && c === c) {
            for (var d = h; d--; )
                if (t[d] === c)
                    continue t;
            l.push(u)
        } else
            s(t, c, i) || l.push(u)
    }
    return l
}
function GP(e) {
    var t = e == null ? 0 : e.length;
    return t ? e[t - 1] : void 0
}
var v5 = EF(function(e, t) {
    var r = GP(t);
    return Mm(r) && (r = void 0),
    Mm(e) ? y5(e, Lv(t, 1, Mm, !0), wp(r)) : []
});
const WY = v5;
function x5(e, t) {
    var r = [];
    return Hv(e, function(i, n, s) {
        t(i, n, s) && r.push(i)
    }),
    r
}
function E5(e, t) {
    var r = -1
      , i = fl(e) ? Array(e.length) : [];
    return Hv(e, function(n, s, o) {
        i[++r] = t(n, s, o)
    }),
    i
}
function VY(e, t) {
    var r = be(e) ? Ou : E5;
    return r(e, wp(t))
}
var T5 = "Expected a function"
  , S5 = 8
  , w5 = 32
  , A5 = 128
  , b5 = 256;
function C5(e) {
    return yP(function(t) {
        var r = t.length
          , i = r
          , n = Ps.prototype.thru;
        for (e && t.reverse(); i--; ) {
            var s = t[i];
            if (typeof s != "function")
                throw new TypeError(T5);
            if (n && !o && dd(s) == "wrapper")
                var o = new Ps([],!0)
        }
        for (i = o ? i : r; ++i < r; ) {
            s = t[i];
            var a = dd(s)
              , l = a == "wrapper" ? sP(s) : void 0;
            l && dT(l[0]) && l[1] == (A5 | S5 | w5 | b5) && !l[4].length && l[9] == 1 ? o = o[dd(l[0])].apply(o, l[3]) : o = s.length == 1 && dT(s) ? o[a]() : o.thru(s)
        }
        return function() {
            var h = arguments
              , u = h[0];
            if (o && h.length == 1 && be(u))
                return o.plant(u).value();
            for (var c = 0, d = r ? t[c].apply(this, h) : u; ++c < r; )
                d = t[c].call(this, d);
            return d
        }
    })
}
var P5 = C5();
const I5 = P5;
var R5 = Object.prototype
  , M5 = R5.hasOwnProperty
  , O5 = g5(function(e, t, r) {
    M5.call(e, r) ? e[r].push(t) : Sv(e, r, [t])
});
const jY = O5;
var N5 = "[object String]";
function L5(e) {
    return typeof e == "string" || !be(e) && li(e) && ks(e) == N5
}
function D5(e, t) {
    return Ou(t, function(r) {
        return e[r]
    })
}
function HP(e) {
    return e == null ? [] : D5(e, pl(e))
}
var B5 = Math.max;
function XY(e, t, r, i) {
    e = fl(e) ? e : HP(e),
    r = r && !i ? rP(r) : 0;
    var n = e.length;
    return r < 0 && (r = B5(n + r, 0)),
    L5(e) ? r <= n && e.indexOf(t, r) > -1 : !!n && aP(e, t, r) > -1
}
function k5(e, t) {
    return t.length < 2 ? e : Ov(e, Bv(t, 0, -1))
}
function V0(e, t) {
    return Sp(e, t)
}
var F5 = "Expected a function";
function U5(e) {
    if (typeof e != "function")
        throw new TypeError(F5);
    return function() {
        var t = arguments;
        switch (t.length) {
        case 0:
            return !e.call(this);
        case 1:
            return !e.call(this, t[0]);
        case 2:
            return !e.call(this, t[0], t[1]);
        case 3:
            return !e.call(this, t[0], t[1], t[2])
        }
        return !e.apply(this, t)
    }
}
function G5(e, t) {
    return t = Tp(t, e),
    e = k5(e, t),
    e == null || delete e[Lu(GP(t))]
}
function H5(e) {
    return hU(e) ? void 0 : e
}
var $5 = 1
  , z5 = 2
  , W5 = 4
  , V5 = yP(function(e, t) {
    var r = {};
    if (e == null)
        return r;
    var i = !1;
    t = Ou(t, function(s) {
        return s = Tp(s, e),
        i || (i = s.length > 1),
        s
    }),
    Nu(e, OP(e), r),
    i && (r = fd(r, $5 | z5 | W5, H5));
    for (var n = t.length; n--; )
        G5(r, t[n]);
    return r
});
const YY = V5;
var j5 = Math.floor
  , X5 = Math.random;
function Y5(e, t) {
    return e + j5(X5() * (t - e + 1))
}
function KY(e, t) {
    var r = be(e) ? PP : x5;
    return r(e, U5(wp(t)))
}
function $P(e, t) {
    var r = -1
      , i = e.length
      , n = i - 1;
    for (t = t === void 0 ? i : t; ++r < t; ) {
        var s = Y5(r, n)
          , o = e[s];
        e[s] = e[r],
        e[r] = o
    }
    return e.length = t,
    e
}
function K5(e) {
    return $P(Tv(e))
}
function q5(e) {
    return $P(HP(e))
}
function Za(e) {
    var t = be(e) ? K5 : q5;
    return t(e)
}
function qY(e, t, r) {
    return e && e.length ? (t = r || t === void 0 ? 1 : rP(t),
    Bv(e, 0, t < 0 ? 0 : t)) : []
}
var Z5 = 1 / 0
  , Q5 = Ra && 1 / Gv(new Ra([, -0]))[1] == Z5 ? function(e) {
    return new Ra(e)
}
: nP;
const J5 = Q5;
var tH = 200;
function eH(e, t, r) {
    var i = -1
      , n = lP
      , s = e.length
      , o = !0
      , a = []
      , l = a;
    if (r)
        o = !1,
        n = UP;
    else if (s >= tH) {
        var h = t ? null : J5(e);
        if (h)
            return Gv(h);
        o = !1,
        n = Uv,
        l = new qa
    } else
        l = t ? [] : a;
    t: for (; ++i < s; ) {
        var u = e[i]
          , c = t ? t(u) : u;
        if (u = r || u !== 0 ? u : 0,
        o && c === c) {
            for (var d = l.length; d--; )
                if (l[d] === c)
                    continue t;
            t && l.push(c),
            a.push(u)
        } else
            n(l, c, r) || (l !== a && l.push(c),
            a.push(u))
    }
    return a
}
function ZY(e) {
    return e && e.length ? eH(e) : []
}
const rH = e => new Promise(t => setTimeout(t, e))
  , iH = e => e.replace(/_([a-zA-Z0-9])/g, t => t[1].toUpperCase())
  , QY = e => e.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`)
  , JY = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
  , BT = e => {
    if (Array.isArray(e))
        return e.map(t => BT(t));
    if (Fn(e)) {
        const t = {};
        return Object.entries(e).forEach( ([r,i]) => {
            t[iH(r)] = BT(i)
        }
        ),
        t
    }
    return e
}
  , kT = e => {
    let t;
    const r = new Set
      , i = (l, h) => {
        const u = typeof l == "function" ? l(t) : l;
        if (!Object.is(u, t)) {
            const c = t;
            t = h ?? typeof u != "object" ? u : Object.assign({}, t, u),
            r.forEach(d => d(t, c))
        }
    }
      , n = () => t
      , a = {
        setState: i,
        getState: n,
        subscribe: l => (r.add(l),
        () => r.delete(l)),
        destroy: () => {
            ({
                VITE_USER_NODE_ENV: "production",
                VITE_APP_VERSION: "v3.11.4",
                VITE_UUID_CHECKSUM: "U0hBMSh1dWlkLXBja2cuemlwKT0gYWM2NzA4ODE4YTI2OTY3MjNiZGYzMDgzMmQzMjgzYWI0OWRiOTlmZgo=",
                VITE_NODE_ENV: "production",
                VITE_PROJECT_ENV: "production",
                VITE_DEMO_MODE_URL: "https://demo.aviatrix.bet",
                VITE_DEMO_MODE_REDIRECT_ENABLED: "true",
                BASE_URL: "/",
                MODE: "production",
                DEV: !1,
                PROD: !0,
                SSR: !1
            } && "production") !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),
            r.clear()
        }
    };
    return t = e(i, n, a),
    a
}
  , Ap = e => e ? kT(e) : kT;
var zP = {
    exports: {}
}
  , WP = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bp = ae
  , nH = eD;
function sH(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var oH = typeof Object.is == "function" ? Object.is : sH
  , aH = nH.useSyncExternalStore
  , lH = bp.useRef
  , hH = bp.useEffect
  , uH = bp.useMemo
  , cH = bp.useDebugValue;
WP.useSyncExternalStoreWithSelector = function(e, t, r, i, n) {
    var s = lH(null);
    if (s.current === null) {
        var o = {
            hasValue: !1,
            value: null
        };
        s.current = o
    } else
        o = s.current;
    s = uH(function() {
        function l(f) {
            if (!h) {
                if (h = !0,
                u = f,
                f = i(f),
                n !== void 0 && o.hasValue) {
                    var g = o.value;
                    if (n(g, f))
                        return c = g
                }
                return c = f
            }
            if (g = c,
            oH(u, f))
                return g;
            var p = i(f);
            return n !== void 0 && n(g, p) ? g : (u = f,
            c = p)
        }
        var h = !1, u, c, d = r === void 0 ? null : r;
        return [function() {
            return l(t())
        }
        , d === null ? void 0 : function() {
            return l(d())
        }
        ]
    }, [t, r, i, n]);
    var a = aH(e, s[0], s[1]);
    return hH(function() {
        o.hasValue = !0,
        o.value = a
    }, [a]),
    cH(a),
    a
}
;
zP.exports = WP;
var dH = zP.exports;
const fH = hl(dH)
  , {useSyncExternalStoreWithSelector: pH} = fH;
function VP(e, t=e.getState, r) {
    const i = pH(e.subscribe, e.getState, e.getServerState || e.getState, t, r);
    return ae.useDebugValue(i),
    i
}
const FT = e => {
    ({
        VITE_USER_NODE_ENV: "production",
        VITE_APP_VERSION: "v3.11.4",
        VITE_UUID_CHECKSUM: "U0hBMSh1dWlkLXBja2cuemlwKT0gYWM2NzA4ODE4YTI2OTY3MjNiZGYzMDgzMmQzMjgzYWI0OWRiOTlmZgo=",
        VITE_NODE_ENV: "production",
        VITE_PROJECT_ENV: "production",
        VITE_DEMO_MODE_URL: "https://demo.aviatrix.bet",
        VITE_DEMO_MODE_REDIRECT_ENABLED: "true",
        BASE_URL: "/",
        MODE: "production",
        DEV: !1,
        PROD: !0,
        SSR: !1
    } && "production") !== "production" && typeof e != "function" && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
    const t = typeof e == "function" ? Ap(e) : e
      , r = (i, n) => VP(t, i, n);
    return Object.assign(r, t),
    r
}
  , mH = e => e ? FT(e) : FT
  , j0 = new Map
  , vc = e => {
    const t = j0.get(e);
    return t ? Object.fromEntries(Object.entries(t.stores).map( ([r,i]) => [r, i.getState()])) : {}
}
  , gH = (e, t, r) => {
    if (e === void 0)
        return {
            type: "untracked",
            connection: t.connect(r)
        };
    const i = j0.get(r.name);
    if (i)
        return {
            type: "tracked",
            store: e,
            ...i
        };
    const n = {
        connection: t.connect(r),
        stores: {}
    };
    return j0.set(r.name, n),
    {
        type: "tracked",
        store: e,
        ...n
    }
}
  , _H = (e, t={}) => (r, i, n) => {
    const {enabled: s, anonymousActionType: o, store: a, ...l} = t;
    let h;
    try {
        h = (s ?? ({
            VITE_USER_NODE_ENV: "production",
            VITE_APP_VERSION: "v3.11.4",
            VITE_UUID_CHECKSUM: "U0hBMSh1dWlkLXBja2cuemlwKT0gYWM2NzA4ODE4YTI2OTY3MjNiZGYzMDgzMmQzMjgzYWI0OWRiOTlmZgo=",
            VITE_NODE_ENV: "production",
            VITE_PROJECT_ENV: "production",
            VITE_DEMO_MODE_URL: "https://demo.aviatrix.bet",
            VITE_DEMO_MODE_REDIRECT_ENABLED: "true",
            BASE_URL: "/",
            MODE: "production",
            DEV: !1,
            PROD: !0,
            SSR: !1
        } && "production") !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__
    } catch {}
    if (!h)
        return ({
            VITE_USER_NODE_ENV: "production",
            VITE_APP_VERSION: "v3.11.4",
            VITE_UUID_CHECKSUM: "U0hBMSh1dWlkLXBja2cuemlwKT0gYWM2NzA4ODE4YTI2OTY3MjNiZGYzMDgzMmQzMjgzYWI0OWRiOTlmZgo=",
            VITE_NODE_ENV: "production",
            VITE_PROJECT_ENV: "production",
            VITE_DEMO_MODE_URL: "https://demo.aviatrix.bet",
            VITE_DEMO_MODE_REDIRECT_ENABLED: "true",
            BASE_URL: "/",
            MODE: "production",
            DEV: !1,
            PROD: !0,
            SSR: !1
        } && "production") !== "production" && s && console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension"),
        e(r, i, n);
    const {connection: u, ...c} = gH(a, h, l);
    let d = !0;
    n.setState = (p, v, y) => {
        const m = r(p, v);
        if (!d)
            return m;
        const _ = y === void 0 ? {
            type: o || "anonymous"
        } : typeof y == "string" ? {
            type: y
        } : y;
        return a === void 0 ? (u?.send(_, i()),
        m) : (u?.send({
            ..._,
            type: `${a}/${_.type}`
        }, {
            ...vc(l.name),
            [a]: n.getState()
        }),
        m)
    }
    ;
    const f = (...p) => {
        const v = d;
        d = !1,
        r(...p),
        d = v
    }
      , g = e(n.setState, i, n);
    if (c.type === "untracked" ? u?.init(g) : (c.stores[c.store] = n,
    u?.init(Object.fromEntries(Object.entries(c.stores).map( ([p,v]) => [p, p === c.store ? g : v.getState()])))),
    n.dispatchFromDevtools && typeof n.dispatch == "function") {
        let p = !1;
        const v = n.dispatch;
        n.dispatch = (...y) => {
            ({
                VITE_USER_NODE_ENV: "production",
                VITE_APP_VERSION: "v3.11.4",
                VITE_UUID_CHECKSUM: "U0hBMSh1dWlkLXBja2cuemlwKT0gYWM2NzA4ODE4YTI2OTY3MjNiZGYzMDgzMmQzMjgzYWI0OWRiOTlmZgo=",
                VITE_NODE_ENV: "production",
                VITE_PROJECT_ENV: "production",
                VITE_DEMO_MODE_URL: "https://demo.aviatrix.bet",
                VITE_DEMO_MODE_REDIRECT_ENABLED: "true",
                BASE_URL: "/",
                MODE: "production",
                DEV: !1,
                PROD: !0,
                SSR: !1
            } && "production") !== "production" && y[0].type === "__setState" && !p && (console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),
            p = !0),
            v(...y)
        }
    }
    return u.subscribe(p => {
        var v;
        switch (p.type) {
        case "ACTION":
            if (typeof p.payload != "string") {
                console.error("[zustand devtools middleware] Unsupported action format");
                return
            }
            return Om(p.payload, y => {
                if (y.type === "__setState") {
                    if (a === void 0) {
                        f(y.state);
                        return
                    }
                    Object.keys(y.state).length !== 1 && console.error(`
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);
                    const m = y.state[a];
                    if (m == null)
                        return;
                    JSON.stringify(n.getState()) !== JSON.stringify(m) && f(m);
                    return
                }
                n.dispatchFromDevtools && typeof n.dispatch == "function" && n.dispatch(y)
            }
            );
        case "DISPATCH":
            switch (p.payload.type) {
            case "RESET":
                return f(g),
                a === void 0 ? u?.init(n.getState()) : u?.init(vc(l.name));
            case "COMMIT":
                if (a === void 0) {
                    u?.init(n.getState());
                    return
                }
                return u?.init(vc(l.name));
            case "ROLLBACK":
                return Om(p.state, y => {
                    if (a === void 0) {
                        f(y),
                        u?.init(n.getState());
                        return
                    }
                    f(y[a]),
                    u?.init(vc(l.name))
                }
                );
            case "JUMP_TO_STATE":
            case "JUMP_TO_ACTION":
                return Om(p.state, y => {
                    if (a === void 0) {
                        f(y);
                        return
                    }
                    JSON.stringify(n.getState()) !== JSON.stringify(y[a]) && f(y[a])
                }
                );
            case "IMPORT_STATE":
                {
                    const {nextLiftedState: y} = p.payload
                      , m = (v = y.computedStates.slice(-1)[0]) == null ? void 0 : v.state;
                    if (!m)
                        return;
                    f(a === void 0 ? m : m[a]),
                    u?.send(null, y);
                    return
                }
            case "PAUSE_RECORDING":
                return d = !d
            }
            return
        }
    }
    ),
    g
}
  , yH = _H
  , Om = (e, t) => {
    let r;
    try {
        r = JSON.parse(e)
    } catch (i) {
        console.error("[zustand devtools middleware] Could not parse the received json", i)
    }
    r !== void 0 && t(r)
}
;
function vH(e, t) {
    let r;
    try {
        r = e()
    } catch {
        return
    }
    return {
        getItem: n => {
            var s;
            const o = l => l === null ? null : JSON.parse(l, t?.reviver)
              , a = (s = r.getItem(n)) != null ? s : null;
            return a instanceof Promise ? a.then(o) : o(a)
        }
        ,
        setItem: (n, s) => r.setItem(n, JSON.stringify(s, t?.replacer)),
        removeItem: n => r.removeItem(n)
    }
}
const Yh = e => t => {
    try {
        const r = e(t);
        return r instanceof Promise ? r : {
            then(i) {
                return Yh(i)(r)
            },
            catch(i) {
                return this
            }
        }
    } catch (r) {
        return {
            then(i) {
                return this
            },
            catch(i) {
                return Yh(i)(r)
            }
        }
    }
}
  , xH = (e, t) => (r, i, n) => {
    let s = {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: v => v,
        version: 0,
        merge: (v, y) => ({
            ...y,
            ...v
        }),
        ...t
    }
      , o = !1;
    const a = new Set
      , l = new Set;
    let h;
    try {
        h = s.getStorage()
    } catch {}
    if (!h)
        return e( (...v) => {
            console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),
            r(...v)
        }
        , i, n);
    const u = Yh(s.serialize)
      , c = () => {
        const v = s.partialize({
            ...i()
        });
        let y;
        const m = u({
            state: v,
            version: s.version
        }).then(_ => h.setItem(s.name, _)).catch(_ => {
            y = _
        }
        );
        if (y)
            throw y;
        return m
    }
      , d = n.setState;
    n.setState = (v, y) => {
        d(v, y),
        c()
    }
    ;
    const f = e( (...v) => {
        r(...v),
        c()
    }
    , i, n);
    let g;
    const p = () => {
        var v;
        if (!h)
            return;
        o = !1,
        a.forEach(m => m(i()));
        const y = ((v = s.onRehydrateStorage) == null ? void 0 : v.call(s, i())) || void 0;
        return Yh(h.getItem.bind(h))(s.name).then(m => {
            if (m)
                return s.deserialize(m)
        }
        ).then(m => {
            if (m)
                if (typeof m.version == "number" && m.version !== s.version) {
                    if (s.migrate)
                        return s.migrate(m.state, m.version);
                    console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                } else
                    return m.state
        }
        ).then(m => {
            var _;
            return g = s.merge(m, (_ = i()) != null ? _ : f),
            r(g, !0),
            c()
        }
        ).then( () => {
            y?.(g, void 0),
            o = !0,
            l.forEach(m => m(g))
        }
        ).catch(m => {
            y?.(void 0, m)
        }
        )
    }
    ;
    return n.persist = {
        setOptions: v => {
            s = {
                ...s,
                ...v
            },
            v.getStorage && (h = v.getStorage())
        }
        ,
        clearStorage: () => {
            h?.removeItem(s.name)
        }
        ,
        getOptions: () => s,
        rehydrate: () => p(),
        hasHydrated: () => o,
        onHydrate: v => (a.add(v),
        () => {
            a.delete(v)
        }
        ),
        onFinishHydration: v => (l.add(v),
        () => {
            l.delete(v)
        }
        )
    },
    p(),
    g || f
}
  , EH = (e, t) => (r, i, n) => {
    let s = {
        storage: vH( () => localStorage),
        partialize: p => p,
        version: 0,
        merge: (p, v) => ({
            ...v,
            ...p
        }),
        ...t
    }
      , o = !1;
    const a = new Set
      , l = new Set;
    let h = s.storage;
    if (!h)
        return e( (...p) => {
            console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),
            r(...p)
        }
        , i, n);
    const u = () => {
        const p = s.partialize({
            ...i()
        });
        return h.setItem(s.name, {
            state: p,
            version: s.version
        })
    }
      , c = n.setState;
    n.setState = (p, v) => {
        c(p, v),
        u()
    }
    ;
    const d = e( (...p) => {
        r(...p),
        u()
    }
    , i, n);
    let f;
    const g = () => {
        var p, v;
        if (!h)
            return;
        o = !1,
        a.forEach(m => {
            var _;
            return m((_ = i()) != null ? _ : d)
        }
        );
        const y = ((v = s.onRehydrateStorage) == null ? void 0 : v.call(s, (p = i()) != null ? p : d)) || void 0;
        return Yh(h.getItem.bind(h))(s.name).then(m => {
            if (m)
                if (typeof m.version == "number" && m.version !== s.version) {
                    if (s.migrate)
                        return s.migrate(m.state, m.version);
                    console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                } else
                    return m.state
        }
        ).then(m => {
            var _;
            return f = s.merge(m, (_ = i()) != null ? _ : d),
            r(f, !0),
            u()
        }
        ).then( () => {
            y?.(f, void 0),
            f = i(),
            o = !0,
            l.forEach(m => m(f))
        }
        ).catch(m => {
            y?.(void 0, m)
        }
        )
    }
    ;
    return n.persist = {
        setOptions: p => {
            s = {
                ...s,
                ...p
            },
            p.storage && (h = p.storage)
        }
        ,
        clearStorage: () => {
            h?.removeItem(s.name)
        }
        ,
        getOptions: () => s,
        rehydrate: () => g(),
        hasHydrated: () => o,
        onHydrate: p => (a.add(p),
        () => {
            a.delete(p)
        }
        ),
        onFinishHydration: p => (l.add(p),
        () => {
            l.delete(p)
        }
        )
    },
    s.skipHydration || g(),
    f || d
}
  , TH = (e, t) => "getStorage"in t || "serialize"in t || "deserialize"in t ? (({
    VITE_USER_NODE_ENV: "production",
    VITE_APP_VERSION: "v3.11.4",
    VITE_UUID_CHECKSUM: "U0hBMSh1dWlkLXBja2cuemlwKT0gYWM2NzA4ODE4YTI2OTY3MjNiZGYzMDgzMmQzMjgzYWI0OWRiOTlmZgo=",
    VITE_NODE_ENV: "production",
    VITE_PROJECT_ENV: "production",
    VITE_DEMO_MODE_URL: "https://demo.aviatrix.bet",
    VITE_DEMO_MODE_REDIRECT_ENABLED: "true",
    BASE_URL: "/",
    MODE: "production",
    DEV: !1,
    PROD: !0,
    SSR: !1
} && "production") !== "production" && console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),
xH(e, t)) : EH(e, t)
  , SH = TH
  , wH = () => window.APP_CONFIG
  , AH = () => window.APP_CONFIG?.platform || {}
  , $v = () => window.APP_CONFIG?.game
  , Cp = () => window.ENV_CONFIG
  , tK = () => {
    const e = bH()
      , r = !!$v()?.maintenance?.isActive;
    return !e && r
}
  , bH = () => {
    const e = wH() || {}
      , t = Cp().maintenanceWhitelistedIps || ""
      , r = e.clientIp || "";
    return t !== "" && t.replace(/\s/g, "").split(",").includes(r)
}
  , jP = e => {
    const r = $v()?.currencyLimits || []
      , i = e || _p
      , n = r.find(s => s.currency === i);
    return n ? {
        ...n,
        hasFractions: n?.roundPolicy === XB.ROUND_DOWN,
        fractions: n?.amplifier ? Math.round(2 - Math.log10(Number(n.amplifier))) : Xa
    } : {
        currency: i,
        minStake: 0,
        maxStake: 0,
        inputStake: 0,
        presets: [],
        maxWinAmount: 0,
        hasFractions: !1,
        fractions: Xa,
        amplifier: "",
        roundPolicy: ""
    }
}
  , eK = () => {
    const {keepAliveOld: e} = Cp();
    let t;
    if (e) {
        try {
            t = atob(e.slice(1))
        } catch (r) {
            logger.warn(r, {
                prefix: "[GET_KEEP_ALIVE_OLD_FROM_CONFIG]"
            })
        }
        return t
    }
}
  , rK = (e, t) => e === "all" ? !0 : typeof t == "string" && e ? e.split(",").includes(t) : !1
  , iK = () => {
    const {testingCids: e} = Cp();
    let t = [];
    if (!e)
        return t;
    try {
        t = atob(e.slice(1)).split(",")
    } catch (r) {
        logger.warn(r, {
            prefix: "[GET_TESTING_CIDS_FROM_CONFIG]"
        })
    }
    return t
}
  , XP = "[LOCAL_STORAGE]"
  , CH = e => {
    try {
        return JSON.parse(localStorage.getItem(e))
    } catch (t) {
        return logger?.warn(t, {
            prefix: XP
        }),
        null
    }
}
  , nK = (e, t) => {
    try {
        localStorage.setItem(e, JSON.stringify(t))
    } catch (r) {
        logger?.warn(r, {
            prefix: XP
        })
    }
}
;
var YP = {
    exports: {}
};
(function(e) {
    var t = Object.prototype.hasOwnProperty
      , r = "~";
    function i() {}
    Object.create && (i.prototype = Object.create(null),
    new i().__proto__ || (r = !1));
    function n(l, h, u) {
        this.fn = l,
        this.context = h,
        this.once = u || !1
    }
    function s(l, h, u, c, d) {
        if (typeof u != "function")
            throw new TypeError("The listener must be a function");
        var f = new n(u,c || l,d)
          , g = r ? r + h : h;
        return l._events[g] ? l._events[g].fn ? l._events[g] = [l._events[g], f] : l._events[g].push(f) : (l._events[g] = f,
        l._eventsCount++),
        l
    }
    function o(l, h) {
        --l._eventsCount === 0 ? l._events = new i : delete l._events[h]
    }
    function a() {
        this._events = new i,
        this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var h = [], u, c;
        if (this._eventsCount === 0)
            return h;
        for (c in u = this._events)
            t.call(u, c) && h.push(r ? c.slice(1) : c);
        return Object.getOwnPropertySymbols ? h.concat(Object.getOwnPropertySymbols(u)) : h
    }
    ,
    a.prototype.listeners = function(h) {
        var u = r ? r + h : h
          , c = this._events[u];
        if (!c)
            return [];
        if (c.fn)
            return [c.fn];
        for (var d = 0, f = c.length, g = new Array(f); d < f; d++)
            g[d] = c[d].fn;
        return g
    }
    ,
    a.prototype.listenerCount = function(h) {
        var u = r ? r + h : h
          , c = this._events[u];
        return c ? c.fn ? 1 : c.length : 0
    }
    ,
    a.prototype.emit = function(h, u, c, d, f, g) {
        var p = r ? r + h : h;
        if (!this._events[p])
            return !1;
        var v = this._events[p], y = arguments.length, m, _;
        if (v.fn) {
            switch (v.once && this.removeListener(h, v.fn, void 0, !0),
            y) {
            case 1:
                return v.fn.call(v.context),
                !0;
            case 2:
                return v.fn.call(v.context, u),
                !0;
            case 3:
                return v.fn.call(v.context, u, c),
                !0;
            case 4:
                return v.fn.call(v.context, u, c, d),
                !0;
            case 5:
                return v.fn.call(v.context, u, c, d, f),
                !0;
            case 6:
                return v.fn.call(v.context, u, c, d, f, g),
                !0
            }
            for (_ = 1,
            m = new Array(y - 1); _ < y; _++)
                m[_ - 1] = arguments[_];
            v.fn.apply(v.context, m)
        } else {
            var x = v.length, E;
            for (_ = 0; _ < x; _++)
                switch (v[_].once && this.removeListener(h, v[_].fn, void 0, !0),
                y) {
                case 1:
                    v[_].fn.call(v[_].context);
                    break;
                case 2:
                    v[_].fn.call(v[_].context, u);
                    break;
                case 3:
                    v[_].fn.call(v[_].context, u, c);
                    break;
                case 4:
                    v[_].fn.call(v[_].context, u, c, d);
                    break;
                default:
                    if (!m)
                        for (E = 1,
                        m = new Array(y - 1); E < y; E++)
                            m[E - 1] = arguments[E];
                    v[_].fn.apply(v[_].context, m)
                }
        }
        return !0
    }
    ,
    a.prototype.on = function(h, u, c) {
        return s(this, h, u, c, !1)
    }
    ,
    a.prototype.once = function(h, u, c) {
        return s(this, h, u, c, !0)
    }
    ,
    a.prototype.removeListener = function(h, u, c, d) {
        var f = r ? r + h : h;
        if (!this._events[f])
            return this;
        if (!u)
            return o(this, f),
            this;
        var g = this._events[f];
        if (g.fn)
            g.fn === u && (!d || g.once) && (!c || g.context === c) && o(this, f);
        else {
            for (var p = 0, v = [], y = g.length; p < y; p++)
                (g[p].fn !== u || d && !g[p].once || c && g[p].context !== c) && v.push(g[p]);
            v.length ? this._events[f] = v.length === 1 ? v[0] : v : o(this, f)
        }
        return this
    }
    ,
    a.prototype.removeAllListeners = function(h) {
        var u;
        return h ? (u = r ? r + h : h,
        this._events[u] && o(this, u)) : (this._events = new i,
        this._eventsCount = 0),
        this
    }
    ,
    a.prototype.off = a.prototype.removeListener,
    a.prototype.addListener = a.prototype.on,
    a.prefixed = r,
    a.EventEmitter = a,
    e.exports = a
}
)(YP);
var PH = YP.exports;
const ci = hl(PH)
  , dt = e => `${parseInt(e, 10) - .02}px`
  , ie = {
    MOBILE_S: "mobile-s",
    MOBILE: "mobile",
    TABLET: "tablet",
    TABLET_S: "tablet-s",
    TABLET_HOR: "tablet-hor",
    DESKTOP: "desktop",
    XS_MIN: "xs-min",
    XS_MEDIUM: "xs-medium",
    XS_LARGE: "xs-large",
    XS_X_LARGE: "xs-x-large",
    S_MIN: "s-min",
    S_MEDIUM: "s-medium",
    S_LARGE: "s-large",
    S_X_LARGE: "s-x-large",
    M_MIN: "m-min",
    M_MEDIUM: "m-medium",
    M_LARGE: "m-large",
    L_MIN: "l-min",
    L_MEDIUM: "l-medium",
    L_LARGE: "l-large"
}
  , Ei = {
    XS: "xs",
    SM: "sm",
    MD: "md",
    LG: "lg",
    XL: "xl"
}
  , ye = {
    [Ei.XS]: "0",
    [Ei.SM]: "360px",
    [Ei.MD]: "720px",
    [Ei.LG]: "1024px",
    [Ei.XL]: "1280px"
}
  , zl = {
    DOWN_XS: "down-xs",
    DOWN_SM: "down-sm",
    DOWN_MD: "down-md",
    DOWN_LG: "down-lg"
}
  , IH = {
    MEDIA_BY_BREAKPOINTS: {
        [ie.XS_MIN]: `(max-height: ${dt("332px")}) and (max-width: ${dt("547px")})`,
        [ie.XS_MEDIUM]: `(min-height: 332px) and (max-height: ${dt("410px")}) and (max-width: ${dt("547px")})`,
        [ie.XS_LARGE]: `(min-height: 410px) and (max-height: ${dt("492px")}) and (max-width: ${dt("547px")})`,
        [ie.XS_X_LARGE]: `(min-height: 492px) and (max-height: ${dt("548px")}) and (max-width: ${dt("547px")})`,
        [ie.S_MIN]: `(max-height: ${dt("332px")}) and (min-width: 547px) and (max-width: ${dt("720px")})`,
        [ie.S_MEDIUM]: `(min-height: 332px) and (max-height: ${dt("410px")}) and (min-width: 547px) and (max-width: ${dt("720px")})`,
        [ie.S_LARGE]: `(min-height: 410px) and (max-height: ${dt("492px")}) and (min-width: 547px) and (max-width: ${dt("720px")})`,
        [ie.S_X_LARGE]: `(min-height: 492px) and (max-height: ${dt("548px")}) and (min-width: 547px) and (max-width: ${dt("720px")})`,
        [ie.M_MIN]: `(max-height: ${dt("332px")}) and (min-width: 720px) and (max-width: ${dt("960px")})`,
        [ie.M_MEDIUM]: `(min-height: 332px) and (max-height: ${dt("410px")}) and (min-width: 720px) and (max-width: ${dt("960px")})`,
        [ie.M_LARGE]: `(min-height: 410px) and (max-height: ${dt("700px")}) and (min-width: 720px) and (max-width: ${dt("960px")})`,
        [ie.L_MIN]: `(max-height: ${dt("332px")}) and (min-width: 960px)`,
        [ie.L_MEDIUM]: `(min-height: 332px) and (max-height: ${dt("410px")}) and (min-width: 960px)`,
        [ie.L_LARGE]: `(min-height: 410px) and (max-height: ${dt("700px")}) and (min-width: 960px)`,
        [ie.MOBILE_S]: `(max-width: ${dt(ye.md)}) and (min-height: 548px) and (max-height: ${dt("620px")})`,
        [ie.MOBILE]: `(max-width: ${dt(ye.md)}) and (min-height: 620px)`,
        [ie.TABLET]: `(min-width: ${ye.md}) and (max-width: ${dt(ye.lg)}) and (min-height: 1024px)`,
        [ie.TABLET_S]: `(min-width: ${ye.md}) and (max-width: ${dt(ye.lg)}) and (min-height: 700px) and (max-height: ${dt("1024px")})`,
        [ie.TABLET_HOR]: `(min-width: ${ye.lg}) and (max-width: ${dt(ye.xl)}) and (min-height: 700px)`,
        [ie.DESKTOP]: `(min-width: ${ye.xl}) and (min-height: 700px)`
    },
    COMMON_MEDIA_BY_BREAKPOINTS: {
        [Ei.XS]: `(min-width: ${ye.xs})`,
        [Ei.SM]: `(min-width: ${ye.sm})`,
        [Ei.MD]: `(min-width: ${ye.md})`,
        [Ei.LG]: `(min-width: ${ye.lg})`,
        [Ei.XL]: `(min-width: ${ye.xl})`
    },
    COMMON_MEDIA_DOWN_BY_BREAKPOINTS: {
        [zl.DOWN_XS]: `(max-width: ${dt(ye.sm)})`,
        [zl.DOWN_SM]: `(max-width: ${dt(ye.md)})`,
        [zl.DOWN_MD]: `(max-width: ${dt(ye.lg)})`,
        [zl.DOWN_LG]: `(max-width: ${dt(ye.xl)})`
    }
};
let KP;
function RH(e) {
    return KP = e,
    e
}
function Kh() {
    return KP
}
var Fs = (e => (e[e.WEBGL_LEGACY = 0] = "WEBGL_LEGACY",
e[e.WEBGL = 1] = "WEBGL",
e[e.WEBGL2 = 2] = "WEBGL2",
e))(Fs || {})
  , zv = (e => (e[e.UNKNOWN = 0] = "UNKNOWN",
e[e.WEBGL = 1] = "WEBGL",
e[e.CANVAS = 2] = "CANVAS",
e))(zv || {})
  , lf = (e => (e[e.COLOR = 16384] = "COLOR",
e[e.DEPTH = 256] = "DEPTH",
e[e.STENCIL = 1024] = "STENCIL",
e))(lf || {})
  , tt = (e => (e[e.NORMAL = 0] = "NORMAL",
e[e.ADD = 1] = "ADD",
e[e.MULTIPLY = 2] = "MULTIPLY",
e[e.SCREEN = 3] = "SCREEN",
e[e.OVERLAY = 4] = "OVERLAY",
e[e.DARKEN = 5] = "DARKEN",
e[e.LIGHTEN = 6] = "LIGHTEN",
e[e.COLOR_DODGE = 7] = "COLOR_DODGE",
e[e.COLOR_BURN = 8] = "COLOR_BURN",
e[e.HARD_LIGHT = 9] = "HARD_LIGHT",
e[e.SOFT_LIGHT = 10] = "SOFT_LIGHT",
e[e.DIFFERENCE = 11] = "DIFFERENCE",
e[e.EXCLUSION = 12] = "EXCLUSION",
e[e.HUE = 13] = "HUE",
e[e.SATURATION = 14] = "SATURATION",
e[e.COLOR = 15] = "COLOR",
e[e.LUMINOSITY = 16] = "LUMINOSITY",
e[e.NORMAL_NPM = 17] = "NORMAL_NPM",
e[e.ADD_NPM = 18] = "ADD_NPM",
e[e.SCREEN_NPM = 19] = "SCREEN_NPM",
e[e.NONE = 20] = "NONE",
e[e.SRC_OVER = 0] = "SRC_OVER",
e[e.SRC_IN = 21] = "SRC_IN",
e[e.SRC_OUT = 22] = "SRC_OUT",
e[e.SRC_ATOP = 23] = "SRC_ATOP",
e[e.DST_OVER = 24] = "DST_OVER",
e[e.DST_IN = 25] = "DST_IN",
e[e.DST_OUT = 26] = "DST_OUT",
e[e.DST_ATOP = 27] = "DST_ATOP",
e[e.ERASE = 26] = "ERASE",
e[e.SUBTRACT = 28] = "SUBTRACT",
e[e.XOR = 29] = "XOR",
e))(tt || {})
  , Ti = (e => (e[e.POINTS = 0] = "POINTS",
e[e.LINES = 1] = "LINES",
e[e.LINE_LOOP = 2] = "LINE_LOOP",
e[e.LINE_STRIP = 3] = "LINE_STRIP",
e[e.TRIANGLES = 4] = "TRIANGLES",
e[e.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP",
e[e.TRIANGLE_FAN = 6] = "TRIANGLE_FAN",
e))(Ti || {})
  , B = (e => (e[e.RGBA = 6408] = "RGBA",
e[e.RGB = 6407] = "RGB",
e[e.RG = 33319] = "RG",
e[e.RED = 6403] = "RED",
e[e.RGBA_INTEGER = 36249] = "RGBA_INTEGER",
e[e.RGB_INTEGER = 36248] = "RGB_INTEGER",
e[e.RG_INTEGER = 33320] = "RG_INTEGER",
e[e.RED_INTEGER = 36244] = "RED_INTEGER",
e[e.ALPHA = 6406] = "ALPHA",
e[e.LUMINANCE = 6409] = "LUMINANCE",
e[e.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA",
e[e.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT",
e[e.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL",
e))(B || {})
  , co = (e => (e[e.TEXTURE_2D = 3553] = "TEXTURE_2D",
e[e.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP",
e[e.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY",
e[e.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X",
e[e.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X",
e[e.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y",
e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y",
e[e.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z",
e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z",
e))(co || {})
  , Q = (e => (e[e.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
e[e.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
e[e.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5",
e[e.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4",
e[e.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1",
e[e.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
e[e.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV",
e[e.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV",
e[e.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8",
e[e.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV",
e[e.BYTE = 5120] = "BYTE",
e[e.SHORT = 5122] = "SHORT",
e[e.INT = 5124] = "INT",
e[e.FLOAT = 5126] = "FLOAT",
e[e.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV",
e[e.HALF_FLOAT = 36193] = "HALF_FLOAT",
e))(Q || {})
  , W = (e => (e[e.FLOAT = 0] = "FLOAT",
e[e.INT = 1] = "INT",
e[e.UINT = 2] = "UINT",
e))(W || {})
  , Qi = (e => (e[e.NEAREST = 0] = "NEAREST",
e[e.LINEAR = 1] = "LINEAR",
e))(Qi || {})
  , Ci = (e => (e[e.CLAMP = 33071] = "CLAMP",
e[e.REPEAT = 10497] = "REPEAT",
e[e.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT",
e))(Ci || {})
  , Ni = (e => (e[e.OFF = 0] = "OFF",
e[e.POW2 = 1] = "POW2",
e[e.ON = 2] = "ON",
e[e.ON_MANUAL = 3] = "ON_MANUAL",
e))(Ni || {})
  , tr = (e => (e[e.NPM = 0] = "NPM",
e[e.UNPACK = 1] = "UNPACK",
e[e.PMA = 2] = "PMA",
e[e.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA",
e[e.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD",
e[e.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA",
e))(tr || {})
  , vi = (e => (e[e.NO = 0] = "NO",
e[e.YES = 1] = "YES",
e[e.AUTO = 2] = "AUTO",
e[e.BLEND = 0] = "BLEND",
e[e.CLEAR = 1] = "CLEAR",
e[e.BLIT = 2] = "BLIT",
e))(vi || {})
  , Pp = (e => (e[e.AUTO = 0] = "AUTO",
e[e.MANUAL = 1] = "MANUAL",
e))(Pp || {})
  , Ir = (e => (e.LOW = "lowp",
e.MEDIUM = "mediump",
e.HIGH = "highp",
e))(Ir || {})
  , he = (e => (e[e.NONE = 0] = "NONE",
e[e.SCISSOR = 1] = "SCISSOR",
e[e.STENCIL = 2] = "STENCIL",
e[e.SPRITE = 3] = "SPRITE",
e[e.COLOR = 4] = "COLOR",
e))(he || {})
  , qP = (e => (e[e.RED = 1] = "RED",
e[e.GREEN = 2] = "GREEN",
e[e.BLUE = 4] = "BLUE",
e[e.ALPHA = 8] = "ALPHA",
e))(qP || {})
  , se = (e => (e[e.NONE = 0] = "NONE",
e[e.LOW = 2] = "LOW",
e[e.MEDIUM = 4] = "MEDIUM",
e[e.HIGH = 8] = "HIGH",
e))(se || {})
  , Pi = (e => (e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER",
e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
e[e.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER",
e))(Pi || {});
const ZP = {
    createCanvas: (e, t) => {
        const r = document.createElement("canvas");
        return r.width = e,
        r.height = t,
        r
    }
    ,
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (e, t) => fetch(e, t),
    parseXML: e => new DOMParser().parseFromString(e, "text/xml")
}
  , z = {
    ADAPTER: ZP,
    RESOLUTION: 1,
    CREATE_IMAGE_BITMAP: !1,
    ROUND_PIXELS: !1
};
var Nm = /iPhone/i
  , UT = /iPod/i
  , GT = /iPad/i
  , HT = /\biOS-universal(?:.+)Mac\b/i
  , Lm = /\bAndroid(?:.+)Mobile\b/i
  , $T = /Android/i
  , Ko = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i
  , xc = /Silk/i
  , pn = /Windows Phone/i
  , zT = /\bWindows(?:.+)ARM\b/i
  , WT = /BlackBerry/i
  , VT = /BB10/i
  , jT = /Opera Mini/i
  , XT = /\b(CriOS|Chrome)(?:.+)Mobile/i
  , YT = /Mobile(?:.+)Firefox\b/i
  , KT = function(e) {
    return typeof e < "u" && e.platform === "MacIntel" && typeof e.maxTouchPoints == "number" && e.maxTouchPoints > 1 && typeof MSStream > "u"
};
function MH(e) {
    return function(t) {
        return t.test(e)
    }
}
function qT(e) {
    var t = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
    };
    !e && typeof navigator < "u" ? t = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof e == "string" ? t.userAgent = e : e && e.userAgent && (t = {
        userAgent: e.userAgent,
        platform: e.platform,
        maxTouchPoints: e.maxTouchPoints || 0
    });
    var r = t.userAgent
      , i = r.split("[FBAN");
    typeof i[1] < "u" && (r = i[0]),
    i = r.split("Twitter"),
    typeof i[1] < "u" && (r = i[0]);
    var n = MH(r)
      , s = {
        apple: {
            phone: n(Nm) && !n(pn),
            ipod: n(UT),
            tablet: !n(Nm) && (n(GT) || KT(t)) && !n(pn),
            universal: n(HT),
            device: (n(Nm) || n(UT) || n(GT) || n(HT) || KT(t)) && !n(pn)
        },
        amazon: {
            phone: n(Ko),
            tablet: !n(Ko) && n(xc),
            device: n(Ko) || n(xc)
        },
        android: {
            phone: !n(pn) && n(Ko) || !n(pn) && n(Lm),
            tablet: !n(pn) && !n(Ko) && !n(Lm) && (n(xc) || n($T)),
            device: !n(pn) && (n(Ko) || n(xc) || n(Lm) || n($T)) || n(/\bokhttp\b/i)
        },
        windows: {
            phone: n(pn),
            tablet: n(zT),
            device: n(pn) || n(zT)
        },
        other: {
            blackberry: n(WT),
            blackberry10: n(VT),
            opera: n(jT),
            firefox: n(YT),
            chrome: n(XT),
            device: n(WT) || n(VT) || n(jT) || n(YT) || n(XT)
        },
        any: !1,
        phone: !1,
        tablet: !1
    };
    return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device,
    s.phone = s.apple.phone || s.android.phone || s.windows.phone,
    s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet,
    s
}
const OH = qT.default ?? qT
  , Si = OH(globalThis.navigator);
z.RETINA_PREFIX = /@([0-9\.]+)x/;
z.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var Wv = {
    exports: {}
};
Wv.exports = Ip;
Wv.exports.default = Ip;
function Ip(e, t, r) {
    r = r || 2;
    var i = t && t.length
      , n = i ? t[0] * r : e.length
      , s = QP(e, 0, n, r, !0)
      , o = [];
    if (!s || s.next === s.prev)
        return o;
    var a, l, h, u, c, d, f;
    if (i && (s = kH(e, t, s, r)),
    e.length > 80 * r) {
        a = h = e[0],
        l = u = e[1];
        for (var g = r; g < n; g += r)
            c = e[g],
            d = e[g + 1],
            c < a && (a = c),
            d < l && (l = d),
            c > h && (h = c),
            d > u && (u = d);
        f = Math.max(h - a, u - l),
        f = f !== 0 ? 32767 / f : 0
    }
    return qh(s, o, r, a, l, f, 0),
    o
}
function QP(e, t, r, i, n) {
    var s, o;
    if (n === K0(e, t, r, i) > 0)
        for (s = t; s < r; s += i)
            o = ZT(s, e[s], e[s + 1], o);
    else
        for (s = r - i; s >= t; s -= i)
            o = ZT(s, e[s], e[s + 1], o);
    return o && Rp(o, o.next) && (Qh(o),
    o = o.next),
    o
}
function Ro(e, t) {
    if (!e)
        return e;
    t || (t = e);
    var r = e, i;
    do
        if (i = !1,
        !r.steiner && (Rp(r, r.next) || Yt(r.prev, r, r.next) === 0)) {
            if (Qh(r),
            r = t = r.prev,
            r === r.next)
                break;
            i = !0
        } else
            r = r.next;
    while (i || r !== t);
    return t
}
function qh(e, t, r, i, n, s, o) {
    if (e) {
        !o && s && $H(e, i, n, s);
        for (var a = e, l, h; e.prev !== e.next; ) {
            if (l = e.prev,
            h = e.next,
            s ? LH(e, i, n, s) : NH(e)) {
                t.push(l.i / r | 0),
                t.push(e.i / r | 0),
                t.push(h.i / r | 0),
                Qh(e),
                e = h.next,
                a = h.next;
                continue
            }
            if (e = h,
            e === a) {
                o ? o === 1 ? (e = DH(Ro(e), t, r),
                qh(e, t, r, i, n, s, 2)) : o === 2 && BH(e, t, r, i, n, s) : qh(Ro(e), t, r, i, n, s, 1);
                break
            }
        }
    }
}
function NH(e) {
    var t = e.prev
      , r = e
      , i = e.next;
    if (Yt(t, r, i) >= 0)
        return !1;
    for (var n = t.x, s = r.x, o = i.x, a = t.y, l = r.y, h = i.y, u = n < s ? n < o ? n : o : s < o ? s : o, c = a < l ? a < h ? a : h : l < h ? l : h, d = n > s ? n > o ? n : o : s > o ? s : o, f = a > l ? a > h ? a : h : l > h ? l : h, g = i.next; g !== t; ) {
        if (g.x >= u && g.x <= d && g.y >= c && g.y <= f && Ea(n, a, s, l, o, h, g.x, g.y) && Yt(g.prev, g, g.next) >= 0)
            return !1;
        g = g.next
    }
    return !0
}
function LH(e, t, r, i) {
    var n = e.prev
      , s = e
      , o = e.next;
    if (Yt(n, s, o) >= 0)
        return !1;
    for (var a = n.x, l = s.x, h = o.x, u = n.y, c = s.y, d = o.y, f = a < l ? a < h ? a : h : l < h ? l : h, g = u < c ? u < d ? u : d : c < d ? c : d, p = a > l ? a > h ? a : h : l > h ? l : h, v = u > c ? u > d ? u : d : c > d ? c : d, y = X0(f, g, t, r, i), m = X0(p, v, t, r, i), _ = e.prevZ, x = e.nextZ; _ && _.z >= y && x && x.z <= m; ) {
        if (_.x >= f && _.x <= p && _.y >= g && _.y <= v && _ !== n && _ !== o && Ea(a, u, l, c, h, d, _.x, _.y) && Yt(_.prev, _, _.next) >= 0 || (_ = _.prevZ,
        x.x >= f && x.x <= p && x.y >= g && x.y <= v && x !== n && x !== o && Ea(a, u, l, c, h, d, x.x, x.y) && Yt(x.prev, x, x.next) >= 0))
            return !1;
        x = x.nextZ
    }
    for (; _ && _.z >= y; ) {
        if (_.x >= f && _.x <= p && _.y >= g && _.y <= v && _ !== n && _ !== o && Ea(a, u, l, c, h, d, _.x, _.y) && Yt(_.prev, _, _.next) >= 0)
            return !1;
        _ = _.prevZ
    }
    for (; x && x.z <= m; ) {
        if (x.x >= f && x.x <= p && x.y >= g && x.y <= v && x !== n && x !== o && Ea(a, u, l, c, h, d, x.x, x.y) && Yt(x.prev, x, x.next) >= 0)
            return !1;
        x = x.nextZ
    }
    return !0
}
function DH(e, t, r) {
    var i = e;
    do {
        var n = i.prev
          , s = i.next.next;
        !Rp(n, s) && JP(n, i, i.next, s) && Zh(n, s) && Zh(s, n) && (t.push(n.i / r | 0),
        t.push(i.i / r | 0),
        t.push(s.i / r | 0),
        Qh(i),
        Qh(i.next),
        i = e = s),
        i = i.next
    } while (i !== e);
    return Ro(i)
}
function BH(e, t, r, i, n, s) {
    var o = e;
    do {
        for (var a = o.next.next; a !== o.prev; ) {
            if (o.i !== a.i && VH(o, a)) {
                var l = tI(o, a);
                o = Ro(o, o.next),
                l = Ro(l, l.next),
                qh(o, t, r, i, n, s, 0),
                qh(l, t, r, i, n, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== e)
}
function kH(e, t, r, i) {
    var n = [], s, o, a, l, h;
    for (s = 0,
    o = t.length; s < o; s++)
        a = t[s] * i,
        l = s < o - 1 ? t[s + 1] * i : e.length,
        h = QP(e, a, l, i, !1),
        h === h.next && (h.steiner = !0),
        n.push(WH(h));
    for (n.sort(FH),
    s = 0; s < n.length; s++)
        r = UH(n[s], r);
    return r
}
function FH(e, t) {
    return e.x - t.x
}
function UH(e, t) {
    var r = GH(e, t);
    if (!r)
        return t;
    var i = tI(r, e);
    return Ro(i, i.next),
    Ro(r, r.next)
}
function GH(e, t) {
    var r = t, i = e.x, n = e.y, s = -1 / 0, o;
    do {
        if (n <= r.y && n >= r.next.y && r.next.y !== r.y) {
            var a = r.x + (n - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
            if (a <= i && a > s && (s = a,
            o = r.x < r.next.x ? r : r.next,
            a === i))
                return o
        }
        r = r.next
    } while (r !== t);
    if (!o)
        return null;
    var l = o, h = o.x, u = o.y, c = 1 / 0, d;
    r = o;
    do
        i >= r.x && r.x >= h && i !== r.x && Ea(n < u ? i : s, n, h, u, n < u ? s : i, n, r.x, r.y) && (d = Math.abs(n - r.y) / (i - r.x),
        Zh(r, e) && (d < c || d === c && (r.x > o.x || r.x === o.x && HH(o, r))) && (o = r,
        c = d)),
        r = r.next;
    while (r !== l);
    return o
}
function HH(e, t) {
    return Yt(e.prev, e, t.prev) < 0 && Yt(t.next, e, e.next) < 0
}
function $H(e, t, r, i) {
    var n = e;
    do
        n.z === 0 && (n.z = X0(n.x, n.y, t, r, i)),
        n.prevZ = n.prev,
        n.nextZ = n.next,
        n = n.next;
    while (n !== e);
    n.prevZ.nextZ = null,
    n.prevZ = null,
    zH(n)
}
function zH(e) {
    var t, r, i, n, s, o, a, l, h = 1;
    do {
        for (r = e,
        e = null,
        s = null,
        o = 0; r; ) {
            for (o++,
            i = r,
            a = 0,
            t = 0; t < h && (a++,
            i = i.nextZ,
            !!i); t++)
                ;
            for (l = h; a > 0 || l > 0 && i; )
                a !== 0 && (l === 0 || !i || r.z <= i.z) ? (n = r,
                r = r.nextZ,
                a--) : (n = i,
                i = i.nextZ,
                l--),
                s ? s.nextZ = n : e = n,
                n.prevZ = s,
                s = n;
            r = i
        }
        s.nextZ = null,
        h *= 2
    } while (o > 1);
    return e
}
function X0(e, t, r, i, n) {
    return e = (e - r) * n | 0,
    t = (t - i) * n | 0,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    t = (t | t << 8) & 16711935,
    t = (t | t << 4) & 252645135,
    t = (t | t << 2) & 858993459,
    t = (t | t << 1) & 1431655765,
    e | t << 1
}
function WH(e) {
    var t = e
      , r = e;
    do
        (t.x < r.x || t.x === r.x && t.y < r.y) && (r = t),
        t = t.next;
    while (t !== e);
    return r
}
function Ea(e, t, r, i, n, s, o, a) {
    return (n - o) * (t - a) >= (e - o) * (s - a) && (e - o) * (i - a) >= (r - o) * (t - a) && (r - o) * (s - a) >= (n - o) * (i - a)
}
function VH(e, t) {
    return e.next.i !== t.i && e.prev.i !== t.i && !jH(e, t) && (Zh(e, t) && Zh(t, e) && XH(e, t) && (Yt(e.prev, e, t.prev) || Yt(e, t.prev, t)) || Rp(e, t) && Yt(e.prev, e, e.next) > 0 && Yt(t.prev, t, t.next) > 0)
}
function Yt(e, t, r) {
    return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y)
}
function Rp(e, t) {
    return e.x === t.x && e.y === t.y
}
function JP(e, t, r, i) {
    var n = Tc(Yt(e, t, r))
      , s = Tc(Yt(e, t, i))
      , o = Tc(Yt(r, i, e))
      , a = Tc(Yt(r, i, t));
    return !!(n !== s && o !== a || n === 0 && Ec(e, r, t) || s === 0 && Ec(e, i, t) || o === 0 && Ec(r, e, i) || a === 0 && Ec(r, t, i))
}
function Ec(e, t, r) {
    return t.x <= Math.max(e.x, r.x) && t.x >= Math.min(e.x, r.x) && t.y <= Math.max(e.y, r.y) && t.y >= Math.min(e.y, r.y)
}
function Tc(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0
}
function jH(e, t) {
    var r = e;
    do {
        if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && JP(r, r.next, e, t))
            return !0;
        r = r.next
    } while (r !== e);
    return !1
}
function Zh(e, t) {
    return Yt(e.prev, e, e.next) < 0 ? Yt(e, t, e.next) >= 0 && Yt(e, e.prev, t) >= 0 : Yt(e, t, e.prev) < 0 || Yt(e, e.next, t) < 0
}
function XH(e, t) {
    var r = e
      , i = !1
      , n = (e.x + t.x) / 2
      , s = (e.y + t.y) / 2;
    do
        r.y > s != r.next.y > s && r.next.y !== r.y && n < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (i = !i),
        r = r.next;
    while (r !== e);
    return i
}
function tI(e, t) {
    var r = new Y0(e.i,e.x,e.y)
      , i = new Y0(t.i,t.x,t.y)
      , n = e.next
      , s = t.prev;
    return e.next = t,
    t.prev = e,
    r.next = n,
    n.prev = r,
    i.next = r,
    r.prev = i,
    s.next = i,
    i.prev = s,
    i
}
function ZT(e, t, r, i) {
    var n = new Y0(e,t,r);
    return i ? (n.next = i.next,
    n.prev = i,
    i.next.prev = n,
    i.next = n) : (n.prev = n,
    n.next = n),
    n
}
function Qh(e) {
    e.next.prev = e.prev,
    e.prev.next = e.next,
    e.prevZ && (e.prevZ.nextZ = e.nextZ),
    e.nextZ && (e.nextZ.prevZ = e.prevZ)
}
function Y0(e, t, r) {
    this.i = e,
    this.x = t,
    this.y = r,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
Ip.deviation = function(e, t, r, i) {
    var n = t && t.length
      , s = n ? t[0] * r : e.length
      , o = Math.abs(K0(e, 0, s, r));
    if (n)
        for (var a = 0, l = t.length; a < l; a++) {
            var h = t[a] * r
              , u = a < l - 1 ? t[a + 1] * r : e.length;
            o -= Math.abs(K0(e, h, u, r))
        }
    var c = 0;
    for (a = 0; a < i.length; a += 3) {
        var d = i[a] * r
          , f = i[a + 1] * r
          , g = i[a + 2] * r;
        c += Math.abs((e[d] - e[g]) * (e[f + 1] - e[d + 1]) - (e[d] - e[f]) * (e[g + 1] - e[d + 1]))
    }
    return o === 0 && c === 0 ? 0 : Math.abs((c - o) / o)
}
;
function K0(e, t, r, i) {
    for (var n = 0, s = t, o = r - i; s < r; s += i)
        n += (e[o] - e[s]) * (e[s + 1] + e[o + 1]),
        o = s;
    return n
}
Ip.flatten = function(e) {
    for (var t = e[0][0].length, r = {
        vertices: [],
        holes: [],
        dimensions: t
    }, i = 0, n = 0; n < e.length; n++) {
        for (var s = 0; s < e[n].length; s++)
            for (var o = 0; o < t; o++)
                r.vertices.push(e[n][s][o]);
        n > 0 && (i += e[n - 1].length,
        r.holes.push(i))
    }
    return r
}
;
var YH = Wv.exports;
const eI = hl(YH);
var hf = {
    exports: {}
};
/*! https://mths.be/punycode v1.4.1 by @mathias */
hf.exports;
(function(e, t) {
    (function(r) {
        var i = t && !t.nodeType && t
          , n = e && !e.nodeType && e
          , s = typeof rh == "object" && rh;
        (s.global === s || s.window === s || s.self === s) && (r = s);
        var o, a = 2147483647, l = 36, h = 1, u = 26, c = 38, d = 700, f = 72, g = 128, p = "-", v = /^xn--/, y = /[^\x20-\x7E]/, m = /[\x2E\u3002\uFF0E\uFF61]/g, _ = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, x = l - h, E = Math.floor, S = String.fromCharCode, w;
        function T(I) {
            throw new RangeError(_[I])
        }
        function C(I, H) {
            for (var K = I.length, ct = []; K--; )
                ct[K] = H(I[K]);
            return ct
        }
        function R(I, H) {
            var K = I.split("@")
              , ct = "";
            K.length > 1 && (ct = K[0] + "@",
            I = K[1]),
            I = I.replace(m, ".");
            var rt = I.split(".")
              , Et = C(rt, H).join(".");
            return ct + Et
        }
        function O(I) {
            for (var H = [], K = 0, ct = I.length, rt, Et; K < ct; )
                rt = I.charCodeAt(K++),
                rt >= 55296 && rt <= 56319 && K < ct ? (Et = I.charCodeAt(K++),
                (Et & 64512) == 56320 ? H.push(((rt & 1023) << 10) + (Et & 1023) + 65536) : (H.push(rt),
                K--)) : H.push(rt);
            return H
        }
        function N(I) {
            return C(I, function(H) {
                var K = "";
                return H > 65535 && (H -= 65536,
                K += S(H >>> 10 & 1023 | 55296),
                H = 56320 | H & 1023),
                K += S(H),
                K
            }).join("")
        }
        function P(I) {
            return I - 48 < 10 ? I - 22 : I - 65 < 26 ? I - 65 : I - 97 < 26 ? I - 97 : l
        }
        function M(I, H) {
            return I + 22 + 75 * (I < 26) - ((H != 0) << 5)
        }
        function V(I, H, K) {
            var ct = 0;
            for (I = K ? E(I / d) : I >> 1,
            I += E(I / H); I > x * u >> 1; ct += l)
                I = E(I / x);
            return E(ct + (x + 1) * I / (I + c))
        }
        function X(I) {
            var H = [], K = I.length, ct, rt = 0, Et = g, bt = f, Wt, Be, gr, Ie, kt, le, pe, ki, Fi;
            for (Wt = I.lastIndexOf(p),
            Wt < 0 && (Wt = 0),
            Be = 0; Be < Wt; ++Be)
                I.charCodeAt(Be) >= 128 && T("not-basic"),
                H.push(I.charCodeAt(Be));
            for (gr = Wt > 0 ? Wt + 1 : 0; gr < K; ) {
                for (Ie = rt,
                kt = 1,
                le = l; gr >= K && T("invalid-input"),
                pe = P(I.charCodeAt(gr++)),
                (pe >= l || pe > E((a - rt) / kt)) && T("overflow"),
                rt += pe * kt,
                ki = le <= bt ? h : le >= bt + u ? u : le - bt,
                !(pe < ki); le += l)
                    Fi = l - ki,
                    kt > E(a / Fi) && T("overflow"),
                    kt *= Fi;
                ct = H.length + 1,
                bt = V(rt - Ie, ct, Ie == 0),
                E(rt / ct) > a - Et && T("overflow"),
                Et += E(rt / ct),
                rt %= ct,
                H.splice(rt++, 0, Et)
            }
            return N(H)
        }
        function k(I) {
            var H, K, ct, rt, Et, bt, Wt, Be, gr, Ie, kt, le = [], pe, ki, Fi, vl;
            for (I = O(I),
            pe = I.length,
            H = g,
            K = 0,
            Et = f,
            bt = 0; bt < pe; ++bt)
                kt = I[bt],
                kt < 128 && le.push(S(kt));
            for (ct = rt = le.length,
            rt && le.push(p); ct < pe; ) {
                for (Wt = a,
                bt = 0; bt < pe; ++bt)
                    kt = I[bt],
                    kt >= H && kt < Wt && (Wt = kt);
                for (ki = ct + 1,
                Wt - H > E((a - K) / ki) && T("overflow"),
                K += (Wt - H) * ki,
                H = Wt,
                bt = 0; bt < pe; ++bt)
                    if (kt = I[bt],
                    kt < H && ++K > a && T("overflow"),
                    kt == H) {
                        for (Be = K,
                        gr = l; Ie = gr <= Et ? h : gr >= Et + u ? u : gr - Et,
                        !(Be < Ie); gr += l)
                            vl = Be - Ie,
                            Fi = l - Ie,
                            le.push(S(M(Ie + vl % Fi, 0))),
                            Be = E(vl / Fi);
                        le.push(S(M(Be, 0))),
                        Et = V(K, ki, ct == rt),
                        K = 0,
                        ++ct
                    }
                ++K,
                ++H
            }
            return le.join("")
        }
        function L(I) {
            return R(I, function(H) {
                return v.test(H) ? X(H.slice(4).toLowerCase()) : H
            })
        }
        function $(I) {
            return R(I, function(H) {
                return y.test(H) ? "xn--" + k(H) : H
            })
        }
        if (o = {
            version: "1.4.1",
            ucs2: {
                decode: O,
                encode: N
            },
            decode: X,
            encode: k,
            toASCII: $,
            toUnicode: L
        },
        i && n)
            if (e.exports == i)
                n.exports = o;
            else
                for (w in o)
                    o.hasOwnProperty(w) && (i[w] = o[w]);
        else
            r.punycode = o
    }
    )(rh)
}
)(hf, hf.exports);
var KH = hf.exports, qH = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return !1;
    if (typeof Symbol.iterator == "symbol")
        return !0;
    var t = {}
      , r = Symbol("test")
      , i = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
        return !1;
    var n = 42;
    t[r] = n;
    for (r in t)
        return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
        return !1;
    var s = Object.getOwnPropertySymbols(t);
    if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
        return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
        var o = Object.getOwnPropertyDescriptor(t, r);
        if (o.value !== n || o.enumerable !== !0)
            return !1
    }
    return !0
}, QT = typeof Symbol < "u" && Symbol, ZH = qH, QH = function() {
    return typeof QT != "function" || typeof Symbol != "function" || typeof QT("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : ZH()
}, JT = {
    foo: {}
}, JH = Object, t6 = function() {
    return {
        __proto__: JT
    }.foo === JT.foo && !({
        __proto__: null
    }instanceof JH)
}, e6 = "Function.prototype.bind called on incompatible ", Dm = Array.prototype.slice, r6 = Object.prototype.toString, i6 = "[object Function]", n6 = function(t) {
    var r = this;
    if (typeof r != "function" || r6.call(r) !== i6)
        throw new TypeError(e6 + r);
    for (var i = Dm.call(arguments, 1), n, s = function() {
        if (this instanceof n) {
            var u = r.apply(this, i.concat(Dm.call(arguments)));
            return Object(u) === u ? u : this
        } else
            return r.apply(t, i.concat(Dm.call(arguments)))
    }, o = Math.max(0, r.length - i.length), a = [], l = 0; l < o; l++)
        a.push("$" + l);
    if (n = Function("binder", "return function (" + a.join(",") + "){ return binder.apply(this,arguments); }")(s),
    r.prototype) {
        var h = function() {};
        h.prototype = r.prototype,
        n.prototype = new h,
        h.prototype = null
    }
    return n
}, s6 = n6, Vv = Function.prototype.bind || s6, o6 = Vv, a6 = o6.call(Function.call, Object.prototype.hasOwnProperty), ft, Qa = SyntaxError, rI = Function, Ma = TypeError, Bm = function(e) {
    try {
        return rI('"use strict"; return (' + e + ").constructor;")()
    } catch {}
}, fo = Object.getOwnPropertyDescriptor;
if (fo)
    try {
        fo({}, "")
    } catch {
        fo = null
    }
var km = function() {
    throw new Ma
}
  , l6 = fo ? function() {
    try {
        return arguments.callee,
        km
    } catch {
        try {
            return fo(arguments, "callee").get
        } catch {
            return km
        }
    }
}() : km
  , qo = QH()
  , h6 = t6()
  , Ee = Object.getPrototypeOf || (h6 ? function(e) {
    return e.__proto__
}
: null)
  , ta = {}
  , u6 = typeof Uint8Array > "u" || !Ee ? ft : Ee(Uint8Array)
  , po = {
    "%AggregateError%": typeof AggregateError > "u" ? ft : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ft : ArrayBuffer,
    "%ArrayIteratorPrototype%": qo && Ee ? Ee([][Symbol.iterator]()) : ft,
    "%AsyncFromSyncIteratorPrototype%": ft,
    "%AsyncFunction%": ta,
    "%AsyncGenerator%": ta,
    "%AsyncGeneratorFunction%": ta,
    "%AsyncIteratorPrototype%": ta,
    "%Atomics%": typeof Atomics > "u" ? ft : Atomics,
    "%BigInt%": typeof BigInt > "u" ? ft : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? ft : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? ft : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? ft : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? ft : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? ft : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ft : FinalizationRegistry,
    "%Function%": rI,
    "%GeneratorFunction%": ta,
    "%Int8Array%": typeof Int8Array > "u" ? ft : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? ft : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? ft : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": qo && Ee ? Ee(Ee([][Symbol.iterator]())) : ft,
    "%JSON%": typeof JSON == "object" ? JSON : ft,
    "%Map%": typeof Map > "u" ? ft : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !qo || !Ee ? ft : Ee(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? ft : Promise,
    "%Proxy%": typeof Proxy > "u" ? ft : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? ft : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? ft : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !qo || !Ee ? ft : Ee(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ft : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": qo && Ee ? Ee(""[Symbol.iterator]()) : ft,
    "%Symbol%": qo ? Symbol : ft,
    "%SyntaxError%": Qa,
    "%ThrowTypeError%": l6,
    "%TypedArray%": u6,
    "%TypeError%": Ma,
    "%Uint8Array%": typeof Uint8Array > "u" ? ft : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ft : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? ft : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? ft : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? ft : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? ft : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? ft : WeakSet
};
if (Ee)
    try {
        null.error
    } catch (e) {
        var c6 = Ee(Ee(e));
        po["%Error.prototype%"] = c6
    }
var d6 = function e(t) {
    var r;
    if (t === "%AsyncFunction%")
        r = Bm("async function () {}");
    else if (t === "%GeneratorFunction%")
        r = Bm("function* () {}");
    else if (t === "%AsyncGeneratorFunction%")
        r = Bm("async function* () {}");
    else if (t === "%AsyncGenerator%") {
        var i = e("%AsyncGeneratorFunction%");
        i && (r = i.prototype)
    } else if (t === "%AsyncIteratorPrototype%") {
        var n = e("%AsyncGenerator%");
        n && Ee && (r = Ee(n.prototype))
    }
    return po[t] = r,
    r
}
  , tS = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
}
  , Du = Vv
  , uf = a6
  , f6 = Du.call(Function.call, Array.prototype.concat)
  , p6 = Du.call(Function.apply, Array.prototype.splice)
  , eS = Du.call(Function.call, String.prototype.replace)
  , cf = Du.call(Function.call, String.prototype.slice)
  , m6 = Du.call(Function.call, RegExp.prototype.exec)
  , g6 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
  , _6 = /\\(\\)?/g
  , y6 = function(t) {
    var r = cf(t, 0, 1)
      , i = cf(t, -1);
    if (r === "%" && i !== "%")
        throw new Qa("invalid intrinsic syntax, expected closing `%`");
    if (i === "%" && r !== "%")
        throw new Qa("invalid intrinsic syntax, expected opening `%`");
    var n = [];
    return eS(t, g6, function(s, o, a, l) {
        n[n.length] = a ? eS(l, _6, "$1") : o || s
    }),
    n
}
  , v6 = function(t, r) {
    var i = t, n;
    if (uf(tS, i) && (n = tS[i],
    i = "%" + n[0] + "%"),
    uf(po, i)) {
        var s = po[i];
        if (s === ta && (s = d6(i)),
        typeof s > "u" && !r)
            throw new Ma("intrinsic " + t + " exists, but is not available. Please file an issue!");
        return {
            alias: n,
            name: i,
            value: s
        }
    }
    throw new Qa("intrinsic " + t + " does not exist!")
}
  , jv = function(t, r) {
    if (typeof t != "string" || t.length === 0)
        throw new Ma("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof r != "boolean")
        throw new Ma('"allowMissing" argument must be a boolean');
    if (m6(/^%?[^%]*%?$/, t) === null)
        throw new Qa("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var i = y6(t)
      , n = i.length > 0 ? i[0] : ""
      , s = v6("%" + n + "%", r)
      , o = s.name
      , a = s.value
      , l = !1
      , h = s.alias;
    h && (n = h[0],
    p6(i, f6([0, 1], h)));
    for (var u = 1, c = !0; u < i.length; u += 1) {
        var d = i[u]
          , f = cf(d, 0, 1)
          , g = cf(d, -1);
        if ((f === '"' || f === "'" || f === "`" || g === '"' || g === "'" || g === "`") && f !== g)
            throw new Qa("property names with quotes must have matching quotes");
        if ((d === "constructor" || !c) && (l = !0),
        n += "." + d,
        o = "%" + n + "%",
        uf(po, o))
            a = po[o];
        else if (a != null) {
            if (!(d in a)) {
                if (!r)
                    throw new Ma("base intrinsic for " + t + " exists, but the property is not available.");
                return
            }
            if (fo && u + 1 >= i.length) {
                var p = fo(a, d);
                c = !!p,
                c && "get"in p && !("originalValue"in p.get) ? a = p.get : a = a[d]
            } else
                c = uf(a, d),
                a = a[d];
            c && !l && (po[o] = a)
        }
    }
    return a
}
  , iI = {
    exports: {}
};
(function(e) {
    var t = Vv
      , r = jv
      , i = r("%Function.prototype.apply%")
      , n = r("%Function.prototype.call%")
      , s = r("%Reflect.apply%", !0) || t.call(n, i)
      , o = r("%Object.getOwnPropertyDescriptor%", !0)
      , a = r("%Object.defineProperty%", !0)
      , l = r("%Math.max%");
    if (a)
        try {
            a({}, "a", {
                value: 1
            })
        } catch {
            a = null
        }
    e.exports = function(c) {
        var d = s(t, n, arguments);
        if (o && a) {
            var f = o(d, "length");
            f.configurable && a(d, "length", {
                value: 1 + l(0, c.length - (arguments.length - 1))
            })
        }
        return d
    }
    ;
    var h = function() {
        return s(t, i, arguments)
    };
    a ? a(e.exports, "apply", {
        value: h
    }) : e.exports.apply = h
}
)(iI);
var x6 = iI.exports
  , nI = jv
  , sI = x6
  , E6 = sI(nI("String.prototype.indexOf"))
  , T6 = function(t, r) {
    var i = nI(t, !!r);
    return typeof i == "function" && E6(t, ".prototype.") > -1 ? sI(i) : i
};
const S6 = {}
  , w6 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: S6
}, Symbol.toStringTag, {
    value: "Module"
}))
  , A6 = x2(w6);
var Xv = typeof Map == "function" && Map.prototype
  , Fm = Object.getOwnPropertyDescriptor && Xv ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null
  , df = Xv && Fm && typeof Fm.get == "function" ? Fm.get : null
  , rS = Xv && Map.prototype.forEach
  , Yv = typeof Set == "function" && Set.prototype
  , Um = Object.getOwnPropertyDescriptor && Yv ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null
  , ff = Yv && Um && typeof Um.get == "function" ? Um.get : null
  , iS = Yv && Set.prototype.forEach
  , b6 = typeof WeakMap == "function" && WeakMap.prototype
  , fh = b6 ? WeakMap.prototype.has : null
  , C6 = typeof WeakSet == "function" && WeakSet.prototype
  , ph = C6 ? WeakSet.prototype.has : null
  , P6 = typeof WeakRef == "function" && WeakRef.prototype
  , nS = P6 ? WeakRef.prototype.deref : null
  , I6 = Boolean.prototype.valueOf
  , R6 = Object.prototype.toString
  , M6 = Function.prototype.toString
  , O6 = String.prototype.match
  , Kv = String.prototype.slice
  , hs = String.prototype.replace
  , N6 = String.prototype.toUpperCase
  , sS = String.prototype.toLowerCase
  , oI = RegExp.prototype.test
  , oS = Array.prototype.concat
  , Xi = Array.prototype.join
  , L6 = Array.prototype.slice
  , aS = Math.floor
  , q0 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null
  , Gm = Object.getOwnPropertySymbols
  , Z0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null
  , Ja = typeof Symbol == "function" && typeof Symbol.iterator == "object"
  , Xe = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === Ja || "symbol") ? Symbol.toStringTag : null
  , aI = Object.prototype.propertyIsEnumerable
  , lS = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
    return e.__proto__
}
: null);
function hS(e, t) {
    if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || oI.call(/e/, t))
        return t;
    var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof e == "number") {
        var i = e < 0 ? -aS(-e) : aS(e);
        if (i !== e) {
            var n = String(i)
              , s = Kv.call(t, n.length + 1);
            return hs.call(n, r, "$&_") + "." + hs.call(hs.call(s, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return hs.call(t, r, "$&_")
}
var Q0 = A6
  , uS = Q0.custom
  , cS = hI(uS) ? uS : null
  , D6 = function e(t, r, i, n) {
    var s = r || {};
    if (ts(s, "quoteStyle") && s.quoteStyle !== "single" && s.quoteStyle !== "double")
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (ts(s, "maxStringLength") && (typeof s.maxStringLength == "number" ? s.maxStringLength < 0 && s.maxStringLength !== 1 / 0 : s.maxStringLength !== null))
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var o = ts(s, "customInspect") ? s.customInspect : !0;
    if (typeof o != "boolean" && o !== "symbol")
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (ts(s, "indent") && s.indent !== null && s.indent !== "	" && !(parseInt(s.indent, 10) === s.indent && s.indent > 0))
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (ts(s, "numericSeparator") && typeof s.numericSeparator != "boolean")
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var a = s.numericSeparator;
    if (typeof t > "u")
        return "undefined";
    if (t === null)
        return "null";
    if (typeof t == "boolean")
        return t ? "true" : "false";
    if (typeof t == "string")
        return cI(t, s);
    if (typeof t == "number") {
        if (t === 0)
            return 1 / 0 / t > 0 ? "0" : "-0";
        var l = String(t);
        return a ? hS(t, l) : l
    }
    if (typeof t == "bigint") {
        var h = String(t) + "n";
        return a ? hS(t, h) : h
    }
    var u = typeof s.depth > "u" ? 5 : s.depth;
    if (typeof i > "u" && (i = 0),
    i >= u && u > 0 && typeof t == "object")
        return J0(t) ? "[Array]" : "[Object]";
    var c = J6(s, i);
    if (typeof n > "u")
        n = [];
    else if (uI(n, t) >= 0)
        return "[Circular]";
    function d(P, M, V) {
        if (M && (n = L6.call(n),
        n.push(M)),
        V) {
            var X = {
                depth: s.depth
            };
            return ts(s, "quoteStyle") && (X.quoteStyle = s.quoteStyle),
            e(P, X, i + 1, n)
        }
        return e(P, s, i + 1, n)
    }
    if (typeof t == "function" && !dS(t)) {
        var f = W6(t)
          , g = Sc(t, d);
        return "[Function" + (f ? ": " + f : " (anonymous)") + "]" + (g.length > 0 ? " { " + Xi.call(g, ", ") + " }" : "")
    }
    if (hI(t)) {
        var p = Ja ? hs.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : Z0.call(t);
        return typeof t == "object" && !Ja ? Il(p) : p
    }
    if (q6(t)) {
        for (var v = "<" + sS.call(String(t.nodeName)), y = t.attributes || [], m = 0; m < y.length; m++)
            v += " " + y[m].name + "=" + lI(B6(y[m].value), "double", s);
        return v += ">",
        t.childNodes && t.childNodes.length && (v += "..."),
        v += "</" + sS.call(String(t.nodeName)) + ">",
        v
    }
    if (J0(t)) {
        if (t.length === 0)
            return "[]";
        var _ = Sc(t, d);
        return c && !Q6(_) ? "[" + t_(_, c) + "]" : "[ " + Xi.call(_, ", ") + " ]"
    }
    if (F6(t)) {
        var x = Sc(t, d);
        return !("cause"in Error.prototype) && "cause"in t && !aI.call(t, "cause") ? "{ [" + String(t) + "] " + Xi.call(oS.call("[cause]: " + d(t.cause), x), ", ") + " }" : x.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + Xi.call(x, ", ") + " }"
    }
    if (typeof t == "object" && o) {
        if (cS && typeof t[cS] == "function" && Q0)
            return Q0(t, {
                depth: u - i
            });
        if (o !== "symbol" && typeof t.inspect == "function")
            return t.inspect()
    }
    if (V6(t)) {
        var E = [];
        return rS && rS.call(t, function(P, M) {
            E.push(d(M, t, !0) + " => " + d(P, t))
        }),
        fS("Map", df.call(t), E, c)
    }
    if (Y6(t)) {
        var S = [];
        return iS && iS.call(t, function(P) {
            S.push(d(P, t))
        }),
        fS("Set", ff.call(t), S, c)
    }
    if (j6(t))
        return Hm("WeakMap");
    if (K6(t))
        return Hm("WeakSet");
    if (X6(t))
        return Hm("WeakRef");
    if (G6(t))
        return Il(d(Number(t)));
    if ($6(t))
        return Il(d(q0.call(t)));
    if (H6(t))
        return Il(I6.call(t));
    if (U6(t))
        return Il(d(String(t)));
    if (!k6(t) && !dS(t)) {
        var w = Sc(t, d)
          , T = lS ? lS(t) === Object.prototype : t instanceof Object || t.constructor === Object
          , C = t instanceof Object ? "" : "null prototype"
          , R = !T && Xe && Object(t) === t && Xe in t ? Kv.call(Us(t), 8, -1) : C ? "Object" : ""
          , O = T || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : ""
          , N = O + (R || C ? "[" + Xi.call(oS.call([], R || [], C || []), ": ") + "] " : "");
        return w.length === 0 ? N + "{}" : c ? N + "{" + t_(w, c) + "}" : N + "{ " + Xi.call(w, ", ") + " }"
    }
    return String(t)
};
function lI(e, t, r) {
    var i = (r.quoteStyle || t) === "double" ? '"' : "'";
    return i + e + i
}
function B6(e) {
    return hs.call(String(e), /"/g, "&quot;")
}
function J0(e) {
    return Us(e) === "[object Array]" && (!Xe || !(typeof e == "object" && Xe in e))
}
function k6(e) {
    return Us(e) === "[object Date]" && (!Xe || !(typeof e == "object" && Xe in e))
}
function dS(e) {
    return Us(e) === "[object RegExp]" && (!Xe || !(typeof e == "object" && Xe in e))
}
function F6(e) {
    return Us(e) === "[object Error]" && (!Xe || !(typeof e == "object" && Xe in e))
}
function U6(e) {
    return Us(e) === "[object String]" && (!Xe || !(typeof e == "object" && Xe in e))
}
function G6(e) {
    return Us(e) === "[object Number]" && (!Xe || !(typeof e == "object" && Xe in e))
}
function H6(e) {
    return Us(e) === "[object Boolean]" && (!Xe || !(typeof e == "object" && Xe in e))
}
function hI(e) {
    if (Ja)
        return e && typeof e == "object" && e instanceof Symbol;
    if (typeof e == "symbol")
        return !0;
    if (!e || typeof e != "object" || !Z0)
        return !1;
    try {
        return Z0.call(e),
        !0
    } catch {}
    return !1
}
function $6(e) {
    if (!e || typeof e != "object" || !q0)
        return !1;
    try {
        return q0.call(e),
        !0
    } catch {}
    return !1
}
var z6 = Object.prototype.hasOwnProperty || function(e) {
    return e in this
}
;
function ts(e, t) {
    return z6.call(e, t)
}
function Us(e) {
    return R6.call(e)
}
function W6(e) {
    if (e.name)
        return e.name;
    var t = O6.call(M6.call(e), /^function\s*([\w$]+)/);
    return t ? t[1] : null
}
function uI(e, t) {
    if (e.indexOf)
        return e.indexOf(t);
    for (var r = 0, i = e.length; r < i; r++)
        if (e[r] === t)
            return r;
    return -1
}
function V6(e) {
    if (!df || !e || typeof e != "object")
        return !1;
    try {
        df.call(e);
        try {
            ff.call(e)
        } catch {
            return !0
        }
        return e instanceof Map
    } catch {}
    return !1
}
function j6(e) {
    if (!fh || !e || typeof e != "object")
        return !1;
    try {
        fh.call(e, fh);
        try {
            ph.call(e, ph)
        } catch {
            return !0
        }
        return e instanceof WeakMap
    } catch {}
    return !1
}
function X6(e) {
    if (!nS || !e || typeof e != "object")
        return !1;
    try {
        return nS.call(e),
        !0
    } catch {}
    return !1
}
function Y6(e) {
    if (!ff || !e || typeof e != "object")
        return !1;
    try {
        ff.call(e);
        try {
            df.call(e)
        } catch {
            return !0
        }
        return e instanceof Set
    } catch {}
    return !1
}
function K6(e) {
    if (!ph || !e || typeof e != "object")
        return !1;
    try {
        ph.call(e, ph);
        try {
            fh.call(e, fh)
        } catch {
            return !0
        }
        return e instanceof WeakSet
    } catch {}
    return !1
}
function q6(e) {
    return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function"
}
function cI(e, t) {
    if (e.length > t.maxStringLength) {
        var r = e.length - t.maxStringLength
          , i = "... " + r + " more character" + (r > 1 ? "s" : "");
        return cI(Kv.call(e, 0, t.maxStringLength), t) + i
    }
    var n = hs.call(hs.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Z6);
    return lI(n, "single", t)
}
function Z6(e) {
    var t = e.charCodeAt(0)
      , r = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
    }[t];
    return r ? "\\" + r : "\\x" + (t < 16 ? "0" : "") + N6.call(t.toString(16))
}
function Il(e) {
    return "Object(" + e + ")"
}
function Hm(e) {
    return e + " { ? }"
}
function fS(e, t, r, i) {
    var n = i ? t_(r, i) : Xi.call(r, ", ");
    return e + " (" + t + ") {" + n + "}"
}
function Q6(e) {
    for (var t = 0; t < e.length; t++)
        if (uI(e[t], `
`) >= 0)
            return !1;
    return !0
}
function J6(e, t) {
    var r;
    if (e.indent === "	")
        r = "	";
    else if (typeof e.indent == "number" && e.indent > 0)
        r = Xi.call(Array(e.indent + 1), " ");
    else
        return null;
    return {
        base: r,
        prev: Xi.call(Array(t + 1), r)
    }
}
function t_(e, t) {
    if (e.length === 0)
        return "";
    var r = `
` + t.prev + t.base;
    return r + Xi.call(e, "," + r) + `
` + t.prev
}
function Sc(e, t) {
    var r = J0(e)
      , i = [];
    if (r) {
        i.length = e.length;
        for (var n = 0; n < e.length; n++)
            i[n] = ts(e, n) ? t(e[n], e) : ""
    }
    var s = typeof Gm == "function" ? Gm(e) : [], o;
    if (Ja) {
        o = {};
        for (var a = 0; a < s.length; a++)
            o["$" + s[a]] = s[a]
    }
    for (var l in e)
        ts(e, l) && (r && String(Number(l)) === l && l < e.length || Ja && o["$" + l]instanceof Symbol || (oI.call(/[^\w$]/, l) ? i.push(t(l, e) + ": " + t(e[l], e)) : i.push(l + ": " + t(e[l], e))));
    if (typeof Gm == "function")
        for (var h = 0; h < s.length; h++)
            aI.call(e, s[h]) && i.push("[" + t(s[h]) + "]: " + t(e[s[h]], e));
    return i
}
var qv = jv
  , ml = T6
  , t$ = D6
  , e$ = qv("%TypeError%")
  , wc = qv("%WeakMap%", !0)
  , Ac = qv("%Map%", !0)
  , r$ = ml("WeakMap.prototype.get", !0)
  , i$ = ml("WeakMap.prototype.set", !0)
  , n$ = ml("WeakMap.prototype.has", !0)
  , s$ = ml("Map.prototype.get", !0)
  , o$ = ml("Map.prototype.set", !0)
  , a$ = ml("Map.prototype.has", !0)
  , Zv = function(e, t) {
    for (var r = e, i; (i = r.next) !== null; r = i)
        if (i.key === t)
            return r.next = i.next,
            i.next = e.next,
            e.next = i,
            i
}
  , l$ = function(e, t) {
    var r = Zv(e, t);
    return r && r.value
}
  , h$ = function(e, t, r) {
    var i = Zv(e, t);
    i ? i.value = r : e.next = {
        key: t,
        next: e.next,
        value: r
    }
}
  , u$ = function(e, t) {
    return !!Zv(e, t)
}
  , c$ = function() {
    var t, r, i, n = {
        assert: function(s) {
            if (!n.has(s))
                throw new e$("Side channel does not contain " + t$(s))
        },
        get: function(s) {
            if (wc && s && (typeof s == "object" || typeof s == "function")) {
                if (t)
                    return r$(t, s)
            } else if (Ac) {
                if (r)
                    return s$(r, s)
            } else if (i)
                return l$(i, s)
        },
        has: function(s) {
            if (wc && s && (typeof s == "object" || typeof s == "function")) {
                if (t)
                    return n$(t, s)
            } else if (Ac) {
                if (r)
                    return a$(r, s)
            } else if (i)
                return u$(i, s);
            return !1
        },
        set: function(s, o) {
            wc && s && (typeof s == "object" || typeof s == "function") ? (t || (t = new wc),
            i$(t, s, o)) : Ac ? (r || (r = new Ac),
            o$(r, s, o)) : (i || (i = {
                key: {},
                next: null
            }),
            h$(i, s, o))
        }
    };
    return n
}
  , d$ = String.prototype.replace
  , f$ = /%20/g
  , $m = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
}
  , Qv = {
    default: $m.RFC3986,
    formatters: {
        RFC1738: function(e) {
            return d$.call(e, f$, "+")
        },
        RFC3986: function(e) {
            return String(e)
        }
    },
    RFC1738: $m.RFC1738,
    RFC3986: $m.RFC3986
}
  , p$ = Qv
  , zm = Object.prototype.hasOwnProperty
  , io = Array.isArray
  , Gi = function() {
    for (var e = [], t = 0; t < 256; ++t)
        e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
    return e
}()
  , m$ = function(t) {
    for (; t.length > 1; ) {
        var r = t.pop()
          , i = r.obj[r.prop];
        if (io(i)) {
            for (var n = [], s = 0; s < i.length; ++s)
                typeof i[s] < "u" && n.push(i[s]);
            r.obj[r.prop] = n
        }
    }
}
  , dI = function(t, r) {
    for (var i = r && r.plainObjects ? Object.create(null) : {}, n = 0; n < t.length; ++n)
        typeof t[n] < "u" && (i[n] = t[n]);
    return i
}
  , g$ = function e(t, r, i) {
    if (!r)
        return t;
    if (typeof r != "object") {
        if (io(t))
            t.push(r);
        else if (t && typeof t == "object")
            (i && (i.plainObjects || i.allowPrototypes) || !zm.call(Object.prototype, r)) && (t[r] = !0);
        else
            return [t, r];
        return t
    }
    if (!t || typeof t != "object")
        return [t].concat(r);
    var n = t;
    return io(t) && !io(r) && (n = dI(t, i)),
    io(t) && io(r) ? (r.forEach(function(s, o) {
        if (zm.call(t, o)) {
            var a = t[o];
            a && typeof a == "object" && s && typeof s == "object" ? t[o] = e(a, s, i) : t.push(s)
        } else
            t[o] = s
    }),
    t) : Object.keys(r).reduce(function(s, o) {
        var a = r[o];
        return zm.call(s, o) ? s[o] = e(s[o], a, i) : s[o] = a,
        s
    }, n)
}
  , _$ = function(t, r) {
    return Object.keys(r).reduce(function(i, n) {
        return i[n] = r[n],
        i
    }, t)
}
  , y$ = function(e, t, r) {
    var i = e.replace(/\+/g, " ");
    if (r === "iso-8859-1")
        return i.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
        return decodeURIComponent(i)
    } catch {
        return i
    }
}
  , v$ = function(t, r, i, n, s) {
    if (t.length === 0)
        return t;
    var o = t;
    if (typeof t == "symbol" ? o = Symbol.prototype.toString.call(t) : typeof t != "string" && (o = String(t)),
    i === "iso-8859-1")
        return escape(o).replace(/%u[0-9a-f]{4}/gi, function(u) {
            return "%26%23" + parseInt(u.slice(2), 16) + "%3B"
        });
    for (var a = "", l = 0; l < o.length; ++l) {
        var h = o.charCodeAt(l);
        if (h === 45 || h === 46 || h === 95 || h === 126 || h >= 48 && h <= 57 || h >= 65 && h <= 90 || h >= 97 && h <= 122 || s === p$.RFC1738 && (h === 40 || h === 41)) {
            a += o.charAt(l);
            continue
        }
        if (h < 128) {
            a = a + Gi[h];
            continue
        }
        if (h < 2048) {
            a = a + (Gi[192 | h >> 6] + Gi[128 | h & 63]);
            continue
        }
        if (h < 55296 || h >= 57344) {
            a = a + (Gi[224 | h >> 12] + Gi[128 | h >> 6 & 63] + Gi[128 | h & 63]);
            continue
        }
        l += 1,
        h = 65536 + ((h & 1023) << 10 | o.charCodeAt(l) & 1023),
        a += Gi[240 | h >> 18] + Gi[128 | h >> 12 & 63] + Gi[128 | h >> 6 & 63] + Gi[128 | h & 63]
    }
    return a
}
  , x$ = function(t) {
    for (var r = [{
        obj: {
            o: t
        },
        prop: "o"
    }], i = [], n = 0; n < r.length; ++n)
        for (var s = r[n], o = s.obj[s.prop], a = Object.keys(o), l = 0; l < a.length; ++l) {
            var h = a[l]
              , u = o[h];
            typeof u == "object" && u !== null && i.indexOf(u) === -1 && (r.push({
                obj: o,
                prop: h
            }),
            i.push(u))
        }
    return m$(r),
    t
}
  , E$ = function(t) {
    return Object.prototype.toString.call(t) === "[object RegExp]"
}
  , T$ = function(t) {
    return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t))
}
  , S$ = function(t, r) {
    return [].concat(t, r)
}
  , w$ = function(t, r) {
    if (io(t)) {
        for (var i = [], n = 0; n < t.length; n += 1)
            i.push(r(t[n]));
        return i
    }
    return r(t)
}
  , fI = {
    arrayToObject: dI,
    assign: _$,
    combine: S$,
    compact: x$,
    decode: y$,
    encode: v$,
    isBuffer: T$,
    isRegExp: E$,
    maybeMap: w$,
    merge: g$
}
  , pI = c$
  , pd = fI
  , mh = Qv
  , A$ = Object.prototype.hasOwnProperty
  , pS = {
    brackets: function(t) {
        return t + "[]"
    },
    comma: "comma",
    indices: function(t, r) {
        return t + "[" + r + "]"
    },
    repeat: function(t) {
        return t
    }
}
  , Tn = Array.isArray
  , b$ = Array.prototype.push
  , mI = function(e, t) {
    b$.apply(e, Tn(t) ? t : [t])
}
  , C$ = Date.prototype.toISOString
  , mS = mh.default
  , Ue = {
    addQueryPrefix: !1,
    allowDots: !1,
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encoder: pd.encode,
    encodeValuesOnly: !1,
    format: mS,
    formatter: mh.formatters[mS],
    indices: !1,
    serializeDate: function(t) {
        return C$.call(t)
    },
    skipNulls: !1,
    strictNullHandling: !1
}
  , P$ = function(t) {
    return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint"
}
  , Wm = {}
  , I$ = function e(t, r, i, n, s, o, a, l, h, u, c, d, f, g, p, v) {
    for (var y = t, m = v, _ = 0, x = !1; (m = m.get(Wm)) !== void 0 && !x; ) {
        var E = m.get(t);
        if (_ += 1,
        typeof E < "u") {
            if (E === _)
                throw new RangeError("Cyclic object value");
            x = !0
        }
        typeof m.get(Wm) > "u" && (_ = 0)
    }
    if (typeof l == "function" ? y = l(r, y) : y instanceof Date ? y = c(y) : i === "comma" && Tn(y) && (y = pd.maybeMap(y, function(X) {
        return X instanceof Date ? c(X) : X
    })),
    y === null) {
        if (s)
            return a && !g ? a(r, Ue.encoder, p, "key", d) : r;
        y = ""
    }
    if (P$(y) || pd.isBuffer(y)) {
        if (a) {
            var S = g ? r : a(r, Ue.encoder, p, "key", d);
            return [f(S) + "=" + f(a(y, Ue.encoder, p, "value", d))]
        }
        return [f(r) + "=" + f(String(y))]
    }
    var w = [];
    if (typeof y > "u")
        return w;
    var T;
    if (i === "comma" && Tn(y))
        g && a && (y = pd.maybeMap(y, a)),
        T = [{
            value: y.length > 0 ? y.join(",") || null : void 0
        }];
    else if (Tn(l))
        T = l;
    else {
        var C = Object.keys(y);
        T = h ? C.sort(h) : C
    }
    for (var R = n && Tn(y) && y.length === 1 ? r + "[]" : r, O = 0; O < T.length; ++O) {
        var N = T[O]
          , P = typeof N == "object" && typeof N.value < "u" ? N.value : y[N];
        if (!(o && P === null)) {
            var M = Tn(y) ? typeof i == "function" ? i(R, N) : R : R + (u ? "." + N : "[" + N + "]");
            v.set(t, _);
            var V = pI();
            V.set(Wm, v),
            mI(w, e(P, M, i, n, s, o, i === "comma" && g && Tn(y) ? null : a, l, h, u, c, d, f, g, p, V))
        }
    }
    return w
}
  , R$ = function(t) {
    if (!t)
        return Ue;
    if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
        throw new TypeError("Encoder has to be a function.");
    var r = t.charset || Ue.charset;
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var i = mh.default;
    if (typeof t.format < "u") {
        if (!A$.call(mh.formatters, t.format))
            throw new TypeError("Unknown format option provided.");
        i = t.format
    }
    var n = mh.formatters[i]
      , s = Ue.filter;
    return (typeof t.filter == "function" || Tn(t.filter)) && (s = t.filter),
    {
        addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : Ue.addQueryPrefix,
        allowDots: typeof t.allowDots > "u" ? Ue.allowDots : !!t.allowDots,
        charset: r,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Ue.charsetSentinel,
        delimiter: typeof t.delimiter > "u" ? Ue.delimiter : t.delimiter,
        encode: typeof t.encode == "boolean" ? t.encode : Ue.encode,
        encoder: typeof t.encoder == "function" ? t.encoder : Ue.encoder,
        encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : Ue.encodeValuesOnly,
        filter: s,
        format: i,
        formatter: n,
        serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : Ue.serializeDate,
        skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Ue.skipNulls,
        sort: typeof t.sort == "function" ? t.sort : null,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Ue.strictNullHandling
    }
}
  , M$ = function(e, t) {
    var r = e, i = R$(t), n, s;
    typeof i.filter == "function" ? (s = i.filter,
    r = s("", r)) : Tn(i.filter) && (s = i.filter,
    n = s);
    var o = [];
    if (typeof r != "object" || r === null)
        return "";
    var a;
    t && t.arrayFormat in pS ? a = t.arrayFormat : t && "indices"in t ? a = t.indices ? "indices" : "repeat" : a = "indices";
    var l = pS[a];
    if (t && "commaRoundTrip"in t && typeof t.commaRoundTrip != "boolean")
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var h = l === "comma" && t && t.commaRoundTrip;
    n || (n = Object.keys(r)),
    i.sort && n.sort(i.sort);
    for (var u = pI(), c = 0; c < n.length; ++c) {
        var d = n[c];
        i.skipNulls && r[d] === null || mI(o, I$(r[d], d, l, h, i.strictNullHandling, i.skipNulls, i.encode ? i.encoder : null, i.filter, i.sort, i.allowDots, i.serializeDate, i.format, i.formatter, i.encodeValuesOnly, i.charset, u))
    }
    var f = o.join(i.delimiter)
      , g = i.addQueryPrefix === !0 ? "?" : "";
    return i.charsetSentinel && (i.charset === "iso-8859-1" ? g += "utf8=%26%2310003%3B&" : g += "utf8=%E2%9C%93&"),
    f.length > 0 ? g + f : ""
}
  , tl = fI
  , e_ = Object.prototype.hasOwnProperty
  , O$ = Array.isArray
  , xe = {
    allowDots: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decoder: tl.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictNullHandling: !1
}
  , N$ = function(e) {
    return e.replace(/&#(\d+);/g, function(t, r) {
        return String.fromCharCode(parseInt(r, 10))
    })
}
  , gI = function(e, t) {
    return e && typeof e == "string" && t.comma && e.indexOf(",") > -1 ? e.split(",") : e
}
  , L$ = "utf8=%26%2310003%3B"
  , D$ = "utf8=%E2%9C%93"
  , B$ = function(t, r) {
    var i = {
        __proto__: null
    }, n = r.ignoreQueryPrefix ? t.replace(/^\?/, "") : t, s = r.parameterLimit === 1 / 0 ? void 0 : r.parameterLimit, o = n.split(r.delimiter, s), a = -1, l, h = r.charset;
    if (r.charsetSentinel)
        for (l = 0; l < o.length; ++l)
            o[l].indexOf("utf8=") === 0 && (o[l] === D$ ? h = "utf-8" : o[l] === L$ && (h = "iso-8859-1"),
            a = l,
            l = o.length);
    for (l = 0; l < o.length; ++l)
        if (l !== a) {
            var u = o[l], c = u.indexOf("]="), d = c === -1 ? u.indexOf("=") : c + 1, f, g;
            d === -1 ? (f = r.decoder(u, xe.decoder, h, "key"),
            g = r.strictNullHandling ? null : "") : (f = r.decoder(u.slice(0, d), xe.decoder, h, "key"),
            g = tl.maybeMap(gI(u.slice(d + 1), r), function(p) {
                return r.decoder(p, xe.decoder, h, "value")
            })),
            g && r.interpretNumericEntities && h === "iso-8859-1" && (g = N$(g)),
            u.indexOf("[]=") > -1 && (g = O$(g) ? [g] : g),
            e_.call(i, f) ? i[f] = tl.combine(i[f], g) : i[f] = g
        }
    return i
}
  , k$ = function(e, t, r, i) {
    for (var n = i ? t : gI(t, r), s = e.length - 1; s >= 0; --s) {
        var o, a = e[s];
        if (a === "[]" && r.parseArrays)
            o = [].concat(n);
        else {
            o = r.plainObjects ? Object.create(null) : {};
            var l = a.charAt(0) === "[" && a.charAt(a.length - 1) === "]" ? a.slice(1, -1) : a
              , h = parseInt(l, 10);
            !r.parseArrays && l === "" ? o = {
                0: n
            } : !isNaN(h) && a !== l && String(h) === l && h >= 0 && r.parseArrays && h <= r.arrayLimit ? (o = [],
            o[h] = n) : l !== "__proto__" && (o[l] = n)
        }
        n = o
    }
    return n
}
  , F$ = function(t, r, i, n) {
    if (t) {
        var s = i.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t
          , o = /(\[[^[\]]*])/
          , a = /(\[[^[\]]*])/g
          , l = i.depth > 0 && o.exec(s)
          , h = l ? s.slice(0, l.index) : s
          , u = [];
        if (h) {
            if (!i.plainObjects && e_.call(Object.prototype, h) && !i.allowPrototypes)
                return;
            u.push(h)
        }
        for (var c = 0; i.depth > 0 && (l = a.exec(s)) !== null && c < i.depth; ) {
            if (c += 1,
            !i.plainObjects && e_.call(Object.prototype, l[1].slice(1, -1)) && !i.allowPrototypes)
                return;
            u.push(l[1])
        }
        return l && u.push("[" + s.slice(l.index) + "]"),
        k$(u, r, i, n)
    }
}
  , U$ = function(t) {
    if (!t)
        return xe;
    if (t.decoder !== null && t.decoder !== void 0 && typeof t.decoder != "function")
        throw new TypeError("Decoder has to be a function.");
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var r = typeof t.charset > "u" ? xe.charset : t.charset;
    return {
        allowDots: typeof t.allowDots > "u" ? xe.allowDots : !!t.allowDots,
        allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : xe.allowPrototypes,
        allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : xe.allowSparse,
        arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : xe.arrayLimit,
        charset: r,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : xe.charsetSentinel,
        comma: typeof t.comma == "boolean" ? t.comma : xe.comma,
        decoder: typeof t.decoder == "function" ? t.decoder : xe.decoder,
        delimiter: typeof t.delimiter == "string" || tl.isRegExp(t.delimiter) ? t.delimiter : xe.delimiter,
        depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : xe.depth,
        ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
        interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : xe.interpretNumericEntities,
        parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : xe.parameterLimit,
        parseArrays: t.parseArrays !== !1,
        plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : xe.plainObjects,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : xe.strictNullHandling
    }
}
  , G$ = function(e, t) {
    var r = U$(t);
    if (e === "" || e === null || typeof e > "u")
        return r.plainObjects ? Object.create(null) : {};
    for (var i = typeof e == "string" ? B$(e, r) : e, n = r.plainObjects ? Object.create(null) : {}, s = Object.keys(i), o = 0; o < s.length; ++o) {
        var a = s[o]
          , l = F$(a, i[a], r, typeof e == "string");
        n = tl.merge(n, l, r)
    }
    return r.allowSparse === !0 ? n : tl.compact(n)
}
  , H$ = M$
  , $$ = G$
  , z$ = Qv
  , W$ = {
    formats: z$,
    parse: $$,
    stringify: H$
}
  , V$ = KH;
function Ii() {
    this.protocol = null,
    this.slashes = null,
    this.auth = null,
    this.host = null,
    this.port = null,
    this.hostname = null,
    this.hash = null,
    this.search = null,
    this.query = null,
    this.pathname = null,
    this.path = null,
    this.href = null
}
var j$ = /^([a-z0-9.+-]+:)/i
  , X$ = /:[0-9]*$/
  , Y$ = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/
  , K$ = ["<", ">", '"', "`", " ", "\r", `
`, "	"]
  , q$ = ["{", "}", "|", "\\", "^", "`"].concat(K$)
  , r_ = ["'"].concat(q$)
  , gS = ["%", "/", "?", ";", "#"].concat(r_)
  , _S = ["/", "?", "#"]
  , Z$ = 255
  , yS = /^[+a-z0-9A-Z_-]{0,63}$/
  , Q$ = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
  , J$ = {
    javascript: !0,
    "javascript:": !0
}
  , i_ = {
    javascript: !0,
    "javascript:": !0
}
  , Oa = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
}
  , n_ = W$;
function Mp(e, t, r) {
    if (e && typeof e == "object" && e instanceof Ii)
        return e;
    var i = new Ii;
    return i.parse(e, t, r),
    i
}
Ii.prototype.parse = function(e, t, r) {
    if (typeof e != "string")
        throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
    var i = e.indexOf("?")
      , n = i !== -1 && i < e.indexOf("#") ? "?" : "#"
      , s = e.split(n)
      , o = /\\/g;
    s[0] = s[0].replace(o, "/"),
    e = s.join(n);
    var a = e;
    if (a = a.trim(),
    !r && e.split("#").length === 1) {
        var l = Y$.exec(a);
        if (l)
            return this.path = a,
            this.href = a,
            this.pathname = l[1],
            l[2] ? (this.search = l[2],
            t ? this.query = n_.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "",
            this.query = {}),
            this
    }
    var h = j$.exec(a);
    if (h) {
        h = h[0];
        var u = h.toLowerCase();
        this.protocol = u,
        a = a.substr(h.length)
    }
    if (r || h || a.match(/^\/\/[^@/]+@[^@/]+/)) {
        var c = a.substr(0, 2) === "//";
        c && !(h && i_[h]) && (a = a.substr(2),
        this.slashes = !0)
    }
    if (!i_[h] && (c || h && !Oa[h])) {
        for (var d = -1, f = 0; f < _S.length; f++) {
            var g = a.indexOf(_S[f]);
            g !== -1 && (d === -1 || g < d) && (d = g)
        }
        var p, v;
        d === -1 ? v = a.lastIndexOf("@") : v = a.lastIndexOf("@", d),
        v !== -1 && (p = a.slice(0, v),
        a = a.slice(v + 1),
        this.auth = decodeURIComponent(p)),
        d = -1;
        for (var f = 0; f < gS.length; f++) {
            var g = a.indexOf(gS[f]);
            g !== -1 && (d === -1 || g < d) && (d = g)
        }
        d === -1 && (d = a.length),
        this.host = a.slice(0, d),
        a = a.slice(d),
        this.parseHost(),
        this.hostname = this.hostname || "";
        var y = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!y)
            for (var m = this.hostname.split(/\./), f = 0, _ = m.length; f < _; f++) {
                var x = m[f];
                if (x && !x.match(yS)) {
                    for (var E = "", S = 0, w = x.length; S < w; S++)
                        x.charCodeAt(S) > 127 ? E += "x" : E += x[S];
                    if (!E.match(yS)) {
                        var T = m.slice(0, f)
                          , C = m.slice(f + 1)
                          , R = x.match(Q$);
                        R && (T.push(R[1]),
                        C.unshift(R[2])),
                        C.length && (a = "/" + C.join(".") + a),
                        this.hostname = T.join(".");
                        break
                    }
                }
            }
        this.hostname.length > Z$ ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(),
        y || (this.hostname = V$.toASCII(this.hostname));
        var O = this.port ? ":" + this.port : ""
          , N = this.hostname || "";
        this.host = N + O,
        this.href += this.host,
        y && (this.hostname = this.hostname.substr(1, this.hostname.length - 2),
        a[0] !== "/" && (a = "/" + a))
    }
    if (!J$[u])
        for (var f = 0, _ = r_.length; f < _; f++) {
            var P = r_[f];
            if (a.indexOf(P) !== -1) {
                var M = encodeURIComponent(P);
                M === P && (M = escape(P)),
                a = a.split(P).join(M)
            }
        }
    var V = a.indexOf("#");
    V !== -1 && (this.hash = a.substr(V),
    a = a.slice(0, V));
    var X = a.indexOf("?");
    if (X !== -1 ? (this.search = a.substr(X),
    this.query = a.substr(X + 1),
    t && (this.query = n_.parse(this.query)),
    a = a.slice(0, X)) : t && (this.search = "",
    this.query = {}),
    a && (this.pathname = a),
    Oa[u] && this.hostname && !this.pathname && (this.pathname = "/"),
    this.pathname || this.search) {
        var O = this.pathname || ""
          , k = this.search || "";
        this.path = O + k
    }
    return this.href = this.format(),
    this
}
;
function t8(e) {
    return typeof e == "string" && (e = Mp(e)),
    e instanceof Ii ? e.format() : Ii.prototype.format.call(e)
}
Ii.prototype.format = function() {
    var e = this.auth || "";
    e && (e = encodeURIComponent(e),
    e = e.replace(/%3A/i, ":"),
    e += "@");
    var t = this.protocol || ""
      , r = this.pathname || ""
      , i = this.hash || ""
      , n = !1
      , s = "";
    this.host ? n = e + this.host : this.hostname && (n = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"),
    this.port && (n += ":" + this.port)),
    this.query && typeof this.query == "object" && Object.keys(this.query).length && (s = n_.stringify(this.query, {
        arrayFormat: "repeat",
        addQueryPrefix: !1
    }));
    var o = this.search || s && "?" + s || "";
    return t && t.substr(-1) !== ":" && (t += ":"),
    this.slashes || (!t || Oa[t]) && n !== !1 ? (n = "//" + (n || ""),
    r && r.charAt(0) !== "/" && (r = "/" + r)) : n || (n = ""),
    i && i.charAt(0) !== "#" && (i = "#" + i),
    o && o.charAt(0) !== "?" && (o = "?" + o),
    r = r.replace(/[?#]/g, function(a) {
        return encodeURIComponent(a)
    }),
    o = o.replace("#", "%23"),
    t + n + r + o + i
}
;
function e8(e, t) {
    return Mp(e, !1, !0).resolve(t)
}
Ii.prototype.resolve = function(e) {
    return this.resolveObject(Mp(e, !1, !0)).format()
}
;
Ii.prototype.resolveObject = function(e) {
    if (typeof e == "string") {
        var t = new Ii;
        t.parse(e, !1, !0),
        e = t
    }
    for (var r = new Ii, i = Object.keys(this), n = 0; n < i.length; n++) {
        var s = i[n];
        r[s] = this[s]
    }
    if (r.hash = e.hash,
    e.href === "")
        return r.href = r.format(),
        r;
    if (e.slashes && !e.protocol) {
        for (var o = Object.keys(e), a = 0; a < o.length; a++) {
            var l = o[a];
            l !== "protocol" && (r[l] = e[l])
        }
        return Oa[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/",
        r.path = r.pathname),
        r.href = r.format(),
        r
    }
    if (e.protocol && e.protocol !== r.protocol) {
        if (!Oa[e.protocol]) {
            for (var h = Object.keys(e), u = 0; u < h.length; u++) {
                var c = h[u];
                r[c] = e[c]
            }
            return r.href = r.format(),
            r
        }
        if (r.protocol = e.protocol,
        !e.host && !i_[e.protocol]) {
            for (var _ = (e.pathname || "").split("/"); _.length && !(e.host = _.shift()); )
                ;
            e.host || (e.host = ""),
            e.hostname || (e.hostname = ""),
            _[0] !== "" && _.unshift(""),
            _.length < 2 && _.unshift(""),
            r.pathname = _.join("/")
        } else
            r.pathname = e.pathname;
        if (r.search = e.search,
        r.query = e.query,
        r.host = e.host || "",
        r.auth = e.auth,
        r.hostname = e.hostname || e.host,
        r.port = e.port,
        r.pathname || r.search) {
            var d = r.pathname || ""
              , f = r.search || "";
            r.path = d + f
        }
        return r.slashes = r.slashes || e.slashes,
        r.href = r.format(),
        r
    }
    var g = r.pathname && r.pathname.charAt(0) === "/"
      , p = e.host || e.pathname && e.pathname.charAt(0) === "/"
      , v = p || g || r.host && e.pathname
      , y = v
      , m = r.pathname && r.pathname.split("/") || []
      , _ = e.pathname && e.pathname.split("/") || []
      , x = r.protocol && !Oa[r.protocol];
    if (x && (r.hostname = "",
    r.port = null,
    r.host && (m[0] === "" ? m[0] = r.host : m.unshift(r.host)),
    r.host = "",
    e.protocol && (e.hostname = null,
    e.port = null,
    e.host && (_[0] === "" ? _[0] = e.host : _.unshift(e.host)),
    e.host = null),
    v = v && (_[0] === "" || m[0] === "")),
    p)
        r.host = e.host || e.host === "" ? e.host : r.host,
        r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname,
        r.search = e.search,
        r.query = e.query,
        m = _;
    else if (_.length)
        m || (m = []),
        m.pop(),
        m = m.concat(_),
        r.search = e.search,
        r.query = e.query;
    else if (e.search != null) {
        if (x) {
            r.host = m.shift(),
            r.hostname = r.host;
            var E = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
            E && (r.auth = E.shift(),
            r.hostname = E.shift(),
            r.host = r.hostname)
        }
        return r.search = e.search,
        r.query = e.query,
        (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")),
        r.href = r.format(),
        r
    }
    if (!m.length)
        return r.pathname = null,
        r.search ? r.path = "/" + r.search : r.path = null,
        r.href = r.format(),
        r;
    for (var S = m.slice(-1)[0], w = (r.host || e.host || m.length > 1) && (S === "." || S === "..") || S === "", T = 0, C = m.length; C >= 0; C--)
        S = m[C],
        S === "." ? m.splice(C, 1) : S === ".." ? (m.splice(C, 1),
        T++) : T && (m.splice(C, 1),
        T--);
    if (!v && !y)
        for (; T--; T)
            m.unshift("..");
    v && m[0] !== "" && (!m[0] || m[0].charAt(0) !== "/") && m.unshift(""),
    w && m.join("/").substr(-1) !== "/" && m.push("");
    var R = m[0] === "" || m[0] && m[0].charAt(0) === "/";
    if (x) {
        r.hostname = R ? "" : m.length ? m.shift() : "",
        r.host = r.hostname;
        var E = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
        E && (r.auth = E.shift(),
        r.hostname = E.shift(),
        r.host = r.hostname)
    }
    return v = v || r.host && m.length,
    v && !R && m.unshift(""),
    m.length > 0 ? r.pathname = m.join("/") : (r.pathname = null,
    r.path = null),
    (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")),
    r.auth = e.auth || r.auth,
    r.slashes = r.slashes || e.slashes,
    r.href = r.format(),
    r
}
;
Ii.prototype.parseHost = function() {
    var e = this.host
      , t = X$.exec(e);
    t && (t = t[0],
    t !== ":" && (this.port = t.substr(1)),
    e = e.substr(0, e.length - t.length)),
    e && (this.hostname = e)
}
;
var r8 = Mp
  , i8 = e8
  , n8 = t8;
const vS = {};
function et(e, t, r=3) {
    if (vS[t])
        return;
    let i = new Error().stack;
    typeof i > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${e}`) : (i = i.split(`
`).splice(r).join(`
`),
    console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${e}`),
    console.warn(i),
    console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${e}`),
    console.warn(i))),
    vS[t] = !0
}
const s8 = {
    get parse() {
        return et("7.3.0", "utils.url.parse is deprecated, use native URL API instead."),
        r8
    },
    get format() {
        return et("7.3.0", "utils.url.format is deprecated, use native URL API instead."),
        n8
    },
    get resolve() {
        return et("7.3.0", "utils.url.resolve is deprecated, use native URL API instead."),
        i8
    }
};
function fi(e) {
    if (typeof e != "string")
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(e)}`)
}
function Rl(e) {
    return e.split("?")[0].split("#")[0]
}
function o8(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}
function a8(e, t, r) {
    return e.replace(new RegExp(o8(t),"g"), r)
}
function l8(e, t) {
    let r = ""
      , i = 0
      , n = -1
      , s = 0
      , o = -1;
    for (let a = 0; a <= e.length; ++a) {
        if (a < e.length)
            o = e.charCodeAt(a);
        else {
            if (o === 47)
                break;
            o = 47
        }
        if (o === 47) {
            if (!(n === a - 1 || s === 1))
                if (n !== a - 1 && s === 2) {
                    if (r.length < 2 || i !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
                        if (r.length > 2) {
                            const l = r.lastIndexOf("/");
                            if (l !== r.length - 1) {
                                l === -1 ? (r = "",
                                i = 0) : (r = r.slice(0, l),
                                i = r.length - 1 - r.lastIndexOf("/")),
                                n = a,
                                s = 0;
                                continue
                            }
                        } else if (r.length === 2 || r.length === 1) {
                            r = "",
                            i = 0,
                            n = a,
                            s = 0;
                            continue
                        }
                    }
                    t && (r.length > 0 ? r += "/.." : r = "..",
                    i = 2)
                } else
                    r.length > 0 ? r += `/${e.slice(n + 1, a)}` : r = e.slice(n + 1, a),
                    i = a - n - 1;
            n = a,
            s = 0
        } else
            o === 46 && s !== -1 ? ++s : s = -1
    }
    return r
}
const fe = {
    toPosix(e) {
        return a8(e, "\\", "/")
    },
    isUrl(e) {
        return /^https?:/.test(this.toPosix(e))
    },
    isDataUrl(e) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(e)
    },
    isBlobUrl(e) {
        return e.startsWith("blob:")
    },
    hasProtocol(e) {
        return /^[^/:]+:/.test(this.toPosix(e))
    },
    getProtocol(e) {
        fi(e),
        e = this.toPosix(e);
        const t = /^file:\/\/\//.exec(e);
        if (t)
            return t[0];
        const r = /^[^/:]+:\/{0,2}/.exec(e);
        return r ? r[0] : ""
    },
    toAbsolute(e, t, r) {
        if (fi(e),
        this.isDataUrl(e) || this.isBlobUrl(e))
            return e;
        const i = Rl(this.toPosix(t ?? z.ADAPTER.getBaseUrl()))
          , n = Rl(this.toPosix(r ?? this.rootname(i)));
        return e = this.toPosix(e),
        e.startsWith("/") ? fe.join(n, e.slice(1)) : this.isAbsolute(e) ? e : this.join(i, e)
    },
    normalize(e) {
        if (fi(e),
        e.length === 0)
            return ".";
        if (this.isDataUrl(e) || this.isBlobUrl(e))
            return e;
        e = this.toPosix(e);
        let t = "";
        const r = e.startsWith("/");
        this.hasProtocol(e) && (t = this.rootname(e),
        e = e.slice(t.length));
        const i = e.endsWith("/");
        return e = l8(e, !1),
        e.length > 0 && i && (e += "/"),
        r ? `/${e}` : t + e
    },
    isAbsolute(e) {
        return fi(e),
        e = this.toPosix(e),
        this.hasProtocol(e) ? !0 : e.startsWith("/")
    },
    join(...e) {
        if (e.length === 0)
            return ".";
        let t;
        for (let r = 0; r < e.length; ++r) {
            const i = e[r];
            if (fi(i),
            i.length > 0)
                if (t === void 0)
                    t = i;
                else {
                    const n = e[r - 1] ?? "";
                    this.extname(n) ? t += `/../${i}` : t += `/${i}`
                }
        }
        return t === void 0 ? "." : this.normalize(t)
    },
    dirname(e) {
        if (fi(e),
        e.length === 0)
            return ".";
        e = this.toPosix(e);
        let t = e.charCodeAt(0);
        const r = t === 47;
        let i = -1
          , n = !0;
        const s = this.getProtocol(e)
          , o = e;
        e = e.slice(s.length);
        for (let a = e.length - 1; a >= 1; --a)
            if (t = e.charCodeAt(a),
            t === 47) {
                if (!n) {
                    i = a;
                    break
                }
            } else
                n = !1;
        return i === -1 ? r ? "/" : this.isUrl(o) ? s + e : s : r && i === 1 ? "//" : s + e.slice(0, i)
    },
    rootname(e) {
        fi(e),
        e = this.toPosix(e);
        let t = "";
        if (e.startsWith("/") ? t = "/" : t = this.getProtocol(e),
        this.isUrl(e)) {
            const r = e.indexOf("/", t.length);
            r !== -1 ? t = e.slice(0, r) : t = e,
            t.endsWith("/") || (t += "/")
        }
        return t
    },
    basename(e, t) {
        fi(e),
        t && fi(t),
        e = Rl(this.toPosix(e));
        let r = 0, i = -1, n = !0, s;
        if (t !== void 0 && t.length > 0 && t.length <= e.length) {
            if (t.length === e.length && t === e)
                return "";
            let o = t.length - 1
              , a = -1;
            for (s = e.length - 1; s >= 0; --s) {
                const l = e.charCodeAt(s);
                if (l === 47) {
                    if (!n) {
                        r = s + 1;
                        break
                    }
                } else
                    a === -1 && (n = !1,
                    a = s + 1),
                    o >= 0 && (l === t.charCodeAt(o) ? --o === -1 && (i = s) : (o = -1,
                    i = a))
            }
            return r === i ? i = a : i === -1 && (i = e.length),
            e.slice(r, i)
        }
        for (s = e.length - 1; s >= 0; --s)
            if (e.charCodeAt(s) === 47) {
                if (!n) {
                    r = s + 1;
                    break
                }
            } else
                i === -1 && (n = !1,
                i = s + 1);
        return i === -1 ? "" : e.slice(r, i)
    },
    extname(e) {
        fi(e),
        e = Rl(this.toPosix(e));
        let t = -1
          , r = 0
          , i = -1
          , n = !0
          , s = 0;
        for (let o = e.length - 1; o >= 0; --o) {
            const a = e.charCodeAt(o);
            if (a === 47) {
                if (!n) {
                    r = o + 1;
                    break
                }
                continue
            }
            i === -1 && (n = !1,
            i = o + 1),
            a === 46 ? t === -1 ? t = o : s !== 1 && (s = 1) : t !== -1 && (s = -1)
        }
        return t === -1 || i === -1 || s === 0 || s === 1 && t === i - 1 && t === r + 1 ? "" : e.slice(t, i)
    },
    parse(e) {
        fi(e);
        const t = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (e.length === 0)
            return t;
        e = Rl(this.toPosix(e));
        let r = e.charCodeAt(0);
        const i = this.isAbsolute(e);
        let n;
        t.root = this.rootname(e),
        i || this.hasProtocol(e) ? n = 1 : n = 0;
        let s = -1
          , o = 0
          , a = -1
          , l = !0
          , h = e.length - 1
          , u = 0;
        for (; h >= n; --h) {
            if (r = e.charCodeAt(h),
            r === 47) {
                if (!l) {
                    o = h + 1;
                    break
                }
                continue
            }
            a === -1 && (l = !1,
            a = h + 1),
            r === 46 ? s === -1 ? s = h : u !== 1 && (u = 1) : s !== -1 && (u = -1)
        }
        return s === -1 || a === -1 || u === 0 || u === 1 && s === a - 1 && s === o + 1 ? a !== -1 && (o === 0 && i ? t.base = t.name = e.slice(1, a) : t.base = t.name = e.slice(o, a)) : (o === 0 && i ? (t.name = e.slice(1, s),
        t.base = e.slice(1, a)) : (t.name = e.slice(o, s),
        t.base = e.slice(o, a)),
        t.ext = e.slice(s, a)),
        t.dir = this.dirname(e),
        t
    },
    sep: "/",
    delimiter: ":"
};
let Vm;
async function _I() {
    return Vm ?? (Vm = (async () => {
        const e = document.createElement("canvas").getContext("webgl");
        if (!e)
            return tr.UNPACK;
        const t = await new Promise(s => {
            const o = document.createElement("video");
            o.onloadeddata = () => s(o),
            o.onerror = () => s(null),
            o.autoplay = !1,
            o.crossOrigin = "anonymous",
            o.preload = "auto",
            o.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",
            o.load()
        }
        );
        if (!t)
            return tr.UNPACK;
        const r = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, r);
        const i = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, i),
        e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0),
        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
        e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE),
        e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
        const n = new Uint8Array(4);
        return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, n),
        e.deleteFramebuffer(i),
        e.deleteTexture(r),
        e.getExtension("WEBGL_lose_context")?.loseContext(),
        n[0] <= n[3] ? tr.PMA : tr.UNPACK
    }
    )()),
    Vm
}
function h8() {
    et("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello")
}
function u8() {
    et("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`)
}
let jm;
function yI() {
    return typeof jm > "u" && (jm = function() {
        const e = {
            stencil: !0,
            failIfMajorPerformanceCaveat: z.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
            if (!z.ADAPTER.getWebGLRenderingContext())
                return !1;
            const t = z.ADAPTER.createCanvas();
            let r = t.getContext("webgl", e) || t.getContext("experimental-webgl", e);
            const i = !!r?.getContextAttributes()?.stencil;
            if (r) {
                const n = r.getExtension("WEBGL_lose_context");
                n && n.loseContext()
            }
            return r = null,
            i
        } catch {
            return !1
        }
    }()),
    jm
}
var c8 = {
    grad: .9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
}
  , mn = function(e) {
    return typeof e == "string" ? e.length > 0 : typeof e == "number"
}
  , Se = function(e, t, r) {
    return t === void 0 && (t = 0),
    r === void 0 && (r = Math.pow(10, t)),
    Math.round(r * e) / r + 0
}
  , Qr = function(e, t, r) {
    return t === void 0 && (t = 0),
    r === void 0 && (r = 1),
    e > r ? r : e > t ? e : t
}
  , vI = function(e) {
    return (e = isFinite(e) ? e % 360 : 0) > 0 ? e : e + 360
}
  , xS = function(e) {
    return {
        r: Qr(e.r, 0, 255),
        g: Qr(e.g, 0, 255),
        b: Qr(e.b, 0, 255),
        a: Qr(e.a)
    }
}
  , Xm = function(e) {
    return {
        r: Se(e.r),
        g: Se(e.g),
        b: Se(e.b),
        a: Se(e.a, 3)
    }
}
  , d8 = /^#([0-9a-f]{3,8})$/i
  , bc = function(e) {
    var t = e.toString(16);
    return t.length < 2 ? "0" + t : t
}
  , xI = function(e) {
    var t = e.r
      , r = e.g
      , i = e.b
      , n = e.a
      , s = Math.max(t, r, i)
      , o = s - Math.min(t, r, i)
      , a = o ? s === t ? (r - i) / o : s === r ? 2 + (i - t) / o : 4 + (t - r) / o : 0;
    return {
        h: 60 * (a < 0 ? a + 6 : a),
        s: s ? o / s * 100 : 0,
        v: s / 255 * 100,
        a: n
    }
}
  , EI = function(e) {
    var t = e.h
      , r = e.s
      , i = e.v
      , n = e.a;
    t = t / 360 * 6,
    r /= 100,
    i /= 100;
    var s = Math.floor(t)
      , o = i * (1 - r)
      , a = i * (1 - (t - s) * r)
      , l = i * (1 - (1 - t + s) * r)
      , h = s % 6;
    return {
        r: 255 * [i, a, o, o, l, i][h],
        g: 255 * [l, i, i, a, o, o][h],
        b: 255 * [o, o, l, i, i, a][h],
        a: n
    }
}
  , ES = function(e) {
    return {
        h: vI(e.h),
        s: Qr(e.s, 0, 100),
        l: Qr(e.l, 0, 100),
        a: Qr(e.a)
    }
}
  , TS = function(e) {
    return {
        h: Se(e.h),
        s: Se(e.s),
        l: Se(e.l),
        a: Se(e.a, 3)
    }
}
  , SS = function(e) {
    return EI((r = (t = e).s,
    {
        h: t.h,
        s: (r *= ((i = t.l) < 50 ? i : 100 - i) / 100) > 0 ? 2 * r / (i + r) * 100 : 0,
        v: i + r,
        a: t.a
    }));
    var t, r, i
}
  , gh = function(e) {
    return {
        h: (t = xI(e)).h,
        s: (n = (200 - (r = t.s)) * (i = t.v) / 100) > 0 && n < 200 ? r * i / 100 / (n <= 100 ? n : 200 - n) * 100 : 0,
        l: n / 2,
        a: t.a
    };
    var t, r, i, n
}
  , f8 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
  , p8 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
  , m8 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
  , g8 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
  , s_ = {
    string: [[function(e) {
        var t = d8.exec(e);
        return t ? (e = t[1]).length <= 4 ? {
            r: parseInt(e[0] + e[0], 16),
            g: parseInt(e[1] + e[1], 16),
            b: parseInt(e[2] + e[2], 16),
            a: e.length === 4 ? Se(parseInt(e[3] + e[3], 16) / 255, 2) : 1
        } : e.length === 6 || e.length === 8 ? {
            r: parseInt(e.substr(0, 2), 16),
            g: parseInt(e.substr(2, 2), 16),
            b: parseInt(e.substr(4, 2), 16),
            a: e.length === 8 ? Se(parseInt(e.substr(6, 2), 16) / 255, 2) : 1
        } : null : null
    }
    , "hex"], [function(e) {
        var t = m8.exec(e) || g8.exec(e);
        return t ? t[2] !== t[4] || t[4] !== t[6] ? null : xS({
            r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
            g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
            b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
            a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
        }) : null
    }
    , "rgb"], [function(e) {
        var t = f8.exec(e) || p8.exec(e);
        if (!t)
            return null;
        var r, i, n = ES({
            h: (r = t[1],
            i = t[2],
            i === void 0 && (i = "deg"),
            Number(r) * (c8[i] || 1)),
            s: Number(t[3]),
            l: Number(t[4]),
            a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1)
        });
        return SS(n)
    }
    , "hsl"]],
    object: [[function(e) {
        var t = e.r
          , r = e.g
          , i = e.b
          , n = e.a
          , s = n === void 0 ? 1 : n;
        return mn(t) && mn(r) && mn(i) ? xS({
            r: Number(t),
            g: Number(r),
            b: Number(i),
            a: Number(s)
        }) : null
    }
    , "rgb"], [function(e) {
        var t = e.h
          , r = e.s
          , i = e.l
          , n = e.a
          , s = n === void 0 ? 1 : n;
        if (!mn(t) || !mn(r) || !mn(i))
            return null;
        var o = ES({
            h: Number(t),
            s: Number(r),
            l: Number(i),
            a: Number(s)
        });
        return SS(o)
    }
    , "hsl"], [function(e) {
        var t = e.h
          , r = e.s
          , i = e.v
          , n = e.a
          , s = n === void 0 ? 1 : n;
        if (!mn(t) || !mn(r) || !mn(i))
            return null;
        var o = function(a) {
            return {
                h: vI(a.h),
                s: Qr(a.s, 0, 100),
                v: Qr(a.v, 0, 100),
                a: Qr(a.a)
            }
        }({
            h: Number(t),
            s: Number(r),
            v: Number(i),
            a: Number(s)
        });
        return EI(o)
    }
    , "hsv"]]
}
  , wS = function(e, t) {
    for (var r = 0; r < t.length; r++) {
        var i = t[r][0](e);
        if (i)
            return [i, t[r][1]]
    }
    return [null, void 0]
}
  , _8 = function(e) {
    return typeof e == "string" ? wS(e.trim(), s_.string) : typeof e == "object" && e !== null ? wS(e, s_.object) : [null, void 0]
}
  , Ym = function(e, t) {
    var r = gh(e);
    return {
        h: r.h,
        s: Qr(r.s + 100 * t, 0, 100),
        l: r.l,
        a: r.a
    }
}
  , Km = function(e) {
    return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3 / 255
}
  , AS = function(e, t) {
    var r = gh(e);
    return {
        h: r.h,
        s: r.s,
        l: Qr(r.l + 100 * t, 0, 100),
        a: r.a
    }
}
  , o_ = function() {
    function e(t) {
        this.parsed = _8(t)[0],
        this.rgba = this.parsed || {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        }
    }
    return e.prototype.isValid = function() {
        return this.parsed !== null
    }
    ,
    e.prototype.brightness = function() {
        return Se(Km(this.rgba), 2)
    }
    ,
    e.prototype.isDark = function() {
        return Km(this.rgba) < .5
    }
    ,
    e.prototype.isLight = function() {
        return Km(this.rgba) >= .5
    }
    ,
    e.prototype.toHex = function() {
        return t = Xm(this.rgba),
        r = t.r,
        i = t.g,
        n = t.b,
        o = (s = t.a) < 1 ? bc(Se(255 * s)) : "",
        "#" + bc(r) + bc(i) + bc(n) + o;
        var t, r, i, n, s, o
    }
    ,
    e.prototype.toRgb = function() {
        return Xm(this.rgba)
    }
    ,
    e.prototype.toRgbString = function() {
        return t = Xm(this.rgba),
        r = t.r,
        i = t.g,
        n = t.b,
        (s = t.a) < 1 ? "rgba(" + r + ", " + i + ", " + n + ", " + s + ")" : "rgb(" + r + ", " + i + ", " + n + ")";
        var t, r, i, n, s
    }
    ,
    e.prototype.toHsl = function() {
        return TS(gh(this.rgba))
    }
    ,
    e.prototype.toHslString = function() {
        return t = TS(gh(this.rgba)),
        r = t.h,
        i = t.s,
        n = t.l,
        (s = t.a) < 1 ? "hsla(" + r + ", " + i + "%, " + n + "%, " + s + ")" : "hsl(" + r + ", " + i + "%, " + n + "%)";
        var t, r, i, n, s
    }
    ,
    e.prototype.toHsv = function() {
        return t = xI(this.rgba),
        {
            h: Se(t.h),
            s: Se(t.s),
            v: Se(t.v),
            a: Se(t.a, 3)
        };
        var t
    }
    ,
    e.prototype.invert = function() {
        return Hi({
            r: 255 - (t = this.rgba).r,
            g: 255 - t.g,
            b: 255 - t.b,
            a: t.a
        });
        var t
    }
    ,
    e.prototype.saturate = function(t) {
        return t === void 0 && (t = .1),
        Hi(Ym(this.rgba, t))
    }
    ,
    e.prototype.desaturate = function(t) {
        return t === void 0 && (t = .1),
        Hi(Ym(this.rgba, -t))
    }
    ,
    e.prototype.grayscale = function() {
        return Hi(Ym(this.rgba, -1))
    }
    ,
    e.prototype.lighten = function(t) {
        return t === void 0 && (t = .1),
        Hi(AS(this.rgba, t))
    }
    ,
    e.prototype.darken = function(t) {
        return t === void 0 && (t = .1),
        Hi(AS(this.rgba, -t))
    }
    ,
    e.prototype.rotate = function(t) {
        return t === void 0 && (t = 15),
        this.hue(this.hue() + t)
    }
    ,
    e.prototype.alpha = function(t) {
        return typeof t == "number" ? Hi({
            r: (r = this.rgba).r,
            g: r.g,
            b: r.b,
            a: t
        }) : Se(this.rgba.a, 3);
        var r
    }
    ,
    e.prototype.hue = function(t) {
        var r = gh(this.rgba);
        return typeof t == "number" ? Hi({
            h: t,
            s: r.s,
            l: r.l,
            a: r.a
        }) : Se(r.h)
    }
    ,
    e.prototype.isEqual = function(t) {
        return this.toHex() === Hi(t).toHex()
    }
    ,
    e
}()
  , Hi = function(e) {
    return e instanceof o_ ? e : new o_(e)
}
  , bS = []
  , y8 = function(e) {
    e.forEach(function(t) {
        bS.indexOf(t) < 0 && (t(o_, s_),
        bS.push(t))
    })
};
function v8(e, t) {
    var r = {
        white: "#ffffff",
        bisque: "#ffe4c4",
        blue: "#0000ff",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        azure: "#f0ffff",
        whitesmoke: "#f5f5f5",
        papayawhip: "#ffefd5",
        plum: "#dda0dd",
        blanchedalmond: "#ffebcd",
        black: "#000000",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gainsboro: "#dcdcdc",
        cornsilk: "#fff8dc",
        cornflowerblue: "#6495ed",
        burlywood: "#deb887",
        aquamarine: "#7fffd4",
        beige: "#f5f5dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkkhaki: "#bdb76b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        peachpuff: "#ffdab9",
        darkmagenta: "#8b008b",
        darkred: "#8b0000",
        darkorchid: "#9932cc",
        darkorange: "#ff8c00",
        darkslateblue: "#483d8b",
        gray: "#808080",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        wheat: "#f5deb3",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        ghostwhite: "#f8f8ff",
        darkviolet: "#9400d3",
        magenta: "#ff00ff",
        green: "#008000",
        dodgerblue: "#1e90ff",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        blueviolet: "#8a2be2",
        forestgreen: "#228b22",
        lawngreen: "#7cfc00",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        fuchsia: "#ff00ff",
        brown: "#a52a2a",
        maroon: "#800000",
        mediumblue: "#0000cd",
        lightcoral: "#f08080",
        darkturquoise: "#00ced1",
        lightcyan: "#e0ffff",
        ivory: "#fffff0",
        lightyellow: "#ffffe0",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        linen: "#faf0e6",
        mediumaquamarine: "#66cdaa",
        lemonchiffon: "#fffacd",
        lime: "#00ff00",
        khaki: "#f0e68c",
        mediumseagreen: "#3cb371",
        limegreen: "#32cd32",
        mediumspringgreen: "#00fa9a",
        lightskyblue: "#87cefa",
        lightblue: "#add8e6",
        midnightblue: "#191970",
        lightpink: "#ffb6c1",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        mintcream: "#f5fffa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        navajowhite: "#ffdead",
        navy: "#000080",
        mediumvioletred: "#c71585",
        powderblue: "#b0e0e6",
        palegoldenrod: "#eee8aa",
        oldlace: "#fdf5e6",
        paleturquoise: "#afeeee",
        mediumturquoise: "#48d1cc",
        mediumorchid: "#ba55d3",
        rebeccapurple: "#663399",
        lightsteelblue: "#b0c4de",
        mediumslateblue: "#7b68ee",
        thistle: "#d8bfd8",
        tan: "#d2b48c",
        orchid: "#da70d6",
        mediumpurple: "#9370db",
        purple: "#800080",
        pink: "#ffc0cb",
        skyblue: "#87ceeb",
        springgreen: "#00ff7f",
        palegreen: "#98fb98",
        red: "#ff0000",
        yellow: "#ffff00",
        slateblue: "#6a5acd",
        lavenderblush: "#fff0f5",
        peru: "#cd853f",
        palevioletred: "#db7093",
        violet: "#ee82ee",
        teal: "#008080",
        slategray: "#708090",
        slategrey: "#708090",
        aliceblue: "#f0f8ff",
        darkseagreen: "#8fbc8f",
        darkolivegreen: "#556b2f",
        greenyellow: "#adff2f",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        tomato: "#ff6347",
        silver: "#c0c0c0",
        sienna: "#a0522d",
        lavender: "#e6e6fa",
        lightgreen: "#90ee90",
        orange: "#ffa500",
        orangered: "#ff4500",
        steelblue: "#4682b4",
        royalblue: "#4169e1",
        turquoise: "#40e0d0",
        yellowgreen: "#9acd32",
        salmon: "#fa8072",
        saddlebrown: "#8b4513",
        sandybrown: "#f4a460",
        rosybrown: "#bc8f8f",
        darksalmon: "#e9967a",
        lightgoldenrodyellow: "#fafad2",
        snow: "#fffafa",
        lightgrey: "#d3d3d3",
        lightgray: "#d3d3d3",
        dimgray: "#696969",
        dimgrey: "#696969",
        olivedrab: "#6b8e23",
        olive: "#808000"
    }
      , i = {};
    for (var n in r)
        i[r[n]] = n;
    var s = {};
    e.prototype.toName = function(o) {
        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
            return "transparent";
        var a, l, h = i[this.toHex()];
        if (h)
            return h;
        if (o?.closest) {
            var u = this.toRgb()
              , c = 1 / 0
              , d = "black";
            if (!s.length)
                for (var f in r)
                    s[f] = new e(r[f]).toRgb();
            for (var g in r) {
                var p = (a = u,
                l = s[g],
                Math.pow(a.r - l.r, 2) + Math.pow(a.g - l.g, 2) + Math.pow(a.b - l.b, 2));
                p < c && (c = p,
                d = g)
            }
            return d
        }
    }
    ,
    t.string.push([function(o) {
        var a = o.toLowerCase()
          , l = a === "transparent" ? "#0000" : r[a];
        return l ? new e(l).toRgb() : null
    }
    , "name"])
}
y8([v8]);
const ea = class md {
    constructor(t=16777215) {
        this._value = null,
        this._components = new Float32Array(4),
        this._components.fill(1),
        this._int = 16777215,
        this.value = t
    }
    get red() {
        return this._components[0]
    }
    get green() {
        return this._components[1]
    }
    get blue() {
        return this._components[2]
    }
    get alpha() {
        return this._components[3]
    }
    setValue(t) {
        return this.value = t,
        this
    }
    set value(t) {
        if (t instanceof md)
            this._value = this.cloneSource(t._value),
            this._int = t._int,
            this._components.set(t._components);
        else {
            if (t === null)
                throw new Error("Cannot set PIXI.Color#value to null");
            (this._value === null || !this.isSourceEqual(this._value, t)) && (this.normalize(t),
            this._value = this.cloneSource(t))
        }
    }
    get value() {
        return this._value
    }
    cloneSource(t) {
        return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? {
            ...t
        } : t
    }
    isSourceEqual(t, r) {
        const i = typeof t;
        if (i !== typeof r)
            return !1;
        if (i === "number" || i === "string" || t instanceof Number)
            return t === r;
        if (Array.isArray(t) && Array.isArray(r) || ArrayBuffer.isView(t) && ArrayBuffer.isView(r))
            return t.length !== r.length ? !1 : t.every( (n, s) => n === r[s]);
        if (t !== null && r !== null) {
            const n = Object.keys(t)
              , s = Object.keys(r);
            return n.length !== s.length ? !1 : n.every(o => t[o] === r[o])
        }
        return t === r
    }
    toRgba() {
        const [t,r,i,n] = this._components;
        return {
            r: t,
            g: r,
            b: i,
            a: n
        }
    }
    toRgb() {
        const [t,r,i] = this._components;
        return {
            r: t,
            g: r,
            b: i
        }
    }
    toRgbaString() {
        const [t,r,i] = this.toUint8RgbArray();
        return `rgba(${t},${r},${i},${this.alpha})`
    }
    toUint8RgbArray(t) {
        const [r,i,n] = this._components;
        return t = t ?? [],
        t[0] = Math.round(r * 255),
        t[1] = Math.round(i * 255),
        t[2] = Math.round(n * 255),
        t
    }
    toRgbArray(t) {
        t = t ?? [];
        const [r,i,n] = this._components;
        return t[0] = r,
        t[1] = i,
        t[2] = n,
        t
    }
    toNumber() {
        return this._int
    }
    toLittleEndianNumber() {
        const t = this._int;
        return (t >> 16) + (t & 65280) + ((t & 255) << 16)
    }
    multiply(t) {
        const [r,i,n,s] = md.temp.setValue(t)._components;
        return this._components[0] *= r,
        this._components[1] *= i,
        this._components[2] *= n,
        this._components[3] *= s,
        this.refreshInt(),
        this._value = null,
        this
    }
    premultiply(t, r=!0) {
        return r && (this._components[0] *= t,
        this._components[1] *= t,
        this._components[2] *= t),
        this._components[3] = t,
        this.refreshInt(),
        this._value = null,
        this
    }
    toPremultiplied(t, r=!0) {
        if (t === 1)
            return (255 << 24) + this._int;
        if (t === 0)
            return r ? 0 : this._int;
        let i = this._int >> 16 & 255
          , n = this._int >> 8 & 255
          , s = this._int & 255;
        return r && (i = i * t + .5 | 0,
        n = n * t + .5 | 0,
        s = s * t + .5 | 0),
        (t * 255 << 24) + (i << 16) + (n << 8) + s
    }
    toHex() {
        const t = this._int.toString(16);
        return `#${"000000".substring(0, 6 - t.length) + t}`
    }
    toHexa() {
        const t = Math.round(this._components[3] * 255).toString(16);
        return this.toHex() + "00".substring(0, 2 - t.length) + t
    }
    setAlpha(t) {
        return this._components[3] = this._clamp(t),
        this
    }
    round(t) {
        const [r,i,n] = this._components;
        return this._components[0] = Math.round(r * t) / t,
        this._components[1] = Math.round(i * t) / t,
        this._components[2] = Math.round(n * t) / t,
        this.refreshInt(),
        this._value = null,
        this
    }
    toArray(t) {
        t = t ?? [];
        const [r,i,n,s] = this._components;
        return t[0] = r,
        t[1] = i,
        t[2] = n,
        t[3] = s,
        t
    }
    normalize(t) {
        let r, i, n, s;
        if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
            const o = t;
            r = (o >> 16 & 255) / 255,
            i = (o >> 8 & 255) / 255,
            n = (o & 255) / 255,
            s = 1
        } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4)
            t = this._clamp(t),
            [r,i,n,s=1] = t;
        else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4)
            t = this._clamp(t, 0, 255),
            [r,i,n,s=255] = t,
            r /= 255,
            i /= 255,
            n /= 255,
            s /= 255;
        else if (typeof t == "string" || typeof t == "object") {
            if (typeof t == "string") {
                const a = md.HEX_PATTERN.exec(t);
                a && (t = `#${a[2]}`)
            }
            const o = Hi(t);
            o.isValid() && ({r, g: i, b: n, a: s} = o.rgba,
            r /= 255,
            i /= 255,
            n /= 255)
        }
        if (r !== void 0)
            this._components[0] = r,
            this._components[1] = i,
            this._components[2] = n,
            this._components[3] = s,
            this.refreshInt();
        else
            throw new Error(`Unable to convert color ${t}`)
    }
    refreshInt() {
        this._clamp(this._components);
        const [t,r,i] = this._components;
        this._int = (t * 255 << 16) + (r * 255 << 8) + (i * 255 | 0)
    }
    _clamp(t, r=0, i=1) {
        return typeof t == "number" ? Math.min(Math.max(t, r), i) : (t.forEach( (n, s) => {
            t[s] = Math.min(Math.max(n, r), i)
        }
        ),
        t)
    }
}
;
ea.shared = new ea,
ea.temp = new ea,
ea.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let xt = ea;
function x8(e, t=[]) {
    return et("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"),
    xt.shared.setValue(e).toRgbArray(t)
}
function TI(e) {
    return et("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"),
    xt.shared.setValue(e).toHex()
}
function E8(e) {
    return et("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead"),
    xt.shared.setValue(e).toNumber()
}
function SI(e) {
    return et("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"),
    xt.shared.setValue(e).toNumber()
}
function T8() {
    const e = []
      , t = [];
    for (let i = 0; i < 32; i++)
        e[i] = i,
        t[i] = i;
    e[tt.NORMAL_NPM] = tt.NORMAL,
    e[tt.ADD_NPM] = tt.ADD,
    e[tt.SCREEN_NPM] = tt.SCREEN,
    t[tt.NORMAL] = tt.NORMAL_NPM,
    t[tt.ADD] = tt.ADD_NPM,
    t[tt.SCREEN] = tt.SCREEN_NPM;
    const r = [];
    return r.push(t),
    r.push(e),
    r
}
const Jv = T8();
function tx(e, t) {
    return Jv[t ? 1 : 0][e]
}
function S8(e, t, r, i=!0) {
    return et("7.2.0", "utils.premultiplyRgba has moved to Color.premultiply"),
    xt.shared.setValue(e).premultiply(t, i).toArray(r ?? new Float32Array(4))
}
function w8(e, t) {
    return et("7.2.0", "utils.premultiplyTint has moved to Color.toPremultiplied"),
    xt.shared.setValue(e).toPremultiplied(t)
}
function A8(e, t, r, i=!0) {
    return et("7.2.0", "utils.premultiplyTintToRgba has moved to Color.premultiply"),
    xt.shared.setValue(e).premultiply(t, i).toArray(r ?? new Float32Array(4))
}
const wI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
function AI(e, t=null) {
    const r = e * 6;
    if (t = t || new Uint16Array(r),
    t.length !== r)
        throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${r}`);
    for (let i = 0, n = 0; i < r; i += 6,
    n += 4)
        t[i + 0] = n + 0,
        t[i + 1] = n + 1,
        t[i + 2] = n + 2,
        t[i + 3] = n + 0,
        t[i + 4] = n + 2,
        t[i + 5] = n + 3;
    return t
}
function Op(e) {
    if (e.BYTES_PER_ELEMENT === 4)
        return e instanceof Float32Array ? "Float32Array" : e instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (e.BYTES_PER_ELEMENT === 2) {
        if (e instanceof Uint16Array)
            return "Uint16Array"
    } else if (e.BYTES_PER_ELEMENT === 1 && e instanceof Uint8Array)
        return "Uint8Array";
    return null
}
const b8 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
};
function C8(e, t) {
    let r = 0
      , i = 0;
    const n = {};
    for (let l = 0; l < e.length; l++)
        i += t[l],
        r += e[l].length;
    const s = new ArrayBuffer(r * 4);
    let o = null
      , a = 0;
    for (let l = 0; l < e.length; l++) {
        const h = t[l]
          , u = e[l]
          , c = Op(u);
        n[c] || (n[c] = new b8[c](s)),
        o = n[c];
        for (let d = 0; d < u.length; d++) {
            const f = (d / h | 0) * i + a
              , g = d % h;
            o[f + g] = u[d]
        }
        a += h
    }
    return new Float32Array(s)
}
function Jh(e) {
    return e += e === 0 ? 1 : 0,
    --e,
    e |= e >>> 1,
    e |= e >>> 2,
    e |= e >>> 4,
    e |= e >>> 8,
    e |= e >>> 16,
    e + 1
}
function a_(e) {
    return !(e & e - 1) && !!e
}
function l_(e) {
    let t = (e > 65535 ? 1 : 0) << 4;
    e >>>= t;
    let r = (e > 255 ? 1 : 0) << 3;
    return e >>>= r,
    t |= r,
    r = (e > 15 ? 1 : 0) << 2,
    e >>>= r,
    t |= r,
    r = (e > 3 ? 1 : 0) << 1,
    e >>>= r,
    t |= r,
    t | e >> 1
}
function mo(e, t, r) {
    const i = e.length;
    let n;
    if (t >= i || r === 0)
        return;
    r = t + r > i ? i - t : r;
    const s = i - r;
    for (n = t; n < s; ++n)
        e[n] = e[n + r];
    e.length = s
}
function In(e) {
    return e === 0 ? 0 : e < 0 ? -1 : 1
}
let P8 = 0;
function Is() {
    return ++P8
}
const h_ = class {
    constructor(e, t, r, i) {
        this.left = e,
        this.top = t,
        this.right = r,
        this.bottom = i
    }
    get width() {
        return this.right - this.left
    }
    get height() {
        return this.bottom - this.top
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
}
;
h_.EMPTY = new h_(0,0,0,0);
let u_ = h_;
const c_ = {}
  , Ze = Object.create(null)
  , Tr = Object.create(null);
function I8() {
    let e;
    for (e in Ze)
        Ze[e].destroy();
    for (e in Tr)
        Tr[e].destroy()
}
function R8() {
    let e;
    for (e in Ze)
        delete Ze[e];
    for (e in Tr)
        delete Tr[e]
}
class bI {
    constructor(t, r, i) {
        this._canvas = z.ADAPTER.createCanvas(),
        this._context = this._canvas.getContext("2d"),
        this.resolution = i || z.RESOLUTION,
        this.resize(t, r)
    }
    clear() {
        this._checkDestroyed(),
        this._context.setTransform(1, 0, 0, 1, 0, 0),
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
    }
    resize(t, r) {
        this._checkDestroyed(),
        this._canvas.width = Math.round(t * this.resolution),
        this._canvas.height = Math.round(r * this.resolution)
    }
    destroy() {
        this._context = null,
        this._canvas = null
    }
    get width() {
        return this._checkDestroyed(),
        this._canvas.width
    }
    set width(t) {
        this._checkDestroyed(),
        this._canvas.width = Math.round(t)
    }
    get height() {
        return this._checkDestroyed(),
        this._canvas.height
    }
    set height(t) {
        this._checkDestroyed(),
        this._canvas.height = Math.round(t)
    }
    get canvas() {
        return this._checkDestroyed(),
        this._canvas
    }
    get context() {
        return this._checkDestroyed(),
        this._context
    }
    _checkDestroyed() {
        if (this._canvas === null)
            throw new TypeError("The CanvasRenderTarget has already been destroyed")
    }
}
function CS(e, t, r) {
    for (let i = 0, n = 4 * r * t; i < t; ++i,
    n += 4)
        if (e[n + 3] !== 0)
            return !1;
    return !0
}
function PS(e, t, r, i, n) {
    const s = 4 * t;
    for (let o = i, a = i * s + 4 * r; o <= n; ++o,
    a += s)
        if (e[a + 3] !== 0)
            return !1;
    return !0
}
function CI(e) {
    const {width: t, height: r} = e
      , i = e.getContext("2d", {
        willReadFrequently: !0
    });
    if (i === null)
        throw new TypeError("Failed to get canvas 2D context");
    const n = i.getImageData(0, 0, t, r).data;
    let s = 0
      , o = 0
      , a = t - 1
      , l = r - 1;
    for (; o < r && CS(n, t, o); )
        ++o;
    if (o === r)
        return u_.EMPTY;
    for (; CS(n, t, l); )
        --l;
    for (; PS(n, t, s, o, l); )
        ++s;
    for (; PS(n, t, a, o, l); )
        --a;
    return ++a,
    ++l,
    new u_(s,o,a,l)
}
function PI(e) {
    const t = CI(e)
      , {width: r, height: i} = t;
    let n = null;
    if (!t.isEmpty()) {
        const s = e.getContext("2d");
        if (s === null)
            throw new TypeError("Failed to get canvas 2D context");
        n = s.getImageData(t.left, t.top, r, i)
    }
    return {
        width: r,
        height: i,
        data: n
    }
}
function M8(e) {
    const t = wI.exec(e);
    if (t)
        return {
            mediaType: t[1] ? t[1].toLowerCase() : void 0,
            subType: t[2] ? t[2].toLowerCase() : void 0,
            charset: t[3] ? t[3].toLowerCase() : void 0,
            encoding: t[4] ? t[4].toLowerCase() : void 0,
            data: t[5]
        }
}
function II(e, t=globalThis.location) {
    if (e.startsWith("data:"))
        return "";
    t = t || globalThis.location;
    const r = new URL(e,document.baseURI);
    return r.hostname !== t.hostname || r.port !== t.port || r.protocol !== t.protocol ? "anonymous" : ""
}
function un(e, t=1) {
    const r = z.RETINA_PREFIX?.exec(e);
    return r ? parseFloat(r[1]) : t
}
const O8 = Object.freeze(Object.defineProperty({
    __proto__: null,
    BaseTextureCache: Tr,
    BoundingBox: u_,
    CanvasRenderTarget: bI,
    DATA_URI: wI,
    EventEmitter: ci,
    ProgramCache: c_,
    TextureCache: Ze,
    clearTextureCache: R8,
    correctBlendMode: tx,
    createIndicesForQuads: AI,
    decomposeDataUri: M8,
    deprecation: et,
    destroyTextureCache: I8,
    detectVideoAlphaMode: _I,
    determineCrossOrigin: II,
    earcut: eI,
    getBufferType: Op,
    getCanvasBoundingBox: CI,
    getResolutionOfUrl: un,
    hex2rgb: x8,
    hex2string: TI,
    interleaveTypedArrays: C8,
    isMobile: Si,
    isPow2: a_,
    isWebGLSupported: yI,
    log2: l_,
    nextPow2: Jh,
    path: fe,
    premultiplyBlendMode: Jv,
    premultiplyRgba: S8,
    premultiplyTint: w8,
    premultiplyTintToRgba: A8,
    removeItems: mo,
    rgb2hex: SI,
    sayHello: u8,
    sign: In,
    skipHello: h8,
    string2hex: E8,
    trimCanvas: PI,
    uid: Is,
    url: s8
}, Symbol.toStringTag, {
    value: "Module"
}));
var G = (e => (e.Renderer = "renderer",
e.Application = "application",
e.RendererSystem = "renderer-webgl-system",
e.RendererPlugin = "renderer-webgl-plugin",
e.CanvasRendererSystem = "renderer-canvas-system",
e.CanvasRendererPlugin = "renderer-canvas-plugin",
e.Asset = "asset",
e.LoadParser = "load-parser",
e.ResolveParser = "resolve-parser",
e.CacheParser = "cache-parser",
e.DetectionParser = "detection-parser",
e))(G || {});
const d_ = e => {
    if (typeof e == "function" || typeof e == "object" && e.extension) {
        if (!e.extension)
            throw new Error("Extension class must have an extension object");
        e = {
            ...typeof e.extension != "object" ? {
                type: e.extension
            } : e.extension,
            ref: e
        }
    }
    if (typeof e == "object")
        e = {
            ...e
        };
    else
        throw new Error("Invalid extension type");
    return typeof e.type == "string" && (e.type = [e.type]),
    e
}
  , IS = (e, t) => d_(e).priority ?? t
  , Y = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...e) {
        return e.map(d_).forEach(t => {
            t.type.forEach(r => this._removeHandlers[r]?.(t))
        }
        ),
        this
    },
    add(...e) {
        return e.map(d_).forEach(t => {
            t.type.forEach(r => {
                const i = this._addHandlers
                  , n = this._queue;
                i[r] ? i[r](t) : (n[r] = n[r] || [],
                n[r].push(t))
            }
            )
        }
        ),
        this
    },
    handle(e, t, r) {
        const i = this._addHandlers
          , n = this._removeHandlers;
        if (i[e] || n[e])
            throw new Error(`Extension type ${e} already has a handler`);
        i[e] = t,
        n[e] = r;
        const s = this._queue;
        return s[e] && (s[e].forEach(o => t(o)),
        delete s[e]),
        this
    },
    handleByMap(e, t) {
        return this.handle(e, r => {
            t[r.name] = r.ref
        }
        , r => {
            delete t[r.name]
        }
        )
    },
    handleByList(e, t, r=-1) {
        return this.handle(e, i => {
            t.includes(i.ref) || (t.push(i.ref),
            t.sort( (n, s) => IS(s, r) - IS(n, r)))
        }
        , i => {
            const n = t.indexOf(i.ref);
            n !== -1 && t.splice(n, 1)
        }
        )
    }
};
class pf {
    constructor(t) {
        typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t,
        this.uint32View = new Uint32Array(this.rawBinaryData),
        this.float32View = new Float32Array(this.rawBinaryData)
    }
    get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
        this._int8View
    }
    get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
        this._uint8View
    }
    get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
        this._int16View
    }
    get uint16View() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)),
        this._uint16View
    }
    get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
        this._int32View
    }
    view(t) {
        return this[`${t}View`]
    }
    destroy() {
        this.rawBinaryData = null,
        this._int8View = null,
        this._uint8View = null,
        this._int16View = null,
        this._uint16View = null,
        this._int32View = null,
        this.uint32View = null,
        this.float32View = null
    }
    static sizeOf(t) {
        switch (t) {
        case "int8":
        case "uint8":
            return 1;
        case "int16":
        case "uint16":
            return 2;
        case "int32":
        case "uint32":
        case "float32":
            return 4;
        default:
            throw new Error(`${t} isn't a valid view type`)
        }
    }
}
const N8 = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);
function L8(e) {
    let t = "";
    for (let r = 0; r < e; ++r)
        r > 0 && (t += `
else `),
        r < e - 1 && (t += `if(test == ${r}.0){}`);
    return t
}
function RI(e, t) {
    if (e === 0)
        throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const r = t.createShader(t.FRAGMENT_SHADER);
    for (; ; ) {
        const i = N8.replace(/%forloop%/gi, L8(e));
        if (t.shaderSource(r, i),
        t.compileShader(r),
        !t.getShaderParameter(r, t.COMPILE_STATUS))
            e = e / 2 | 0;
        else
            break
    }
    return e
}
const qm = 0
  , Zm = 1
  , Qm = 2
  , Jm = 3
  , tg = 4
  , eg = 5;
class Bi {
    constructor() {
        this.data = 0,
        this.blendMode = tt.NORMAL,
        this.polygonOffset = 0,
        this.blend = !0,
        this.depthMask = !0
    }
    get blend() {
        return !!(this.data & 1 << qm)
    }
    set blend(t) {
        !!(this.data & 1 << qm) !== t && (this.data ^= 1 << qm)
    }
    get offsets() {
        return !!(this.data & 1 << Zm)
    }
    set offsets(t) {
        !!(this.data & 1 << Zm) !== t && (this.data ^= 1 << Zm)
    }
    get culling() {
        return !!(this.data & 1 << Qm)
    }
    set culling(t) {
        !!(this.data & 1 << Qm) !== t && (this.data ^= 1 << Qm)
    }
    get depthTest() {
        return !!(this.data & 1 << Jm)
    }
    set depthTest(t) {
        !!(this.data & 1 << Jm) !== t && (this.data ^= 1 << Jm)
    }
    get depthMask() {
        return !!(this.data & 1 << eg)
    }
    set depthMask(t) {
        !!(this.data & 1 << eg) !== t && (this.data ^= 1 << eg)
    }
    get clockwiseFrontFace() {
        return !!(this.data & 1 << tg)
    }
    set clockwiseFrontFace(t) {
        !!(this.data & 1 << tg) !== t && (this.data ^= 1 << tg)
    }
    get blendMode() {
        return this._blendMode
    }
    set blendMode(t) {
        this.blend = t !== tt.NONE,
        this._blendMode = t
    }
    get polygonOffset() {
        return this._polygonOffset
    }
    set polygonOffset(t) {
        this.offsets = !!t,
        this._polygonOffset = t
    }
    static for2d() {
        const t = new Bi;
        return t.depthTest = !1,
        t.blend = !0,
        t
    }
}
Bi.prototype.toString = function() {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
}
;
const mf = [];
function ex(e, t) {
    if (!e)
        return null;
    let r = "";
    if (typeof e == "string") {
        const i = /\.(\w{3,4})(?:$|\?|#)/i.exec(e);
        i && (r = i[1].toLowerCase())
    }
    for (let i = mf.length - 1; i >= 0; --i) {
        const n = mf[i];
        if (n.test && n.test(e, r))
            return new n(e,t)
    }
    throw new Error("Unrecognized source type to auto-detect Resource")
}
class Nr {
    constructor(t) {
        this.items = [],
        this._name = t,
        this._aliasCount = 0
    }
    emit(t, r, i, n, s, o, a, l) {
        if (arguments.length > 8)
            throw new Error("max arguments reached");
        const {name: h, items: u} = this;
        this._aliasCount++;
        for (let c = 0, d = u.length; c < d; c++)
            u[c][h](t, r, i, n, s, o, a, l);
        return u === this.items && this._aliasCount--,
        this
    }
    ensureNonAliasedItems() {
        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0,
        this.items = this.items.slice(0))
    }
    add(t) {
        return t[this._name] && (this.ensureNonAliasedItems(),
        this.remove(t),
        this.items.push(t)),
        this
    }
    remove(t) {
        const r = this.items.indexOf(t);
        return r !== -1 && (this.ensureNonAliasedItems(),
        this.items.splice(r, 1)),
        this
    }
    contains(t) {
        return this.items.includes(t)
    }
    removeAll() {
        return this.ensureNonAliasedItems(),
        this.items.length = 0,
        this
    }
    destroy() {
        this.removeAll(),
        this.items = null,
        this._name = null
    }
    get empty() {
        return this.items.length === 0
    }
    get name() {
        return this._name
    }
}
Object.defineProperties(Nr.prototype, {
    dispatch: {
        value: Nr.prototype.emit
    },
    run: {
        value: Nr.prototype.emit
    }
});
class el {
    constructor(t=0, r=0) {
        this._width = t,
        this._height = r,
        this.destroyed = !1,
        this.internal = !1,
        this.onResize = new Nr("setRealSize"),
        this.onUpdate = new Nr("update"),
        this.onError = new Nr("onError")
    }
    bind(t) {
        this.onResize.add(t),
        this.onUpdate.add(t),
        this.onError.add(t),
        (this._width || this._height) && this.onResize.emit(this._width, this._height)
    }
    unbind(t) {
        this.onResize.remove(t),
        this.onUpdate.remove(t),
        this.onError.remove(t)
    }
    resize(t, r) {
        (t !== this._width || r !== this._height) && (this._width = t,
        this._height = r,
        this.onResize.emit(t, r))
    }
    get valid() {
        return !!this._width && !!this._height
    }
    update() {
        this.destroyed || this.onUpdate.emit()
    }
    load() {
        return Promise.resolve(this)
    }
    get width() {
        return this._width
    }
    get height() {
        return this._height
    }
    style(t, r, i) {
        return !1
    }
    dispose() {}
    destroy() {
        this.destroyed || (this.destroyed = !0,
        this.dispose(),
        this.onError.removeAll(),
        this.onError = null,
        this.onResize.removeAll(),
        this.onResize = null,
        this.onUpdate.removeAll(),
        this.onUpdate = null)
    }
    static test(t, r) {
        return !1
    }
}
class Bu extends el {
    constructor(t, r) {
        const {width: i, height: n} = r || {};
        if (!i || !n)
            throw new Error("BufferResource width or height invalid");
        super(i, n),
        this.data = t,
        this.unpackAlignment = r.unpackAlignment ?? 4
    }
    upload(t, r, i) {
        const n = t.gl;
        n.pixelStorei(n.UNPACK_ALIGNMENT, this.unpackAlignment),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === tr.UNPACK);
        const s = r.realWidth
          , o = r.realHeight;
        return i.width === s && i.height === o ? n.texSubImage2D(r.target, 0, 0, 0, s, o, r.format, i.type, this.data) : (i.width = s,
        i.height = o,
        n.texImage2D(r.target, 0, i.internalFormat, s, o, 0, r.format, i.type, this.data)),
        !0
    }
    dispose() {
        this.data = null
    }
    static test(t) {
        return t === null || t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array
    }
}
const D8 = {
    scaleMode: Qi.NEAREST,
    alphaMode: tr.NPM
}
  , f_ = class ra extends ci {
    constructor(t=null, r=null) {
        super(),
        r = Object.assign({}, ra.defaultOptions, r);
        const {alphaMode: i, mipmap: n, anisotropicLevel: s, scaleMode: o, width: a, height: l, wrapMode: h, format: u, type: c, target: d, resolution: f, resourceOptions: g} = r;
        t && !(t instanceof el) && (t = ex(t, g),
        t.internal = !0),
        this.resolution = f || z.RESOLUTION,
        this.width = Math.round((a || 0) * this.resolution) / this.resolution,
        this.height = Math.round((l || 0) * this.resolution) / this.resolution,
        this._mipmap = n,
        this.anisotropicLevel = s,
        this._wrapMode = h,
        this._scaleMode = o,
        this.format = u,
        this.type = c,
        this.target = d,
        this.alphaMode = i,
        this.uid = Is(),
        this.touched = 0,
        this.isPowerOfTwo = !1,
        this._refreshPOT(),
        this._glTextures = {},
        this.dirtyId = 0,
        this.dirtyStyleId = 0,
        this.cacheId = null,
        this.valid = a > 0 && l > 0,
        this.textureCacheIds = [],
        this.destroyed = !1,
        this.resource = null,
        this._batchEnabled = 0,
        this._batchLocation = 0,
        this.parentTextureArray = null,
        this.setResource(t)
    }
    get realWidth() {
        return Math.round(this.width * this.resolution)
    }
    get realHeight() {
        return Math.round(this.height * this.resolution)
    }
    get mipmap() {
        return this._mipmap
    }
    set mipmap(t) {
        this._mipmap !== t && (this._mipmap = t,
        this.dirtyStyleId++)
    }
    get scaleMode() {
        return this._scaleMode
    }
    set scaleMode(t) {
        this._scaleMode !== t && (this._scaleMode = t,
        this.dirtyStyleId++)
    }
    get wrapMode() {
        return this._wrapMode
    }
    set wrapMode(t) {
        this._wrapMode !== t && (this._wrapMode = t,
        this.dirtyStyleId++)
    }
    setStyle(t, r) {
        let i;
        return t !== void 0 && t !== this.scaleMode && (this.scaleMode = t,
        i = !0),
        r !== void 0 && r !== this.mipmap && (this.mipmap = r,
        i = !0),
        i && this.dirtyStyleId++,
        this
    }
    setSize(t, r, i) {
        return i = i || this.resolution,
        this.setRealSize(t * i, r * i, i)
    }
    setRealSize(t, r, i) {
        return this.resolution = i || this.resolution,
        this.width = Math.round(t) / this.resolution,
        this.height = Math.round(r) / this.resolution,
        this._refreshPOT(),
        this.update(),
        this
    }
    _refreshPOT() {
        this.isPowerOfTwo = a_(this.realWidth) && a_(this.realHeight)
    }
    setResolution(t) {
        const r = this.resolution;
        return r === t ? this : (this.resolution = t,
        this.valid && (this.width = Math.round(this.width * r) / t,
        this.height = Math.round(this.height * r) / t,
        this.emit("update", this)),
        this._refreshPOT(),
        this)
    }
    setResource(t) {
        if (this.resource === t)
            return this;
        if (this.resource)
            throw new Error("Resource can be set only once");
        return t.bind(this),
        this.resource = t,
        this
    }
    update() {
        this.valid ? (this.dirtyId++,
        this.dirtyStyleId++,
        this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0,
        this.emit("loaded", this),
        this.emit("update", this))
    }
    onError(t) {
        this.emit("error", this, t)
    }
    destroy() {
        this.resource && (this.resource.unbind(this),
        this.resource.internal && this.resource.destroy(),
        this.resource = null),
        this.cacheId && (delete Tr[this.cacheId],
        delete Ze[this.cacheId],
        this.cacheId = null),
        this.valid = !1,
        this.dispose(),
        ra.removeFromCache(this),
        this.textureCacheIds = null,
        this.destroyed = !0,
        this.emit("destroyed", this),
        this.removeAllListeners()
    }
    dispose() {
        this.emit("dispose", this)
    }
    castToBaseTexture() {
        return this
    }
    static from(t, r, i=z.STRICT_TEXTURE_CACHE) {
        const n = typeof t == "string";
        let s = null;
        if (n)
            s = t;
        else {
            if (!t._pixiId) {
                const a = r?.pixiIdPrefix || "pixiid";
                t._pixiId = `${a}_${Is()}`
            }
            s = t._pixiId
        }
        let o = Tr[s];
        if (n && i && !o)
            throw new Error(`The cacheId "${s}" does not exist in BaseTextureCache.`);
        return o || (o = new ra(t,r),
        o.cacheId = s,
        ra.addToCache(o, s)),
        o
    }
    static fromBuffer(t, r, i, n) {
        t = t || new Float32Array(r * i * 4);
        const s = new Bu(t,{
            width: r,
            height: i,
            ...n?.resourceOptions
        });
        let o, a;
        return t instanceof Float32Array ? (o = B.RGBA,
        a = Q.FLOAT) : t instanceof Int32Array ? (o = B.RGBA_INTEGER,
        a = Q.INT) : t instanceof Uint32Array ? (o = B.RGBA_INTEGER,
        a = Q.UNSIGNED_INT) : t instanceof Int16Array ? (o = B.RGBA_INTEGER,
        a = Q.SHORT) : t instanceof Uint16Array ? (o = B.RGBA_INTEGER,
        a = Q.UNSIGNED_SHORT) : t instanceof Int8Array ? (o = B.RGBA,
        a = Q.BYTE) : (o = B.RGBA,
        a = Q.UNSIGNED_BYTE),
        s.internal = !0,
        new ra(s,Object.assign({}, D8, {
            type: a,
            format: o
        }, n))
    }
    static addToCache(t, r) {
        r && (t.textureCacheIds.includes(r) || t.textureCacheIds.push(r),
        Tr[r] && Tr[r] !== t && console.warn(`BaseTexture added to the cache with an id [${r}] that already had an entry`),
        Tr[r] = t)
    }
    static removeFromCache(t) {
        if (typeof t == "string") {
            const r = Tr[t];
            if (r) {
                const i = r.textureCacheIds.indexOf(t);
                return i > -1 && r.textureCacheIds.splice(i, 1),
                delete Tr[t],
                r
            }
        } else if (t?.textureCacheIds) {
            for (let r = 0; r < t.textureCacheIds.length; ++r)
                delete Tr[t.textureCacheIds[r]];
            return t.textureCacheIds.length = 0,
            t
        }
        return null
    }
}
;
f_.defaultOptions = {
    mipmap: Ni.POW2,
    anisotropicLevel: 0,
    scaleMode: Qi.LINEAR,
    wrapMode: Ci.CLAMP,
    alphaMode: tr.UNPACK,
    target: co.TEXTURE_2D,
    format: B.RGBA,
    type: Q.UNSIGNED_BYTE
},
f_._globalBatch = 0;
let nt = f_;
class gf {
    constructor() {
        this.texArray = null,
        this.blend = 0,
        this.type = Ti.TRIANGLES,
        this.start = 0,
        this.size = 0,
        this.data = null
    }
}
let B8 = 0;
class te {
    constructor(t, r=!0, i=!1) {
        this.data = t || new Float32Array(1),
        this._glBuffers = {},
        this._updateID = 0,
        this.index = i,
        this.static = r,
        this.id = B8++,
        this.disposeRunner = new Nr("disposeBuffer")
    }
    update(t) {
        t instanceof Array && (t = new Float32Array(t)),
        this.data = t || this.data,
        this._updateID++
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(),
        this.data = null
    }
    set index(t) {
        this.type = t ? Pi.ELEMENT_ARRAY_BUFFER : Pi.ARRAY_BUFFER
    }
    get index() {
        return this.type === Pi.ELEMENT_ARRAY_BUFFER
    }
    static from(t) {
        return t instanceof Array && (t = new Float32Array(t)),
        new te(t)
    }
}
class tu {
    constructor(t, r=0, i=!1, n=Q.FLOAT, s, o, a, l=1) {
        this.buffer = t,
        this.size = r,
        this.normalized = i,
        this.type = n,
        this.stride = s,
        this.start = o,
        this.instance = a,
        this.divisor = l
    }
    destroy() {
        this.buffer = null
    }
    static from(t, r, i, n, s) {
        return new tu(t,r,i,n,s)
    }
}
const k8 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
};
function F8(e, t) {
    let r = 0
      , i = 0;
    const n = {};
    for (let l = 0; l < e.length; l++)
        i += t[l],
        r += e[l].length;
    const s = new ArrayBuffer(r * 4);
    let o = null
      , a = 0;
    for (let l = 0; l < e.length; l++) {
        const h = t[l]
          , u = e[l]
          , c = Op(u);
        n[c] || (n[c] = new k8[c](s)),
        o = n[c];
        for (let d = 0; d < u.length; d++) {
            const f = (d / h | 0) * i + a
              , g = d % h;
            o[f + g] = u[d]
        }
        a += h
    }
    return new Float32Array(s)
}
const RS = {
    5126: 4,
    5123: 2,
    5121: 1
};
let U8 = 0;
const G8 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array,
    Uint16Array
};
class Un {
    constructor(t=[], r={}) {
        this.buffers = t,
        this.indexBuffer = null,
        this.attributes = r,
        this.glVertexArrayObjects = {},
        this.id = U8++,
        this.instanced = !1,
        this.instanceCount = 1,
        this.disposeRunner = new Nr("disposeGeometry"),
        this.refCount = 0
    }
    addAttribute(t, r, i=0, n=!1, s, o, a, l=!1) {
        if (!r)
            throw new Error("You must pass a buffer when creating an attribute");
        r instanceof te || (r instanceof Array && (r = new Float32Array(r)),
        r = new te(r));
        const h = t.split("|");
        if (h.length > 1) {
            for (let c = 0; c < h.length; c++)
                this.addAttribute(h[c], r, i, n, s);
            return this
        }
        let u = this.buffers.indexOf(r);
        return u === -1 && (this.buffers.push(r),
        u = this.buffers.length - 1),
        this.attributes[t] = new tu(u,i,n,s,o,a,l),
        this.instanced = this.instanced || l,
        this
    }
    getAttribute(t) {
        return this.attributes[t]
    }
    getBuffer(t) {
        return this.buffers[this.getAttribute(t).buffer]
    }
    addIndex(t) {
        return t instanceof te || (t instanceof Array && (t = new Uint16Array(t)),
        t = new te(t)),
        t.type = Pi.ELEMENT_ARRAY_BUFFER,
        this.indexBuffer = t,
        this.buffers.includes(t) || this.buffers.push(t),
        this
    }
    getIndex() {
        return this.indexBuffer
    }
    interleave() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
            return this;
        const t = []
          , r = []
          , i = new te;
        let n;
        for (n in this.attributes) {
            const s = this.attributes[n]
              , o = this.buffers[s.buffer];
            t.push(o.data),
            r.push(s.size * RS[s.type] / 4),
            s.buffer = 0
        }
        for (i.data = F8(t, r),
        n = 0; n < this.buffers.length; n++)
            this.buffers[n] !== this.indexBuffer && this.buffers[n].destroy();
        return this.buffers = [i],
        this.indexBuffer && this.buffers.push(this.indexBuffer),
        this
    }
    getSize() {
        for (const t in this.attributes) {
            const r = this.attributes[t];
            return this.buffers[r.buffer].data.length / (r.stride / 4 || r.size)
        }
        return 0
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(),
        this.buffers = null,
        this.indexBuffer = null,
        this.attributes = null
    }
    clone() {
        const t = new Un;
        for (let r = 0; r < this.buffers.length; r++)
            t.buffers[r] = new te(this.buffers[r].data.slice(0));
        for (const r in this.attributes) {
            const i = this.attributes[r];
            t.attributes[r] = new tu(i.buffer,i.size,i.normalized,i.type,i.stride,i.start,i.instance)
        }
        return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)],
        t.indexBuffer.type = Pi.ELEMENT_ARRAY_BUFFER),
        t
    }
    static merge(t) {
        const r = new Un
          , i = []
          , n = []
          , s = [];
        let o;
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let l = 0; l < o.buffers.length; l++)
                n[l] = n[l] || 0,
                n[l] += o.buffers[l].data.length,
                s[l] = 0
        }
        for (let a = 0; a < o.buffers.length; a++)
            i[a] = new G8[Op(o.buffers[a].data)](n[a]),
            r.buffers[a] = new te(i[a]);
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let l = 0; l < o.buffers.length; l++)
                i[l].set(o.buffers[l].data, s[l]),
                s[l] += o.buffers[l].data.length
        }
        if (r.attributes = o.attributes,
        o.indexBuffer) {
            r.indexBuffer = r.buffers[o.buffers.indexOf(o.indexBuffer)],
            r.indexBuffer.type = Pi.ELEMENT_ARRAY_BUFFER;
            let a = 0
              , l = 0
              , h = 0
              , u = 0;
            for (let c = 0; c < o.buffers.length; c++)
                if (o.buffers[c] !== o.indexBuffer) {
                    u = c;
                    break
                }
            for (const c in o.attributes) {
                const d = o.attributes[c];
                (d.buffer | 0) === u && (l += d.size * RS[d.type] / 4)
            }
            for (let c = 0; c < t.length; c++) {
                const d = t[c].indexBuffer.data;
                for (let f = 0; f < d.length; f++)
                    r.indexBuffer.data[f + h] += a;
                a += t[c].buffers[u].data.length / l,
                h += d.length
            }
        }
        return r
    }
}
class rx extends Un {
    constructor(t=!1) {
        super(),
        this._buffer = new te(null,t,!1),
        this._indexBuffer = new te(null,t,!0),
        this.addAttribute("aVertexPosition", this._buffer, 2, !1, Q.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, Q.FLOAT).addAttribute("aColor", this._buffer, 4, !0, Q.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, Q.FLOAT).addIndex(this._indexBuffer)
    }
}
const eu = Math.PI * 2
  , MI = 180 / Math.PI
  , OI = Math.PI / 180;
var we = (e => (e[e.POLY = 0] = "POLY",
e[e.RECT = 1] = "RECT",
e[e.CIRC = 2] = "CIRC",
e[e.ELIP = 3] = "ELIP",
e[e.RREC = 4] = "RREC",
e))(we || {});
class st {
    constructor(t=0, r=0) {
        this.x = 0,
        this.y = 0,
        this.x = t,
        this.y = r
    }
    clone() {
        return new st(this.x,this.y)
    }
    copyFrom(t) {
        return this.set(t.x, t.y),
        this
    }
    copyTo(t) {
        return t.set(this.x, this.y),
        t
    }
    equals(t) {
        return t.x === this.x && t.y === this.y
    }
    set(t=0, r=t) {
        return this.x = t,
        this.y = r,
        this
    }
}
st.prototype.toString = function() {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`
}
;
const Cc = [new st, new st, new st, new st];
let lt = class p_ {
    constructor(t=0, r=0, i=0, n=0) {
        this.x = Number(t),
        this.y = Number(r),
        this.width = Number(i),
        this.height = Number(n),
        this.type = we.RECT
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    static get EMPTY() {
        return new p_(0,0,0,0)
    }
    clone() {
        return new p_(this.x,this.y,this.width,this.height)
    }
    copyFrom(t) {
        return this.x = t.x,
        this.y = t.y,
        this.width = t.width,
        this.height = t.height,
        this
    }
    copyTo(t) {
        return t.x = this.x,
        t.y = this.y,
        t.width = this.width,
        t.height = this.height,
        t
    }
    contains(t, r) {
        return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && r >= this.y && r < this.y + this.height
    }
    intersects(t, r) {
        if (!r) {
            const T = this.x < t.x ? t.x : this.x;
            if ((this.right > t.right ? t.right : this.right) <= T)
                return !1;
            const C = this.y < t.y ? t.y : this.y;
            return (this.bottom > t.bottom ? t.bottom : this.bottom) > C
        }
        const i = this.left
          , n = this.right
          , s = this.top
          , o = this.bottom;
        if (n <= i || o <= s)
            return !1;
        const a = Cc[0].set(t.left, t.top)
          , l = Cc[1].set(t.left, t.bottom)
          , h = Cc[2].set(t.right, t.top)
          , u = Cc[3].set(t.right, t.bottom);
        if (h.x <= a.x || l.y <= a.y)
            return !1;
        const c = Math.sign(r.a * r.d - r.b * r.c);
        if (c === 0 || (r.apply(a, a),
        r.apply(l, l),
        r.apply(h, h),
        r.apply(u, u),
        Math.max(a.x, l.x, h.x, u.x) <= i || Math.min(a.x, l.x, h.x, u.x) >= n || Math.max(a.y, l.y, h.y, u.y) <= s || Math.min(a.y, l.y, h.y, u.y) >= o))
            return !1;
        const d = c * (l.y - a.y)
          , f = c * (a.x - l.x)
          , g = d * i + f * s
          , p = d * n + f * s
          , v = d * i + f * o
          , y = d * n + f * o;
        if (Math.max(g, p, v, y) <= d * a.x + f * a.y || Math.min(g, p, v, y) >= d * u.x + f * u.y)
            return !1;
        const m = c * (a.y - h.y)
          , _ = c * (h.x - a.x)
          , x = m * i + _ * s
          , E = m * n + _ * s
          , S = m * i + _ * o
          , w = m * n + _ * o;
        return !(Math.max(x, E, S, w) <= m * a.x + _ * a.y || Math.min(x, E, S, w) >= m * u.x + _ * u.y)
    }
    pad(t=0, r=t) {
        return this.x -= t,
        this.y -= r,
        this.width += t * 2,
        this.height += r * 2,
        this
    }
    fit(t) {
        const r = Math.max(this.x, t.x)
          , i = Math.min(this.x + this.width, t.x + t.width)
          , n = Math.max(this.y, t.y)
          , s = Math.min(this.y + this.height, t.y + t.height);
        return this.x = r,
        this.width = Math.max(i - r, 0),
        this.y = n,
        this.height = Math.max(s - n, 0),
        this
    }
    ceil(t=1, r=.001) {
        const i = Math.ceil((this.x + this.width - r) * t) / t
          , n = Math.ceil((this.y + this.height - r) * t) / t;
        return this.x = Math.floor((this.x + r) * t) / t,
        this.y = Math.floor((this.y + r) * t) / t,
        this.width = i - this.x,
        this.height = n - this.y,
        this
    }
    enlarge(t) {
        const r = Math.min(this.x, t.x)
          , i = Math.max(this.x + this.width, t.x + t.width)
          , n = Math.min(this.y, t.y)
          , s = Math.max(this.y + this.height, t.y + t.height);
        return this.x = r,
        this.width = i - r,
        this.y = n,
        this.height = s - n,
        this
    }
}
;
lt.prototype.toString = function() {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
}
;
class ku {
    constructor(t=0, r=0, i=0) {
        this.x = t,
        this.y = r,
        this.radius = i,
        this.type = we.CIRC
    }
    clone() {
        return new ku(this.x,this.y,this.radius)
    }
    contains(t, r) {
        if (this.radius <= 0)
            return !1;
        const i = this.radius * this.radius;
        let n = this.x - t
          , s = this.y - r;
        return n *= n,
        s *= s,
        n + s <= i
    }
    getBounds() {
        return new lt(this.x - this.radius,this.y - this.radius,this.radius * 2,this.radius * 2)
    }
}
ku.prototype.toString = function() {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
}
;
class Fu {
    constructor(t=0, r=0, i=0, n=0) {
        this.x = t,
        this.y = r,
        this.width = i,
        this.height = n,
        this.type = we.ELIP
    }
    clone() {
        return new Fu(this.x,this.y,this.width,this.height)
    }
    contains(t, r) {
        if (this.width <= 0 || this.height <= 0)
            return !1;
        let i = (t - this.x) / this.width
          , n = (r - this.y) / this.height;
        return i *= i,
        n *= n,
        i + n <= 1
    }
    getBounds() {
        return new lt(this.x - this.width,this.y - this.height,this.width,this.height)
    }
}
Fu.prototype.toString = function() {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
}
;
class Ts {
    constructor(...t) {
        let r = Array.isArray(t[0]) ? t[0] : t;
        if (typeof r[0] != "number") {
            const i = [];
            for (let n = 0, s = r.length; n < s; n++)
                i.push(r[n].x, r[n].y);
            r = i
        }
        this.points = r,
        this.type = we.POLY,
        this.closeStroke = !0
    }
    clone() {
        const t = this.points.slice()
          , r = new Ts(t);
        return r.closeStroke = this.closeStroke,
        r
    }
    contains(t, r) {
        let i = !1;
        const n = this.points.length / 2;
        for (let s = 0, o = n - 1; s < n; o = s++) {
            const a = this.points[s * 2]
              , l = this.points[s * 2 + 1]
              , h = this.points[o * 2]
              , u = this.points[o * 2 + 1];
            l > r != u > r && t < (h - a) * ((r - l) / (u - l)) + a && (i = !i)
        }
        return i
    }
}
Ts.prototype.toString = function() {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce( (e, t) => `${e}, ${t}`, "")}]`
}
;
class Uu {
    constructor(t=0, r=0, i=0, n=0, s=20) {
        this.x = t,
        this.y = r,
        this.width = i,
        this.height = n,
        this.radius = s,
        this.type = we.RREC
    }
    clone() {
        return new Uu(this.x,this.y,this.width,this.height,this.radius)
    }
    contains(t, r) {
        if (this.width <= 0 || this.height <= 0)
            return !1;
        if (t >= this.x && t <= this.x + this.width && r >= this.y && r <= this.y + this.height) {
            const i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (r >= this.y + i && r <= this.y + this.height - i || t >= this.x + i && t <= this.x + this.width - i)
                return !0;
            let n = t - (this.x + i)
              , s = r - (this.y + i);
            const o = i * i;
            if (n * n + s * s <= o || (n = t - (this.x + this.width - i),
            n * n + s * s <= o) || (s = r - (this.y + this.height - i),
            n * n + s * s <= o) || (n = t - (this.x + i),
            n * n + s * s <= o))
                return !0
        }
        return !1
    }
}
Uu.prototype.toString = function() {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
}
;
class Mt {
    constructor(t=1, r=0, i=0, n=1, s=0, o=0) {
        this.array = null,
        this.a = t,
        this.b = r,
        this.c = i,
        this.d = n,
        this.tx = s,
        this.ty = o
    }
    fromArray(t) {
        this.a = t[0],
        this.b = t[1],
        this.c = t[3],
        this.d = t[4],
        this.tx = t[2],
        this.ty = t[5]
    }
    set(t, r, i, n, s, o) {
        return this.a = t,
        this.b = r,
        this.c = i,
        this.d = n,
        this.tx = s,
        this.ty = o,
        this
    }
    toArray(t, r) {
        this.array || (this.array = new Float32Array(9));
        const i = r || this.array;
        return t ? (i[0] = this.a,
        i[1] = this.b,
        i[2] = 0,
        i[3] = this.c,
        i[4] = this.d,
        i[5] = 0,
        i[6] = this.tx,
        i[7] = this.ty,
        i[8] = 1) : (i[0] = this.a,
        i[1] = this.c,
        i[2] = this.tx,
        i[3] = this.b,
        i[4] = this.d,
        i[5] = this.ty,
        i[6] = 0,
        i[7] = 0,
        i[8] = 1),
        i
    }
    apply(t, r) {
        r = r || new st;
        const i = t.x
          , n = t.y;
        return r.x = this.a * i + this.c * n + this.tx,
        r.y = this.b * i + this.d * n + this.ty,
        r
    }
    applyInverse(t, r) {
        r = r || new st;
        const i = 1 / (this.a * this.d + this.c * -this.b)
          , n = t.x
          , s = t.y;
        return r.x = this.d * i * n + -this.c * i * s + (this.ty * this.c - this.tx * this.d) * i,
        r.y = this.a * i * s + -this.b * i * n + (-this.ty * this.a + this.tx * this.b) * i,
        r
    }
    translate(t, r) {
        return this.tx += t,
        this.ty += r,
        this
    }
    scale(t, r) {
        return this.a *= t,
        this.d *= r,
        this.c *= t,
        this.b *= r,
        this.tx *= t,
        this.ty *= r,
        this
    }
    rotate(t) {
        const r = Math.cos(t)
          , i = Math.sin(t)
          , n = this.a
          , s = this.c
          , o = this.tx;
        return this.a = n * r - this.b * i,
        this.b = n * i + this.b * r,
        this.c = s * r - this.d * i,
        this.d = s * i + this.d * r,
        this.tx = o * r - this.ty * i,
        this.ty = o * i + this.ty * r,
        this
    }
    append(t) {
        const r = this.a
          , i = this.b
          , n = this.c
          , s = this.d;
        return this.a = t.a * r + t.b * n,
        this.b = t.a * i + t.b * s,
        this.c = t.c * r + t.d * n,
        this.d = t.c * i + t.d * s,
        this.tx = t.tx * r + t.ty * n + this.tx,
        this.ty = t.tx * i + t.ty * s + this.ty,
        this
    }
    setTransform(t, r, i, n, s, o, a, l, h) {
        return this.a = Math.cos(a + h) * s,
        this.b = Math.sin(a + h) * s,
        this.c = -Math.sin(a - l) * o,
        this.d = Math.cos(a - l) * o,
        this.tx = t - (i * this.a + n * this.c),
        this.ty = r - (i * this.b + n * this.d),
        this
    }
    prepend(t) {
        const r = this.tx;
        if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
            const i = this.a
              , n = this.c;
            this.a = i * t.a + this.b * t.c,
            this.b = i * t.b + this.b * t.d,
            this.c = n * t.a + this.d * t.c,
            this.d = n * t.b + this.d * t.d
        }
        return this.tx = r * t.a + this.ty * t.c + t.tx,
        this.ty = r * t.b + this.ty * t.d + t.ty,
        this
    }
    decompose(t) {
        const r = this.a
          , i = this.b
          , n = this.c
          , s = this.d
          , o = t.pivot
          , a = -Math.atan2(-n, s)
          , l = Math.atan2(i, r)
          , h = Math.abs(a + l);
        return h < 1e-5 || Math.abs(eu - h) < 1e-5 ? (t.rotation = l,
        t.skew.x = t.skew.y = 0) : (t.rotation = 0,
        t.skew.x = a,
        t.skew.y = l),
        t.scale.x = Math.sqrt(r * r + i * i),
        t.scale.y = Math.sqrt(n * n + s * s),
        t.position.x = this.tx + (o.x * r + o.y * n),
        t.position.y = this.ty + (o.x * i + o.y * s),
        t
    }
    invert() {
        const t = this.a
          , r = this.b
          , i = this.c
          , n = this.d
          , s = this.tx
          , o = t * n - r * i;
        return this.a = n / o,
        this.b = -r / o,
        this.c = -i / o,
        this.d = t / o,
        this.tx = (i * this.ty - n * s) / o,
        this.ty = -(t * this.ty - r * s) / o,
        this
    }
    identity() {
        return this.a = 1,
        this.b = 0,
        this.c = 0,
        this.d = 1,
        this.tx = 0,
        this.ty = 0,
        this
    }
    clone() {
        const t = new Mt;
        return t.a = this.a,
        t.b = this.b,
        t.c = this.c,
        t.d = this.d,
        t.tx = this.tx,
        t.ty = this.ty,
        t
    }
    copyTo(t) {
        return t.a = this.a,
        t.b = this.b,
        t.c = this.c,
        t.d = this.d,
        t.tx = this.tx,
        t.ty = this.ty,
        t
    }
    copyFrom(t) {
        return this.a = t.a,
        this.b = t.b,
        this.c = t.c,
        this.d = t.d,
        this.tx = t.tx,
        this.ty = t.ty,
        this
    }
    static get IDENTITY() {
        return new Mt
    }
    static get TEMP_MATRIX() {
        return new Mt
    }
}
Mt.prototype.toString = function() {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
}
;
const Qs = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]
  , Js = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]
  , to = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]
  , eo = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]
  , m_ = []
  , NI = []
  , Pc = Math.sign;
function H8() {
    for (let e = 0; e < 16; e++) {
        const t = [];
        m_.push(t);
        for (let r = 0; r < 16; r++) {
            const i = Pc(Qs[e] * Qs[r] + to[e] * Js[r])
              , n = Pc(Js[e] * Qs[r] + eo[e] * Js[r])
              , s = Pc(Qs[e] * to[r] + to[e] * eo[r])
              , o = Pc(Js[e] * to[r] + eo[e] * eo[r]);
            for (let a = 0; a < 16; a++)
                if (Qs[a] === i && Js[a] === n && to[a] === s && eo[a] === o) {
                    t.push(a);
                    break
                }
        }
    }
    for (let e = 0; e < 16; e++) {
        const t = new Mt;
        t.set(Qs[e], Js[e], to[e], eo[e], 0, 0),
        NI.push(t)
    }
}
H8();
const Ut = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: e => Qs[e],
    uY: e => Js[e],
    vX: e => to[e],
    vY: e => eo[e],
    inv: e => e & 8 ? e & 15 : -e & 7,
    add: (e, t) => m_[e][t],
    sub: (e, t) => m_[e][Ut.inv(t)],
    rotate180: e => e ^ 4,
    isVertical: e => (e & 3) === 2,
    byDirection: (e, t) => Math.abs(e) * 2 <= Math.abs(t) ? t >= 0 ? Ut.S : Ut.N : Math.abs(t) * 2 <= Math.abs(e) ? e > 0 ? Ut.E : Ut.W : t > 0 ? e > 0 ? Ut.SE : Ut.SW : e > 0 ? Ut.NE : Ut.NW,
    matrixAppendRotationInv: (e, t, r=0, i=0) => {
        const n = NI[Ut.inv(t)];
        n.tx = r,
        n.ty = i,
        e.append(n)
    }
};
class Ji {
    constructor(t, r, i=0, n=0) {
        this._x = i,
        this._y = n,
        this.cb = t,
        this.scope = r
    }
    clone(t=this.cb, r=this.scope) {
        return new Ji(t,r,this._x,this._y)
    }
    set(t=0, r=t) {
        return (this._x !== t || this._y !== r) && (this._x = t,
        this._y = r,
        this.cb.call(this.scope)),
        this
    }
    copyFrom(t) {
        return (this._x !== t.x || this._y !== t.y) && (this._x = t.x,
        this._y = t.y,
        this.cb.call(this.scope)),
        this
    }
    copyTo(t) {
        return t.set(this._x, this._y),
        t
    }
    equals(t) {
        return t.x === this._x && t.y === this._y
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x !== t && (this._x = t,
        this.cb.call(this.scope))
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y !== t && (this._y = t,
        this.cb.call(this.scope))
    }
}
Ji.prototype.toString = function() {
    return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`
}
;
const g_ = class {
    constructor() {
        this.worldTransform = new Mt,
        this.localTransform = new Mt,
        this.position = new Ji(this.onChange,this,0,0),
        this.scale = new Ji(this.onChange,this,1,1),
        this.pivot = new Ji(this.onChange,this,0,0),
        this.skew = new Ji(this.updateSkew,this,0,0),
        this._rotation = 0,
        this._cx = 1,
        this._sx = 0,
        this._cy = 0,
        this._sy = 1,
        this._localID = 0,
        this._currentLocalID = 0,
        this._worldID = 0,
        this._parentID = 0
    }
    onChange() {
        this._localID++
    }
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y),
        this._sx = Math.sin(this._rotation + this.skew.y),
        this._cy = -Math.sin(this._rotation - this.skew.x),
        this._sy = Math.cos(this._rotation - this.skew.x),
        this._localID++
    }
    updateLocalTransform() {
        const e = this.localTransform;
        this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x,
        e.b = this._sx * this.scale.x,
        e.c = this._cy * this.scale.y,
        e.d = this._sy * this.scale.y,
        e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c),
        e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d),
        this._currentLocalID = this._localID,
        this._parentID = -1)
    }
    updateTransform(e) {
        const t = this.localTransform;
        if (this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x,
        t.b = this._sx * this.scale.x,
        t.c = this._cy * this.scale.y,
        t.d = this._sy * this.scale.y,
        t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c),
        t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d),
        this._currentLocalID = this._localID,
        this._parentID = -1),
        this._parentID !== e._worldID) {
            const r = e.worldTransform
              , i = this.worldTransform;
            i.a = t.a * r.a + t.b * r.c,
            i.b = t.a * r.b + t.b * r.d,
            i.c = t.c * r.a + t.d * r.c,
            i.d = t.c * r.b + t.d * r.d,
            i.tx = t.tx * r.a + t.ty * r.c + r.tx,
            i.ty = t.tx * r.b + t.ty * r.d + r.ty,
            this._parentID = e._worldID,
            this._worldID++
        }
    }
    setFromMatrix(e) {
        e.decompose(this),
        this._localID++
    }
    get rotation() {
        return this._rotation
    }
    set rotation(e) {
        this._rotation !== e && (this._rotation = e,
        this.updateSkew())
    }
}
;
g_.IDENTITY = new g_;
let Gu = g_;
Gu.prototype.toString = function() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
}
;
var $8 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`
  , z8 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;
function MS(e, t, r) {
    const i = e.createShader(t);
    return e.shaderSource(i, r),
    e.compileShader(i),
    i
}
function rg(e) {
    const t = new Array(e);
    for (let r = 0; r < t.length; r++)
        t[r] = !1;
    return t
}
function LI(e, t) {
    switch (e) {
    case "float":
        return 0;
    case "vec2":
        return new Float32Array(2 * t);
    case "vec3":
        return new Float32Array(3 * t);
    case "vec4":
        return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
        return 0;
    case "ivec2":
        return new Int32Array(2 * t);
    case "ivec3":
        return new Int32Array(3 * t);
    case "ivec4":
        return new Int32Array(4 * t);
    case "uvec2":
        return new Uint32Array(2 * t);
    case "uvec3":
        return new Uint32Array(3 * t);
    case "uvec4":
        return new Uint32Array(4 * t);
    case "bool":
        return !1;
    case "bvec2":
        return rg(2 * t);
    case "bvec3":
        return rg(3 * t);
    case "bvec4":
        return rg(4 * t);
    case "mat2":
        return new Float32Array([1, 0, 0, 1]);
    case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    case "mat4":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
const go = [{
    test: e => e.type === "float" && e.size === 1 && !e.isArray,
    code: e => `
            if(uv["${e}"] !== ud["${e}"].value)
            {
                ud["${e}"].value = uv["${e}"]
                gl.uniform1f(ud["${e}"].location, uv["${e}"])
            }
            `
}, {
    test: (e, t) => (e.type === "sampler2D" || e.type === "samplerCube" || e.type === "sampler2DArray") && e.size === 1 && !e.isArray && (t == null || t.castToBaseTexture !== void 0),
    code: e => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${e}"], t);

            if(ud["${e}"].value !== t)
            {
                ud["${e}"].value = t;
                gl.uniform1i(ud["${e}"].location, t);
; // eslint-disable-line max-len
            }`
}, {
    test: (e, t) => e.type === "mat3" && e.size === 1 && !e.isArray && t.a !== void 0,
    code: e => `
            gl.uniformMatrix3fv(ud["${e}"].location, false, uv["${e}"].toArray(true));
            `,
    codeUbo: e => `
                var ${e}_matrix = uv.${e}.toArray(true);

                data[offset] = ${e}_matrix[0];
                data[offset+1] = ${e}_matrix[1];
                data[offset+2] = ${e}_matrix[2];
        
                data[offset + 4] = ${e}_matrix[3];
                data[offset + 5] = ${e}_matrix[4];
                data[offset + 6] = ${e}_matrix[5];
        
                data[offset + 8] = ${e}_matrix[6];
                data[offset + 9] = ${e}_matrix[7];
                data[offset + 10] = ${e}_matrix[8];
            `
}, {
    test: (e, t) => e.type === "vec2" && e.size === 1 && !e.isArray && t.x !== void 0,
    code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${e}"].location, v.x, v.y);
                }`,
    codeUbo: e => `
                v = uv.${e};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
}, {
    test: e => e.type === "vec2" && e.size === 1 && !e.isArray,
    code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${e}"].location, v[0], v[1]);
                }
            `
}, {
    test: (e, t) => e.type === "vec4" && e.size === 1 && !e.isArray && t.width !== void 0,
    code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${e}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: e => `
                    v = uv.${e};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
}, {
    test: (e, t) => e.type === "vec4" && e.size === 1 && !e.isArray && t.red !== void 0,
    code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${e}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: e => `
                    v = uv.${e};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
}, {
    test: (e, t) => e.type === "vec3" && e.size === 1 && !e.isArray && t.red !== void 0,
    code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${e}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: e => `
                    v = uv.${e};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
}, {
    test: e => e.type === "vec4" && e.size === 1 && !e.isArray,
    code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${e}"].location, v[0], v[1], v[2], v[3])
                }`
}]
  , W8 = {
    float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
    vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
    vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
    vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
    int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
    uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
    uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
    uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
    bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
    bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}
  , V8 = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: "gl.uniform4fv(location, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    int: "gl.uniform1iv(location, v)",
    ivec2: "gl.uniform2iv(location, v)",
    ivec3: "gl.uniform3iv(location, v)",
    ivec4: "gl.uniform4iv(location, v)",
    uint: "gl.uniform1uiv(location, v)",
    uvec2: "gl.uniform2uiv(location, v)",
    uvec3: "gl.uniform3uiv(location, v)",
    uvec4: "gl.uniform4uiv(location, v)",
    bool: "gl.uniform1iv(location, v)",
    bvec2: "gl.uniform2iv(location, v)",
    bvec3: "gl.uniform3iv(location, v)",
    bvec4: "gl.uniform4iv(location, v)",
    sampler2D: "gl.uniform1iv(location, v)",
    samplerCube: "gl.uniform1iv(location, v)",
    sampler2DArray: "gl.uniform1iv(location, v)"
};
function j8(e, t) {
    const r = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const i in e.uniforms) {
        const n = t[i];
        if (!n) {
            e.uniforms[i]?.group === !0 && (e.uniforms[i].ubo ? r.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `) : r.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `));
            continue
        }
        const s = e.uniforms[i];
        let o = !1;
        for (let a = 0; a < go.length; a++)
            if (go[a].test(n, s)) {
                r.push(go[a].code(i, s)),
                o = !0;
                break
            }
        if (!o) {
            const a = (n.size === 1 && !n.isArray ? W8 : V8)[n.type].replace("location", `ud["${i}"].location`);
            r.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${a};`)
        }
    }
    return new Function("ud","uv","renderer","syncData",r.join(`
`))
}
const DI = {};
let Ic = DI;
function BI() {
    if (Ic === DI || Ic?.isContextLost()) {
        const e = z.ADAPTER.createCanvas();
        let t;
        z.PREFER_ENV >= Fs.WEBGL2 && (t = e.getContext("webgl2", {})),
        t || (t = e.getContext("webgl", {}) || e.getContext("experimental-webgl", {}),
        t ? t.getExtension("WEBGL_draw_buffers") : t = null),
        Ic = t
    }
    return Ic
}
let Rc;
function X8() {
    if (!Rc) {
        Rc = Ir.MEDIUM;
        const e = BI();
        e && e.getShaderPrecisionFormat && (Rc = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision ? Ir.HIGH : Ir.MEDIUM)
    }
    return Rc
}
function OS(e, t) {
    const r = e.getShaderSource(t).split(`
`).map( (h, u) => `${u}: ${h}`)
      , i = e.getShaderInfoLog(t)
      , n = i.split(`
`)
      , s = {}
      , o = n.map(h => parseFloat(h.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(h => h && !s[h] ? (s[h] = !0,
    !0) : !1)
      , a = [""];
    o.forEach(h => {
        r[h - 1] = `%c${r[h - 1]}%c`,
        a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
    }
    );
    const l = r.join(`
`);
    a[0] = l,
    console.error(i),
    console.groupCollapsed("click to view full shader code"),
    console.warn(...a),
    console.groupEnd()
}
function Y8(e, t, r, i) {
    e.getProgramParameter(t, e.LINK_STATUS) || (e.getShaderParameter(r, e.COMPILE_STATUS) || OS(e, r),
    e.getShaderParameter(i, e.COMPILE_STATUS) || OS(e, i),
    console.error("PixiJS Error: Could not initialize shader."),
    e.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", e.getProgramInfoLog(t)))
}
const K8 = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
};
function kI(e) {
    return K8[e]
}
let Mc = null;
const NS = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function FI(e, t) {
    if (!Mc) {
        const r = Object.keys(NS);
        Mc = {};
        for (let i = 0; i < r.length; ++i) {
            const n = r[i];
            Mc[e[n]] = NS[n]
        }
    }
    return Mc[t]
}
function LS(e, t, r) {
    if (e.substring(0, 9) !== "precision") {
        let i = t;
        return t === Ir.HIGH && r !== Ir.HIGH && (i = Ir.MEDIUM),
        `precision ${i} float;
${e}`
    } else if (r !== Ir.HIGH && e.substring(0, 15) === "precision highp")
        return e.replace("precision highp", "precision mediump");
    return e
}
let Ml;
function UI() {
    if (typeof Ml == "boolean")
        return Ml;
    try {
        Ml = new Function("param1","param2","param3","return param1[param2] === param3;")({
            a: "b"
        }, "a", "b") === !0
    } catch {
        Ml = !1
    }
    return Ml
}
let q8 = 0;
const Oc = {}
  , __ = class ia {
    constructor(t, r, i="pixi-shader", n={}) {
        this.extra = {},
        this.id = q8++,
        this.vertexSrc = t || ia.defaultVertexSrc,
        this.fragmentSrc = r || ia.defaultFragmentSrc,
        this.vertexSrc = this.vertexSrc.trim(),
        this.fragmentSrc = this.fragmentSrc.trim(),
        this.extra = n,
        this.vertexSrc.substring(0, 8) !== "#version" && (i = i.replace(/\s+/g, "-"),
        Oc[i] ? (Oc[i]++,
        i += `-${Oc[i]}`) : Oc[i] = 1,
        this.vertexSrc = `#define SHADER_NAME ${i}
${this.vertexSrc}`,
        this.fragmentSrc = `#define SHADER_NAME ${i}
${this.fragmentSrc}`,
        this.vertexSrc = LS(this.vertexSrc, ia.defaultVertexPrecision, Ir.HIGH),
        this.fragmentSrc = LS(this.fragmentSrc, ia.defaultFragmentPrecision, X8())),
        this.glPrograms = {},
        this.syncUniforms = null
    }
    static get defaultVertexSrc() {
        return z8
    }
    static get defaultFragmentSrc() {
        return $8
    }
    static from(t, r, i) {
        const n = t + r;
        let s = c_[n];
        return s || (c_[n] = s = new ia(t,r,i)),
        s
    }
}
;
__.defaultVertexPrecision = Ir.HIGH,
__.defaultFragmentPrecision = Si.apple.device ? Ir.HIGH : Ir.MEDIUM;
let tn = __
  , Z8 = 0;
class ni {
    constructor(t, r, i) {
        this.group = !0,
        this.syncUniforms = {},
        this.dirtyId = 0,
        this.id = Z8++,
        this.static = !!r,
        this.ubo = !!i,
        t instanceof te ? (this.buffer = t,
        this.buffer.type = Pi.UNIFORM_BUFFER,
        this.autoManage = !1,
        this.ubo = !0) : (this.uniforms = t,
        this.ubo && (this.buffer = new te(new Float32Array(1)),
        this.buffer.type = Pi.UNIFORM_BUFFER,
        this.autoManage = !0))
    }
    update() {
        this.dirtyId++,
        !this.autoManage && this.buffer && this.buffer.update()
    }
    add(t, r, i) {
        if (!this.ubo)
            this.uniforms[t] = new ni(r,i);
        else
            throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them")
    }
    static from(t, r, i) {
        return new ni(t,r,i)
    }
    static uboFrom(t, r) {
        return new ni(t,r ?? !0,!0)
    }
}
class Ri {
    constructor(t, r) {
        this.uniformBindCount = 0,
        this.program = t,
        r ? r instanceof ni ? this.uniformGroup = r : this.uniformGroup = new ni(r) : this.uniformGroup = new ni({}),
        this.disposeRunner = new Nr("disposeShader")
    }
    checkUniformExists(t, r) {
        if (r.uniforms[t])
            return !0;
        for (const i in r.uniforms) {
            const n = r.uniforms[i];
            if (n.group === !0 && this.checkUniformExists(t, n))
                return !0
        }
        return !1
    }
    destroy() {
        this.uniformGroup = null,
        this.disposeRunner.emit(this),
        this.disposeRunner.destroy()
    }
    get uniforms() {
        return this.uniformGroup.uniforms
    }
    static from(t, r, i) {
        const n = tn.from(t, r);
        return new Ri(n,i)
    }
}
class GI {
    constructor(t, r) {
        if (this.vertexSrc = t,
        this.fragTemplate = r,
        this.programCache = {},
        this.defaultGroupCache = {},
        !r.includes("%count%"))
            throw new Error('Fragment template must contain "%count%".');
        if (!r.includes("%forloop%"))
            throw new Error('Fragment template must contain "%forloop%".')
    }
    generateShader(t) {
        if (!this.programCache[t]) {
            const i = new Int32Array(t);
            for (let s = 0; s < t; s++)
                i[s] = s;
            this.defaultGroupCache[t] = ni.from({
                uSamplers: i
            }, !0);
            let n = this.fragTemplate;
            n = n.replace(/%count%/gi, `${t}`),
            n = n.replace(/%forloop%/gi, this.generateSampleSrc(t)),
            this.programCache[t] = new tn(this.vertexSrc,n)
        }
        const r = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Mt,
            default: this.defaultGroupCache[t]
        };
        return new Ri(this.programCache[t],r)
    }
    generateSampleSrc(t) {
        let r = "";
        r += `
`,
        r += `
`;
        for (let i = 0; i < t; i++)
            i > 0 && (r += `
else `),
            i < t - 1 && (r += `if(vTextureId < ${i}.5)`),
            r += `
{`,
            r += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`,
            r += `
}`;
        return r += `
`,
        r += `
`,
        r
    }
}
class _f {
    constructor() {
        this.elements = [],
        this.ids = [],
        this.count = 0
    }
    clear() {
        for (let t = 0; t < this.count; t++)
            this.elements[t] = null;
        this.count = 0
    }
}
function Q8() {
    return !Si.apple.device
}
function J8(e) {
    let t = !0;
    const r = z.ADAPTER.getNavigator();
    if (Si.tablet || Si.phone) {
        if (Si.apple.device) {
            const i = r.userAgent.match(/OS (\d+)_(\d+)?/);
            i && parseInt(i[1], 10) < 11 && (t = !1)
        }
        if (Si.android.device) {
            const i = r.userAgent.match(/Android\s([0-9.]*)/);
            i && parseInt(i[1], 10) < 7 && (t = !1)
        }
    }
    return t ? e : 4
}
class Hu {
    constructor(t) {
        this.renderer = t
    }
    flush() {}
    destroy() {
        this.renderer = null
    }
    start() {}
    stop() {
        this.flush()
    }
    render(t) {}
}
var tz = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`
  , ez = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
const Wl = class mi extends Hu {
    constructor(t) {
        super(t),
        this.setShaderGenerator(),
        this.geometryClass = rx,
        this.vertexSize = 6,
        this.state = Bi.for2d(),
        this.size = mi.defaultBatchSize * 4,
        this._vertexCount = 0,
        this._indexCount = 0,
        this._bufferedElements = [],
        this._bufferedTextures = [],
        this._bufferSize = 0,
        this._shader = null,
        this._packedGeometries = [],
        this._packedGeometryPoolSize = 2,
        this._flushId = 0,
        this._aBuffers = {},
        this._iBuffers = {},
        this.maxTextures = 1,
        this.renderer.on("prerender", this.onPrerender, this),
        t.runners.contextChange.add(this),
        this._dcIndex = 0,
        this._aIndex = 0,
        this._iIndex = 0,
        this._attributeBuffer = null,
        this._indexBuffer = null,
        this._tempBoundTextures = []
    }
    static get defaultMaxTextures() {
        return this._defaultMaxTextures = this._defaultMaxTextures ?? J8(32),
        this._defaultMaxTextures
    }
    static set defaultMaxTextures(t) {
        this._defaultMaxTextures = t
    }
    static get canUploadSameBuffer() {
        return this._canUploadSameBuffer = this._canUploadSameBuffer ?? Q8(),
        this._canUploadSameBuffer
    }
    static set canUploadSameBuffer(t) {
        this._canUploadSameBuffer = t
    }
    get MAX_TEXTURES() {
        return et("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"),
        this.maxTextures
    }
    static get defaultVertexSrc() {
        return ez
    }
    static get defaultFragmentTemplate() {
        return tz
    }
    setShaderGenerator({vertex: t=mi.defaultVertexSrc, fragment: r=mi.defaultFragmentTemplate}={}) {
        this.shaderGenerator = new GI(t,r)
    }
    contextChange() {
        const t = this.renderer.gl;
        z.PREFER_ENV === Fs.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), mi.defaultMaxTextures),
        this.maxTextures = RI(this.maxTextures, t)),
        this._shader = this.shaderGenerator.generateShader(this.maxTextures);
        for (let r = 0; r < this._packedGeometryPoolSize; r++)
            this._packedGeometries[r] = new this.geometryClass;
        this.initFlushBuffers()
    }
    initFlushBuffers() {
        const {_drawCallPool: t, _textureArrayPool: r} = mi
          , i = this.size / 4
          , n = Math.floor(i / this.maxTextures) + 1;
        for (; t.length < i; )
            t.push(new gf);
        for (; r.length < n; )
            r.push(new _f);
        for (let s = 0; s < this.maxTextures; s++)
            this._tempBoundTextures[s] = null
    }
    onPrerender() {
        this._flushId = 0
    }
    render(t) {
        t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(),
        this._vertexCount += t.vertexData.length / 2,
        this._indexCount += t.indices.length,
        this._bufferedTextures[this._bufferSize] = t._texture.baseTexture,
        this._bufferedElements[this._bufferSize++] = t)
    }
    buildTexturesAndDrawCalls() {
        const {_bufferedTextures: t, maxTextures: r} = this
          , i = mi._textureArrayPool
          , n = this.renderer.batch
          , s = this._tempBoundTextures
          , o = this.renderer.textureGC.count;
        let a = ++nt._globalBatch
          , l = 0
          , h = i[0]
          , u = 0;
        n.copyBoundTextures(s, r);
        for (let c = 0; c < this._bufferSize; ++c) {
            const d = t[c];
            t[c] = null,
            d._batchEnabled !== a && (h.count >= r && (n.boundArray(h, s, a, r),
            this.buildDrawCalls(h, u, c),
            u = c,
            h = i[++l],
            ++a),
            d._batchEnabled = a,
            d.touched = o,
            h.elements[h.count++] = d)
        }
        h.count > 0 && (n.boundArray(h, s, a, r),
        this.buildDrawCalls(h, u, this._bufferSize),
        ++l,
        ++a);
        for (let c = 0; c < s.length; c++)
            s[c] = null;
        nt._globalBatch = a
    }
    buildDrawCalls(t, r, i) {
        const {_bufferedElements: n, _attributeBuffer: s, _indexBuffer: o, vertexSize: a} = this
          , l = mi._drawCallPool;
        let h = this._dcIndex
          , u = this._aIndex
          , c = this._iIndex
          , d = l[h];
        d.start = this._iIndex,
        d.texArray = t;
        for (let f = r; f < i; ++f) {
            const g = n[f]
              , p = g._texture.baseTexture
              , v = Jv[p.alphaMode ? 1 : 0][g.blendMode];
            n[f] = null,
            r < f && d.blend !== v && (d.size = c - d.start,
            r = f,
            d = l[++h],
            d.texArray = t,
            d.start = c),
            this.packInterleavedGeometry(g, s, o, u, c),
            u += g.vertexData.length / 2 * a,
            c += g.indices.length,
            d.blend = v
        }
        r < i && (d.size = c - d.start,
        ++h),
        this._dcIndex = h,
        this._aIndex = u,
        this._iIndex = c
    }
    bindAndClearTexArray(t) {
        const r = this.renderer.texture;
        for (let i = 0; i < t.count; i++)
            r.bind(t.elements[i], t.ids[i]),
            t.elements[i] = null;
        t.count = 0
    }
    updateGeometry() {
        const {_packedGeometries: t, _attributeBuffer: r, _indexBuffer: i} = this;
        mi.canUploadSameBuffer ? (t[this._flushId]._buffer.update(r.rawBinaryData),
        t[this._flushId]._indexBuffer.update(i),
        this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++,
        t[this._flushId] = new this.geometryClass),
        t[this._flushId]._buffer.update(r.rawBinaryData),
        t[this._flushId]._indexBuffer.update(i),
        this.renderer.geometry.bind(t[this._flushId]),
        this.renderer.geometry.updateBuffers(),
        this._flushId++)
    }
    drawBatches() {
        const t = this._dcIndex
          , {gl: r, state: i} = this.renderer
          , n = mi._drawCallPool;
        let s = null;
        for (let o = 0; o < t; o++) {
            const {texArray: a, type: l, size: h, start: u, blend: c} = n[o];
            s !== a && (s = a,
            this.bindAndClearTexArray(a)),
            this.state.blendMode = c,
            i.set(this.state),
            r.drawElements(l, h, r.UNSIGNED_SHORT, u * 2)
        }
    }
    flush() {
        this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount),
        this._indexBuffer = this.getIndexBuffer(this._indexCount),
        this._aIndex = 0,
        this._iIndex = 0,
        this._dcIndex = 0,
        this.buildTexturesAndDrawCalls(),
        this.updateGeometry(),
        this.drawBatches(),
        this._bufferSize = 0,
        this._vertexCount = 0,
        this._indexCount = 0)
    }
    start() {
        this.renderer.state.set(this.state),
        this.renderer.texture.ensureSamplerType(this.maxTextures),
        this.renderer.shader.bind(this._shader),
        mi.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
    }
    stop() {
        this.flush()
    }
    destroy() {
        for (let t = 0; t < this._packedGeometryPoolSize; t++)
            this._packedGeometries[t] && this._packedGeometries[t].destroy();
        this.renderer.off("prerender", this.onPrerender, this),
        this._aBuffers = null,
        this._iBuffers = null,
        this._packedGeometries = null,
        this._attributeBuffer = null,
        this._indexBuffer = null,
        this._shader && (this._shader.destroy(),
        this._shader = null),
        super.destroy()
    }
    getAttributeBuffer(t) {
        const r = Jh(Math.ceil(t / 8))
          , i = l_(r)
          , n = r * 8;
        this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
        let s = this._aBuffers[n];
        return s || (this._aBuffers[n] = s = new pf(n * this.vertexSize * 4)),
        s
    }
    getIndexBuffer(t) {
        const r = Jh(Math.ceil(t / 12))
          , i = l_(r)
          , n = r * 12;
        this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
        let s = this._iBuffers[i];
        return s || (this._iBuffers[i] = s = new Uint16Array(n)),
        s
    }
    packInterleavedGeometry(t, r, i, n, s) {
        const {uint32View: o, float32View: a} = r
          , l = n / this.vertexSize
          , h = t.uvs
          , u = t.indices
          , c = t.vertexData
          , d = t._texture.baseTexture._batchLocation
          , f = Math.min(t.worldAlpha, 1)
          , g = xt.shared.setValue(t._tintRGB).toPremultiplied(f, t._texture.baseTexture.alphaMode > 0);
        for (let p = 0; p < c.length; p += 2)
            a[n++] = c[p],
            a[n++] = c[p + 1],
            a[n++] = h[p],
            a[n++] = h[p + 1],
            o[n++] = g,
            a[n++] = d;
        for (let p = 0; p < u.length; p++)
            i[s++] = l + u[p]
    }
}
;
Wl.defaultBatchSize = 4096,
Wl.extension = {
    name: "batch",
    type: G.RendererPlugin
},
Wl._drawCallPool = [],
Wl._textureArrayPool = [];
let es = Wl;
Y.add(es);
var rz = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`
  , iz = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const y_ = class Vl extends Ri {
    constructor(t, r, i) {
        const n = tn.from(t || Vl.defaultVertexSrc, r || Vl.defaultFragmentSrc);
        super(n, i),
        this.padding = 0,
        this.resolution = Vl.defaultResolution,
        this.multisample = Vl.defaultMultisample,
        this.enabled = !0,
        this.autoFit = !0,
        this.state = new Bi
    }
    apply(t, r, i, n, s) {
        t.applyFilter(this, r, i, n)
    }
    get blendMode() {
        return this.state.blendMode
    }
    set blendMode(t) {
        this.state.blendMode = t
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._resolution = t
    }
    static get defaultVertexSrc() {
        return iz
    }
    static get defaultFragmentSrc() {
        return rz
    }
}
;
y_.defaultResolution = 1,
y_.defaultMultisample = se.NONE;
let ze = y_;
class ru {
    constructor() {
        this.clearBeforeRender = !0,
        this._backgroundColor = new xt(0),
        this.alpha = 1
    }
    init(t) {
        this.clearBeforeRender = t.clearBeforeRender;
        const {backgroundColor: r, background: i, backgroundAlpha: n} = t
          , s = i ?? r;
        s !== void 0 && (this.color = s),
        this.alpha = n
    }
    get color() {
        return this._backgroundColor.value
    }
    set color(t) {
        this._backgroundColor.setValue(t)
    }
    get alpha() {
        return this._backgroundColor.alpha
    }
    set alpha(t) {
        this._backgroundColor.setAlpha(t)
    }
    get backgroundColor() {
        return this._backgroundColor
    }
    destroy() {}
}
ru.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: !0
},
ru.extension = {
    type: [G.RendererSystem, G.CanvasRendererSystem],
    name: "background"
};
Y.add(ru);
class ix {
    constructor(t) {
        this.renderer = t,
        this.emptyRenderer = new Hu(t),
        this.currentRenderer = this.emptyRenderer
    }
    setObjectRenderer(t) {
        this.currentRenderer !== t && (this.currentRenderer.stop(),
        this.currentRenderer = t,
        this.currentRenderer.start())
    }
    flush() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    reset() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    copyBoundTextures(t, r) {
        const {boundTextures: i} = this.renderer.texture;
        for (let n = r - 1; n >= 0; --n)
            t[n] = i[n] || null,
            t[n] && (t[n]._batchLocation = n)
    }
    boundArray(t, r, i, n) {
        const {elements: s, ids: o, count: a} = t;
        let l = 0;
        for (let h = 0; h < a; h++) {
            const u = s[h]
              , c = u._batchLocation;
            if (c >= 0 && c < n && r[c] === u) {
                o[h] = c;
                continue
            }
            for (; l < n; ) {
                const d = r[l];
                if (d && d._batchEnabled === i && d._batchLocation === l) {
                    l++;
                    continue
                }
                o[h] = l,
                u._batchLocation = l,
                r[l] = u;
                break
            }
        }
    }
    destroy() {
        this.renderer = null
    }
}
ix.extension = {
    type: G.RendererSystem,
    name: "batch"
};
Y.add(ix);
let DS = 0;
class iu {
    constructor(t) {
        this.renderer = t,
        this.webGLVersion = 1,
        this.extensions = {},
        this.supports = {
            uint32Indices: !1
        },
        this.handleContextLost = this.handleContextLost.bind(this),
        this.handleContextRestored = this.handleContextRestored.bind(this)
    }
    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }
    contextChange(t) {
        this.gl = t,
        this.renderer.gl = t,
        this.renderer.CONTEXT_UID = DS++
    }
    init(t) {
        if (t.context)
            this.initFromContext(t.context);
        else {
            const r = this.renderer.background.alpha < 1
              , i = t.premultipliedAlpha;
            this.preserveDrawingBuffer = t.preserveDrawingBuffer,
            this.useContextAlpha = t.useContextAlpha,
            this.powerPreference = t.powerPreference,
            this.initFromOptions({
                alpha: r,
                premultipliedAlpha: i,
                antialias: t.antialias,
                stencil: !0,
                preserveDrawingBuffer: t.preserveDrawingBuffer,
                powerPreference: t.powerPreference
            })
        }
    }
    initFromContext(t) {
        this.gl = t,
        this.validateContext(t),
        this.renderer.gl = t,
        this.renderer.CONTEXT_UID = DS++,
        this.renderer.runners.contextChange.emit(t);
        const r = this.renderer.view;
        r.addEventListener !== void 0 && (r.addEventListener("webglcontextlost", this.handleContextLost, !1),
        r.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
    }
    initFromOptions(t) {
        const r = this.createContext(this.renderer.view, t);
        this.initFromContext(r)
    }
    createContext(t, r) {
        let i;
        if (z.PREFER_ENV >= Fs.WEBGL2 && (i = t.getContext("webgl2", r)),
        i)
            this.webGLVersion = 2;
        else if (this.webGLVersion = 1,
        i = t.getContext("webgl", r) || t.getContext("experimental-webgl", r),
        !i)
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        return this.gl = i,
        this.getExtensions(),
        this.gl
    }
    getExtensions() {
        const {gl: t} = this
          , r = {
            loseContext: t.getExtension("WEBGL_lose_context"),
            anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: t.getExtension("WEBGL_compressed_texture_etc"),
            etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: t.getExtension("WEBGL_compressed_texture_atc"),
            astc: t.getExtension("WEBGL_compressed_texture_astc")
        };
        this.webGLVersion === 1 ? Object.assign(this.extensions, r, {
            drawBuffers: t.getExtension("WEBGL_draw_buffers"),
            depthTexture: t.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: t.getExtension("OES_element_index_uint"),
            floatTexture: t.getExtension("OES_texture_float"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            textureHalfFloat: t.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
        }) : this.webGLVersion === 2 && Object.assign(this.extensions, r, {
            colorBufferFloat: t.getExtension("EXT_color_buffer_float")
        })
    }
    handleContextLost(t) {
        t.preventDefault(),
        setTimeout( () => {
            this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
        }
        , 0)
    }
    handleContextRestored() {
        this.renderer.runners.contextChange.emit(this.gl)
    }
    destroy() {
        const t = this.renderer.view;
        this.renderer = null,
        t.removeEventListener !== void 0 && (t.removeEventListener("webglcontextlost", this.handleContextLost),
        t.removeEventListener("webglcontextrestored", this.handleContextRestored)),
        this.gl.useProgram(null),
        this.extensions.loseContext && this.extensions.loseContext.loseContext()
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
    }
    validateContext(t) {
        const r = t.getContextAttributes()
          , i = "WebGL2RenderingContext"in globalThis && t instanceof globalThis.WebGL2RenderingContext;
        i && (this.webGLVersion = 2),
        r && !r.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        const n = i || !!t.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = n,
        n || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
    }
}
iu.defaultOptions = {
    context: null,
    antialias: !1,
    premultipliedAlpha: !0,
    preserveDrawingBuffer: !1,
    powerPreference: "default"
},
iu.extension = {
    type: G.RendererSystem,
    name: "context"
};
Y.add(iu);
class yf {
    constructor(t, r) {
        if (this.width = Math.round(t),
        this.height = Math.round(r),
        !this.width || !this.height)
            throw new Error("Framebuffer width or height is zero");
        this.stencil = !1,
        this.depth = !1,
        this.dirtyId = 0,
        this.dirtyFormat = 0,
        this.dirtySize = 0,
        this.depthTexture = null,
        this.colorTextures = [],
        this.glFramebuffers = {},
        this.disposeRunner = new Nr("disposeFramebuffer"),
        this.multisample = se.NONE
    }
    get colorTexture() {
        return this.colorTextures[0]
    }
    addColorTexture(t=0, r) {
        return this.colorTextures[t] = r || new nt(null,{
            scaleMode: Qi.NEAREST,
            resolution: 1,
            mipmap: Ni.OFF,
            width: this.width,
            height: this.height
        }),
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    addDepthTexture(t) {
        return this.depthTexture = t || new nt(null,{
            scaleMode: Qi.NEAREST,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: Ni.OFF,
            format: B.DEPTH_COMPONENT,
            type: Q.UNSIGNED_SHORT
        }),
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    enableDepth() {
        return this.depth = !0,
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    enableStencil() {
        return this.stencil = !0,
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    resize(t, r) {
        if (t = Math.round(t),
        r = Math.round(r),
        !t || !r)
            throw new Error("Framebuffer width and height must not be zero");
        if (!(t === this.width && r === this.height)) {
            this.width = t,
            this.height = r,
            this.dirtyId++,
            this.dirtySize++;
            for (let i = 0; i < this.colorTextures.length; i++) {
                const n = this.colorTextures[i]
                  , s = n.resolution;
                n.setSize(t / s, r / s)
            }
            if (this.depthTexture) {
                const i = this.depthTexture.resolution;
                this.depthTexture.setSize(t / i, r / i)
            }
        }
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroyDepthTexture() {
        this.depthTexture && (this.depthTexture.destroy(),
        this.depthTexture = null,
        ++this.dirtyId,
        ++this.dirtyFormat)
    }
}
class nx extends nt {
    constructor(t={}) {
        if (typeof t == "number") {
            const r = arguments[0]
              , i = arguments[1]
              , n = arguments[2]
              , s = arguments[3];
            t = {
                width: r,
                height: i,
                scaleMode: n,
                resolution: s
            }
        }
        t.width = t.width ?? 100,
        t.height = t.height ?? 100,
        t.multisample ?? (t.multisample = se.NONE),
        super(null, t),
        this.mipmap = Ni.OFF,
        this.valid = !0,
        this._clear = new xt([0, 0, 0, 0]),
        this.framebuffer = new yf(this.realWidth,this.realHeight).addColorTexture(0, this),
        this.framebuffer.multisample = t.multisample,
        this.maskStack = [],
        this.filterStack = [{}]
    }
    set clearColor(t) {
        this._clear.setValue(t)
    }
    get clearColor() {
        return this._clear.value
    }
    get clear() {
        return this._clear
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(t) {
        this.framebuffer.multisample = t
    }
    resize(t, r) {
        this.framebuffer.resize(t * this.resolution, r * this.resolution),
        this.setRealSize(this.framebuffer.width, this.framebuffer.height)
    }
    dispose() {
        this.framebuffer.dispose(),
        super.dispose()
    }
    destroy() {
        super.destroy(),
        this.framebuffer.destroyDepthTexture(),
        this.framebuffer = null
    }
}
class Gn extends el {
    constructor(t) {
        const r = t
          , i = r.naturalWidth || r.videoWidth || r.width
          , n = r.naturalHeight || r.videoHeight || r.height;
        super(i, n),
        this.source = t,
        this.noSubImage = !1
    }
    static crossOrigin(t, r, i) {
        i === void 0 && !r.startsWith("data:") ? t.crossOrigin = II(r) : i !== !1 && (t.crossOrigin = typeof i == "string" ? i : "anonymous")
    }
    upload(t, r, i, n) {
        const s = t.gl
          , o = r.realWidth
          , a = r.realHeight;
        if (n = n || this.source,
        typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) {
            if (!n.complete || n.naturalWidth === 0)
                return !1
        } else if (typeof HTMLVideoElement < "u" && n instanceof HTMLVideoElement && n.readyState <= 1)
            return !1;
        return s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === tr.UNPACK),
        !this.noSubImage && r.target === s.TEXTURE_2D && i.width === o && i.height === a ? s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, r.format, i.type, n) : (i.width = o,
        i.height = a,
        s.texImage2D(r.target, 0, i.internalFormat, r.format, i.type, n)),
        !0
    }
    update() {
        if (this.destroyed)
            return;
        const t = this.source
          , r = t.naturalWidth || t.videoWidth || t.width
          , i = t.naturalHeight || t.videoHeight || t.height;
        this.resize(r, i),
        super.update()
    }
    dispose() {
        this.source = null
    }
}
class sx extends Gn {
    constructor(t, r) {
        if (r = r || {},
        typeof t == "string") {
            const i = new Image;
            Gn.crossOrigin(i, t, r.crossorigin),
            i.src = t,
            t = i
        }
        super(t),
        !t.complete && this._width && this._height && (this._width = 0,
        this._height = 0),
        this.url = t.src,
        this._process = null,
        this.preserveBitmap = !1,
        this.createBitmap = (r.createBitmap ?? z.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap,
        this.alphaMode = typeof r.alphaMode == "number" ? r.alphaMode : null,
        this.bitmap = null,
        this._load = null,
        r.autoLoad !== !1 && this.load()
    }
    load(t) {
        return this._load ? this._load : (t !== void 0 && (this.createBitmap = t),
        this._load = new Promise( (r, i) => {
            const n = this.source;
            this.url = n.src;
            const s = () => {
                this.destroyed || (n.onload = null,
                n.onerror = null,
                this.update(),
                this._load = null,
                this.createBitmap ? r(this.process()) : r(this))
            }
            ;
            n.complete && n.src ? s() : (n.onload = s,
            n.onerror = o => {
                i(o),
                this.onError.emit(o)
            }
            )
        }
        ),
        this._load)
    }
    process() {
        const t = this.source;
        if (this._process !== null)
            return this._process;
        if (this.bitmap !== null || !globalThis.createImageBitmap)
            return Promise.resolve(this);
        const r = globalThis.createImageBitmap
          , i = !t.crossOrigin || t.crossOrigin === "anonymous";
        return this._process = fetch(t.src, {
            mode: i ? "cors" : "no-cors"
        }).then(n => n.blob()).then(n => r(n, 0, 0, t.width, t.height, {
            premultiplyAlpha: this.alphaMode === null || this.alphaMode === tr.UNPACK ? "premultiply" : "none"
        })).then(n => this.destroyed ? Promise.reject() : (this.bitmap = n,
        this.update(),
        this._process = null,
        Promise.resolve(this))),
        this._process
    }
    upload(t, r, i) {
        if (typeof this.alphaMode == "number" && (r.alphaMode = this.alphaMode),
        !this.createBitmap)
            return super.upload(t, r, i);
        if (!this.bitmap && (this.process(),
        !this.bitmap))
            return !1;
        if (super.upload(t, r, i, this.bitmap),
        !this.preserveBitmap) {
            let n = !0;
            const s = r._glTextures;
            for (const o in s) {
                const a = s[o];
                if (a !== i && a.dirtyId !== r.dirtyId) {
                    n = !1;
                    break
                }
            }
            n && (this.bitmap.close && this.bitmap.close(),
            this.bitmap = null)
        }
        return !0
    }
    dispose() {
        this.source.onload = null,
        this.source.onerror = null,
        super.dispose(),
        this.bitmap && (this.bitmap.close(),
        this.bitmap = null),
        this._process = null,
        this._load = null
    }
    static test(t) {
        return typeof HTMLImageElement < "u" && (typeof t == "string" || t instanceof HTMLImageElement)
    }
}
class Np {
    constructor() {
        this.x0 = 0,
        this.y0 = 0,
        this.x1 = 1,
        this.y1 = 0,
        this.x2 = 1,
        this.y2 = 1,
        this.x3 = 0,
        this.y3 = 1,
        this.uvsFloat32 = new Float32Array(8)
    }
    set(t, r, i) {
        const n = r.width
          , s = r.height;
        if (i) {
            const o = t.width / 2 / n
              , a = t.height / 2 / s
              , l = t.x / n + o
              , h = t.y / s + a;
            i = Ut.add(i, Ut.NW),
            this.x0 = l + o * Ut.uX(i),
            this.y0 = h + a * Ut.uY(i),
            i = Ut.add(i, 2),
            this.x1 = l + o * Ut.uX(i),
            this.y1 = h + a * Ut.uY(i),
            i = Ut.add(i, 2),
            this.x2 = l + o * Ut.uX(i),
            this.y2 = h + a * Ut.uY(i),
            i = Ut.add(i, 2),
            this.x3 = l + o * Ut.uX(i),
            this.y3 = h + a * Ut.uY(i)
        } else
            this.x0 = t.x / n,
            this.y0 = t.y / s,
            this.x1 = (t.x + t.width) / n,
            this.y1 = t.y / s,
            this.x2 = (t.x + t.width) / n,
            this.y2 = (t.y + t.height) / s,
            this.x3 = t.x / n,
            this.y3 = (t.y + t.height) / s;
        this.uvsFloat32[0] = this.x0,
        this.uvsFloat32[1] = this.y0,
        this.uvsFloat32[2] = this.x1,
        this.uvsFloat32[3] = this.y1,
        this.uvsFloat32[4] = this.x2,
        this.uvsFloat32[5] = this.y2,
        this.uvsFloat32[6] = this.x3,
        this.uvsFloat32[7] = this.y3
    }
}
Np.prototype.toString = function() {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
}
;
const BS = new Np;
function Nc(e) {
    e.destroy = function() {}
    ,
    e.on = function() {}
    ,
    e.once = function() {}
    ,
    e.emit = function() {}
}
class F extends ci {
    constructor(t, r, i, n, s, o, a) {
        if (super(),
        this.noFrame = !1,
        r || (this.noFrame = !0,
        r = new lt(0,0,1,1)),
        t instanceof F && (t = t.baseTexture),
        this.baseTexture = t,
        this._frame = r,
        this.trim = n,
        this.valid = !1,
        this.destroyed = !1,
        this._uvs = BS,
        this.uvMatrix = null,
        this.orig = i || r,
        this._rotate = Number(s || 0),
        s === !0)
            this._rotate = 2;
        else if (this._rotate % 2 !== 0)
            throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        this.defaultAnchor = o ? new st(o.x,o.y) : new st(0,0),
        this.defaultBorders = a,
        this._updateID = 0,
        this.textureCacheIds = [],
        t.valid ? this.noFrame ? t.valid && this.onBaseTextureUpdated(t) : this.frame = r : t.once("loaded", this.onBaseTextureUpdated, this),
        this.noFrame && t.on("update", this.onBaseTextureUpdated, this)
    }
    update() {
        this.baseTexture.resource && this.baseTexture.resource.update()
    }
    onBaseTextureUpdated(t) {
        if (this.noFrame) {
            if (!this.baseTexture.valid)
                return;
            this._frame.width = t.width,
            this._frame.height = t.height,
            this.valid = !0,
            this.updateUvs()
        } else
            this.frame = this._frame;
        this.emit("update", this)
    }
    destroy(t) {
        if (this.baseTexture) {
            if (t) {
                const {resource: r} = this.baseTexture;
                r?.url && Ze[r.url] && F.removeFromCache(r.url),
                this.baseTexture.destroy()
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this),
            this.baseTexture.off("update", this.onBaseTextureUpdated, this),
            this.baseTexture = null
        }
        this._frame = null,
        this._uvs = null,
        this.trim = null,
        this.orig = null,
        this.valid = !1,
        F.removeFromCache(this),
        this.textureCacheIds = null,
        this.destroyed = !0,
        this.emit("destroyed", this),
        this.removeAllListeners()
    }
    clone() {
        const t = this._frame.clone()
          , r = this._frame === this.orig ? t : this.orig.clone()
          , i = new F(this.baseTexture,!this.noFrame && t,r,this.trim?.clone(),this.rotate,this.defaultAnchor,this.defaultBorders);
        return this.noFrame && (i._frame = t),
        i
    }
    updateUvs() {
        this._uvs === BS && (this._uvs = new Np),
        this._uvs.set(this._frame, this.baseTexture, this.rotate),
        this._updateID++
    }
    static from(t, r={}, i=z.STRICT_TEXTURE_CACHE) {
        const n = typeof t == "string";
        let s = null;
        if (n)
            s = t;
        else if (t instanceof nt) {
            if (!t.cacheId) {
                const a = r?.pixiIdPrefix || "pixiid";
                t.cacheId = `${a}-${Is()}`,
                nt.addToCache(t, t.cacheId)
            }
            s = t.cacheId
        } else {
            if (!t._pixiId) {
                const a = r?.pixiIdPrefix || "pixiid";
                t._pixiId = `${a}_${Is()}`
            }
            s = t._pixiId
        }
        let o = Ze[s];
        if (n && i && !o)
            throw new Error(`The cacheId "${s}" does not exist in TextureCache.`);
        return !o && !(t instanceof nt) ? (r.resolution || (r.resolution = un(t)),
        o = new F(new nt(t,r)),
        o.baseTexture.cacheId = s,
        nt.addToCache(o.baseTexture, s),
        F.addToCache(o, s)) : !o && t instanceof nt && (o = new F(t),
        F.addToCache(o, s)),
        o
    }
    static fromURL(t, r) {
        const i = Object.assign({
            autoLoad: !1
        }, r?.resourceOptions)
          , n = F.from(t, Object.assign({
            resourceOptions: i
        }, r), !1)
          , s = n.baseTexture.resource;
        return n.baseTexture.valid ? Promise.resolve(n) : s.load().then( () => Promise.resolve(n))
    }
    static fromBuffer(t, r, i, n) {
        return new F(nt.fromBuffer(t, r, i, n))
    }
    static fromLoader(t, r, i, n) {
        const s = new nt(t,Object.assign({
            scaleMode: nt.defaultOptions.scaleMode,
            resolution: un(r)
        }, n))
          , {resource: o} = s;
        o instanceof sx && (o.url = r);
        const a = new F(s);
        return i || (i = r),
        nt.addToCache(a.baseTexture, i),
        F.addToCache(a, i),
        i !== r && (nt.addToCache(a.baseTexture, r),
        F.addToCache(a, r)),
        a.baseTexture.valid ? Promise.resolve(a) : new Promise(l => {
            a.baseTexture.once("loaded", () => l(a))
        }
        )
    }
    static addToCache(t, r) {
        r && (t.textureCacheIds.includes(r) || t.textureCacheIds.push(r),
        Ze[r] && Ze[r] !== t && console.warn(`Texture added to the cache with an id [${r}] that already had an entry`),
        Ze[r] = t)
    }
    static removeFromCache(t) {
        if (typeof t == "string") {
            const r = Ze[t];
            if (r) {
                const i = r.textureCacheIds.indexOf(t);
                return i > -1 && r.textureCacheIds.splice(i, 1),
                delete Ze[t],
                r
            }
        } else if (t?.textureCacheIds) {
            for (let r = 0; r < t.textureCacheIds.length; ++r)
                Ze[t.textureCacheIds[r]] === t && delete Ze[t.textureCacheIds[r]];
            return t.textureCacheIds.length = 0,
            t
        }
        return null
    }
    get resolution() {
        return this.baseTexture.resolution
    }
    get frame() {
        return this._frame
    }
    set frame(t) {
        this._frame = t,
        this.noFrame = !1;
        const {x: r, y: i, width: n, height: s} = t
          , o = r + n > this.baseTexture.width
          , a = i + s > this.baseTexture.height;
        if (o || a) {
            const l = o && a ? "and" : "or"
              , h = `X: ${r} + ${n} = ${r + n} > ${this.baseTexture.width}`
              , u = `Y: ${i} + ${s} = ${i + s} > ${this.baseTexture.height}`;
            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${h} ${l} ${u}`)
        }
        this.valid = n && s && this.baseTexture.valid,
        !this.trim && !this.rotate && (this.orig = t),
        this.valid && this.updateUvs()
    }
    get rotate() {
        return this._rotate
    }
    set rotate(t) {
        this._rotate = t,
        this.valid && this.updateUvs()
    }
    get width() {
        return this.orig.width
    }
    get height() {
        return this.orig.height
    }
    castToBaseTexture() {
        return this.baseTexture
    }
    static get EMPTY() {
        return F._EMPTY || (F._EMPTY = new F(new nt),
        Nc(F._EMPTY),
        Nc(F._EMPTY.baseTexture)),
        F._EMPTY
    }
    static get WHITE() {
        if (!F._WHITE) {
            const t = z.ADAPTER.createCanvas(16, 16)
              , r = t.getContext("2d");
            t.width = 16,
            t.height = 16,
            r.fillStyle = "white",
            r.fillRect(0, 0, 16, 16),
            F._WHITE = new F(nt.from(t)),
            Nc(F._WHITE),
            Nc(F._WHITE.baseTexture)
        }
        return F._WHITE
    }
}
class Gs extends F {
    constructor(t, r) {
        super(t, r),
        this.valid = !0,
        this.filterFrame = null,
        this.filterPoolKey = null,
        this.updateUvs()
    }
    get framebuffer() {
        return this.baseTexture.framebuffer
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(t) {
        this.framebuffer.multisample = t
    }
    resize(t, r, i=!0) {
        const n = this.baseTexture.resolution
          , s = Math.round(t * n) / n
          , o = Math.round(r * n) / n;
        this.valid = s > 0 && o > 0,
        this._frame.width = this.orig.width = s,
        this._frame.height = this.orig.height = o,
        i && this.baseTexture.resize(s, o),
        this.updateUvs()
    }
    setResolution(t) {
        const {baseTexture: r} = this;
        r.resolution !== t && (r.setResolution(t),
        this.resize(r.width, r.height, !1))
    }
    static create(t) {
        return new Gs(new nx(t))
    }
}
class ox {
    constructor(t) {
        this.texturePool = {},
        this.textureOptions = t || {},
        this.enableFullScreen = !1,
        this._pixelsWidth = 0,
        this._pixelsHeight = 0
    }
    createTexture(t, r, i=se.NONE) {
        const n = new nx(Object.assign({
            width: t,
            height: r,
            resolution: 1,
            multisample: i
        }, this.textureOptions));
        return new Gs(n)
    }
    getOptimalTexture(t, r, i=1, n=se.NONE) {
        let s;
        t = Math.max(Math.ceil(t * i - 1e-6), 1),
        r = Math.max(Math.ceil(r * i - 1e-6), 1),
        !this.enableFullScreen || t !== this._pixelsWidth || r !== this._pixelsHeight ? (t = Jh(t),
        r = Jh(r),
        s = ((t & 65535) << 16 | r & 65535) >>> 0,
        n > 1 && (s += n * 4294967296)) : s = n > 1 ? -n : -1,
        this.texturePool[s] || (this.texturePool[s] = []);
        let o = this.texturePool[s].pop();
        return o || (o = this.createTexture(t, r, n)),
        o.filterPoolKey = s,
        o.setResolution(i),
        o
    }
    getFilterTexture(t, r, i) {
        const n = this.getOptimalTexture(t.width, t.height, r || t.resolution, i || se.NONE);
        return n.filterFrame = t.filterFrame,
        n
    }
    returnTexture(t) {
        const r = t.filterPoolKey;
        t.filterFrame = null,
        this.texturePool[r].push(t)
    }
    returnFilterTexture(t) {
        this.returnTexture(t)
    }
    clear(t) {
        if (t = t !== !1,
        t)
            for (const r in this.texturePool) {
                const i = this.texturePool[r];
                if (i)
                    for (let n = 0; n < i.length; n++)
                        i[n].destroy(!0)
            }
        this.texturePool = {}
    }
    setScreenSize(t) {
        if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
            this.enableFullScreen = t.width > 0 && t.height > 0;
            for (const r in this.texturePool) {
                if (!(Number(r) < 0))
                    continue;
                const i = this.texturePool[r];
                if (i)
                    for (let n = 0; n < i.length; n++)
                        i[n].destroy(!0);
                this.texturePool[r] = []
            }
            this._pixelsWidth = t.width,
            this._pixelsHeight = t.height
        }
    }
}
ox.SCREEN_KEY = -1;
class HI extends Un {
    constructor() {
        super(),
        this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
    }
}
class ax extends Un {
    constructor() {
        super(),
        this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]),
        this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        this.vertexBuffer = new te(this.vertices),
        this.uvBuffer = new te(this.uvs),
        this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
    }
    map(t, r) {
        let i = 0
          , n = 0;
        return this.uvs[0] = i,
        this.uvs[1] = n,
        this.uvs[2] = i + r.width / t.width,
        this.uvs[3] = n,
        this.uvs[4] = i + r.width / t.width,
        this.uvs[5] = n + r.height / t.height,
        this.uvs[6] = i,
        this.uvs[7] = n + r.height / t.height,
        i = r.x,
        n = r.y,
        this.vertices[0] = i,
        this.vertices[1] = n,
        this.vertices[2] = i + r.width,
        this.vertices[3] = n,
        this.vertices[4] = i + r.width,
        this.vertices[5] = n + r.height,
        this.vertices[6] = i,
        this.vertices[7] = n + r.height,
        this.invalidate(),
        this
    }
    invalidate() {
        return this.vertexBuffer._updateID++,
        this.uvBuffer._updateID++,
        this
    }
}
class $I {
    constructor() {
        this.renderTexture = null,
        this.target = null,
        this.legacy = !1,
        this.resolution = 1,
        this.multisample = se.NONE,
        this.sourceFrame = new lt,
        this.destinationFrame = new lt,
        this.bindingSourceFrame = new lt,
        this.bindingDestinationFrame = new lt,
        this.filters = [],
        this.transform = null
    }
    clear() {
        this.target = null,
        this.filters = null,
        this.renderTexture = null
    }
}
const Lc = [new st, new st, new st, new st]
  , ig = new Mt;
class lx {
    constructor(t) {
        this.renderer = t,
        this.defaultFilterStack = [{}],
        this.texturePool = new ox,
        this.statePool = [],
        this.quad = new HI,
        this.quadUv = new ax,
        this.tempRect = new lt,
        this.activeState = {},
        this.globalUniforms = new ni({
            outputFrame: new lt,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4)
        },!0),
        this.forceClear = !1,
        this.useMaxPadding = !1
    }
    init() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    push(t, r) {
        const i = this.renderer
          , n = this.defaultFilterStack
          , s = this.statePool.pop() || new $I
          , o = i.renderTexture;
        let a, l;
        if (o.current) {
            const v = o.current;
            a = v.resolution,
            l = v.multisample
        } else
            a = i.resolution,
            l = i.multisample;
        let h = r[0].resolution || a
          , u = r[0].multisample ?? l
          , c = r[0].padding
          , d = r[0].autoFit
          , f = r[0].legacy ?? !0;
        for (let v = 1; v < r.length; v++) {
            const y = r[v];
            h = Math.min(h, y.resolution || a),
            u = Math.min(u, y.multisample ?? l),
            c = this.useMaxPadding ? Math.max(c, y.padding) : c + y.padding,
            d = d && y.autoFit,
            f = f || (y.legacy ?? !0)
        }
        n.length === 1 && (this.defaultFilterStack[0].renderTexture = o.current),
        n.push(s),
        s.resolution = h,
        s.multisample = u,
        s.legacy = f,
        s.target = t,
        s.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
        s.sourceFrame.pad(c);
        const g = this.tempRect.copyFrom(o.sourceFrame);
        i.projection.transform && this.transformAABB(ig.copyFrom(i.projection.transform).invert(), g),
        d ? (s.sourceFrame.fit(g),
        (s.sourceFrame.width <= 0 || s.sourceFrame.height <= 0) && (s.sourceFrame.width = 0,
        s.sourceFrame.height = 0)) : s.sourceFrame.intersects(g) || (s.sourceFrame.width = 0,
        s.sourceFrame.height = 0),
        this.roundFrame(s.sourceFrame, o.current ? o.current.resolution : i.resolution, o.sourceFrame, o.destinationFrame, i.projection.transform),
        s.renderTexture = this.getOptimalFilterTexture(s.sourceFrame.width, s.sourceFrame.height, h, u),
        s.filters = r,
        s.destinationFrame.width = s.renderTexture.width,
        s.destinationFrame.height = s.renderTexture.height;
        const p = this.tempRect;
        p.x = 0,
        p.y = 0,
        p.width = s.sourceFrame.width,
        p.height = s.sourceFrame.height,
        s.renderTexture.filterFrame = s.sourceFrame,
        s.bindingSourceFrame.copyFrom(o.sourceFrame),
        s.bindingDestinationFrame.copyFrom(o.destinationFrame),
        s.transform = i.projection.transform,
        i.projection.transform = null,
        o.bind(s.renderTexture, s.sourceFrame, p),
        i.framebuffer.clear(0, 0, 0, 0)
    }
    pop() {
        const t = this.defaultFilterStack
          , r = t.pop()
          , i = r.filters;
        this.activeState = r;
        const n = this.globalUniforms.uniforms;
        n.outputFrame = r.sourceFrame,
        n.resolution = r.resolution;
        const s = n.inputSize
          , o = n.inputPixel
          , a = n.inputClamp;
        if (s[0] = r.destinationFrame.width,
        s[1] = r.destinationFrame.height,
        s[2] = 1 / s[0],
        s[3] = 1 / s[1],
        o[0] = Math.round(s[0] * r.resolution),
        o[1] = Math.round(s[1] * r.resolution),
        o[2] = 1 / o[0],
        o[3] = 1 / o[1],
        a[0] = .5 * o[2],
        a[1] = .5 * o[3],
        a[2] = r.sourceFrame.width * s[2] - .5 * o[2],
        a[3] = r.sourceFrame.height * s[3] - .5 * o[3],
        r.legacy) {
            const h = n.filterArea;
            h[0] = r.destinationFrame.width,
            h[1] = r.destinationFrame.height,
            h[2] = r.sourceFrame.x,
            h[3] = r.sourceFrame.y,
            n.filterClamp = n.inputClamp
        }
        this.globalUniforms.update();
        const l = t[t.length - 1];
        if (this.renderer.framebuffer.blit(),
        i.length === 1)
            i[0].apply(this, r.renderTexture, l.renderTexture, vi.BLEND, r),
            this.returnFilterTexture(r.renderTexture);
        else {
            let h = r.renderTexture
              , u = this.getOptimalFilterTexture(h.width, h.height, r.resolution);
            u.filterFrame = h.filterFrame;
            let c = 0;
            for (c = 0; c < i.length - 1; ++c) {
                c === 1 && r.multisample > 1 && (u = this.getOptimalFilterTexture(h.width, h.height, r.resolution),
                u.filterFrame = h.filterFrame),
                i[c].apply(this, h, u, vi.CLEAR, r);
                const d = h;
                h = u,
                u = d
            }
            i[c].apply(this, h, l.renderTexture, vi.BLEND, r),
            c > 1 && r.multisample > 1 && this.returnFilterTexture(r.renderTexture),
            this.returnFilterTexture(h),
            this.returnFilterTexture(u)
        }
        r.clear(),
        this.statePool.push(r)
    }
    bindAndClear(t, r=vi.CLEAR) {
        const {renderTexture: i, state: n} = this.renderer;
        if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null,
        t?.filterFrame) {
            const o = this.tempRect;
            o.x = 0,
            o.y = 0,
            o.width = t.filterFrame.width,
            o.height = t.filterFrame.height,
            i.bind(t, t.filterFrame, o)
        } else
            t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? i.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        const s = n.stateId & 1 || this.forceClear;
        (r === vi.CLEAR || r === vi.BLIT && s) && this.renderer.framebuffer.clear(0, 0, 0, 0)
    }
    applyFilter(t, r, i, n) {
        const s = this.renderer;
        s.state.set(t.state),
        this.bindAndClear(i, n),
        t.uniforms.uSampler = r,
        t.uniforms.filterGlobals = this.globalUniforms,
        s.shader.bind(t),
        t.legacy = !!t.program.attributeData.aTextureCoord,
        t.legacy ? (this.quadUv.map(r._frame, r.filterFrame),
        s.geometry.bind(this.quadUv),
        s.geometry.draw(Ti.TRIANGLES)) : (s.geometry.bind(this.quad),
        s.geometry.draw(Ti.TRIANGLE_STRIP))
    }
    calculateSpriteMatrix(t, r) {
        const {sourceFrame: i, destinationFrame: n} = this.activeState
          , {orig: s} = r._texture
          , o = t.set(n.width, 0, 0, n.height, i.x, i.y)
          , a = r.worldTransform.copyTo(Mt.TEMP_MATRIX);
        return a.invert(),
        o.prepend(a),
        o.scale(1 / s.width, 1 / s.height),
        o.translate(r.anchor.x, r.anchor.y),
        o
    }
    destroy() {
        this.renderer = null,
        this.texturePool.clear(!1)
    }
    getOptimalFilterTexture(t, r, i=1, n=se.NONE) {
        return this.texturePool.getOptimalTexture(t, r, i, n)
    }
    getFilterTexture(t, r, i) {
        if (typeof t == "number") {
            const s = t;
            t = r,
            r = s
        }
        t = t || this.activeState.renderTexture;
        const n = this.texturePool.getOptimalTexture(t.width, t.height, r || t.resolution, i || se.NONE);
        return n.filterFrame = t.filterFrame,
        n
    }
    returnFilterTexture(t) {
        this.texturePool.returnTexture(t)
    }
    emptyPool() {
        this.texturePool.clear(!0)
    }
    resize() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    transformAABB(t, r) {
        const i = Lc[0]
          , n = Lc[1]
          , s = Lc[2]
          , o = Lc[3];
        i.set(r.left, r.top),
        n.set(r.left, r.bottom),
        s.set(r.right, r.top),
        o.set(r.right, r.bottom),
        t.apply(i, i),
        t.apply(n, n),
        t.apply(s, s),
        t.apply(o, o);
        const a = Math.min(i.x, n.x, s.x, o.x)
          , l = Math.min(i.y, n.y, s.y, o.y)
          , h = Math.max(i.x, n.x, s.x, o.x)
          , u = Math.max(i.y, n.y, s.y, o.y);
        r.x = a,
        r.y = l,
        r.width = h - a,
        r.height = u - l
    }
    roundFrame(t, r, i, n, s) {
        if (!(t.width <= 0 || t.height <= 0 || i.width <= 0 || i.height <= 0)) {
            if (s) {
                const {a: o, b: a, c: l, d: h} = s;
                if ((Math.abs(a) > 1e-4 || Math.abs(l) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(h) > 1e-4))
                    return
            }
            s = s ? ig.copyFrom(s) : ig.identity(),
            s.translate(-i.x, -i.y).scale(n.width / i.width, n.height / i.height).translate(n.x, n.y),
            this.transformAABB(s, t),
            t.ceil(r),
            this.transformAABB(s.invert(), t)
        }
    }
}
lx.extension = {
    type: G.RendererSystem,
    name: "filter"
};
Y.add(lx);
class zI {
    constructor(t) {
        this.framebuffer = t,
        this.stencil = null,
        this.dirtyId = -1,
        this.dirtyFormat = -1,
        this.dirtySize = -1,
        this.multisample = se.NONE,
        this.msaaBuffer = null,
        this.blitFramebuffer = null,
        this.mipLevel = 0
    }
}
const nz = new lt;
class hx {
    constructor(t) {
        this.renderer = t,
        this.managedFramebuffers = [],
        this.unknownFramebuffer = new yf(10,10),
        this.msaaSamples = null
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        this.current = this.unknownFramebuffer,
        this.viewport = new lt,
        this.hasMRT = !0,
        this.writeDepthTexture = !0,
        this.renderer.context.webGLVersion === 1) {
            let r = this.renderer.context.extensions.drawBuffers
              , i = this.renderer.context.extensions.depthTexture;
            z.PREFER_ENV === Fs.WEBGL_LEGACY && (r = null,
            i = null),
            r ? t.drawBuffers = n => r.drawBuffersWEBGL(n) : (this.hasMRT = !1,
            t.drawBuffers = () => {}
            ),
            i || (this.writeDepthTexture = !1)
        } else
            this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
    }
    bind(t, r, i=0) {
        const {gl: n} = this;
        if (t) {
            const s = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
            this.current !== t && (this.current = t,
            n.bindFramebuffer(n.FRAMEBUFFER, s.framebuffer)),
            s.mipLevel !== i && (t.dirtyId++,
            t.dirtyFormat++,
            s.mipLevel = i),
            s.dirtyId !== t.dirtyId && (s.dirtyId = t.dirtyId,
            s.dirtyFormat !== t.dirtyFormat ? (s.dirtyFormat = t.dirtyFormat,
            s.dirtySize = t.dirtySize,
            this.updateFramebuffer(t, i)) : s.dirtySize !== t.dirtySize && (s.dirtySize = t.dirtySize,
            this.resizeFramebuffer(t)));
            for (let o = 0; o < t.colorTextures.length; o++) {
                const a = t.colorTextures[o];
                this.renderer.texture.unbind(a.parentTextureArray || a)
            }
            if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
            r) {
                const o = r.width >> i
                  , a = r.height >> i
                  , l = o / r.width;
                this.setViewport(r.x * l, r.y * l, o, a)
            } else {
                const o = t.width >> i
                  , a = t.height >> i;
                this.setViewport(0, 0, o, a)
            }
        } else
            this.current && (this.current = null,
            n.bindFramebuffer(n.FRAMEBUFFER, null)),
            r ? this.setViewport(r.x, r.y, r.width, r.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
    }
    setViewport(t, r, i, n) {
        const s = this.viewport;
        t = Math.round(t),
        r = Math.round(r),
        i = Math.round(i),
        n = Math.round(n),
        (s.width !== i || s.height !== n || s.x !== t || s.y !== r) && (s.x = t,
        s.y = r,
        s.width = i,
        s.height = n,
        this.gl.viewport(t, r, i, n))
    }
    get size() {
        return this.current ? {
            x: 0,
            y: 0,
            width: this.current.width,
            height: this.current.height
        } : {
            x: 0,
            y: 0,
            width: this.renderer.width,
            height: this.renderer.height
        }
    }
    clear(t, r, i, n, s=lf.COLOR | lf.DEPTH) {
        const {gl: o} = this;
        o.clearColor(t, r, i, n),
        o.clear(s)
    }
    initFramebuffer(t) {
        const {gl: r} = this
          , i = new zI(r.createFramebuffer());
        return i.multisample = this.detectSamples(t.multisample),
        t.glFramebuffers[this.CONTEXT_UID] = i,
        this.managedFramebuffers.push(t),
        t.disposeRunner.add(this),
        i
    }
    resizeFramebuffer(t) {
        const {gl: r} = this
          , i = t.glFramebuffers[this.CONTEXT_UID];
        if (i.stencil) {
            r.bindRenderbuffer(r.RENDERBUFFER, i.stencil);
            let o;
            this.renderer.context.webGLVersion === 1 ? o = r.DEPTH_STENCIL : t.depth && t.stencil ? o = r.DEPTH24_STENCIL8 : t.depth ? o = r.DEPTH_COMPONENT24 : o = r.STENCIL_INDEX8,
            i.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, i.multisample, o, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, o, t.width, t.height)
        }
        const n = t.colorTextures;
        let s = n.length;
        r.drawBuffers || (s = Math.min(s, 1));
        for (let o = 0; o < s; o++) {
            const a = n[o]
              , l = a.parentTextureArray || a;
            this.renderer.texture.bind(l, 0),
            o === 0 && i.msaaBuffer && (r.bindRenderbuffer(r.RENDERBUFFER, i.msaaBuffer),
            r.renderbufferStorageMultisample(r.RENDERBUFFER, i.multisample, l._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height))
        }
        t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
    }
    updateFramebuffer(t, r) {
        const {gl: i} = this
          , n = t.glFramebuffers[this.CONTEXT_UID]
          , s = t.colorTextures;
        let o = s.length;
        i.drawBuffers || (o = Math.min(o, 1)),
        n.multisample > 1 && this.canMultisampleFramebuffer(t) ? n.msaaBuffer = n.msaaBuffer || i.createRenderbuffer() : n.msaaBuffer && (i.deleteRenderbuffer(n.msaaBuffer),
        n.msaaBuffer = null,
        n.blitFramebuffer && (n.blitFramebuffer.dispose(),
        n.blitFramebuffer = null));
        const a = [];
        for (let l = 0; l < o; l++) {
            const h = s[l]
              , u = h.parentTextureArray || h;
            this.renderer.texture.bind(u, 0),
            l === 0 && n.msaaBuffer ? (i.bindRenderbuffer(i.RENDERBUFFER, n.msaaBuffer),
            i.renderbufferStorageMultisample(i.RENDERBUFFER, n.multisample, u._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, n.msaaBuffer)) : (i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + l, h.target, u._glTextures[this.CONTEXT_UID].texture, r),
            a.push(i.COLOR_ATTACHMENT0 + l))
        }
        if (a.length > 1 && i.drawBuffers(a),
        t.depthTexture && this.writeDepthTexture) {
            const l = t.depthTexture;
            this.renderer.texture.bind(l, 0),
            i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, l._glTextures[this.CONTEXT_UID].texture, r)
        }
        if ((t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture)) {
            n.stencil = n.stencil || i.createRenderbuffer();
            let l, h;
            this.renderer.context.webGLVersion === 1 ? (l = i.DEPTH_STENCIL_ATTACHMENT,
            h = i.DEPTH_STENCIL) : t.depth && t.stencil ? (l = i.DEPTH_STENCIL_ATTACHMENT,
            h = i.DEPTH24_STENCIL8) : t.depth ? (l = i.DEPTH_ATTACHMENT,
            h = i.DEPTH_COMPONENT24) : (l = i.STENCIL_ATTACHMENT,
            h = i.STENCIL_INDEX8),
            i.bindRenderbuffer(i.RENDERBUFFER, n.stencil),
            n.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, n.multisample, h, t.width, t.height) : i.renderbufferStorage(i.RENDERBUFFER, h, t.width, t.height),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, l, i.RENDERBUFFER, n.stencil)
        } else
            n.stencil && (i.deleteRenderbuffer(n.stencil),
            n.stencil = null)
    }
    canMultisampleFramebuffer(t) {
        return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture
    }
    detectSamples(t) {
        const {msaaSamples: r} = this;
        let i = se.NONE;
        if (t <= 1 || r === null)
            return i;
        for (let n = 0; n < r.length; n++)
            if (r[n] <= t) {
                i = r[n];
                break
            }
        return i === 1 && (i = se.NONE),
        i
    }
    blit(t, r, i) {
        const {current: n, renderer: s, gl: o, CONTEXT_UID: a} = this;
        if (s.context.webGLVersion !== 2 || !n)
            return;
        const l = n.glFramebuffers[a];
        if (!l)
            return;
        if (!t) {
            if (!l.msaaBuffer)
                return;
            const u = n.colorTextures[0];
            if (!u)
                return;
            l.blitFramebuffer || (l.blitFramebuffer = new yf(n.width,n.height),
            l.blitFramebuffer.addColorTexture(0, u)),
            t = l.blitFramebuffer,
            t.colorTextures[0] !== u && (t.colorTextures[0] = u,
            t.dirtyId++,
            t.dirtyFormat++),
            (t.width !== n.width || t.height !== n.height) && (t.width = n.width,
            t.height = n.height,
            t.dirtyId++,
            t.dirtySize++)
        }
        r || (r = nz,
        r.width = n.width,
        r.height = n.height),
        i || (i = r);
        const h = r.width === i.width && r.height === i.height;
        this.bind(t),
        o.bindFramebuffer(o.READ_FRAMEBUFFER, l.framebuffer),
        o.blitFramebuffer(r.left, r.top, r.right, r.bottom, i.left, i.top, i.right, i.bottom, o.COLOR_BUFFER_BIT, h ? o.NEAREST : o.LINEAR),
        o.bindFramebuffer(o.READ_FRAMEBUFFER, t.glFramebuffers[this.CONTEXT_UID].framebuffer)
    }
    disposeFramebuffer(t, r) {
        const i = t.glFramebuffers[this.CONTEXT_UID]
          , n = this.gl;
        if (!i)
            return;
        delete t.glFramebuffers[this.CONTEXT_UID];
        const s = this.managedFramebuffers.indexOf(t);
        s >= 0 && this.managedFramebuffers.splice(s, 1),
        t.disposeRunner.remove(this),
        r || (n.deleteFramebuffer(i.framebuffer),
        i.msaaBuffer && n.deleteRenderbuffer(i.msaaBuffer),
        i.stencil && n.deleteRenderbuffer(i.stencil)),
        i.blitFramebuffer && this.disposeFramebuffer(i.blitFramebuffer, r)
    }
    disposeAll(t) {
        const r = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (let i = 0; i < r.length; i++)
            this.disposeFramebuffer(r[i], t)
    }
    forceStencil() {
        const t = this.current;
        if (!t)
            return;
        const r = t.glFramebuffers[this.CONTEXT_UID];
        if (!r || r.stencil && t.stencil)
            return;
        t.stencil = !0;
        const i = t.width
          , n = t.height
          , s = this.gl
          , o = r.stencil = s.createRenderbuffer();
        s.bindRenderbuffer(s.RENDERBUFFER, o);
        let a, l;
        this.renderer.context.webGLVersion === 1 ? (a = s.DEPTH_STENCIL_ATTACHMENT,
        l = s.DEPTH_STENCIL) : t.depth ? (a = s.DEPTH_STENCIL_ATTACHMENT,
        l = s.DEPTH24_STENCIL8) : (a = s.STENCIL_ATTACHMENT,
        l = s.STENCIL_INDEX8),
        r.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, r.multisample, l, i, n) : s.renderbufferStorage(s.RENDERBUFFER, l, i, n),
        s.framebufferRenderbuffer(s.FRAMEBUFFER, a, s.RENDERBUFFER, o)
    }
    reset() {
        this.current = this.unknownFramebuffer,
        this.viewport = new lt
    }
    destroy() {
        this.renderer = null
    }
}
hx.extension = {
    type: G.RendererSystem,
    name: "framebuffer"
};
Y.add(hx);
const ng = {
    5126: 4,
    5123: 2,
    5121: 1
};
class ux {
    constructor(t) {
        this.renderer = t,
        this._activeGeometry = null,
        this._activeVao = null,
        this.hasVao = !0,
        this.hasInstance = !0,
        this.canUseUInt32ElementIndex = !1,
        this.managedGeometries = {}
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl
          , r = this.renderer.context;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        r.webGLVersion !== 2) {
            let i = this.renderer.context.extensions.vertexArrayObject;
            z.PREFER_ENV === Fs.WEBGL_LEGACY && (i = null),
            i ? (t.createVertexArray = () => i.createVertexArrayOES(),
            t.bindVertexArray = n => i.bindVertexArrayOES(n),
            t.deleteVertexArray = n => i.deleteVertexArrayOES(n)) : (this.hasVao = !1,
            t.createVertexArray = () => null,
            t.bindVertexArray = () => null,
            t.deleteVertexArray = () => null)
        }
        if (r.webGLVersion !== 2) {
            const i = t.getExtension("ANGLE_instanced_arrays");
            i ? (t.vertexAttribDivisor = (n, s) => i.vertexAttribDivisorANGLE(n, s),
            t.drawElementsInstanced = (n, s, o, a, l) => i.drawElementsInstancedANGLE(n, s, o, a, l),
            t.drawArraysInstanced = (n, s, o, a) => i.drawArraysInstancedANGLE(n, s, o, a)) : this.hasInstance = !1
        }
        this.canUseUInt32ElementIndex = r.webGLVersion === 2 || !!r.extensions.uint32ElementIndex
    }
    bind(t, r) {
        r = r || this.renderer.shader.shader;
        const {gl: i} = this;
        let n = t.glVertexArrayObjects[this.CONTEXT_UID]
          , s = !1;
        n || (this.managedGeometries[t.id] = t,
        t.disposeRunner.add(this),
        t.glVertexArrayObjects[this.CONTEXT_UID] = n = {},
        s = !0);
        const o = n[r.program.id] || this.initGeometryVao(t, r, s);
        this._activeGeometry = t,
        this._activeVao !== o && (this._activeVao = o,
        this.hasVao ? i.bindVertexArray(o) : this.activateVao(t, r.program)),
        this.updateBuffers()
    }
    reset() {
        this.unbind()
    }
    updateBuffers() {
        const t = this._activeGeometry
          , r = this.renderer.buffer;
        for (let i = 0; i < t.buffers.length; i++) {
            const n = t.buffers[i];
            r.update(n)
        }
    }
    checkCompatibility(t, r) {
        const i = t.attributes
          , n = r.attributeData;
        for (const s in n)
            if (!i[s])
                throw new Error(`shader and geometry incompatible, geometry missing the "${s}" attribute`)
    }
    getSignature(t, r) {
        const i = t.attributes
          , n = r.attributeData
          , s = ["g", t.id];
        for (const o in i)
            n[o] && s.push(o, n[o].location);
        return s.join("-")
    }
    initGeometryVao(t, r, i=!0) {
        const n = this.gl
          , s = this.CONTEXT_UID
          , o = this.renderer.buffer
          , a = r.program;
        a.glPrograms[s] || this.renderer.shader.generateProgram(r),
        this.checkCompatibility(t, a);
        const l = this.getSignature(t, a)
          , h = t.glVertexArrayObjects[this.CONTEXT_UID];
        let u = h[l];
        if (u)
            return h[a.id] = u,
            u;
        const c = t.buffers
          , d = t.attributes
          , f = {}
          , g = {};
        for (const p in c)
            f[p] = 0,
            g[p] = 0;
        for (const p in d)
            !d[p].size && a.attributeData[p] ? d[p].size = a.attributeData[p].size : d[p].size || console.warn(`PIXI Geometry attribute '${p}' size cannot be determined (likely the bound shader does not have the attribute)`),
            f[d[p].buffer] += d[p].size * ng[d[p].type];
        for (const p in d) {
            const v = d[p]
              , y = v.size;
            v.stride === void 0 && (f[v.buffer] === y * ng[v.type] ? v.stride = 0 : v.stride = f[v.buffer]),
            v.start === void 0 && (v.start = g[v.buffer],
            g[v.buffer] += y * ng[v.type])
        }
        u = n.createVertexArray(),
        n.bindVertexArray(u);
        for (let p = 0; p < c.length; p++) {
            const v = c[p];
            o.bind(v),
            i && v._glBuffers[s].refCount++
        }
        return this.activateVao(t, a),
        h[a.id] = u,
        h[l] = u,
        n.bindVertexArray(null),
        o.unbind(Pi.ARRAY_BUFFER),
        u
    }
    disposeGeometry(t, r) {
        if (!this.managedGeometries[t.id])
            return;
        delete this.managedGeometries[t.id];
        const i = t.glVertexArrayObjects[this.CONTEXT_UID]
          , n = this.gl
          , s = t.buffers
          , o = this.renderer?.buffer;
        if (t.disposeRunner.remove(this),
        !!i) {
            if (o)
                for (let a = 0; a < s.length; a++) {
                    const l = s[a]._glBuffers[this.CONTEXT_UID];
                    l && (l.refCount--,
                    l.refCount === 0 && !r && o.dispose(s[a], r))
                }
            if (!r) {
                for (const a in i)
                    if (a[0] === "g") {
                        const l = i[a];
                        this._activeVao === l && this.unbind(),
                        n.deleteVertexArray(l)
                    }
            }
            delete t.glVertexArrayObjects[this.CONTEXT_UID]
        }
    }
    disposeAll(t) {
        const r = Object.keys(this.managedGeometries);
        for (let i = 0; i < r.length; i++)
            this.disposeGeometry(this.managedGeometries[r[i]], t)
    }
    activateVao(t, r) {
        const i = this.gl
          , n = this.CONTEXT_UID
          , s = this.renderer.buffer
          , o = t.buffers
          , a = t.attributes;
        t.indexBuffer && s.bind(t.indexBuffer);
        let l = null;
        for (const h in a) {
            const u = a[h]
              , c = o[u.buffer]
              , d = c._glBuffers[n];
            if (r.attributeData[h]) {
                l !== d && (s.bind(c),
                l = d);
                const f = r.attributeData[h].location;
                if (i.enableVertexAttribArray(f),
                i.vertexAttribPointer(f, u.size, u.type || i.FLOAT, u.normalized, u.stride, u.start),
                u.instance)
                    if (this.hasInstance)
                        i.vertexAttribDivisor(f, u.divisor);
                    else
                        throw new Error("geometry error, GPU Instancing is not supported on this device")
            }
        }
    }
    draw(t, r, i, n) {
        const {gl: s} = this
          , o = this._activeGeometry;
        if (o.indexBuffer) {
            const a = o.indexBuffer.data.BYTES_PER_ELEMENT
              , l = a === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
            a === 2 || a === 4 && this.canUseUInt32ElementIndex ? o.instanced ? s.drawElementsInstanced(t, r || o.indexBuffer.data.length, l, (i || 0) * a, n || 1) : s.drawElements(t, r || o.indexBuffer.data.length, l, (i || 0) * a) : console.warn("unsupported index buffer type: uint32")
        } else
            o.instanced ? s.drawArraysInstanced(t, i, r || o.getSize(), n || 1) : s.drawArrays(t, i, r || o.getSize());
        return this
    }
    unbind() {
        this.gl.bindVertexArray(null),
        this._activeVao = null,
        this._activeGeometry = null
    }
    destroy() {
        this.renderer = null
    }
}
ux.extension = {
    type: G.RendererSystem,
    name: "geometry"
};
Y.add(ux);
const kS = new Mt;
class Lp {
    constructor(t, r) {
        this._texture = t,
        this.mapCoord = new Mt,
        this.uClampFrame = new Float32Array(4),
        this.uClampOffset = new Float32Array(2),
        this._textureID = -1,
        this._updateID = 0,
        this.clampOffset = 0,
        this.clampMargin = typeof r > "u" ? .5 : r,
        this.isSimple = !1
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture = t,
        this._textureID = -1
    }
    multiplyUvs(t, r) {
        r === void 0 && (r = t);
        const i = this.mapCoord;
        for (let n = 0; n < t.length; n += 2) {
            const s = t[n]
              , o = t[n + 1];
            r[n] = s * i.a + o * i.c + i.tx,
            r[n + 1] = s * i.b + o * i.d + i.ty
        }
        return r
    }
    update(t) {
        const r = this._texture;
        if (!r || !r.valid || !t && this._textureID === r._updateID)
            return !1;
        this._textureID = r._updateID,
        this._updateID++;
        const i = r._uvs;
        this.mapCoord.set(i.x1 - i.x0, i.y1 - i.y0, i.x3 - i.x0, i.y3 - i.y0, i.x0, i.y0);
        const n = r.orig
          , s = r.trim;
        s && (kS.set(n.width / s.width, 0, 0, n.height / s.height, -s.x / s.width, -s.y / s.height),
        this.mapCoord.append(kS));
        const o = r.baseTexture
          , a = this.uClampFrame
          , l = this.clampMargin / o.resolution
          , h = this.clampOffset;
        return a[0] = (r._frame.x + l + h) / o.width,
        a[1] = (r._frame.y + l + h) / o.height,
        a[2] = (r._frame.x + r._frame.width - l + h) / o.width,
        a[3] = (r._frame.y + r._frame.height - l + h) / o.height,
        this.uClampOffset[0] = h / o.realWidth,
        this.uClampOffset[1] = h / o.realHeight,
        this.isSimple = r._frame.width === o.width && r._frame.height === o.height && r.rotate === 0,
        !0
    }
}
var sz = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`
  , oz = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
class WI extends ze {
    constructor(t, r, i) {
        let n = null;
        typeof t != "string" && r === void 0 && i === void 0 && (n = t,
        t = void 0,
        r = void 0,
        i = void 0),
        super(t || oz, r || sz, i),
        this.maskSprite = n,
        this.maskMatrix = new Mt
    }
    get maskSprite() {
        return this._maskSprite
    }
    set maskSprite(t) {
        this._maskSprite = t,
        this._maskSprite && (this._maskSprite.renderable = !1)
    }
    apply(t, r, i, n) {
        const s = this._maskSprite
          , o = s._texture;
        o.valid && (o.uvMatrix || (o.uvMatrix = new Lp(o,0)),
        o.uvMatrix.update(),
        this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1,
        this.uniforms.mask = o,
        this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, s).prepend(o.uvMatrix.mapCoord),
        this.uniforms.alpha = s.worldAlpha,
        this.uniforms.maskClamp = o.uvMatrix.uClampFrame,
        t.applyFilter(this, r, i, n))
    }
}
class VI {
    constructor(t=null) {
        this.type = he.NONE,
        this.autoDetect = !0,
        this.maskObject = t || null,
        this.pooled = !1,
        this.isMaskData = !0,
        this.resolution = null,
        this.multisample = ze.defaultMultisample,
        this.enabled = !0,
        this.colorMask = 15,
        this._filters = null,
        this._stencilCounter = 0,
        this._scissorCounter = 0,
        this._scissorRect = null,
        this._scissorRectLocal = null,
        this._colorMask = 15,
        this._target = null
    }
    get filter() {
        return this._filters ? this._filters[0] : null
    }
    set filter(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
    }
    reset() {
        this.pooled && (this.maskObject = null,
        this.type = he.NONE,
        this.autoDetect = !0),
        this._target = null,
        this._scissorRectLocal = null
    }
    copyCountersOrReset(t) {
        t ? (this._stencilCounter = t._stencilCounter,
        this._scissorCounter = t._scissorCounter,
        this._scissorRect = t._scissorRect) : (this._stencilCounter = 0,
        this._scissorCounter = 0,
        this._scissorRect = null)
    }
}
class cx {
    constructor(t) {
        this.renderer = t,
        this.enableScissor = !0,
        this.alphaMaskPool = [],
        this.maskDataPool = [],
        this.maskStack = [],
        this.alphaMaskIndex = 0
    }
    setMaskStack(t) {
        this.maskStack = t,
        this.renderer.scissor.setMaskStack(t),
        this.renderer.stencil.setMaskStack(t)
    }
    push(t, r) {
        let i = r;
        if (!i.isMaskData) {
            const s = this.maskDataPool.pop() || new VI;
            s.pooled = !0,
            s.maskObject = r,
            i = s
        }
        const n = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        if (i.copyCountersOrReset(n),
        i._colorMask = n ? n._colorMask : 15,
        i.autoDetect && this.detect(i),
        i._target = t,
        i.type !== he.SPRITE && this.maskStack.push(i),
        i.enabled)
            switch (i.type) {
            case he.SCISSOR:
                this.renderer.scissor.push(i);
                break;
            case he.STENCIL:
                this.renderer.stencil.push(i);
                break;
            case he.SPRITE:
                i.copyCountersOrReset(null),
                this.pushSpriteMask(i);
                break;
            case he.COLOR:
                this.pushColorMask(i);
                break
            }
        i.type === he.SPRITE && this.maskStack.push(i)
    }
    pop(t) {
        const r = this.maskStack.pop();
        if (!(!r || r._target !== t)) {
            if (r.enabled)
                switch (r.type) {
                case he.SCISSOR:
                    this.renderer.scissor.pop(r);
                    break;
                case he.STENCIL:
                    this.renderer.stencil.pop(r.maskObject);
                    break;
                case he.SPRITE:
                    this.popSpriteMask(r);
                    break;
                case he.COLOR:
                    this.popColorMask(r);
                    break
                }
            if (r.reset(),
            r.pooled && this.maskDataPool.push(r),
            this.maskStack.length !== 0) {
                const i = this.maskStack[this.maskStack.length - 1];
                i.type === he.SPRITE && i._filters && (i._filters[0].maskSprite = i.maskObject)
            }
        }
    }
    detect(t) {
        const r = t.maskObject;
        r ? r.isSprite ? t.type = he.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = he.SCISSOR : t.type = he.STENCIL : t.type = he.COLOR
    }
    pushSpriteMask(t) {
        const {maskObject: r} = t
          , i = t._target;
        let n = t._filters;
        n || (n = this.alphaMaskPool[this.alphaMaskIndex],
        n || (n = this.alphaMaskPool[this.alphaMaskIndex] = [new WI])),
        n[0].resolution = t.resolution,
        n[0].multisample = t.multisample,
        n[0].maskSprite = r;
        const s = i.filterArea;
        i.filterArea = r.getBounds(!0),
        this.renderer.filter.push(i, n),
        i.filterArea = s,
        t._filters || this.alphaMaskIndex++
    }
    popSpriteMask(t) {
        this.renderer.filter.pop(),
        t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--,
        this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
    }
    pushColorMask(t) {
        const r = t._colorMask
          , i = t._colorMask = r & t.colorMask;
        i !== r && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0)
    }
    popColorMask(t) {
        const r = t._colorMask
          , i = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
        i !== r && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0)
    }
    destroy() {
        this.renderer = null
    }
}
cx.extension = {
    type: G.RendererSystem,
    name: "mask"
};
Y.add(cx);
class jI {
    constructor(t) {
        this.renderer = t,
        this.maskStack = [],
        this.glConst = 0
    }
    getStackLength() {
        return this.maskStack.length
    }
    setMaskStack(t) {
        const {gl: r} = this.renderer
          , i = this.getStackLength();
        this.maskStack = t;
        const n = this.getStackLength();
        n !== i && (n === 0 ? r.disable(this.glConst) : (r.enable(this.glConst),
        this._useCurrent()))
    }
    _useCurrent() {}
    destroy() {
        this.renderer = null,
        this.maskStack = null
    }
}
const FS = new Mt
  , US = []
  , XI = class gd extends jI {
    constructor(t) {
        super(t),
        this.glConst = z.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
    }
    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1];
        return t ? t._scissorCounter : 0
    }
    calcScissorRect(t) {
        if (t._scissorRectLocal)
            return;
        const r = t._scissorRect
          , {maskObject: i} = t
          , {renderer: n} = this
          , s = n.renderTexture
          , o = i.getBounds(!0, US.pop() ?? new lt);
        this.roundFrameToPixels(o, s.current ? s.current.resolution : n.resolution, s.sourceFrame, s.destinationFrame, n.projection.transform),
        r && o.fit(r),
        t._scissorRectLocal = o
    }
    static isMatrixRotated(t) {
        if (!t)
            return !1;
        const {a: r, b: i, c: n, d: s} = t;
        return (Math.abs(i) > 1e-4 || Math.abs(n) > 1e-4) && (Math.abs(r) > 1e-4 || Math.abs(s) > 1e-4)
    }
    testScissor(t) {
        const {maskObject: r} = t;
        if (!r.isFastRect || !r.isFastRect() || gd.isMatrixRotated(r.worldTransform) || gd.isMatrixRotated(this.renderer.projection.transform))
            return !1;
        this.calcScissorRect(t);
        const i = t._scissorRectLocal;
        return i.width > 0 && i.height > 0
    }
    roundFrameToPixels(t, r, i, n, s) {
        gd.isMatrixRotated(s) || (s = s ? FS.copyFrom(s) : FS.identity(),
        s.translate(-i.x, -i.y).scale(n.width / i.width, n.height / i.height).translate(n.x, n.y),
        this.renderer.filter.transformAABB(s, t),
        t.fit(n),
        t.x = Math.round(t.x * r),
        t.y = Math.round(t.y * r),
        t.width = Math.round(t.width * r),
        t.height = Math.round(t.height * r))
    }
    push(t) {
        t._scissorRectLocal || this.calcScissorRect(t);
        const {gl: r} = this.renderer;
        t._scissorRect || r.enable(r.SCISSOR_TEST),
        t._scissorCounter++,
        t._scissorRect = t._scissorRectLocal,
        this._useCurrent()
    }
    pop(t) {
        const {gl: r} = this.renderer;
        t && US.push(t._scissorRectLocal),
        this.getStackLength() > 0 ? this._useCurrent() : r.disable(r.SCISSOR_TEST)
    }
    _useCurrent() {
        const t = this.maskStack[this.maskStack.length - 1]._scissorRect;
        let r;
        this.renderer.renderTexture.current ? r = t.y : r = this.renderer.height - t.height - t.y,
        this.renderer.gl.scissor(t.x, r, t.width, t.height)
    }
}
;
XI.extension = {
    type: G.RendererSystem,
    name: "scissor"
};
let YI = XI;
Y.add(YI);
class dx extends jI {
    constructor(t) {
        super(t),
        this.glConst = z.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
    }
    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1];
        return t ? t._stencilCounter : 0
    }
    push(t) {
        const r = t.maskObject
          , {gl: i} = this.renderer
          , n = t._stencilCounter;
        n === 0 && (this.renderer.framebuffer.forceStencil(),
        i.clearStencil(0),
        i.clear(i.STENCIL_BUFFER_BIT),
        i.enable(i.STENCIL_TEST)),
        t._stencilCounter++;
        const s = t._colorMask;
        s !== 0 && (t._colorMask = 0,
        i.colorMask(!1, !1, !1, !1)),
        i.stencilFunc(i.EQUAL, n, 4294967295),
        i.stencilOp(i.KEEP, i.KEEP, i.INCR),
        r.renderable = !0,
        r.render(this.renderer),
        this.renderer.batch.flush(),
        r.renderable = !1,
        s !== 0 && (t._colorMask = s,
        i.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)),
        this._useCurrent()
    }
    pop(t) {
        const r = this.renderer.gl;
        if (this.getStackLength() === 0)
            r.disable(r.STENCIL_TEST);
        else {
            const i = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null
              , n = i ? i._colorMask : 15;
            n !== 0 && (i._colorMask = 0,
            r.colorMask(!1, !1, !1, !1)),
            r.stencilOp(r.KEEP, r.KEEP, r.DECR),
            t.renderable = !0,
            t.render(this.renderer),
            this.renderer.batch.flush(),
            t.renderable = !1,
            n !== 0 && (i._colorMask = n,
            r.colorMask((n & 1) !== 0, (n & 2) !== 0, (n & 4) !== 0, (n & 8) !== 0)),
            this._useCurrent()
        }
    }
    _useCurrent() {
        const t = this.renderer.gl;
        t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
        t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
    }
}
dx.extension = {
    type: G.RendererSystem,
    name: "stencil"
};
Y.add(dx);
class fx {
    constructor(t) {
        this.renderer = t,
        this.plugins = {},
        Object.defineProperties(this.plugins, {
            extract: {
                enumerable: !1,
                get() {
                    return et("7.0.0", "renderer.plugins.extract has moved to renderer.extract"),
                    t.extract
                }
            },
            prepare: {
                enumerable: !1,
                get() {
                    return et("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"),
                    t.prepare
                }
            },
            interaction: {
                enumerable: !1,
                get() {
                    return et("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"),
                    t.events
                }
            }
        })
    }
    init() {
        const t = this.rendererPlugins;
        for (const r in t)
            this.plugins[r] = new t[r](this.renderer)
    }
    destroy() {
        for (const t in this.plugins)
            this.plugins[t].destroy(),
            this.plugins[t] = null
    }
}
fx.extension = {
    type: [G.RendererSystem, G.CanvasRendererSystem],
    name: "_plugin"
};
Y.add(fx);
class px {
    constructor(t) {
        this.renderer = t,
        this.destinationFrame = null,
        this.sourceFrame = null,
        this.defaultFrame = null,
        this.projectionMatrix = new Mt,
        this.transform = null
    }
    update(t, r, i, n) {
        this.destinationFrame = t || this.destinationFrame || this.defaultFrame,
        this.sourceFrame = r || this.sourceFrame || t,
        this.calculateProjection(this.destinationFrame, this.sourceFrame, i, n),
        this.transform && this.projectionMatrix.append(this.transform);
        const s = this.renderer;
        s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix,
        s.globalUniforms.update(),
        s.shader.shader && s.shader.syncUniformGroup(s.shader.shader.uniforms.globals)
    }
    calculateProjection(t, r, i, n) {
        const s = this.projectionMatrix
          , o = n ? -1 : 1;
        s.identity(),
        s.a = 1 / r.width * 2,
        s.d = o * (1 / r.height * 2),
        s.tx = -1 - r.x * s.a,
        s.ty = -o - r.y * s.d
    }
    setTransform(t) {}
    destroy() {
        this.renderer = null
    }
}
px.extension = {
    type: G.RendererSystem,
    name: "projection"
};
Y.add(px);
const az = new Gu
  , GS = new lt;
class mx {
    constructor(t) {
        this.renderer = t,
        this._tempMatrix = new Mt
    }
    generateTexture(t, r) {
        const {region: i, ...n} = r || {}
          , s = i?.copyTo(GS) || t.getLocalBounds(GS, !0)
          , o = n.resolution || this.renderer.resolution;
        s.width = Math.max(s.width, 1 / o),
        s.height = Math.max(s.height, 1 / o),
        n.width = s.width,
        n.height = s.height,
        n.resolution = o,
        n.multisample ?? (n.multisample = this.renderer.multisample);
        const a = Gs.create(n);
        this._tempMatrix.tx = -s.x,
        this._tempMatrix.ty = -s.y;
        const l = t.transform;
        return t.transform = az,
        this.renderer.render(t, {
            renderTexture: a,
            transform: this._tempMatrix,
            skipUpdateTransform: !!t.parent,
            blit: !0
        }),
        t.transform = l,
        a
    }
    destroy() {}
}
mx.extension = {
    type: [G.RendererSystem, G.CanvasRendererSystem],
    name: "textureGenerator"
};
Y.add(mx);
const zs = new lt
  , Ol = new lt;
class gx {
    constructor(t) {
        this.renderer = t,
        this.defaultMaskStack = [],
        this.current = null,
        this.sourceFrame = new lt,
        this.destinationFrame = new lt,
        this.viewportFrame = new lt
    }
    contextChange() {
        const t = this.renderer?.gl.getContextAttributes();
        this._rendererPremultipliedAlpha = !!(t && t.alpha && t.premultipliedAlpha)
    }
    bind(t=null, r, i) {
        const n = this.renderer;
        this.current = t;
        let s, o, a;
        t ? (s = t.baseTexture,
        a = s.resolution,
        r || (zs.width = t.frame.width,
        zs.height = t.frame.height,
        r = zs),
        i || (Ol.x = t.frame.x,
        Ol.y = t.frame.y,
        Ol.width = r.width,
        Ol.height = r.height,
        i = Ol),
        o = s.framebuffer) : (a = n.resolution,
        r || (zs.width = n._view.screen.width,
        zs.height = n._view.screen.height,
        r = zs),
        i || (i = zs,
        i.width = r.width,
        i.height = r.height));
        const l = this.viewportFrame;
        l.x = i.x * a,
        l.y = i.y * a,
        l.width = i.width * a,
        l.height = i.height * a,
        t || (l.y = n.view.height - (l.y + l.height)),
        l.ceil(),
        this.renderer.framebuffer.bind(o, l),
        this.renderer.projection.update(i, r, a, !o),
        t ? this.renderer.mask.setMaskStack(s.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack),
        this.sourceFrame.copyFrom(r),
        this.destinationFrame.copyFrom(i)
    }
    clear(t, r) {
        const i = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor
          , n = xt.shared.setValue(t || i);
        (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && n.premultiply(n.alpha);
        const s = this.destinationFrame
          , o = this.current ? this.current.baseTexture : this.renderer._view.screen
          , a = s.width !== o.width || s.height !== o.height;
        if (a) {
            let {x: l, y: h, width: u, height: c} = this.viewportFrame;
            l = Math.round(l),
            h = Math.round(h),
            u = Math.round(u),
            c = Math.round(c),
            this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
            this.renderer.gl.scissor(l, h, u, c)
        }
        this.renderer.framebuffer.clear(n.red, n.green, n.blue, n.alpha, r),
        a && this.renderer.scissor.pop()
    }
    resize() {
        this.bind(null)
    }
    reset() {
        this.bind(null)
    }
    destroy() {
        this.renderer = null
    }
}
gx.extension = {
    type: G.RendererSystem,
    name: "renderTexture"
};
Y.add(gx);
class lz {
}
class KI {
    constructor(t, r) {
        this.program = t,
        this.uniformData = r,
        this.uniformGroups = {},
        this.uniformDirtyGroups = {},
        this.uniformBufferBindings = {}
    }
    destroy() {
        this.uniformData = null,
        this.uniformGroups = null,
        this.uniformDirtyGroups = null,
        this.uniformBufferBindings = null,
        this.program = null
    }
}
function hz(e, t) {
    const r = {}
      , i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
    for (let n = 0; n < i; n++) {
        const s = t.getActiveAttrib(e, n);
        if (s.name.startsWith("gl_"))
            continue;
        const o = FI(t, s.type)
          , a = {
            type: o,
            name: s.name,
            size: kI(o),
            location: t.getAttribLocation(e, s.name)
        };
        r[s.name] = a
    }
    return r
}
function uz(e, t) {
    const r = {}
      , i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let n = 0; n < i; n++) {
        const s = t.getActiveUniform(e, n)
          , o = s.name.replace(/\[.*?\]$/, "")
          , a = !!s.name.match(/\[.*?\]$/)
          , l = FI(t, s.type);
        r[o] = {
            name: o,
            index: n,
            type: l,
            size: s.size,
            isArray: a,
            value: LI(l, s.size)
        }
    }
    return r
}
function qI(e, t) {
    const r = MS(e, e.VERTEX_SHADER, t.vertexSrc)
      , i = MS(e, e.FRAGMENT_SHADER, t.fragmentSrc)
      , n = e.createProgram();
    e.attachShader(n, r),
    e.attachShader(n, i);
    const s = t.extra?.transformFeedbackVaryings;
    if (s && (typeof e.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : e.transformFeedbackVaryings(n, s.names, s.bufferMode === "separate" ? e.SEPARATE_ATTRIBS : e.INTERLEAVED_ATTRIBS)),
    e.linkProgram(n),
    e.getProgramParameter(n, e.LINK_STATUS) || Y8(e, n, r, i),
    t.attributeData = hz(n, e),
    t.uniformData = uz(n, e),
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
        const a = Object.keys(t.attributeData);
        a.sort( (l, h) => l > h ? 1 : -1);
        for (let l = 0; l < a.length; l++)
            t.attributeData[a[l]].location = l,
            e.bindAttribLocation(n, l, a[l]);
        e.linkProgram(n)
    }
    e.deleteShader(r),
    e.deleteShader(i);
    const o = {};
    for (const a in t.uniformData) {
        const l = t.uniformData[a];
        o[a] = {
            location: e.getUniformLocation(n, a),
            value: LI(l.type, l.size)
        }
    }
    return new KI(n,o)
}
function cz(e, t, r, i, n) {
    r.buffer.update(n)
}
const dz = {
    float: `
        data[offset] = v;
    `,
    vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
    vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
    vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
    mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
    mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
    mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}
  , ZI = {
    float: 4,
    vec2: 8,
    vec3: 12,
    vec4: 16,
    int: 4,
    ivec2: 8,
    ivec3: 12,
    ivec4: 16,
    uint: 4,
    uvec2: 8,
    uvec3: 12,
    uvec4: 16,
    bool: 4,
    bvec2: 8,
    bvec3: 12,
    bvec4: 16,
    mat2: 16 * 2,
    mat3: 16 * 3,
    mat4: 16 * 4
};
function QI(e) {
    const t = e.map(s => ({
        data: s,
        offset: 0,
        dataLen: 0,
        dirty: 0
    }));
    let r = 0
      , i = 0
      , n = 0;
    for (let s = 0; s < t.length; s++) {
        const o = t[s];
        if (r = ZI[o.data.type],
        o.data.size > 1 && (r = Math.max(r, 16) * o.data.size),
        o.dataLen = r,
        i % r !== 0 && i < 16) {
            const a = i % r % 16;
            i += a,
            n += a
        }
        i + r > 16 ? (n = Math.ceil(n / 16) * 16,
        o.offset = n,
        n += r,
        i = r) : (o.offset = n,
        i += r,
        n += r)
    }
    return n = Math.ceil(n / 16) * 16,
    {
        uboElements: t,
        size: n
    }
}
function JI(e, t) {
    const r = [];
    for (const i in e)
        t[i] && r.push(t[i]);
    return r.sort( (i, n) => i.index - n.index),
    r
}
function tR(e, t) {
    if (!e.autoManage)
        return {
            size: 0,
            syncFunc: cz
        };
    const r = JI(e.uniforms, t)
      , {uboElements: i, size: n} = QI(r)
      , s = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
    for (let o = 0; o < i.length; o++) {
        const a = i[o]
          , l = e.uniforms[a.data.name]
          , h = a.data.name;
        let u = !1;
        for (let c = 0; c < go.length; c++) {
            const d = go[c];
            if (d.codeUbo && d.test(a.data, l)) {
                s.push(`offset = ${a.offset / 4};`, go[c].codeUbo(a.data.name, l)),
                u = !0;
                break
            }
        }
        if (!u)
            if (a.data.size > 1) {
                const c = kI(a.data.type)
                  , d = Math.max(ZI[a.data.type] / 16, 1)
                  , f = c / d
                  , g = (4 - f % 4) % 4;
                s.push(`
                cv = ud.${h}.value;
                v = uv.${h};
                offset = ${a.offset / 4};

                t = 0;

                for(var i=0; i < ${a.data.size * d}; i++)
                {
                    for(var j = 0; j < ${f}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${g};
                }

                `)
            } else {
                const c = dz[a.data.type];
                s.push(`
                cv = ud.${h}.value;
                v = uv.${h};
                offset = ${a.offset / 4};
                ${c};
                `)
            }
    }
    return s.push(`
       renderer.buffer.update(buffer);
    `),
    {
        size: n,
        syncFunc: new Function("ud","uv","renderer","syncData","buffer",s.join(`
`))
    }
}
let fz = 0;
const Dc = {
    textureCount: 0,
    uboCount: 0
};
class _x {
    constructor(t) {
        this.destroyed = !1,
        this.renderer = t,
        this.systemCheck(),
        this.gl = null,
        this.shader = null,
        this.program = null,
        this.cache = {},
        this._uboCache = {},
        this.id = fz++
    }
    systemCheck() {
        if (!UI())
            throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
    }
    contextChange(t) {
        this.gl = t,
        this.reset()
    }
    bind(t, r) {
        t.disposeRunner.add(this),
        t.uniforms.globals = this.renderer.globalUniforms;
        const i = t.program
          , n = i.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
        return this.shader = t,
        this.program !== i && (this.program = i,
        this.gl.useProgram(n.program)),
        r || (Dc.textureCount = 0,
        Dc.uboCount = 0,
        this.syncUniformGroup(t.uniformGroup, Dc)),
        n
    }
    setUniforms(t) {
        const r = this.shader.program
          , i = r.glPrograms[this.renderer.CONTEXT_UID];
        r.syncUniforms(i.uniformData, t, this.renderer)
    }
    syncUniformGroup(t, r) {
        const i = this.getGlProgram();
        (!t.static || t.dirtyId !== i.uniformDirtyGroups[t.id]) && (i.uniformDirtyGroups[t.id] = t.dirtyId,
        this.syncUniforms(t, i, r))
    }
    syncUniforms(t, r, i) {
        (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(r.uniformData, t.uniforms, this.renderer, i)
    }
    createSyncGroups(t) {
        const r = this.getSignature(t, this.shader.program.uniformData, "u");
        return this.cache[r] || (this.cache[r] = j8(t, this.shader.program.uniformData)),
        t.syncUniforms[this.shader.program.id] = this.cache[r],
        t.syncUniforms[this.shader.program.id]
    }
    syncUniformBufferGroup(t, r) {
        const i = this.getGlProgram();
        if (!t.static || t.dirtyId !== 0 || !i.uniformGroups[t.id]) {
            t.dirtyId = 0;
            const n = i.uniformGroups[t.id] || this.createSyncBufferGroup(t, i, r);
            t.buffer.update(),
            n(i.uniformData, t.uniforms, this.renderer, Dc, t.buffer)
        }
        this.renderer.buffer.bindBufferBase(t.buffer, i.uniformBufferBindings[r])
    }
    createSyncBufferGroup(t, r, i) {
        const {gl: n} = this.renderer;
        this.renderer.buffer.bind(t.buffer);
        const s = this.gl.getUniformBlockIndex(r.program, i);
        r.uniformBufferBindings[i] = this.shader.uniformBindCount,
        n.uniformBlockBinding(r.program, s, this.shader.uniformBindCount),
        this.shader.uniformBindCount++;
        const o = this.getSignature(t, this.shader.program.uniformData, "ubo");
        let a = this._uboCache[o];
        if (a || (a = this._uboCache[o] = tR(t, this.shader.program.uniformData)),
        t.autoManage) {
            const l = new Float32Array(a.size / 4);
            t.buffer.update(l)
        }
        return r.uniformGroups[t.id] = a.syncFunc,
        r.uniformGroups[t.id]
    }
    getSignature(t, r, i) {
        const n = t.uniforms
          , s = [`${i}-`];
        for (const o in n)
            s.push(o),
            r[o] && s.push(r[o].type);
        return s.join("-")
    }
    getGlProgram() {
        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
    }
    generateProgram(t) {
        const r = this.gl
          , i = t.program
          , n = qI(r, i);
        return i.glPrograms[this.renderer.CONTEXT_UID] = n,
        n
    }
    reset() {
        this.program = null,
        this.shader = null
    }
    disposeShader(t) {
        this.shader === t && (this.shader = null)
    }
    destroy() {
        this.renderer = null,
        this.destroyed = !0
    }
}
_x.extension = {
    type: G.RendererSystem,
    name: "shader"
};
Y.add(_x);
class nu {
    constructor(t) {
        this.renderer = t
    }
    run(t) {
        const {renderer: r} = this;
        r.runners.init.emit(r.options),
        t.hello && console.log(`PixiJS 7.3.1 - ${r.rendererLogId} - https://pixijs.com`),
        r.resize(r.screen.width, r.screen.height)
    }
    destroy() {}
}
nu.defaultOptions = {
    hello: !1
},
nu.extension = {
    type: [G.RendererSystem, G.CanvasRendererSystem],
    name: "startup"
};
Y.add(nu);
function pz(e, t=[]) {
    return t[tt.NORMAL] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.ADD] = [e.ONE, e.ONE],
    t[tt.MULTIPLY] = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.SCREEN] = [e.ONE, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.OVERLAY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.DARKEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.LIGHTEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.COLOR_DODGE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.COLOR_BURN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.HARD_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.SOFT_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.DIFFERENCE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.EXCLUSION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.HUE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.SATURATION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.COLOR] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.LUMINOSITY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.NONE] = [0, 0],
    t[tt.NORMAL_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.ADD_NPM] = [e.SRC_ALPHA, e.ONE, e.ONE, e.ONE],
    t[tt.SCREEN_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[tt.SRC_IN] = [e.DST_ALPHA, e.ZERO],
    t[tt.SRC_OUT] = [e.ONE_MINUS_DST_ALPHA, e.ZERO],
    t[tt.SRC_ATOP] = [e.DST_ALPHA, e.ONE_MINUS_SRC_ALPHA],
    t[tt.DST_OVER] = [e.ONE_MINUS_DST_ALPHA, e.ONE],
    t[tt.DST_IN] = [e.ZERO, e.SRC_ALPHA],
    t[tt.DST_OUT] = [e.ZERO, e.ONE_MINUS_SRC_ALPHA],
    t[tt.DST_ATOP] = [e.ONE_MINUS_DST_ALPHA, e.SRC_ALPHA],
    t[tt.XOR] = [e.ONE_MINUS_DST_ALPHA, e.ONE_MINUS_SRC_ALPHA],
    t[tt.SUBTRACT] = [e.ONE, e.ONE, e.ONE, e.ONE, e.FUNC_REVERSE_SUBTRACT, e.FUNC_ADD],
    t
}
const mz = 0
  , gz = 1
  , _z = 2
  , yz = 3
  , vz = 4
  , xz = 5
  , eR = class v_ {
    constructor() {
        this.gl = null,
        this.stateId = 0,
        this.polygonOffset = 0,
        this.blendMode = tt.NONE,
        this._blendEq = !1,
        this.map = [],
        this.map[mz] = this.setBlend,
        this.map[gz] = this.setOffset,
        this.map[_z] = this.setCullFace,
        this.map[yz] = this.setDepthTest,
        this.map[vz] = this.setFrontFace,
        this.map[xz] = this.setDepthMask,
        this.checks = [],
        this.defaultState = new Bi,
        this.defaultState.blend = !0
    }
    contextChange(t) {
        this.gl = t,
        this.blendModes = pz(t),
        this.set(this.defaultState),
        this.reset()
    }
    set(t) {
        if (t = t || this.defaultState,
        this.stateId !== t.data) {
            let r = this.stateId ^ t.data
              , i = 0;
            for (; r; )
                r & 1 && this.map[i].call(this, !!(t.data & 1 << i)),
                r = r >> 1,
                i++;
            this.stateId = t.data
        }
        for (let r = 0; r < this.checks.length; r++)
            this.checks[r](this, t)
    }
    forceState(t) {
        t = t || this.defaultState;
        for (let r = 0; r < this.map.length; r++)
            this.map[r].call(this, !!(t.data & 1 << r));
        for (let r = 0; r < this.checks.length; r++)
            this.checks[r](this, t);
        this.stateId = t.data
    }
    setBlend(t) {
        this.updateCheck(v_.checkBlendMode, t),
        this.gl[t ? "enable" : "disable"](this.gl.BLEND)
    }
    setOffset(t) {
        this.updateCheck(v_.checkPolygonOffset, t),
        this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
    }
    setDepthTest(t) {
        this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST)
    }
    setDepthMask(t) {
        this.gl.depthMask(t)
    }
    setCullFace(t) {
        this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE)
    }
    setFrontFace(t) {
        this.gl.frontFace(this.gl[t ? "CW" : "CCW"])
    }
    setBlendMode(t) {
        if (t === this.blendMode)
            return;
        this.blendMode = t;
        const r = this.blendModes[t]
          , i = this.gl;
        r.length === 2 ? i.blendFunc(r[0], r[1]) : i.blendFuncSeparate(r[0], r[1], r[2], r[3]),
        r.length === 6 ? (this._blendEq = !0,
        i.blendEquationSeparate(r[4], r[5])) : this._blendEq && (this._blendEq = !1,
        i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD))
    }
    setPolygonOffset(t, r) {
        this.gl.polygonOffset(t, r)
    }
    reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
        this.forceState(this.defaultState),
        this._blendEq = !0,
        this.blendMode = -1,
        this.setBlendMode(0)
    }
    updateCheck(t, r) {
        const i = this.checks.indexOf(t);
        r && i === -1 ? this.checks.push(t) : !r && i !== -1 && this.checks.splice(i, 1)
    }
    static checkBlendMode(t, r) {
        t.setBlendMode(r.blendMode)
    }
    static checkPolygonOffset(t, r) {
        t.setPolygonOffset(1, r.polygonOffset)
    }
    destroy() {
        this.gl = null
    }
}
;
eR.extension = {
    type: G.RendererSystem,
    name: "state"
};
let rR = eR;
Y.add(rR);
class iR extends ci {
    constructor() {
        super(...arguments),
        this.runners = {},
        this._systemsHash = {}
    }
    setup(t) {
        this.addRunners(...t.runners);
        const r = (t.priority ?? []).filter(n => t.systems[n])
          , i = [...r, ...Object.keys(t.systems).filter(n => !r.includes(n))];
        for (const n of i)
            this.addSystem(t.systems[n], n)
    }
    addRunners(...t) {
        t.forEach(r => {
            this.runners[r] = new Nr(r)
        }
        )
    }
    addSystem(t, r) {
        const i = new t(this);
        if (this[r])
            throw new Error(`Whoops! The name "${r}" is already in use`);
        this[r] = i,
        this._systemsHash[r] = i;
        for (const n in this.runners)
            this.runners[n].add(i);
        return this
    }
    emitWithCustomOptions(t, r) {
        const i = Object.keys(this._systemsHash);
        t.items.forEach(n => {
            const s = i.find(o => this._systemsHash[o] === n);
            n[t.name](r[s])
        }
        )
    }
    destroy() {
        Object.values(this.runners).forEach(t => {
            t.destroy()
        }
        ),
        this._systemsHash = {}
    }
}
const jl = class _d {
    constructor(t) {
        this.renderer = t,
        this.count = 0,
        this.checkCount = 0,
        this.maxIdle = _d.defaultMaxIdle,
        this.checkCountMax = _d.defaultCheckCountMax,
        this.mode = _d.defaultMode
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && (this.count++,
        this.mode !== Pp.MANUAL && (this.checkCount++,
        this.checkCount > this.checkCountMax && (this.checkCount = 0,
        this.run())))
    }
    run() {
        const t = this.renderer.texture
          , r = t.managedTextures;
        let i = !1;
        for (let n = 0; n < r.length; n++) {
            const s = r[n];
            s.resource && this.count - s.touched > this.maxIdle && (t.destroyTexture(s, !0),
            r[n] = null,
            i = !0)
        }
        if (i) {
            let n = 0;
            for (let s = 0; s < r.length; s++)
                r[s] !== null && (r[n++] = r[s]);
            r.length = n
        }
    }
    unload(t) {
        const r = this.renderer.texture
          , i = t._texture;
        i && !i.framebuffer && r.destroyTexture(i);
        for (let n = t.children.length - 1; n >= 0; n--)
            this.unload(t.children[n])
    }
    destroy() {
        this.renderer = null
    }
}
;
jl.defaultMode = Pp.AUTO,
jl.defaultMaxIdle = 60 * 60,
jl.defaultCheckCountMax = 60 * 10,
jl.extension = {
    type: G.RendererSystem,
    name: "textureGC"
};
let rs = jl;
Y.add(rs);
class yd {
    constructor(t) {
        this.texture = t,
        this.width = -1,
        this.height = -1,
        this.dirtyId = -1,
        this.dirtyStyleId = -1,
        this.mipmap = !1,
        this.wrapMode = 33071,
        this.type = Q.UNSIGNED_BYTE,
        this.internalFormat = B.RGBA,
        this.samplerType = 0
    }
}
function Ez(e) {
    let t;
    return "WebGL2RenderingContext"in globalThis && e instanceof globalThis.WebGL2RenderingContext ? t = {
        [e.RGB]: W.FLOAT,
        [e.RGBA]: W.FLOAT,
        [e.ALPHA]: W.FLOAT,
        [e.LUMINANCE]: W.FLOAT,
        [e.LUMINANCE_ALPHA]: W.FLOAT,
        [e.R8]: W.FLOAT,
        [e.R8_SNORM]: W.FLOAT,
        [e.RG8]: W.FLOAT,
        [e.RG8_SNORM]: W.FLOAT,
        [e.RGB8]: W.FLOAT,
        [e.RGB8_SNORM]: W.FLOAT,
        [e.RGB565]: W.FLOAT,
        [e.RGBA4]: W.FLOAT,
        [e.RGB5_A1]: W.FLOAT,
        [e.RGBA8]: W.FLOAT,
        [e.RGBA8_SNORM]: W.FLOAT,
        [e.RGB10_A2]: W.FLOAT,
        [e.RGB10_A2UI]: W.FLOAT,
        [e.SRGB8]: W.FLOAT,
        [e.SRGB8_ALPHA8]: W.FLOAT,
        [e.R16F]: W.FLOAT,
        [e.RG16F]: W.FLOAT,
        [e.RGB16F]: W.FLOAT,
        [e.RGBA16F]: W.FLOAT,
        [e.R32F]: W.FLOAT,
        [e.RG32F]: W.FLOAT,
        [e.RGB32F]: W.FLOAT,
        [e.RGBA32F]: W.FLOAT,
        [e.R11F_G11F_B10F]: W.FLOAT,
        [e.RGB9_E5]: W.FLOAT,
        [e.R8I]: W.INT,
        [e.R8UI]: W.UINT,
        [e.R16I]: W.INT,
        [e.R16UI]: W.UINT,
        [e.R32I]: W.INT,
        [e.R32UI]: W.UINT,
        [e.RG8I]: W.INT,
        [e.RG8UI]: W.UINT,
        [e.RG16I]: W.INT,
        [e.RG16UI]: W.UINT,
        [e.RG32I]: W.INT,
        [e.RG32UI]: W.UINT,
        [e.RGB8I]: W.INT,
        [e.RGB8UI]: W.UINT,
        [e.RGB16I]: W.INT,
        [e.RGB16UI]: W.UINT,
        [e.RGB32I]: W.INT,
        [e.RGB32UI]: W.UINT,
        [e.RGBA8I]: W.INT,
        [e.RGBA8UI]: W.UINT,
        [e.RGBA16I]: W.INT,
        [e.RGBA16UI]: W.UINT,
        [e.RGBA32I]: W.INT,
        [e.RGBA32UI]: W.UINT,
        [e.DEPTH_COMPONENT16]: W.FLOAT,
        [e.DEPTH_COMPONENT24]: W.FLOAT,
        [e.DEPTH_COMPONENT32F]: W.FLOAT,
        [e.DEPTH_STENCIL]: W.FLOAT,
        [e.DEPTH24_STENCIL8]: W.FLOAT,
        [e.DEPTH32F_STENCIL8]: W.FLOAT
    } : t = {
        [e.RGB]: W.FLOAT,
        [e.RGBA]: W.FLOAT,
        [e.ALPHA]: W.FLOAT,
        [e.LUMINANCE]: W.FLOAT,
        [e.LUMINANCE_ALPHA]: W.FLOAT,
        [e.DEPTH_STENCIL]: W.FLOAT
    },
    t
}
function Tz(e) {
    let t;
    return "WebGL2RenderingContext"in globalThis && e instanceof globalThis.WebGL2RenderingContext ? t = {
        [Q.UNSIGNED_BYTE]: {
            [B.RGBA]: e.RGBA8,
            [B.RGB]: e.RGB8,
            [B.RG]: e.RG8,
            [B.RED]: e.R8,
            [B.RGBA_INTEGER]: e.RGBA8UI,
            [B.RGB_INTEGER]: e.RGB8UI,
            [B.RG_INTEGER]: e.RG8UI,
            [B.RED_INTEGER]: e.R8UI,
            [B.ALPHA]: e.ALPHA,
            [B.LUMINANCE]: e.LUMINANCE,
            [B.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
        },
        [Q.BYTE]: {
            [B.RGBA]: e.RGBA8_SNORM,
            [B.RGB]: e.RGB8_SNORM,
            [B.RG]: e.RG8_SNORM,
            [B.RED]: e.R8_SNORM,
            [B.RGBA_INTEGER]: e.RGBA8I,
            [B.RGB_INTEGER]: e.RGB8I,
            [B.RG_INTEGER]: e.RG8I,
            [B.RED_INTEGER]: e.R8I
        },
        [Q.UNSIGNED_SHORT]: {
            [B.RGBA_INTEGER]: e.RGBA16UI,
            [B.RGB_INTEGER]: e.RGB16UI,
            [B.RG_INTEGER]: e.RG16UI,
            [B.RED_INTEGER]: e.R16UI,
            [B.DEPTH_COMPONENT]: e.DEPTH_COMPONENT16
        },
        [Q.SHORT]: {
            [B.RGBA_INTEGER]: e.RGBA16I,
            [B.RGB_INTEGER]: e.RGB16I,
            [B.RG_INTEGER]: e.RG16I,
            [B.RED_INTEGER]: e.R16I
        },
        [Q.UNSIGNED_INT]: {
            [B.RGBA_INTEGER]: e.RGBA32UI,
            [B.RGB_INTEGER]: e.RGB32UI,
            [B.RG_INTEGER]: e.RG32UI,
            [B.RED_INTEGER]: e.R32UI,
            [B.DEPTH_COMPONENT]: e.DEPTH_COMPONENT24
        },
        [Q.INT]: {
            [B.RGBA_INTEGER]: e.RGBA32I,
            [B.RGB_INTEGER]: e.RGB32I,
            [B.RG_INTEGER]: e.RG32I,
            [B.RED_INTEGER]: e.R32I
        },
        [Q.FLOAT]: {
            [B.RGBA]: e.RGBA32F,
            [B.RGB]: e.RGB32F,
            [B.RG]: e.RG32F,
            [B.RED]: e.R32F,
            [B.DEPTH_COMPONENT]: e.DEPTH_COMPONENT32F
        },
        [Q.HALF_FLOAT]: {
            [B.RGBA]: e.RGBA16F,
            [B.RGB]: e.RGB16F,
            [B.RG]: e.RG16F,
            [B.RED]: e.R16F
        },
        [Q.UNSIGNED_SHORT_5_6_5]: {
            [B.RGB]: e.RGB565
        },
        [Q.UNSIGNED_SHORT_4_4_4_4]: {
            [B.RGBA]: e.RGBA4
        },
        [Q.UNSIGNED_SHORT_5_5_5_1]: {
            [B.RGBA]: e.RGB5_A1
        },
        [Q.UNSIGNED_INT_2_10_10_10_REV]: {
            [B.RGBA]: e.RGB10_A2,
            [B.RGBA_INTEGER]: e.RGB10_A2UI
        },
        [Q.UNSIGNED_INT_10F_11F_11F_REV]: {
            [B.RGB]: e.R11F_G11F_B10F
        },
        [Q.UNSIGNED_INT_5_9_9_9_REV]: {
            [B.RGB]: e.RGB9_E5
        },
        [Q.UNSIGNED_INT_24_8]: {
            [B.DEPTH_STENCIL]: e.DEPTH24_STENCIL8
        },
        [Q.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
            [B.DEPTH_STENCIL]: e.DEPTH32F_STENCIL8
        }
    } : t = {
        [Q.UNSIGNED_BYTE]: {
            [B.RGBA]: e.RGBA,
            [B.RGB]: e.RGB,
            [B.ALPHA]: e.ALPHA,
            [B.LUMINANCE]: e.LUMINANCE,
            [B.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
        },
        [Q.UNSIGNED_SHORT_5_6_5]: {
            [B.RGB]: e.RGB
        },
        [Q.UNSIGNED_SHORT_4_4_4_4]: {
            [B.RGBA]: e.RGBA
        },
        [Q.UNSIGNED_SHORT_5_5_5_1]: {
            [B.RGBA]: e.RGBA
        }
    },
    t
}
class yx {
    constructor(t) {
        this.renderer = t,
        this.boundTextures = [],
        this.currentLocation = -1,
        this.managedTextures = [],
        this._unknownBoundTextures = !1,
        this.unknownTexture = new nt,
        this.hasIntegerTextures = !1
    }
    contextChange() {
        const t = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        this.webGLVersion = this.renderer.context.webGLVersion,
        this.internalFormats = Tz(t),
        this.samplerTypes = Ez(t);
        const r = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = r;
        for (let n = 0; n < r; n++)
            this.boundTextures[n] = null;
        this.emptyTextures = {};
        const i = new yd(t.createTexture());
        t.bindTexture(t.TEXTURE_2D, i.texture),
        t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)),
        this.emptyTextures[t.TEXTURE_2D] = i,
        this.emptyTextures[t.TEXTURE_CUBE_MAP] = new yd(t.createTexture()),
        t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
        for (let n = 0; n < 6; n++)
            t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
        for (let n = 0; n < this.boundTextures.length; n++)
            this.bind(null, n)
    }
    bind(t, r=0) {
        const {gl: i} = this;
        if (t = t?.castToBaseTexture(),
        t?.valid && !t.parentTextureArray) {
            t.touched = this.renderer.textureGC.count;
            const n = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
            this.boundTextures[r] !== t && (this.currentLocation !== r && (this.currentLocation = r,
            i.activeTexture(i.TEXTURE0 + r)),
            i.bindTexture(t.target, n.texture)),
            n.dirtyId !== t.dirtyId ? (this.currentLocation !== r && (this.currentLocation = r,
            i.activeTexture(i.TEXTURE0 + r)),
            this.updateTexture(t)) : n.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t),
            this.boundTextures[r] = t
        } else
            this.currentLocation !== r && (this.currentLocation = r,
            i.activeTexture(i.TEXTURE0 + r)),
            i.bindTexture(i.TEXTURE_2D, this.emptyTextures[i.TEXTURE_2D].texture),
            this.boundTextures[r] = null
    }
    reset() {
        this._unknownBoundTextures = !0,
        this.hasIntegerTextures = !1,
        this.currentLocation = -1;
        for (let t = 0; t < this.boundTextures.length; t++)
            this.boundTextures[t] = this.unknownTexture
    }
    unbind(t) {
        const {gl: r, boundTextures: i} = this;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = !1;
            for (let n = 0; n < i.length; n++)
                i[n] === this.unknownTexture && this.bind(null, n)
        }
        for (let n = 0; n < i.length; n++)
            i[n] === t && (this.currentLocation !== n && (r.activeTexture(r.TEXTURE0 + n),
            this.currentLocation = n),
            r.bindTexture(t.target, this.emptyTextures[t.target].texture),
            i[n] = null)
    }
    ensureSamplerType(t) {
        const {boundTextures: r, hasIntegerTextures: i, CONTEXT_UID: n} = this;
        if (i)
            for (let s = t - 1; s >= 0; --s) {
                const o = r[s];
                o && o._glTextures[n].samplerType !== W.FLOAT && this.renderer.texture.unbind(o)
            }
    }
    initTexture(t) {
        const r = new yd(this.gl.createTexture());
        return r.dirtyId = -1,
        t._glTextures[this.CONTEXT_UID] = r,
        this.managedTextures.push(t),
        t.on("dispose", this.destroyTexture, this),
        r
    }
    initTextureType(t, r) {
        r.internalFormat = this.internalFormats[t.type]?.[t.format] ?? t.format,
        r.samplerType = this.samplerTypes[r.internalFormat] ?? W.FLOAT,
        this.webGLVersion === 2 && t.type === Q.HALF_FLOAT ? r.type = this.gl.HALF_FLOAT : r.type = t.type
    }
    updateTexture(t) {
        const r = t._glTextures[this.CONTEXT_UID];
        if (!r)
            return;
        const i = this.renderer;
        if (this.initTextureType(t, r),
        t.resource?.upload(i, t, r))
            r.samplerType !== W.FLOAT && (this.hasIntegerTextures = !0);
        else {
            const n = t.realWidth
              , s = t.realHeight
              , o = i.gl;
            (r.width !== n || r.height !== s || r.dirtyId < 0) && (r.width = n,
            r.height = s,
            o.texImage2D(t.target, 0, r.internalFormat, n, s, 0, t.format, r.type, null))
        }
        t.dirtyStyleId !== r.dirtyStyleId && this.updateTextureStyle(t),
        r.dirtyId = t.dirtyId
    }
    destroyTexture(t, r) {
        const {gl: i} = this;
        if (t = t.castToBaseTexture(),
        t._glTextures[this.CONTEXT_UID] && (this.unbind(t),
        i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
        t.off("dispose", this.destroyTexture, this),
        delete t._glTextures[this.CONTEXT_UID],
        !r)) {
            const n = this.managedTextures.indexOf(t);
            n !== -1 && mo(this.managedTextures, n, 1)
        }
    }
    updateTextureStyle(t) {
        const r = t._glTextures[this.CONTEXT_UID];
        r && ((t.mipmap === Ni.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? r.mipmap = !1 : r.mipmap = t.mipmap >= 1,
        this.webGLVersion !== 2 && !t.isPowerOfTwo ? r.wrapMode = Ci.CLAMP : r.wrapMode = t.wrapMode,
        t.resource?.style(this.renderer, t, r) || this.setStyle(t, r),
        r.dirtyStyleId = t.dirtyStyleId)
    }
    setStyle(t, r) {
        const i = this.gl;
        if (r.mipmap && t.mipmap !== Ni.ON_MANUAL && i.generateMipmap(t.target),
        i.texParameteri(t.target, i.TEXTURE_WRAP_S, r.wrapMode),
        i.texParameteri(t.target, i.TEXTURE_WRAP_T, r.wrapMode),
        r.mipmap) {
            i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === Qi.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST);
            const n = this.renderer.context.extensions.anisotropicFiltering;
            if (n && t.anisotropicLevel > 0 && t.scaleMode === Qi.LINEAR) {
                const s = Math.min(t.anisotropicLevel, i.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                i.texParameterf(t.target, n.TEXTURE_MAX_ANISOTROPY_EXT, s)
            }
        } else
            i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === Qi.LINEAR ? i.LINEAR : i.NEAREST);
        i.texParameteri(t.target, i.TEXTURE_MAG_FILTER, t.scaleMode === Qi.LINEAR ? i.LINEAR : i.NEAREST)
    }
    destroy() {
        this.renderer = null
    }
}
yx.extension = {
    type: G.RendererSystem,
    name: "texture"
};
Y.add(yx);
class vx {
    constructor(t) {
        this.renderer = t
    }
    contextChange() {
        this.gl = this.renderer.gl,
        this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {gl: r, CONTEXT_UID: i} = this
          , n = t._glTransformFeedbacks[i] || this.createGLTransformFeedback(t);
        r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, n)
    }
    unbind() {
        const {gl: t} = this;
        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
    }
    beginTransformFeedback(t, r) {
        const {gl: i, renderer: n} = this;
        r && n.shader.bind(r),
        i.beginTransformFeedback(t)
    }
    endTransformFeedback() {
        const {gl: t} = this;
        t.endTransformFeedback()
    }
    createGLTransformFeedback(t) {
        const {gl: r, renderer: i, CONTEXT_UID: n} = this
          , s = r.createTransformFeedback();
        t._glTransformFeedbacks[n] = s,
        r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, s);
        for (let o = 0; o < t.buffers.length; o++) {
            const a = t.buffers[o];
            a && (i.buffer.update(a),
            a._glBuffers[n].refCount++,
            r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER, o, a._glBuffers[n].buffer || null))
        }
        return r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, null),
        t.disposeRunner.add(this),
        s
    }
    disposeTransformFeedback(t, r) {
        const i = t._glTransformFeedbacks[this.CONTEXT_UID]
          , n = this.gl;
        t.disposeRunner.remove(this);
        const s = this.renderer.buffer;
        if (s)
            for (let o = 0; o < t.buffers.length; o++) {
                const a = t.buffers[o];
                if (!a)
                    continue;
                const l = a._glBuffers[this.CONTEXT_UID];
                l && (l.refCount--,
                l.refCount === 0 && !r && s.dispose(a, r))
            }
        i && (r || n.deleteTransformFeedback(i),
        delete t._glTransformFeedbacks[this.CONTEXT_UID])
    }
    destroy() {
        this.renderer = null
    }
}
vx.extension = {
    type: G.RendererSystem,
    name: "transformFeedback"
};
Y.add(vx);
class su {
    constructor(t) {
        this.renderer = t
    }
    init(t) {
        this.screen = new lt(0,0,t.width,t.height),
        this.element = t.view || z.ADAPTER.createCanvas(),
        this.resolution = t.resolution || z.RESOLUTION,
        this.autoDensity = !!t.autoDensity
    }
    resizeView(t, r) {
        this.element.width = Math.round(t * this.resolution),
        this.element.height = Math.round(r * this.resolution);
        const i = this.element.width / this.resolution
          , n = this.element.height / this.resolution;
        this.screen.width = i,
        this.screen.height = n,
        this.autoDensity && (this.element.style.width = `${i}px`,
        this.element.style.height = `${n}px`),
        this.renderer.emit("resize", i, n),
        this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
    }
    destroy(t) {
        t && this.element.parentNode?.removeChild(this.element),
        this.renderer = null,
        this.element = null,
        this.screen = null
    }
}
su.defaultOptions = {
    width: 800,
    height: 600,
    resolution: void 0,
    autoDensity: !1
},
su.extension = {
    type: [G.RendererSystem, G.CanvasRendererSystem],
    name: "_view"
};
Y.add(su);
z.PREFER_ENV = Fs.WEBGL2;
z.STRICT_TEXTURE_CACHE = !1;
z.RENDER_OPTIONS = {
    ...iu.defaultOptions,
    ...ru.defaultOptions,
    ...su.defaultOptions,
    ...nu.defaultOptions
};
Object.defineProperties(z, {
    WRAP_MODE: {
        get() {
            return nt.defaultOptions.wrapMode
        },
        set(e) {
            et("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"),
            nt.defaultOptions.wrapMode = e
        }
    },
    SCALE_MODE: {
        get() {
            return nt.defaultOptions.scaleMode
        },
        set(e) {
            et("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"),
            nt.defaultOptions.scaleMode = e
        }
    },
    MIPMAP_TEXTURES: {
        get() {
            return nt.defaultOptions.mipmap
        },
        set(e) {
            et("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"),
            nt.defaultOptions.mipmap = e
        }
    },
    ANISOTROPIC_LEVEL: {
        get() {
            return nt.defaultOptions.anisotropicLevel
        },
        set(e) {
            et("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"),
            nt.defaultOptions.anisotropicLevel = e
        }
    },
    FILTER_RESOLUTION: {
        get() {
            return et("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"),
            ze.defaultResolution
        },
        set(e) {
            ze.defaultResolution = e
        }
    },
    FILTER_MULTISAMPLE: {
        get() {
            return et("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"),
            ze.defaultMultisample
        },
        set(e) {
            ze.defaultMultisample = e
        }
    },
    SPRITE_MAX_TEXTURES: {
        get() {
            return es.defaultMaxTextures
        },
        set(e) {
            et("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"),
            es.defaultMaxTextures = e
        }
    },
    SPRITE_BATCH_SIZE: {
        get() {
            return es.defaultBatchSize
        },
        set(e) {
            et("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"),
            es.defaultBatchSize = e
        }
    },
    CAN_UPLOAD_SAME_BUFFER: {
        get() {
            return es.canUploadSameBuffer
        },
        set(e) {
            et("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"),
            es.canUploadSameBuffer = e
        }
    },
    GC_MODE: {
        get() {
            return rs.defaultMode
        },
        set(e) {
            et("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"),
            rs.defaultMode = e
        }
    },
    GC_MAX_IDLE: {
        get() {
            return rs.defaultMaxIdle
        },
        set(e) {
            et("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"),
            rs.defaultMaxIdle = e
        }
    },
    GC_MAX_CHECK_COUNT: {
        get() {
            return rs.defaultCheckCountMax
        },
        set(e) {
            et("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"),
            rs.defaultCheckCountMax = e
        }
    },
    PRECISION_VERTEX: {
        get() {
            return tn.defaultVertexPrecision
        },
        set(e) {
            et("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"),
            tn.defaultVertexPrecision = e
        }
    },
    PRECISION_FRAGMENT: {
        get() {
            return tn.defaultFragmentPrecision
        },
        set(e) {
            et("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"),
            tn.defaultFragmentPrecision = e
        }
    }
});
var Hn = (e => (e[e.INTERACTION = 50] = "INTERACTION",
e[e.HIGH = 25] = "HIGH",
e[e.NORMAL = 0] = "NORMAL",
e[e.LOW = -25] = "LOW",
e[e.UTILITY = -50] = "UTILITY",
e))(Hn || {});
class sg {
    constructor(t, r=null, i=0, n=!1) {
        this.next = null,
        this.previous = null,
        this._destroyed = !1,
        this.fn = t,
        this.context = r,
        this.priority = i,
        this.once = n
    }
    match(t, r=null) {
        return this.fn === t && this.context === r
    }
    emit(t) {
        this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
        const r = this.next;
        return this.once && this.destroy(!0),
        this._destroyed && (this.next = null),
        r
    }
    connect(t) {
        this.previous = t,
        t.next && (t.next.previous = this),
        this.next = t.next,
        t.next = this
    }
    destroy(t=!1) {
        this._destroyed = !0,
        this.fn = null,
        this.context = null,
        this.previous && (this.previous.next = this.next),
        this.next && (this.next.previous = this.previous);
        const r = this.next;
        return this.next = t ? null : r,
        this.previous = null,
        r
    }
}
const nR = class yr {
    constructor() {
        this.autoStart = !1,
        this.deltaTime = 1,
        this.lastTime = -1,
        this.speed = 1,
        this.started = !1,
        this._requestId = null,
        this._maxElapsedMS = 100,
        this._minElapsedMS = 0,
        this._protected = !1,
        this._lastFrame = -1,
        this._head = new sg(null,null,1 / 0),
        this.deltaMS = 1 / yr.targetFPMS,
        this.elapsedMS = 1 / yr.targetFPMS,
        this._tick = t => {
            this._requestId = null,
            this.started && (this.update(t),
            this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
        }
    }
    _requestIfNeeded() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(),
        this._lastFrame = this.lastTime,
        this._requestId = requestAnimationFrame(this._tick))
    }
    _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId),
        this._requestId = null)
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }
    add(t, r, i=Hn.NORMAL) {
        return this._addListener(new sg(t,r,i))
    }
    addOnce(t, r, i=Hn.NORMAL) {
        return this._addListener(new sg(t,r,i,!0))
    }
    _addListener(t) {
        let r = this._head.next
          , i = this._head;
        if (!r)
            t.connect(i);
        else {
            for (; r; ) {
                if (t.priority > r.priority) {
                    t.connect(i);
                    break
                }
                i = r,
                r = r.next
            }
            t.previous || t.connect(i)
        }
        return this._startIfPossible(),
        this
    }
    remove(t, r) {
        let i = this._head.next;
        for (; i; )
            i.match(t, r) ? i = i.destroy() : i = i.next;
        return this._head.next || this._cancelIfNeeded(),
        this
    }
    get count() {
        if (!this._head)
            return 0;
        let t = 0
          , r = this._head;
        for (; r = r.next; )
            t++;
        return t
    }
    start() {
        this.started || (this.started = !0,
        this._requestIfNeeded())
    }
    stop() {
        this.started && (this.started = !1,
        this._cancelIfNeeded())
    }
    destroy() {
        if (!this._protected) {
            this.stop();
            let t = this._head.next;
            for (; t; )
                t = t.destroy(!0);
            this._head.destroy(),
            this._head = null
        }
    }
    update(t=performance.now()) {
        let r;
        if (t > this.lastTime) {
            if (r = this.elapsedMS = t - this.lastTime,
            r > this._maxElapsedMS && (r = this._maxElapsedMS),
            r *= this.speed,
            this._minElapsedMS) {
                const s = t - this._lastFrame | 0;
                if (s < this._minElapsedMS)
                    return;
                this._lastFrame = t - s % this._minElapsedMS
            }
            this.deltaMS = r,
            this.deltaTime = this.deltaMS * yr.targetFPMS;
            const i = this._head;
            let n = i.next;
            for (; n; )
                n = n.emit(this.deltaTime);
            i.next || this._cancelIfNeeded()
        } else
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = t
    }
    get FPS() {
        return 1e3 / this.elapsedMS
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }
    set minFPS(t) {
        const r = Math.min(this.maxFPS, t)
          , i = Math.min(Math.max(0, r) / 1e3, yr.targetFPMS);
        this._maxElapsedMS = 1 / i
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }
    set maxFPS(t) {
        if (t === 0)
            this._minElapsedMS = 0;
        else {
            const r = Math.max(this.minFPS, t);
            this._minElapsedMS = 1 / (r / 1e3)
        }
    }
    static get shared() {
        if (!yr._shared) {
            const t = yr._shared = new yr;
            t.autoStart = !0,
            t._protected = !0
        }
        return yr._shared
    }
    static get system() {
        if (!yr._system) {
            const t = yr._system = new yr;
            t.autoStart = !0,
            t._protected = !0
        }
        return yr._system
    }
}
;
nR.targetFPMS = .06;
let $t = nR;
Object.defineProperties(z, {
    TARGET_FPMS: {
        get() {
            return $t.targetFPMS
        },
        set(e) {
            et("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"),
            $t.targetFPMS = e
        }
    }
});
class xx {
    static init(t) {
        t = Object.assign({
            autoStart: !0,
            sharedTicker: !1
        }, t),
        Object.defineProperty(this, "ticker", {
            set(r) {
                this._ticker && this._ticker.remove(this.render, this),
                this._ticker = r,
                r && r.add(this.render, this, Hn.LOW)
            },
            get() {
                return this._ticker
            }
        }),
        this.stop = () => {
            this._ticker.stop()
        }
        ,
        this.start = () => {
            this._ticker.start()
        }
        ,
        this._ticker = null,
        this.ticker = t.sharedTicker ? $t.shared : new $t,
        t.autoStart && this.start()
    }
    static destroy() {
        if (this._ticker) {
            const t = this._ticker;
            this.ticker = null,
            t.destroy()
        }
    }
}
xx.extension = G.Application;
Y.add(xx);
const sR = [];
Y.handleByList(G.Renderer, sR);
function oR(e) {
    for (const t of sR)
        if (t.test(e))
            return new t(e);
    throw new Error("Unable to auto-detect a suitable renderer.")
}
var Sz = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`
  , wz = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const aR = Sz
  , Ex = wz;
class Tx {
    constructor(t) {
        this.renderer = t
    }
    contextChange(t) {
        let r;
        if (this.renderer.context.webGLVersion === 1) {
            const i = t.getParameter(t.FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.FRAMEBUFFER, null),
            r = t.getParameter(t.SAMPLES),
            t.bindFramebuffer(t.FRAMEBUFFER, i)
        } else {
            const i = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
            r = t.getParameter(t.SAMPLES),
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, i)
        }
        r >= se.HIGH ? this.multisample = se.HIGH : r >= se.MEDIUM ? this.multisample = se.MEDIUM : r >= se.LOW ? this.multisample = se.LOW : this.multisample = se.NONE
    }
    destroy() {}
}
Tx.extension = {
    type: G.RendererSystem,
    name: "_multisample"
};
Y.add(Tx);
class Az {
    constructor(t) {
        this.buffer = t || null,
        this.updateID = -1,
        this.byteLength = -1,
        this.refCount = 0
    }
}
class Sx {
    constructor(t) {
        this.renderer = t,
        this.managedBuffers = {},
        this.boundBufferBases = {}
    }
    destroy() {
        this.renderer = null
    }
    contextChange() {
        this.disposeAll(!0),
        this.gl = this.renderer.gl,
        this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {gl: r, CONTEXT_UID: i} = this
          , n = t._glBuffers[i] || this.createGLBuffer(t);
        r.bindBuffer(t.type, n.buffer)
    }
    unbind(t) {
        const {gl: r} = this;
        r.bindBuffer(t, null)
    }
    bindBufferBase(t, r) {
        const {gl: i, CONTEXT_UID: n} = this;
        if (this.boundBufferBases[r] !== t) {
            const s = t._glBuffers[n] || this.createGLBuffer(t);
            this.boundBufferBases[r] = t,
            i.bindBufferBase(i.UNIFORM_BUFFER, r, s.buffer)
        }
    }
    bindBufferRange(t, r, i) {
        const {gl: n, CONTEXT_UID: s} = this;
        i = i || 0;
        const o = t._glBuffers[s] || this.createGLBuffer(t);
        n.bindBufferRange(n.UNIFORM_BUFFER, r || 0, o.buffer, i * 256, 256)
    }
    update(t) {
        const {gl: r, CONTEXT_UID: i} = this
          , n = t._glBuffers[i] || this.createGLBuffer(t);
        if (t._updateID !== n.updateID)
            if (n.updateID = t._updateID,
            r.bindBuffer(t.type, n.buffer),
            n.byteLength >= t.data.byteLength)
                r.bufferSubData(t.type, 0, t.data);
            else {
                const s = t.static ? r.STATIC_DRAW : r.DYNAMIC_DRAW;
                n.byteLength = t.data.byteLength,
                r.bufferData(t.type, t.data, s)
            }
    }
    dispose(t, r) {
        if (!this.managedBuffers[t.id])
            return;
        delete this.managedBuffers[t.id];
        const i = t._glBuffers[this.CONTEXT_UID]
          , n = this.gl;
        t.disposeRunner.remove(this),
        i && (r || n.deleteBuffer(i.buffer),
        delete t._glBuffers[this.CONTEXT_UID])
    }
    disposeAll(t) {
        const r = Object.keys(this.managedBuffers);
        for (let i = 0; i < r.length; i++)
            this.dispose(this.managedBuffers[r[i]], t)
    }
    createGLBuffer(t) {
        const {CONTEXT_UID: r, gl: i} = this;
        return t._glBuffers[r] = new Az(i.createBuffer()),
        this.managedBuffers[t.id] = t,
        t.disposeRunner.add(this),
        t._glBuffers[r]
    }
}
Sx.extension = {
    type: G.RendererSystem,
    name: "buffer"
};
Y.add(Sx);
class wx {
    constructor(t) {
        this.renderer = t
    }
    render(t, r) {
        const i = this.renderer;
        let n, s, o, a;
        if (r && (n = r.renderTexture,
        s = r.clear,
        o = r.transform,
        a = r.skipUpdateTransform),
        this.renderingToScreen = !n,
        i.runners.prerender.emit(),
        i.emit("prerender"),
        i.projection.transform = o,
        !i.context.isLost) {
            if (n || (this.lastObjectRendered = t),
            !a) {
                const l = t.enableTempParent();
                t.updateTransform(),
                t.disableTempParent(l)
            }
            i.renderTexture.bind(n),
            i.batch.currentRenderer.start(),
            (s ?? i.background.clearBeforeRender) && i.renderTexture.clear(),
            t.render(i),
            i.batch.currentRenderer.flush(),
            n && (r.blit && i.framebuffer.blit(),
            n.baseTexture.update()),
            i.runners.postrender.emit(),
            i.projection.transform = null,
            i.emit("postrender")
        }
    }
    destroy() {
        this.renderer = null,
        this.lastObjectRendered = null
    }
}
wx.extension = {
    type: G.RendererSystem,
    name: "objectRenderer"
};
Y.add(wx);
const vd = class x_ extends iR {
    constructor(t) {
        super(),
        this.type = zv.WEBGL,
        t = Object.assign({}, z.RENDER_OPTIONS, t),
        this.gl = null,
        this.CONTEXT_UID = 0,
        this.globalUniforms = new ni({
            projectionMatrix: new Mt
        },!0);
        const r = {
            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
            systems: x_.__systems,
            priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
        };
        this.setup(r),
        "useContextAlpha"in t && (et("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"),
        t.premultipliedAlpha = t.useContextAlpha && t.useContextAlpha !== "notMultiplied",
        t.backgroundAlpha = t.useContextAlpha === !1 ? 1 : t.backgroundAlpha),
        this._plugin.rendererPlugins = x_.__plugins,
        this.options = t,
        this.startup.run(this.options)
    }
    static test(t) {
        return t?.forceCanvas ? !1 : yI()
    }
    render(t, r) {
        this.objectRenderer.render(t, r)
    }
    resize(t, r) {
        this._view.resizeView(t, r)
    }
    reset() {
        return this.runners.reset.emit(),
        this
    }
    clear() {
        this.renderTexture.bind(),
        this.renderTexture.clear()
    }
    destroy(t=!1) {
        this.runners.destroy.items.reverse(),
        this.emitWithCustomOptions(this.runners.destroy, {
            _view: t
        }),
        super.destroy()
    }
    get plugins() {
        return this._plugin.plugins
    }
    get multisample() {
        return this._multisample.multisample
    }
    get width() {
        return this._view.element.width
    }
    get height() {
        return this._view.element.height
    }
    get resolution() {
        return this._view.resolution
    }
    set resolution(t) {
        this._view.resolution = t,
        this.runners.resolutionChange.emit(t)
    }
    get autoDensity() {
        return this._view.autoDensity
    }
    get view() {
        return this._view.element
    }
    get screen() {
        return this._view.screen
    }
    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }
    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }
    get rendererLogId() {
        return `WebGL ${this.context.webGLVersion}`
    }
    get clearBeforeRender() {
        return et("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."),
        this.background.clearBeforeRender
    }
    get useContextAlpha() {
        return et("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."),
        this.context.useContextAlpha
    }
    get preserveDrawingBuffer() {
        return et("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"),
        this.context.preserveDrawingBuffer
    }
    get backgroundColor() {
        return et("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
        this.background.color
    }
    set backgroundColor(t) {
        et("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
        this.background.color = t
    }
    get backgroundAlpha() {
        return et("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
        this.background.alpha
    }
    set backgroundAlpha(t) {
        et("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
        this.background.alpha = t
    }
    get powerPreference() {
        return et("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"),
        this.context.powerPreference
    }
    generateTexture(t, r) {
        return this.textureGenerator.generateTexture(t, r)
    }
}
;
vd.extension = {
    type: G.Renderer,
    priority: 1
},
vd.__plugins = {},
vd.__systems = {};
let Dp = vd;
Y.handleByMap(G.RendererPlugin, Dp.__plugins);
Y.handleByMap(G.RendererSystem, Dp.__systems);
Y.add(Dp);
class Ax extends el {
    constructor(t, r) {
        const {width: i, height: n} = r || {};
        super(i, n),
        this.items = [],
        this.itemDirtyIds = [];
        for (let s = 0; s < t; s++) {
            const o = new nt;
            this.items.push(o),
            this.itemDirtyIds.push(-2)
        }
        this.length = t,
        this._load = null,
        this.baseTexture = null
    }
    initFromArray(t, r) {
        for (let i = 0; i < this.length; i++)
            t[i] && (t[i].castToBaseTexture ? this.addBaseTextureAt(t[i].castToBaseTexture(), i) : t[i]instanceof el ? this.addResourceAt(t[i], i) : this.addResourceAt(ex(t[i], r), i))
    }
    dispose() {
        for (let t = 0, r = this.length; t < r; t++)
            this.items[t].destroy();
        this.items = null,
        this.itemDirtyIds = null,
        this._load = null
    }
    addResourceAt(t, r) {
        if (!this.items[r])
            throw new Error(`Index ${r} is out of bounds`);
        return t.valid && !this.valid && this.resize(t.width, t.height),
        this.items[r].setResource(t),
        this
    }
    bind(t) {
        if (this.baseTexture !== null)
            throw new Error("Only one base texture per TextureArray is allowed");
        super.bind(t);
        for (let r = 0; r < this.length; r++)
            this.items[r].parentTextureArray = t,
            this.items[r].on("update", t.update, t)
    }
    unbind(t) {
        super.unbind(t);
        for (let r = 0; r < this.length; r++)
            this.items[r].parentTextureArray = null,
            this.items[r].off("update", t.update, t)
    }
    load() {
        if (this._load)
            return this._load;
        const t = this.items.map(r => r.resource).filter(r => r).map(r => r.load());
        return this._load = Promise.all(t).then( () => {
            const {realWidth: r, realHeight: i} = this.items[0];
            return this.resize(r, i),
            this.update(),
            Promise.resolve(this)
        }
        ),
        this._load
    }
}
class lR extends Ax {
    constructor(t, r) {
        const {width: i, height: n} = r || {};
        let s, o;
        Array.isArray(t) ? (s = t,
        o = t.length) : o = t,
        super(o, {
            width: i,
            height: n
        }),
        s && this.initFromArray(s, r)
    }
    addBaseTextureAt(t, r) {
        if (t.resource)
            this.addResourceAt(t.resource, r);
        else
            throw new Error("ArrayResource does not support RenderTexture");
        return this
    }
    bind(t) {
        super.bind(t),
        t.target = co.TEXTURE_2D_ARRAY
    }
    upload(t, r, i) {
        const {length: n, itemDirtyIds: s, items: o} = this
          , {gl: a} = t;
        i.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, i.internalFormat, this._width, this._height, n, 0, r.format, i.type, null);
        for (let l = 0; l < n; l++) {
            const h = o[l];
            s[l] < h.dirtyId && (s[l] = h.dirtyId,
            h.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, l, h.resource.width, h.resource.height, 1, r.format, i.type, h.resource.source))
        }
        return !0
    }
}
class hR extends Gn {
    constructor(t) {
        super(t)
    }
    static test(t) {
        const {OffscreenCanvas: r} = globalThis;
        return r && t instanceof r ? !0 : globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
    }
}
const uR = class Xl extends Ax {
    constructor(t, r) {
        const {width: i, height: n, autoLoad: s, linkBaseTexture: o} = r || {};
        if (t && t.length !== Xl.SIDES)
            throw new Error(`Invalid length. Got ${t.length}, expected 6`);
        super(6, {
            width: i,
            height: n
        });
        for (let a = 0; a < Xl.SIDES; a++)
            this.items[a].target = co.TEXTURE_CUBE_MAP_POSITIVE_X + a;
        this.linkBaseTexture = o !== !1,
        t && this.initFromArray(t, r),
        s !== !1 && this.load()
    }
    bind(t) {
        super.bind(t),
        t.target = co.TEXTURE_CUBE_MAP
    }
    addBaseTextureAt(t, r, i) {
        if (i === void 0 && (i = this.linkBaseTexture),
        !this.items[r])
            throw new Error(`Index ${r} is out of bounds`);
        if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0)
            if (t.resource)
                this.addResourceAt(t.resource, r);
            else
                throw new Error("CubeResource does not support copying of renderTexture.");
        else
            t.target = co.TEXTURE_CUBE_MAP_POSITIVE_X + r,
            t.parentTextureArray = this.baseTexture,
            this.items[r] = t;
        return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight),
        this.items[r] = t,
        this
    }
    upload(t, r, i) {
        const n = this.itemDirtyIds;
        for (let s = 0; s < Xl.SIDES; s++) {
            const o = this.items[s];
            (n[s] < o.dirtyId || i.dirtyId < r.dirtyId) && (o.valid && o.resource ? (o.resource.upload(t, o, i),
            n[s] = o.dirtyId) : n[s] < -1 && (t.gl.texImage2D(o.target, 0, i.internalFormat, r.realWidth, r.realHeight, 0, r.format, i.type, null),
            n[s] = -1))
        }
        return !0
    }
    static test(t) {
        return Array.isArray(t) && t.length === Xl.SIDES
    }
}
;
uR.SIDES = 6;
let cR = uR;
class ao extends Gn {
    constructor(t, r) {
        r = r || {};
        let i, n, s;
        typeof t == "string" ? (i = ao.EMPTY,
        n = t,
        s = !0) : (i = t,
        n = null,
        s = !1),
        super(i),
        this.url = n,
        this.crossOrigin = r.crossOrigin ?? !0,
        this.alphaMode = typeof r.alphaMode == "number" ? r.alphaMode : null,
        this.ownsImageBitmap = r.ownsImageBitmap ?? s,
        this._load = null,
        r.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(async (t, r) => {
            if (this.url === null) {
                t(this);
                return
            }
            try {
                const i = await z.ADAPTER.fetch(this.url, {
                    mode: this.crossOrigin ? "cors" : "no-cors"
                });
                if (this.destroyed)
                    return;
                const n = await i.blob();
                if (this.destroyed)
                    return;
                const s = await createImageBitmap(n, {
                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === tr.UNPACK ? "premultiply" : "none"
                });
                if (this.destroyed) {
                    s.close();
                    return
                }
                this.source = s,
                this.update(),
                t(this)
            } catch (i) {
                if (this.destroyed)
                    return;
                r(i),
                this.onError.emit(i)
            }
        }
        ),
        this._load)
    }
    upload(t, r, i) {
        return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (r.alphaMode = this.alphaMode),
        super.upload(t, r, i)) : (this.load(),
        !1)
    }
    dispose() {
        this.ownsImageBitmap && this.source instanceof ImageBitmap && this.source.close(),
        super.dispose(),
        this._load = null
    }
    static test(t) {
        return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof t == "string" || t instanceof ImageBitmap)
    }
    static get EMPTY() {
        return ao._EMPTY = ao._EMPTY ?? z.ADAPTER.createCanvas(0, 0),
        ao._EMPTY
    }
}
const E_ = class xd extends Gn {
    constructor(t, r) {
        r = r || {},
        super(z.ADAPTER.createCanvas()),
        this._width = 0,
        this._height = 0,
        this.svg = t,
        this.scale = r.scale || 1,
        this._overrideWidth = r.width,
        this._overrideHeight = r.height,
        this._resolve = null,
        this._crossorigin = r.crossorigin,
        this._load = null,
        r.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(t => {
            if (this._resolve = () => {
                this.update(),
                t(this)
            }
            ,
            xd.SVG_XML.test(this.svg.trim())) {
                if (!btoa)
                    throw new Error("Your browser doesn't support base64 conversions.");
                this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
            }
            this._loadSvg()
        }
        ),
        this._load)
    }
    _loadSvg() {
        const t = new Image;
        Gn.crossOrigin(t, this.svg, this._crossorigin),
        t.src = this.svg,
        t.onerror = r => {
            this._resolve && (t.onerror = null,
            this.onError.emit(r))
        }
        ,
        t.onload = () => {
            if (!this._resolve)
                return;
            const r = t.width
              , i = t.height;
            if (!r || !i)
                throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
            let n = r * this.scale
              , s = i * this.scale;
            (this._overrideWidth || this._overrideHeight) && (n = this._overrideWidth || this._overrideHeight / i * r,
            s = this._overrideHeight || this._overrideWidth / r * i),
            n = Math.round(n),
            s = Math.round(s);
            const o = this.source;
            o.width = n,
            o.height = s,
            o._pixiId = `canvas_${Is()}`,
            o.getContext("2d").drawImage(t, 0, 0, r, i, 0, 0, n, s),
            this._resolve(),
            this._resolve = null
        }
    }
    static getSize(t) {
        const r = xd.SVG_SIZE.exec(t)
          , i = {};
        return r && (i[r[1]] = Math.round(parseFloat(r[3])),
        i[r[5]] = Math.round(parseFloat(r[7]))),
        i
    }
    dispose() {
        super.dispose(),
        this._resolve = null,
        this._crossorigin = null
    }
    static test(t, r) {
        return r === "svg" || typeof t == "string" && t.startsWith("data:image/svg+xml") || typeof t == "string" && xd.SVG_XML.test(t)
    }
}
;
E_.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m,
E_.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
let vf = E_;
const T_ = class S_ extends Gn {
    constructor(t, r) {
        if (r = r || {},
        !(t instanceof HTMLVideoElement)) {
            const i = document.createElement("video");
            r.autoLoad !== !1 && i.setAttribute("preload", "auto"),
            r.playsinline !== !1 && (i.setAttribute("webkit-playsinline", ""),
            i.setAttribute("playsinline", "")),
            r.muted === !0 && (i.setAttribute("muted", ""),
            i.muted = !0),
            r.loop === !0 && i.setAttribute("loop", ""),
            r.autoPlay !== !1 && i.setAttribute("autoplay", ""),
            typeof t == "string" && (t = [t]);
            const n = t[0].src || t[0];
            Gn.crossOrigin(i, n, r.crossorigin);
            for (let s = 0; s < t.length; ++s) {
                const o = document.createElement("source");
                let {src: a, mime: l} = t[s];
                if (a = a || t[s],
                a.startsWith("data:"))
                    l = a.slice(5, a.indexOf(";"));
                else if (!a.startsWith("blob:")) {
                    const h = a.split("?").shift().toLowerCase()
                      , u = h.slice(h.lastIndexOf(".") + 1);
                    l = l || S_.MIME_TYPES[u] || `video/${u}`
                }
                o.src = a,
                l && (o.type = l),
                i.appendChild(o)
            }
            t = i
        }
        super(t),
        this.noSubImage = !0,
        this._autoUpdate = !0,
        this._isConnectedToTicker = !1,
        this._updateFPS = r.updateFPS || 0,
        this._msToNextUpdate = 0,
        this.autoPlay = r.autoPlay !== !1,
        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this),
        this._videoFrameRequestCallbackHandle = null,
        this._load = null,
        this._resolve = null,
        this._reject = null,
        this._onCanPlay = this._onCanPlay.bind(this),
        this._onError = this._onError.bind(this),
        this._onPlayStart = this._onPlayStart.bind(this),
        this._onPlayStop = this._onPlayStop.bind(this),
        this._onSeeked = this._onSeeked.bind(this),
        r.autoLoad !== !1 && this.load()
    }
    update(t=0) {
        if (!this.destroyed) {
            if (this._updateFPS) {
                const r = $t.shared.elapsedMS * this.source.playbackRate;
                this._msToNextUpdate = Math.floor(this._msToNextUpdate - r)
            }
            (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(),
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
        }
    }
    _videoFrameRequestCallback() {
        this.update(),
        this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(this._videoFrameRequestCallback)
    }
    load() {
        if (this._load)
            return this._load;
        const t = this.source;
        return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0),
        t.addEventListener("play", this._onPlayStart),
        t.addEventListener("pause", this._onPlayStop),
        t.addEventListener("seeked", this._onSeeked),
        this._isSourceReady() ? this._onCanPlay() : (t.addEventListener("canplay", this._onCanPlay),
        t.addEventListener("canplaythrough", this._onCanPlay),
        t.addEventListener("error", this._onError, !0)),
        this._load = new Promise( (r, i) => {
            this.valid ? r(this) : (this._resolve = r,
            this._reject = i,
            t.load())
        }
        ),
        this._load
    }
    _onError(t) {
        this.source.removeEventListener("error", this._onError, !0),
        this.onError.emit(t),
        this._reject && (this._reject(t),
        this._reject = null,
        this._resolve = null)
    }
    _isSourcePlaying() {
        const t = this.source;
        return !t.paused && !t.ended && this._isSourceReady()
    }
    _isSourceReady() {
        return this.source.readyState > 2
    }
    _onPlayStart() {
        this.valid || this._onCanPlay(),
        this._configureAutoUpdate()
    }
    _onPlayStop() {
        this._configureAutoUpdate()
    }
    _onSeeked() {
        this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0,
        this.update(),
        this._msToNextUpdate = 0)
    }
    _onCanPlay() {
        const t = this.source;
        t.removeEventListener("canplay", this._onCanPlay),
        t.removeEventListener("canplaythrough", this._onCanPlay);
        const r = this.valid;
        this._msToNextUpdate = 0,
        this.update(),
        this._msToNextUpdate = 0,
        !r && this._resolve && (this._resolve(this),
        this._resolve = null,
        this._reject = null),
        this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
    }
    dispose() {
        this._configureAutoUpdate();
        const t = this.source;
        t && (t.removeEventListener("play", this._onPlayStart),
        t.removeEventListener("pause", this._onPlayStop),
        t.removeEventListener("seeked", this._onSeeked),
        t.removeEventListener("canplay", this._onCanPlay),
        t.removeEventListener("canplaythrough", this._onCanPlay),
        t.removeEventListener("error", this._onError, !0),
        t.pause(),
        t.src = "",
        t.load()),
        super.dispose()
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        t !== this._autoUpdate && (this._autoUpdate = t,
        this._configureAutoUpdate())
    }
    get updateFPS() {
        return this._updateFPS
    }
    set updateFPS(t) {
        t !== this._updateFPS && (this._updateFPS = t,
        this._configureAutoUpdate())
    }
    _configureAutoUpdate() {
        this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && ($t.shared.remove(this.update, this),
        this._isConnectedToTicker = !1,
        this._msToNextUpdate = 0),
        this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
        this._videoFrameRequestCallbackHandle = null),
        this._isConnectedToTicker || ($t.shared.add(this.update, this),
        this._isConnectedToTicker = !0,
        this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
        this._videoFrameRequestCallbackHandle = null),
        this._isConnectedToTicker && ($t.shared.remove(this.update, this),
        this._isConnectedToTicker = !1,
        this._msToNextUpdate = 0))
    }
    static test(t, r) {
        return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || S_.TYPES.includes(r)
    }
}
;
T_.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"],
T_.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
};
let bx = T_;
mf.push(ao, sx, hR, bx, vf, Bu, cR, lR);
class bz {
    constructor() {
        this._glTransformFeedbacks = {},
        this.buffers = [],
        this.disposeRunner = new Nr("disposeTransformFeedback")
    }
    bindBuffer(t, r) {
        this.buffers[t] = r
    }
    destroy() {
        this.disposeRunner.emit(this, !1)
    }
}
const Cz = "7.3.1";
let Pz = 0;
const w_ = class extends ci {
    constructor(e) {
        super(),
        this.id = Pz++,
        this.init(e)
    }
    set(e, t) {
        if (this[e] === void 0)
            throw new Error(`Property with name ${e} does not exist.`);
        switch (e) {
        case "speed":
            this.speed = t;
            break;
        case "volume":
            this.volume = t;
            break;
        case "paused":
            this.paused = t;
            break;
        case "loop":
            this.loop = t;
            break;
        case "muted":
            this.muted = t;
            break
        }
        return this
    }
    get progress() {
        const {currentTime: e} = this._source;
        return e / this._duration
    }
    get paused() {
        return this._paused
    }
    set paused(e) {
        this._paused = e,
        this.refreshPaused()
    }
    _onPlay() {
        this._playing = !0
    }
    _onPause() {
        this._playing = !1
    }
    init(e) {
        this._playing = !1,
        this._duration = e.source.duration;
        const t = this._source = e.source.cloneNode(!1);
        t.src = e.parent.url,
        t.onplay = this._onPlay.bind(this),
        t.onpause = this._onPause.bind(this),
        e.context.on("refresh", this.refresh, this),
        e.context.on("refreshPaused", this.refreshPaused, this),
        this._media = e
    }
    _internalStop() {
        this._source && this._playing && (this._source.onended = null,
        this._source.pause())
    }
    stop() {
        this._internalStop(),
        this._source && this.emit("stop")
    }
    get speed() {
        return this._speed
    }
    set speed(e) {
        this._speed = e,
        this.refresh()
    }
    get volume() {
        return this._volume
    }
    set volume(e) {
        this._volume = e,
        this.refresh()
    }
    get loop() {
        return this._loop
    }
    set loop(e) {
        this._loop = e,
        this.refresh()
    }
    get muted() {
        return this._muted
    }
    set muted(e) {
        this._muted = e,
        this.refresh()
    }
    get filters() {
        return console.warn("HTML Audio does not support filters"),
        null
    }
    set filters(e) {
        console.warn("HTML Audio does not support filters")
    }
    refresh() {
        const e = this._media.context
          , t = this._media.parent;
        this._source.loop = this._loop || t.loop;
        const r = e.volume * (e.muted ? 0 : 1)
          , i = t.volume * (t.muted ? 0 : 1)
          , n = this._volume * (this._muted ? 0 : 1);
        this._source.volume = n * r * i,
        this._source.playbackRate = this._speed * e.speed * t.speed
    }
    refreshPaused() {
        const e = this._media.context
          , t = this._media.parent
          , r = this._paused || t.paused || e.paused;
        r !== this._pausedReal && (this._pausedReal = r,
        r ? (this._internalStop(),
        this.emit("paused")) : (this.emit("resumed"),
        this.play({
            start: this._source.currentTime,
            end: this._end,
            volume: this._volume,
            speed: this._speed,
            loop: this._loop
        })),
        this.emit("pause", r))
    }
    play(e) {
        const {start: t, end: r, speed: i, loop: n, volume: s, muted: o} = e;
        r && console.assert(r > t, "End time is before start time"),
        this._speed = i,
        this._volume = s,
        this._loop = !!n,
        this._muted = o,
        this.refresh(),
        this.loop && r !== null && (console.warn('Looping not support when specifying an "end" time'),
        this.loop = !1),
        this._start = t,
        this._end = r || this._duration,
        this._start = Math.max(0, this._start - w_.PADDING),
        this._end = Math.min(this._end + w_.PADDING, this._duration),
        this._source.onloadedmetadata = () => {
            this._source && (this._source.currentTime = t,
            this._source.onloadedmetadata = null,
            this.emit("progress", t, this._duration),
            $t.shared.add(this._onUpdate, this))
        }
        ,
        this._source.onended = this._onComplete.bind(this),
        this._source.play(),
        this.emit("start")
    }
    _onUpdate() {
        this.emit("progress", this.progress, this._duration),
        this._source.currentTime >= this._end && !this._source.loop && this._onComplete()
    }
    _onComplete() {
        $t.shared.remove(this._onUpdate, this),
        this._internalStop(),
        this.emit("progress", 1, this._duration),
        this.emit("end", this)
    }
    destroy() {
        $t.shared.remove(this._onUpdate, this),
        this.removeAllListeners();
        const e = this._source;
        e && (e.onended = null,
        e.onplay = null,
        e.onpause = null,
        this._internalStop()),
        this._source = null,
        this._speed = 1,
        this._volume = 1,
        this._loop = !1,
        this._end = null,
        this._start = 0,
        this._duration = 0,
        this._playing = !1,
        this._pausedReal = !1,
        this._paused = !1,
        this._muted = !1,
        this._media && (this._media.context.off("refresh", this.refresh, this),
        this._media.context.off("refreshPaused", this.refreshPaused, this),
        this._media = null)
    }
    toString() {
        return `[HTMLAudioInstance id=${this.id}]`
    }
}
;
let dR = w_;
dR.PADDING = .1;
class Iz extends ci {
    init(t) {
        this.parent = t,
        this._source = t.options.source || new Audio,
        t.url && (this._source.src = t.url)
    }
    create() {
        return new dR(this)
    }
    get isPlayable() {
        return !!this._source && this._source.readyState === 4
    }
    get duration() {
        return this._source.duration
    }
    get context() {
        return this.parent.context
    }
    get filters() {
        return null
    }
    set filters(t) {
        console.warn("HTML Audio does not support filters")
    }
    destroy() {
        this.removeAllListeners(),
        this.parent = null,
        this._source && (this._source.src = "",
        this._source.load(),
        this._source = null)
    }
    get source() {
        return this._source
    }
    load(t) {
        const r = this._source
          , i = this.parent;
        if (r.readyState === 4) {
            i.isLoaded = !0;
            const l = i.autoPlayStart();
            t && setTimeout( () => {
                t(null, i, l)
            }
            , 0);
            return
        }
        if (!i.url) {
            t(new Error("sound.url or sound.source must be set"));
            return
        }
        r.src = i.url;
        const n = () => {
            a(),
            i.isLoaded = !0;
            const l = i.autoPlayStart();
            t && t(null, i, l)
        }
          , s = () => {
            a(),
            t && t(new Error("Sound loading has been aborted"))
        }
          , o = () => {
            a();
            const l = `Failed to load audio element (code: ${r.error.code})`;
            t ? t(new Error(l)) : console.error(l)
        }
          , a = () => {
            r.removeEventListener("canplaythrough", n),
            r.removeEventListener("load", n),
            r.removeEventListener("abort", s),
            r.removeEventListener("error", o)
        }
        ;
        r.addEventListener("canplaythrough", n, !1),
        r.addEventListener("load", n, !1),
        r.addEventListener("abort", s, !1),
        r.addEventListener("error", o, !1),
        r.load()
    }
}
class Rz {
    constructor(t, r) {
        this.parent = t,
        Object.assign(this, r),
        this.duration = this.end - this.start,
        console.assert(this.duration > 0, "End time must be after start time")
    }
    play(t) {
        return this.parent.play({
            complete: t,
            speed: this.speed || this.parent.speed,
            end: this.end,
            start: this.start,
            loop: this.loop
        })
    }
    destroy() {
        this.parent = null
    }
}
const xf = ["ogg", "oga", "opus", "m4a", "mp3", "mpeg", "wav", "aiff", "wma", "mid", "caf"]
  , Mz = ["audio/mpeg", "audio/ogg"]
  , Ef = {};
function Oz(e) {
    const t = {
        m4a: "audio/mp4",
        oga: "audio/ogg",
        opus: 'audio/ogg; codecs="opus"',
        caf: 'audio/x-caf; codecs="opus"',
        ...e || {}
    }
      , r = document.createElement("audio")
      , i = {}
      , n = /^no$/;
    xf.forEach(s => {
        const o = r.canPlayType(`audio/${s}`).replace(n, "")
          , a = t[s] ? r.canPlayType(t[s]).replace(n, "") : "";
        i[s] = !!o || !!a
    }
    ),
    Object.assign(Ef, i)
}
Oz();
class A_ {
    static setParamValue(t, r) {
        if (t.setValueAtTime) {
            const i = Kh().context;
            t.setValueAtTime(r, i.audioContext.currentTime)
        } else
            t.value = r;
        return r
    }
}
let Nz = 0;
class Lz extends ci {
    constructor(t) {
        super(),
        this.id = Nz++,
        this._media = null,
        this._paused = !1,
        this._muted = !1,
        this._elapsed = 0,
        this.init(t)
    }
    set(t, r) {
        if (this[t] === void 0)
            throw new Error(`Property with name ${t} does not exist.`);
        switch (t) {
        case "speed":
            this.speed = r;
            break;
        case "volume":
            this.volume = r;
            break;
        case "muted":
            this.muted = r;
            break;
        case "loop":
            this.loop = r;
            break;
        case "paused":
            this.paused = r;
            break
        }
        return this
    }
    stop() {
        this._source && (this._internalStop(),
        this.emit("stop"))
    }
    get speed() {
        return this._speed
    }
    set speed(t) {
        this._speed = t,
        this.refresh(),
        this._update(!0)
    }
    get volume() {
        return this._volume
    }
    set volume(t) {
        this._volume = t,
        this.refresh()
    }
    get muted() {
        return this._muted
    }
    set muted(t) {
        this._muted = t,
        this.refresh()
    }
    get loop() {
        return this._loop
    }
    set loop(t) {
        this._loop = t,
        this.refresh()
    }
    get filters() {
        return this._filters
    }
    set filters(t) {
        this._filters && (this._filters?.filter(r => r).forEach(r => r.disconnect()),
        this._filters = null,
        this._source.connect(this._gain)),
        this._filters = t?.length ? t.slice(0) : null,
        this.refresh()
    }
    refresh() {
        if (!this._source)
            return;
        const t = this._media.context
          , r = this._media.parent;
        this._source.loop = this._loop || r.loop;
        const i = t.volume * (t.muted ? 0 : 1)
          , n = r.volume * (r.muted ? 0 : 1)
          , s = this._volume * (this._muted ? 0 : 1);
        A_.setParamValue(this._gain.gain, s * n * i),
        A_.setParamValue(this._source.playbackRate, this._speed * r.speed * t.speed),
        this.applyFilters()
    }
    applyFilters() {
        if (this._filters?.length) {
            this._source.disconnect();
            let t = this._source;
            this._filters.forEach(r => {
                t.connect(r.destination),
                t = r
            }
            ),
            t.connect(this._gain)
        }
    }
    refreshPaused() {
        const t = this._media.context
          , r = this._media.parent
          , i = this._paused || r.paused || t.paused;
        i !== this._pausedReal && (this._pausedReal = i,
        i ? (this._internalStop(),
        this.emit("paused")) : (this.emit("resumed"),
        this.play({
            start: this._elapsed % this._duration,
            end: this._end,
            speed: this._speed,
            loop: this._loop,
            volume: this._volume
        })),
        this.emit("pause", i))
    }
    play(t) {
        const {start: r, end: i, speed: n, loop: s, volume: o, muted: a, filters: l} = t;
        i && console.assert(i > r, "End time is before start time"),
        this._paused = !1;
        const {source: h, gain: u} = this._media.nodes.cloneBufferSource();
        this._source = h,
        this._gain = u,
        this._speed = n,
        this._volume = o,
        this._loop = !!s,
        this._muted = a,
        this._filters = l,
        this.refresh();
        const c = this._source.buffer.duration;
        this._duration = c,
        this._end = i,
        this._lastUpdate = this._now(),
        this._elapsed = r,
        this._source.onended = this._onComplete.bind(this),
        this._loop ? (this._source.loopEnd = i,
        this._source.loopStart = r,
        this._source.start(0, r)) : i ? this._source.start(0, r, i - r) : this._source.start(0, r),
        this.emit("start"),
        this._update(!0),
        this.enableTicker(!0)
    }
    enableTicker(t) {
        $t.shared.remove(this._updateListener, this),
        t && $t.shared.add(this._updateListener, this)
    }
    get progress() {
        return this._progress
    }
    get paused() {
        return this._paused
    }
    set paused(t) {
        this._paused = t,
        this.refreshPaused()
    }
    destroy() {
        this.removeAllListeners(),
        this._internalStop(),
        this._gain && (this._gain.disconnect(),
        this._gain = null),
        this._media && (this._media.context.events.off("refresh", this.refresh, this),
        this._media.context.events.off("refreshPaused", this.refreshPaused, this),
        this._media = null),
        this._filters?.forEach(t => t.disconnect()),
        this._filters = null,
        this._end = null,
        this._speed = 1,
        this._volume = 1,
        this._loop = !1,
        this._elapsed = 0,
        this._duration = 0,
        this._paused = !1,
        this._muted = !1,
        this._pausedReal = !1
    }
    toString() {
        return `[WebAudioInstance id=${this.id}]`
    }
    _now() {
        return this._media.context.audioContext.currentTime
    }
    _updateListener() {
        this._update()
    }
    _update(t=!1) {
        if (this._source) {
            const r = this._now()
              , i = r - this._lastUpdate;
            if (i > 0 || t) {
                const n = this._source.playbackRate.value;
                this._elapsed += i * n,
                this._lastUpdate = r;
                const s = this._duration;
                let o;
                if (this._source.loopStart) {
                    const a = this._source.loopEnd - this._source.loopStart;
                    o = (this._source.loopStart + this._elapsed % a) / s
                } else
                    o = this._elapsed % s / s;
                this._progress = o,
                this.emit("progress", this._progress, s)
            }
        }
    }
    init(t) {
        this._media = t,
        t.context.events.on("refresh", this.refresh, this),
        t.context.events.on("refreshPaused", this.refreshPaused, this)
    }
    _internalStop() {
        if (this._source) {
            this.enableTicker(!1),
            this._source.onended = null,
            this._source.stop(0),
            this._source.disconnect();
            try {
                this._source.buffer = null
            } catch (t) {
                console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t)
            }
            this._source = null
        }
    }
    _onComplete() {
        if (this._source) {
            this.enableTicker(!1),
            this._source.onended = null,
            this._source.disconnect();
            try {
                this._source.buffer = null
            } catch (t) {
                console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t)
            }
        }
        this._source = null,
        this._progress = 1,
        this.emit("progress", 1, this._duration),
        this.emit("end", this)
    }
}
class fR {
    constructor(t, r) {
        this._output = r,
        this._input = t
    }
    get destination() {
        return this._input
    }
    get filters() {
        return this._filters
    }
    set filters(t) {
        if (this._filters && (this._filters.forEach(r => {
            r && r.disconnect()
        }
        ),
        this._filters = null,
        this._input.connect(this._output)),
        t && t.length) {
            this._filters = t.slice(0),
            this._input.disconnect();
            let r = null;
            t.forEach(i => {
                r === null ? this._input.connect(i.destination) : r.connect(i.destination),
                r = i
            }
            ),
            r.connect(this._output)
        }
    }
    destroy() {
        this.filters = null,
        this._input = null,
        this._output = null
    }
}
const pR = class extends fR {
    constructor(e) {
        const t = e.audioContext
          , r = t.createBufferSource()
          , i = t.createGain()
          , n = t.createAnalyser();
        r.connect(n),
        n.connect(i),
        i.connect(e.destination),
        super(n, i),
        this.context = e,
        this.bufferSource = r,
        this.gain = i,
        this.analyser = n
    }
    get script() {
        return this._script || (this._script = this.context.audioContext.createScriptProcessor(pR.BUFFER_SIZE),
        this._script.connect(this.context.destination)),
        this._script
    }
    destroy() {
        super.destroy(),
        this.bufferSource.disconnect(),
        this._script && this._script.disconnect(),
        this.gain.disconnect(),
        this.analyser.disconnect(),
        this.bufferSource = null,
        this._script = null,
        this.gain = null,
        this.analyser = null,
        this.context = null
    }
    cloneBufferSource() {
        const e = this.bufferSource
          , t = this.context.audioContext.createBufferSource();
        t.buffer = e.buffer,
        A_.setParamValue(t.playbackRate, e.playbackRate.value),
        t.loop = e.loop;
        const r = this.context.audioContext.createGain();
        return t.connect(r),
        r.connect(this.destination),
        {
            source: t,
            gain: r
        }
    }
    get bufferSize() {
        return this.script.bufferSize
    }
}
;
let mR = pR;
mR.BUFFER_SIZE = 0;
class Dz {
    init(t) {
        this.parent = t,
        this._nodes = new mR(this.context),
        this._source = this._nodes.bufferSource,
        this.source = t.options.source
    }
    destroy() {
        this.parent = null,
        this._nodes.destroy(),
        this._nodes = null;
        try {
            this._source.buffer = null
        } catch (t) {
            console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t)
        }
        this._source = null,
        this.source = null
    }
    create() {
        return new Lz(this)
    }
    get context() {
        return this.parent.context
    }
    get isPlayable() {
        return !!this._source && !!this._source.buffer
    }
    get filters() {
        return this._nodes.filters
    }
    set filters(t) {
        this._nodes.filters = t
    }
    get duration() {
        return console.assert(this.isPlayable, "Sound not yet playable, no duration"),
        this._source.buffer.duration
    }
    get buffer() {
        return this._source.buffer
    }
    set buffer(t) {
        this._source.buffer = t
    }
    get nodes() {
        return this._nodes
    }
    load(t) {
        this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t ? t(new Error("sound.url or sound.source must be set")) : console.error("sound.url or sound.source must be set")
    }
    async _loadUrl(t) {
        const r = this.parent.url
          , i = await z.ADAPTER.fetch(r);
        this._decode(await i.arrayBuffer(), t)
    }
    _decode(t, r) {
        const i = (n, s) => {
            if (n)
                r && r(n);
            else {
                this.parent.isLoaded = !0,
                this.buffer = s;
                const o = this.parent.autoPlayStart();
                r && r(null, this.parent, o)
            }
        }
        ;
        t instanceof AudioBuffer ? i(null, t) : this.parent.context.decode(t, i)
    }
}
const na = class {
    static from(e) {
        let t = {};
        typeof e == "string" ? t.url = e : e instanceof ArrayBuffer || e instanceof AudioBuffer || e instanceof HTMLAudioElement ? t.source = e : Array.isArray(e) ? t.url = e : t = e,
        t = {
            autoPlay: !1,
            singleInstance: !1,
            url: null,
            source: null,
            preload: !1,
            volume: 1,
            speed: 1,
            complete: null,
            loaded: null,
            loop: !1,
            ...t
        },
        Object.freeze(t);
        const r = Kh().useLegacy ? new Iz : new Dz;
        return new na(r,t)
    }
    constructor(e, t) {
        this.media = e,
        this.options = t,
        this._instances = [],
        this._sprites = {},
        this.media.init(this);
        const r = t.complete;
        this._autoPlayOptions = r ? {
            complete: r
        } : null,
        this.isLoaded = !1,
        this._preloadQueue = null,
        this.isPlaying = !1,
        this.autoPlay = t.autoPlay,
        this.singleInstance = t.singleInstance,
        this.preload = t.preload || this.autoPlay,
        this.url = Array.isArray(t.url) ? this.preferUrl(t.url) : t.url,
        this.speed = t.speed,
        this.volume = t.volume,
        this.loop = t.loop,
        t.sprites && this.addSprites(t.sprites),
        this.preload && this._preload(t.loaded)
    }
    preferUrl(e) {
        const [t] = e.map(r => ({
            url: r,
            ext: fe.extname(r).slice(1)
        })).filter( ({ext: r}) => Ef[r]).sort( (r, i) => xf.indexOf(r.ext) - xf.indexOf(i.ext));
        if (!t)
            throw new Error("No supported file type found");
        return t.url
    }
    get context() {
        return Kh().context
    }
    pause() {
        return this.isPlaying = !1,
        this.paused = !0,
        this
    }
    resume() {
        return this.isPlaying = this._instances.length > 0,
        this.paused = !1,
        this
    }
    get paused() {
        return this._paused
    }
    set paused(e) {
        this._paused = e,
        this.refreshPaused()
    }
    get speed() {
        return this._speed
    }
    set speed(e) {
        this._speed = e,
        this.refresh()
    }
    get filters() {
        return this.media.filters
    }
    set filters(e) {
        this.media.filters = e
    }
    addSprites(e, t) {
        if (typeof e == "object") {
            const i = {};
            for (const n in e)
                i[n] = this.addSprites(n, e[n]);
            return i
        }
        console.assert(!this._sprites[e], `Alias ${e} is already taken`);
        const r = new Rz(this,t);
        return this._sprites[e] = r,
        r
    }
    destroy() {
        this._removeInstances(),
        this.removeSprites(),
        this.media.destroy(),
        this.media = null,
        this._sprites = null,
        this._instances = null
    }
    removeSprites(e) {
        if (e) {
            const t = this._sprites[e];
            t !== void 0 && (t.destroy(),
            delete this._sprites[e])
        } else
            for (const t in this._sprites)
                this.removeSprites(t);
        return this
    }
    get isPlayable() {
        return this.isLoaded && this.media && this.media.isPlayable
    }
    stop() {
        if (!this.isPlayable)
            return this.autoPlay = !1,
            this._autoPlayOptions = null,
            this;
        this.isPlaying = !1;
        for (let e = this._instances.length - 1; e >= 0; e--)
            this._instances[e].stop();
        return this
    }
    play(e, t) {
        let r;
        if (typeof e == "string" ? r = {
            sprite: e,
            loop: this.loop,
            complete: t
        } : typeof e == "function" ? (r = {},
        r.complete = e) : r = e,
        r = {
            complete: null,
            loaded: null,
            sprite: null,
            end: null,
            start: 0,
            volume: 1,
            speed: 1,
            muted: !1,
            loop: !1,
            ...r || {}
        },
        r.sprite) {
            const n = r.sprite;
            console.assert(!!this._sprites[n], `Alias ${n} is not available`);
            const s = this._sprites[n];
            r.start = s.start + (r.start || 0),
            r.end = s.end,
            r.speed = s.speed || 1,
            r.loop = s.loop || r.loop,
            delete r.sprite
        }
        if (r.offset && (r.start = r.offset),
        !this.isLoaded)
            return this._preloadQueue ? new Promise(n => {
                this._preloadQueue.push( () => {
                    n(this.play(r))
                }
                )
            }
            ) : (this._preloadQueue = [],
            this.autoPlay = !0,
            this._autoPlayOptions = r,
            new Promise( (n, s) => {
                this._preload( (o, a, l) => {
                    this._preloadQueue.forEach(h => h()),
                    this._preloadQueue = null,
                    o ? s(o) : (r.loaded && r.loaded(o, a, l),
                    n(l))
                }
                )
            }
            ));
        (this.singleInstance || r.singleInstance) && this._removeInstances();
        const i = this._createInstance();
        return this._instances.push(i),
        this.isPlaying = !0,
        i.once("end", () => {
            r.complete && r.complete(this),
            this._onComplete(i)
        }
        ),
        i.once("stop", () => {
            this._onComplete(i)
        }
        ),
        i.play(r),
        i
    }
    refresh() {
        const e = this._instances.length;
        for (let t = 0; t < e; t++)
            this._instances[t].refresh()
    }
    refreshPaused() {
        const e = this._instances.length;
        for (let t = 0; t < e; t++)
            this._instances[t].refreshPaused()
    }
    get volume() {
        return this._volume
    }
    set volume(e) {
        this._volume = e,
        this.refresh()
    }
    get muted() {
        return this._muted
    }
    set muted(e) {
        this._muted = e,
        this.refresh()
    }
    get loop() {
        return this._loop
    }
    set loop(e) {
        this._loop = e,
        this.refresh()
    }
    _preload(e) {
        this.media.load(e)
    }
    get instances() {
        return this._instances
    }
    get sprites() {
        return this._sprites
    }
    get duration() {
        return this.media.duration
    }
    autoPlayStart() {
        let e;
        return this.autoPlay && (e = this.play(this._autoPlayOptions)),
        e
    }
    _removeInstances() {
        for (let e = this._instances.length - 1; e >= 0; e--)
            this._poolInstance(this._instances[e]);
        this._instances.length = 0
    }
    _onComplete(e) {
        if (this._instances) {
            const t = this._instances.indexOf(e);
            t > -1 && this._instances.splice(t, 1),
            this.isPlaying = this._instances.length > 0
        }
        this._poolInstance(e)
    }
    _createInstance() {
        if (na._pool.length > 0) {
            const e = na._pool.pop();
            return e.init(this.media),
            e
        }
        return this.media.create()
    }
    _poolInstance(e) {
        e.destroy(),
        na._pool.indexOf(e) < 0 && na._pool.push(e)
    }
}
;
let Tf = na;
Tf._pool = [];
class Bz extends ci {
    constructor() {
        super(...arguments),
        this.speed = 1,
        this.muted = !1,
        this.volume = 1,
        this.paused = !1
    }
    refresh() {
        this.emit("refresh")
    }
    refreshPaused() {
        this.emit("refreshPaused")
    }
    get filters() {
        return console.warn("HTML Audio does not support filters"),
        null
    }
    set filters(t) {
        console.warn("HTML Audio does not support filters")
    }
    get audioContext() {
        return console.warn("HTML Audio does not support audioContext"),
        null
    }
    toggleMute() {
        return this.muted = !this.muted,
        this.refresh(),
        this.muted
    }
    togglePause() {
        return this.paused = !this.paused,
        this.refreshPaused(),
        this.paused
    }
    destroy() {
        this.removeAllListeners()
    }
}
class ou extends fR {
    constructor() {
        const t = window
          , r = new ou.AudioContext
          , i = r.createDynamicsCompressor()
          , n = r.createAnalyser();
        n.connect(i),
        i.connect(r.destination),
        super(n, i),
        this.autoPause = !0,
        this._ctx = r,
        this._offlineCtx = new ou.OfflineAudioContext(1,2,t.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, r.sampleRate)) : 44100),
        this.compressor = i,
        this.analyser = n,
        this.events = new ci,
        this.volume = 1,
        this.speed = 1,
        this.muted = !1,
        this.paused = !1,
        this._locked = r.state === "suspended" && ("ontouchstart"in globalThis || "onclick"in globalThis),
        this._locked && (this._unlock(),
        this._unlock = this._unlock.bind(this),
        document.addEventListener("mousedown", this._unlock, !0),
        document.addEventListener("touchstart", this._unlock, !0),
        document.addEventListener("touchend", this._unlock, !0)),
        this.onFocus = this.onFocus.bind(this),
        this.onBlur = this.onBlur.bind(this),
        globalThis.addEventListener("focus", this.onFocus),
        globalThis.addEventListener("blur", this.onBlur)
    }
    onFocus() {
        if (!this.autoPause)
            return;
        const t = this._ctx.state;
        (t === "suspended" || t === "interrupted" || !this._locked) && (this.paused = this._pausedOnBlur,
        this.refreshPaused())
    }
    onBlur() {
        this.autoPause && (this._locked || (this._pausedOnBlur = this._paused,
        this.paused = !0,
        this.refreshPaused()))
    }
    _unlock() {
        this._locked && (this.playEmptySound(),
        this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, !0),
        document.removeEventListener("touchend", this._unlock, !0),
        document.removeEventListener("touchstart", this._unlock, !0),
        this._locked = !1))
    }
    playEmptySound() {
        const t = this._ctx.createBufferSource();
        t.buffer = this._ctx.createBuffer(1, 1, 22050),
        t.connect(this._ctx.destination),
        t.start(0, 0, 0),
        t.context.state === "suspended" && t.context.resume()
    }
    static get AudioContext() {
        const t = window;
        return t.AudioContext || t.webkitAudioContext || null
    }
    static get OfflineAudioContext() {
        const t = window;
        return t.OfflineAudioContext || t.webkitOfflineAudioContext || null
    }
    destroy() {
        super.destroy();
        const t = this._ctx;
        typeof t.close < "u" && t.close(),
        globalThis.removeEventListener("focus", this.onFocus),
        globalThis.removeEventListener("blur", this.onBlur),
        this.events.removeAllListeners(),
        this.analyser.disconnect(),
        this.compressor.disconnect(),
        this.analyser = null,
        this.compressor = null,
        this.events = null,
        this._offlineCtx = null,
        this._ctx = null
    }
    get audioContext() {
        return this._ctx
    }
    get offlineContext() {
        return this._offlineCtx
    }
    set paused(t) {
        t && this._ctx.state === "running" ? this._ctx.suspend() : !t && this._ctx.state === "suspended" && this._ctx.resume(),
        this._paused = t
    }
    get paused() {
        return this._paused
    }
    refresh() {
        this.events.emit("refresh")
    }
    refreshPaused() {
        this.events.emit("refreshPaused")
    }
    toggleMute() {
        return this.muted = !this.muted,
        this.refresh(),
        this.muted
    }
    togglePause() {
        return this.paused = !this.paused,
        this.refreshPaused(),
        this._paused
    }
    decode(t, r) {
        const i = s => {
            r(new Error(s?.message || "Unable to decode file"))
        }
          , n = this._offlineCtx.decodeAudioData(t, s => {
            r(null, s)
        }
        , i);
        n && n.catch(i)
    }
}
class kz {
    constructor() {
        this.init()
    }
    init() {
        return this.supported && (this._webAudioContext = new ou),
        this._htmlAudioContext = new Bz,
        this._sounds = {},
        this.useLegacy = !this.supported,
        this
    }
    get context() {
        return this._context
    }
    get filtersAll() {
        return this.useLegacy ? [] : this._context.filters
    }
    set filtersAll(t) {
        this.useLegacy || (this._context.filters = t)
    }
    get supported() {
        return ou.AudioContext !== null
    }
    add(t, r) {
        if (typeof t == "object") {
            const s = {};
            for (const o in t) {
                const a = this._getOptions(t[o], r);
                s[o] = this.add(o, a)
            }
            return s
        }
        if (console.assert(!this._sounds[t], `Sound with alias ${t} already exists.`),
        r instanceof Tf)
            return this._sounds[t] = r,
            r;
        const i = this._getOptions(r)
          , n = Tf.from(i);
        return this._sounds[t] = n,
        n
    }
    _getOptions(t, r) {
        let i;
        return typeof t == "string" ? i = {
            url: t
        } : Array.isArray(t) ? i = {
            url: t
        } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? i = {
            source: t
        } : i = t,
        i = {
            ...i,
            ...r || {}
        },
        i
    }
    get useLegacy() {
        return this._useLegacy
    }
    set useLegacy(t) {
        this._useLegacy = t,
        this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext
    }
    get disableAutoPause() {
        return !this._webAudioContext.autoPause
    }
    set disableAutoPause(t) {
        this._webAudioContext.autoPause = !t
    }
    remove(t) {
        return this.exists(t, !0),
        this._sounds[t].destroy(),
        delete this._sounds[t],
        this
    }
    get volumeAll() {
        return this._context.volume
    }
    set volumeAll(t) {
        this._context.volume = t,
        this._context.refresh()
    }
    get speedAll() {
        return this._context.speed
    }
    set speedAll(t) {
        this._context.speed = t,
        this._context.refresh()
    }
    togglePauseAll() {
        return this._context.togglePause()
    }
    pauseAll() {
        return this._context.paused = !0,
        this._context.refreshPaused(),
        this
    }
    resumeAll() {
        return this._context.paused = !1,
        this._context.refreshPaused(),
        this
    }
    toggleMuteAll() {
        return this._context.toggleMute()
    }
    muteAll() {
        return this._context.muted = !0,
        this._context.refresh(),
        this
    }
    unmuteAll() {
        return this._context.muted = !1,
        this._context.refresh(),
        this
    }
    removeAll() {
        for (const t in this._sounds)
            this._sounds[t].destroy(),
            delete this._sounds[t];
        return this
    }
    stopAll() {
        for (const t in this._sounds)
            this._sounds[t].stop();
        return this
    }
    exists(t, r=!1) {
        const i = !!this._sounds[t];
        return r && console.assert(i, `No sound matching alias '${t}'.`),
        i
    }
    isPlaying() {
        for (const t in this._sounds)
            if (this._sounds[t].isPlaying)
                return !0;
        return !1
    }
    find(t) {
        return this.exists(t, !0),
        this._sounds[t]
    }
    play(t, r) {
        return this.find(t).play(r)
    }
    stop(t) {
        return this.find(t).stop()
    }
    pause(t) {
        return this.find(t).pause()
    }
    resume(t) {
        return this.find(t).resume()
    }
    volume(t, r) {
        const i = this.find(t);
        return r !== void 0 && (i.volume = r),
        i.volume
    }
    speed(t, r) {
        const i = this.find(t);
        return r !== void 0 && (i.speed = r),
        i.speed
    }
    duration(t) {
        return this.find(t).duration
    }
    close() {
        return this.removeAll(),
        this._sounds = null,
        this._webAudioContext && (this._webAudioContext.destroy(),
        this._webAudioContext = null),
        this._htmlAudioContext && (this._htmlAudioContext.destroy(),
        this._htmlAudioContext = null),
        this._context = null,
        this
    }
}
const HS = {
    loader: G.LoadParser,
    resolver: G.ResolveParser,
    cache: G.CacheParser,
    detection: G.DetectionParser
};
Y.handle(G.Asset, e => {
    const t = e.ref;
    Object.entries(HS).filter( ([r]) => !!t[r]).forEach( ([r,i]) => Y.add(Object.assign(t[r], {
        extension: t[r].extension ?? i
    })))
}
, e => {
    const t = e.ref;
    Object.keys(HS).filter(r => !!t[r]).forEach(r => Y.remove(t[r]))
}
);
class Fz {
    constructor(t, r=!1) {
        this._loader = t,
        this._assetList = [],
        this._isLoading = !1,
        this._maxConcurrent = 1,
        this.verbose = r
    }
    add(t) {
        t.forEach(r => {
            this._assetList.push(r)
        }
        ),
        this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList),
        this._isActive && !this._isLoading && this._next()
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const t = []
              , r = Math.min(this._assetList.length, this._maxConcurrent);
            for (let i = 0; i < r; i++)
                t.push(this._assetList.pop());
            await this._loader.load(t),
            this._isLoading = !1,
            this._next()
        }
    }
    get active() {
        return this._isActive
    }
    set active(t) {
        this._isActive !== t && (this._isActive = t,
        t && !this._isLoading && this._next())
    }
}
function Ho(e, t) {
    if (Array.isArray(t)) {
        for (const r of t)
            if (e.startsWith(`data:${r}`))
                return !0;
        return !1
    }
    return e.startsWith(`data:${t}`)
}
function Xn(e, t) {
    const r = e.split("?")[0]
      , i = fe.extname(r).toLowerCase();
    return Array.isArray(t) ? t.includes(i) : i === t
}
const qr = (e, t, r=!1) => (Array.isArray(e) || (e = [e]),
t ? e.map(i => typeof i == "string" || r ? t(i) : i) : e)
  , Sf = (e, t) => {
    const r = t.split("?")[1];
    return r && (e += `?${r}`),
    e
}
;
function gR(e, t, r, i, n) {
    const s = t[r];
    for (let o = 0; o < s.length; o++) {
        const a = s[o];
        r < t.length - 1 ? gR(e.replace(i[r], a), t, r + 1, i, n) : n.push(e.replace(i[r], a))
    }
}
function _R(e) {
    const t = /\{(.*?)\}/g
      , r = e.match(t)
      , i = [];
    if (r) {
        const n = [];
        r.forEach(s => {
            const o = s.substring(1, s.length - 1).split(",");
            n.push(o)
        }
        ),
        gR(e, n, 0, r, i)
    } else
        i.push(e);
    return i
}
const au = e => !Array.isArray(e);
class Uz {
    constructor() {
        this._parsers = [],
        this._cache = new Map,
        this._cacheMap = new Map
    }
    reset() {
        this._cacheMap.clear(),
        this._cache.clear()
    }
    has(t) {
        return this._cache.has(t)
    }
    get(t) {
        const r = this._cache.get(t);
        return r || console.warn(`[Assets] Asset id ${t} was not found in the Cache`),
        r
    }
    set(t, r) {
        const i = qr(t);
        let n;
        for (let a = 0; a < this.parsers.length; a++) {
            const l = this.parsers[a];
            if (l.test(r)) {
                n = l.getCacheableAssets(i, r);
                break
            }
        }
        n || (n = {},
        i.forEach(a => {
            n[a] = r
        }
        ));
        const s = Object.keys(n)
          , o = {
            cacheKeys: s,
            keys: i
        };
        if (i.forEach(a => {
            this._cacheMap.set(a, o)
        }
        ),
        s.forEach(a => {
            this._cache.has(a) && this._cache.get(a) !== r && console.warn("[Cache] already has key:", a),
            this._cache.set(a, n[a])
        }
        ),
        r instanceof F) {
            const a = r;
            i.forEach(l => {
                a.baseTexture !== F.EMPTY.baseTexture && nt.addToCache(a.baseTexture, l),
                F.addToCache(a, l)
            }
            )
        }
    }
    remove(t) {
        if (!this._cacheMap.has(t)) {
            console.warn(`[Assets] Asset id ${t} was not found in the Cache`);
            return
        }
        const r = this._cacheMap.get(t);
        r.cacheKeys.forEach(i => {
            this._cache.delete(i)
        }
        ),
        r.keys.forEach(i => {
            this._cacheMap.delete(i)
        }
        )
    }
    get parsers() {
        return this._parsers
    }
}
const ss = new Uz;
class Gz {
    constructor() {
        this._parsers = [],
        this._parsersValidated = !1,
        this.parsers = new Proxy(this._parsers,{
            set: (t, r, i) => (this._parsersValidated = !1,
            t[r] = i,
            !0)
        }),
        this.promiseCache = {}
    }
    reset() {
        this._parsersValidated = !1,
        this.promiseCache = {}
    }
    _getLoadPromiseAndParser(t, r) {
        const i = {
            promise: null,
            parser: null
        };
        return i.promise = (async () => {
            let n = null
              , s = null;
            if (r.loadParser && (s = this._parserHash[r.loadParser],
            s || console.warn(`[Assets] specified load parser "${r.loadParser}" not found while loading ${t}`)),
            !s) {
                for (let o = 0; o < this.parsers.length; o++) {
                    const a = this.parsers[o];
                    if (a.load && a.test?.(t, r, this)) {
                        s = a;
                        break
                    }
                }
                if (!s)
                    return console.warn(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),
                    null
            }
            n = await s.load(t, r, this),
            i.parser = s;
            for (let o = 0; o < this.parsers.length; o++) {
                const a = this.parsers[o];
                a.parse && a.parse && await a.testParse?.(n, r, this) && (n = await a.parse(n, r, this) || n,
                i.parser = a)
            }
            return n
        }
        )(),
        i
    }
    async load(t, r) {
        this._parsersValidated || this._validateParsers();
        let i = 0;
        const n = {}
          , s = au(t)
          , o = qr(t, h => ({
            alias: [h],
            src: h
        }))
          , a = o.length
          , l = o.map(async h => {
            const u = fe.toAbsolute(h.src);
            if (!n[h.src])
                try {
                    this.promiseCache[u] || (this.promiseCache[u] = this._getLoadPromiseAndParser(u, h)),
                    n[h.src] = await this.promiseCache[u].promise,
                    r && r(++i / a)
                } catch (c) {
                    throw delete this.promiseCache[u],
                    delete n[h.src],
                    new Error(`[Loader.load] Failed to load ${u}.
${c}`)
                }
        }
        );
        return await Promise.all(l),
        s ? n[o[0].src] : n
    }
    async unload(t) {
        const r = qr(t, i => ({
            alias: [i],
            src: i
        })).map(async i => {
            const n = fe.toAbsolute(i.src)
              , s = this.promiseCache[n];
            if (s) {
                const o = await s.promise;
                delete this.promiseCache[n],
                s.parser?.unload?.(o, i, this)
            }
        }
        );
        await Promise.all(r)
    }
    _validateParsers() {
        this._parsersValidated = !0,
        this._parserHash = this._parsers.filter(t => t.name).reduce( (t, r) => (t[r.name] && console.warn(`[Assets] loadParser name conflict "${r.name}"`),
        {
            ...t,
            [r.name]: r
        }), {})
    }
}
var Gr = (e => (e[e.Low = 0] = "Low",
e[e.Normal = 1] = "Normal",
e[e.High = 2] = "High",
e))(Gr || {});
const Hz = ".json"
  , $z = "application/json"
  , yR = {
    extension: {
        type: G.LoadParser,
        priority: Gr.Low
    },
    name: "loadJson",
    test(e) {
        return Ho(e, $z) || Xn(e, Hz)
    },
    async load(e) {
        return await (await z.ADAPTER.fetch(e)).json()
    }
};
Y.add(yR);
const zz = ".txt"
  , Wz = "text/plain"
  , vR = {
    name: "loadTxt",
    extension: {
        type: G.LoadParser,
        priority: Gr.Low
    },
    test(e) {
        return Ho(e, Wz) || Xn(e, zz)
    },
    async load(e) {
        return await (await z.ADAPTER.fetch(e)).text()
    }
};
Y.add(vR);
const Vz = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
  , jz = [".ttf", ".otf", ".woff", ".woff2"]
  , Xz = ["font/ttf", "font/otf", "font/woff", "font/woff2"]
  , Yz = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function xR(e) {
    const t = fe.extname(e)
      , r = fe.basename(e, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(s => s.charAt(0).toUpperCase() + s.slice(1));
    let i = r.length > 0;
    for (const s of r)
        if (!s.match(Yz)) {
            i = !1;
            break
        }
    let n = r.join(" ");
    return i || (n = `"${n.replace(/[\\"]/g, "\\$&")}"`),
    n
}
const ER = {
    extension: {
        type: G.LoadParser,
        priority: Gr.Low
    },
    name: "loadWebFont",
    test(e) {
        return Ho(e, Xz) || Xn(e, jz)
    },
    async load(e, t) {
        const r = z.ADAPTER.getFontFaceSet();
        if (r) {
            const i = []
              , n = t.data?.family ?? xR(e)
              , s = t.data?.weights?.filter(a => Vz.includes(a)) ?? ["normal"]
              , o = t.data ?? {};
            for (let a = 0; a < s.length; a++) {
                const l = s[a]
                  , h = new FontFace(n,`url(${encodeURI(e)})`,{
                    ...o,
                    weight: l
                });
                await h.load(),
                r.add(h),
                i.push(h)
            }
            return i.length === 1 ? i[0] : i
        }
        return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"),
        null
    },
    unload(e) {
        (Array.isArray(e) ? e : [e]).forEach(t => z.ADAPTER.getFontFaceSet().delete(t))
    }
};
Y.add(ER);
let $S = 0, og;
const Kz = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII="
  , qz = {
    id: "checkImageBitmap",
    code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${Kz}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
}
  , Zz = {
    id: "loadImageBitmap",
    code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
};
let ag;
class Qz {
    constructor() {
        this._initialized = !1,
        this._createdWorkers = 0,
        this.workerPool = [],
        this.queue = [],
        this.resolveHash = {}
    }
    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(t => {
            const r = URL.createObjectURL(new Blob([qz.code],{
                type: "application/javascript"
            }))
              , i = new Worker(r);
            i.addEventListener("message", n => {
                i.terminate(),
                URL.revokeObjectURL(r),
                t(n.data)
            }
            )
        }
        ),
        this._isImageBitmapSupported)
    }
    loadImageBitmap(t) {
        return this._run("loadImageBitmap", [t])
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }
    getWorker() {
        og === void 0 && (og = navigator.hardwareConcurrency || 4);
        let t = this.workerPool.pop();
        return !t && this._createdWorkers < og && (ag || (ag = URL.createObjectURL(new Blob([Zz.code],{
            type: "application/javascript"
        }))),
        this._createdWorkers++,
        t = new Worker(ag),
        t.addEventListener("message", r => {
            this.complete(r.data),
            this.returnWorker(r.target),
            this.next()
        }
        )),
        t
    }
    returnWorker(t) {
        this.workerPool.push(t)
    }
    complete(t) {
        t.error !== void 0 ? this.resolveHash[t.uuid].reject(t.error) : this.resolveHash[t.uuid].resolve(t.data),
        this.resolveHash[t.uuid] = null
    }
    async _run(t, r) {
        await this._initWorkers();
        const i = new Promise( (n, s) => {
            this.queue.push({
                id: t,
                arguments: r,
                resolve: n,
                reject: s
            })
        }
        );
        return this.next(),
        i
    }
    next() {
        if (!this.queue.length)
            return;
        const t = this.getWorker();
        if (!t)
            return;
        const r = this.queue.pop()
          , i = r.id;
        this.resolveHash[$S] = {
            resolve: r.resolve,
            reject: r.reject
        },
        t.postMessage({
            data: r.arguments,
            uuid: $S++,
            id: i
        })
    }
}
const zS = new Qz;
function gl(e, t, r) {
    e.resource.internal = !0;
    const i = new F(e)
      , n = () => {
        delete t.promiseCache[r],
        ss.has(r) && ss.remove(r)
    }
    ;
    return i.baseTexture.once("destroyed", () => {
        r in t.promiseCache && (console.warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture."),
        n())
    }
    ),
    i.once("destroyed", () => {
        e.destroyed || (console.warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),
        n())
    }
    ),
    i
}
const Jz = [".jpeg", ".jpg", ".png", ".webp", ".avif"]
  , tW = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function TR(e) {
    const t = await z.ADAPTER.fetch(e);
    if (!t.ok)
        throw new Error(`[loadImageBitmap] Failed to fetch ${e}: ${t.status} ${t.statusText}`);
    const r = await t.blob();
    return await createImageBitmap(r)
}
const $u = {
    name: "loadTextures",
    extension: {
        type: G.LoadParser,
        priority: Gr.High
    },
    config: {
        preferWorkers: !0,
        preferCreateImageBitmap: !0,
        crossOrigin: "anonymous"
    },
    test(e) {
        return Ho(e, tW) || Xn(e, Jz)
    },
    async load(e, t, r) {
        const i = globalThis.createImageBitmap && this.config.preferCreateImageBitmap;
        let n;
        i ? this.config.preferWorkers && await zS.isImageBitmapSupported() ? n = await zS.loadImageBitmap(e) : n = await TR(e) : n = await new Promise( (a, l) => {
            const h = new Image;
            h.crossOrigin = this.config.crossOrigin,
            h.src = e,
            h.complete ? a(h) : (h.onload = () => a(h),
            h.onerror = u => l(u))
        }
        );
        const s = {
            ...t.data
        };
        s.resolution ?? (s.resolution = un(e)),
        i && s.resourceOptions?.ownsImageBitmap === void 0 && (s.resourceOptions = {
            ...s.resourceOptions
        },
        s.resourceOptions.ownsImageBitmap = !0);
        const o = new nt(n,s);
        return o.resource.src = e,
        gl(o, r, e)
    },
    unload(e) {
        e.destroy(!0)
    }
};
Y.add($u);
const eW = ".svg"
  , rW = "image/svg+xml"
  , SR = {
    extension: {
        type: G.LoadParser,
        priority: Gr.High
    },
    name: "loadSVG",
    test(e) {
        return Ho(e, rW) || Xn(e, eW)
    },
    async testParse(e) {
        return vf.test(e)
    },
    async parse(e, t, r) {
        const i = new vf(e,t?.data?.resourceOptions);
        await i.load();
        const n = new nt(i,{
            resolution: un(e),
            ...t?.data
        });
        return n.resource.src = t.src,
        gl(n, r, t.src)
    },
    async load(e, t) {
        return (await z.ADAPTER.fetch(e)).text()
    },
    unload: $u.unload
};
Y.add(SR);
const iW = [".mp4", ".m4v", ".webm", ".ogv"]
  , nW = ["video/mp4", "video/webm", "video/ogg"]
  , wR = {
    name: "loadVideo",
    extension: {
        type: G.LoadParser,
        priority: Gr.High
    },
    config: {
        defaultAutoPlay: !0
    },
    test(e) {
        return Ho(e, nW) || Xn(e, iW)
    },
    async load(e, t, r) {
        let i;
        const n = await (await z.ADAPTER.fetch(e)).blob()
          , s = URL.createObjectURL(n);
        try {
            const o = {
                autoPlay: this.config.defaultAutoPlay,
                ...t?.data?.resourceOptions
            }
              , a = new bx(s,o);
            await a.load();
            const l = new nt(a,{
                alphaMode: await _I(),
                resolution: un(e),
                ...t?.data
            });
            l.resource.src = e,
            i = gl(l, r, e),
            i.baseTexture.once("destroyed", () => {
                URL.revokeObjectURL(s)
            }
            )
        } catch (o) {
            throw URL.revokeObjectURL(s),
            o
        }
        return i
    },
    unload(e) {
        e.destroy(!0)
    }
};
Y.add(wR);
class sW {
    constructor() {
        this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (t, r) => `${t}${this._bundleIdConnector}${r}`,
            extractAssetIdFromBundle: (t, r) => r.replace(`${t}${this._bundleIdConnector}`, "")
        },
        this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector,
        this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId,
        this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,
        this._assetMap = {},
        this._preferredOrder = [],
        this._parsers = [],
        this._resolverHash = {},
        this._bundles = {}
    }
    setBundleIdentifier(t) {
        if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector,
        this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId,
        this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle,
        this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
    }
    prefer(...t) {
        t.forEach(r => {
            this._preferredOrder.push(r),
            r.priority || (r.priority = Object.keys(r.params))
        }
        ),
        this._resolverHash = {}
    }
    set basePath(t) {
        this._basePath = t
    }
    get basePath() {
        return this._basePath
    }
    set rootPath(t) {
        this._rootPath = t
    }
    get rootPath() {
        return this._rootPath
    }
    get parsers() {
        return this._parsers
    }
    reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
        this._assetMap = {},
        this._preferredOrder = [],
        this._resolverHash = {},
        this._rootPath = null,
        this._basePath = null,
        this._manifest = null,
        this._bundles = {},
        this._defaultSearchParams = null
    }
    setDefaultSearchParams(t) {
        if (typeof t == "string")
            this._defaultSearchParams = t;
        else {
            const r = t;
            this._defaultSearchParams = Object.keys(r).map(i => `${encodeURIComponent(i)}=${encodeURIComponent(r[i])}`).join("&")
        }
    }
    getAlias(t) {
        const {alias: r, name: i, src: n, srcs: s} = t;
        return qr(r || i || n || s, o => typeof o == "string" ? o : Array.isArray(o) ? o.map(a => a?.src ?? a?.srcs ?? a) : o?.src || o?.srcs ? o.src ?? o.srcs : o, !0)
    }
    addManifest(t) {
        this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"),
        this._manifest = t,
        t.bundles.forEach(r => {
            this.addBundle(r.name, r.assets)
        }
        )
    }
    addBundle(t, r) {
        const i = [];
        Array.isArray(r) ? r.forEach(n => {
            const s = n.src ?? n.srcs
              , o = n.alias ?? n.name;
            let a;
            if (typeof o == "string") {
                const l = this._createBundleAssetId(t, o);
                i.push(l),
                a = [o, l]
            } else {
                const l = o.map(h => this._createBundleAssetId(t, h));
                i.push(...l),
                a = [...o, ...l]
            }
            this.add({
                ...n,
                alias: a,
                src: s
            })
        }
        ) : Object.keys(r).forEach(n => {
            const s = [n, this._createBundleAssetId(t, n)];
            if (typeof r[n] == "string")
                this.add({
                    alias: s,
                    src: r[n]
                });
            else if (Array.isArray(r[n]))
                this.add({
                    alias: s,
                    src: r[n]
                });
            else {
                const o = r[n]
                  , a = o.src ?? o.srcs;
                this.add({
                    ...o,
                    alias: s,
                    src: Array.isArray(a) ? a : [a]
                })
            }
            i.push(...s)
        }
        ),
        this._bundles[t] = i
    }
    add(t, r, i, n, s) {
        const o = [];
        typeof t == "string" || Array.isArray(t) && typeof t[0] == "string" ? (et("7.2.0", `Assets.add now uses an object instead of individual parameters.
Please use Assets.add({ alias, src, data, format, loadParser }) instead.`),
        o.push({
            alias: t,
            src: r,
            data: i,
            format: n,
            loadParser: s
        })) : Array.isArray(t) ? o.push(...t) : o.push(t);
        let a;
        a = l => {
            this.hasKey(l) && console.warn(`[Resolver] already has key: ${l} overwriting`)
        }
        ,
        qr(o).forEach(l => {
            const {src: h, srcs: u} = l;
            let {data: c, format: d, loadParser: f} = l;
            const g = qr(h || u).map(y => typeof y == "string" ? _R(y) : Array.isArray(y) ? y : [y])
              , p = this.getAlias(l);
            Array.isArray(p) ? p.forEach(a) : a(p);
            const v = [];
            g.forEach(y => {
                y.forEach(m => {
                    let _ = {};
                    if (typeof m != "object") {
                        _.src = m;
                        for (let x = 0; x < this._parsers.length; x++) {
                            const E = this._parsers[x];
                            if (E.test(m)) {
                                _ = E.parse(m);
                                break
                            }
                        }
                    } else
                        c = m.data ?? c,
                        d = m.format ?? d,
                        f = m.loadParser ?? f,
                        _ = {
                            ..._,
                            ...m
                        };
                    if (!p)
                        throw new Error(`[Resolver] alias is undefined for this asset: ${_.src}`);
                    _ = this.buildResolvedAsset(_, {
                        aliases: p,
                        data: c,
                        format: d,
                        loadParser: f
                    }),
                    v.push(_)
                }
                )
            }
            ),
            p.forEach(y => {
                this._assetMap[y] = v
            }
            )
        }
        )
    }
    resolveBundle(t) {
        const r = au(t);
        t = qr(t);
        const i = {};
        return t.forEach(n => {
            const s = this._bundles[n];
            if (s) {
                const o = this.resolve(s)
                  , a = {};
                for (const l in o) {
                    const h = o[l];
                    a[this._extractAssetIdFromBundle(n, l)] = h
                }
                i[n] = a
            }
        }
        ),
        r ? i[t[0]] : i
    }
    resolveUrl(t) {
        const r = this.resolve(t);
        if (typeof t != "string") {
            const i = {};
            for (const n in r)
                i[n] = r[n].src;
            return i
        }
        return r.src
    }
    resolve(t) {
        const r = au(t);
        t = qr(t);
        const i = {};
        return t.forEach(n => {
            if (!this._resolverHash[n])
                if (this._assetMap[n]) {
                    let s = this._assetMap[n];
                    const o = s[0]
                      , a = this._getPreferredOrder(s);
                    a?.priority.forEach(l => {
                        a.params[l].forEach(h => {
                            const u = s.filter(c => c[l] ? c[l] === h : !1);
                            u.length && (s = u)
                        }
                        )
                    }
                    ),
                    this._resolverHash[n] = s[0] ?? o
                } else
                    this._resolverHash[n] = this.buildResolvedAsset({
                        alias: [n],
                        src: n
                    }, {});
            i[n] = this._resolverHash[n]
        }
        ),
        r ? i[t[0]] : i
    }
    hasKey(t) {
        return !!this._assetMap[t]
    }
    hasBundle(t) {
        return !!this._bundles[t]
    }
    _getPreferredOrder(t) {
        for (let r = 0; r < t.length; r++) {
            const i = t[0]
              , n = this._preferredOrder.find(s => s.params.format.includes(i.format));
            if (n)
                return n
        }
        return this._preferredOrder[0]
    }
    _appendDefaultSearchParams(t) {
        if (!this._defaultSearchParams)
            return t;
        const r = /\?/.test(t) ? "&" : "?";
        return `${t}${r}${this._defaultSearchParams}`
    }
    buildResolvedAsset(t, r) {
        const {aliases: i, data: n, loadParser: s, format: o} = r;
        return (this._basePath || this._rootPath) && (t.src = fe.toAbsolute(t.src, this._basePath, this._rootPath)),
        t.alias = i ?? t.alias ?? [t.src],
        t.src = this._appendDefaultSearchParams(t.src),
        t.data = {
            ...n || {},
            ...t.data
        },
        t.loadParser = s ?? t.loadParser,
        t.format = o ?? t.src.split(".").pop(),
        t.srcs = t.src,
        t.name = t.alias,
        t
    }
}
class AR {
    constructor() {
        this._detections = [],
        this._initialized = !1,
        this.resolver = new sW,
        this.loader = new Gz,
        this.cache = ss,
        this._backgroundLoader = new Fz(this.loader),
        this._backgroundLoader.active = !0,
        this.reset()
    }
    async init(t={}) {
        if (this._initialized) {
            console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
            return
        }
        if (this._initialized = !0,
        t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams),
        t.basePath && (this.resolver.basePath = t.basePath),
        t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier),
        t.manifest) {
            let s = t.manifest;
            typeof s == "string" && (s = await this.load(s)),
            this.resolver.addManifest(s)
        }
        const r = t.texturePreference?.resolution ?? 1
          , i = typeof r == "number" ? [r] : r
          , n = await this._detectFormats({
            preferredFormats: t.texturePreference?.format,
            skipDetections: t.skipDetections,
            detections: this._detections
        });
        this.resolver.prefer({
            params: {
                format: n,
                resolution: i
            }
        }),
        t.preferences && this.setPreferences(t.preferences)
    }
    add(t, r, i, n, s) {
        this.resolver.add(t, r, i, n, s)
    }
    async load(t, r) {
        this._initialized || await this.init();
        const i = au(t)
          , n = qr(t).map(a => {
            if (typeof a != "string") {
                const l = this.resolver.getAlias(a);
                return l.some(h => !this.resolver.hasKey(h)) && this.add(a),
                Array.isArray(l) ? l[0] : l
            }
            return this.resolver.hasKey(a) || this.add({
                alias: a,
                src: a
            }),
            a
        }
        )
          , s = this.resolver.resolve(n)
          , o = await this._mapLoadToResolve(s, r);
        return i ? o[n[0]] : o
    }
    addBundle(t, r) {
        this.resolver.addBundle(t, r)
    }
    async loadBundle(t, r) {
        this._initialized || await this.init();
        let i = !1;
        typeof t == "string" && (i = !0,
        t = [t]);
        const n = this.resolver.resolveBundle(t)
          , s = {}
          , o = Object.keys(n);
        let a = 0
          , l = 0;
        const h = () => {
            r?.(++a / l)
        }
          , u = o.map(c => {
            const d = n[c];
            return l += Object.keys(d).length,
            this._mapLoadToResolve(d, h).then(f => {
                s[c] = f
            }
            )
        }
        );
        return await Promise.all(u),
        i ? s[t[0]] : s
    }
    async backgroundLoad(t) {
        this._initialized || await this.init(),
        typeof t == "string" && (t = [t]);
        const r = this.resolver.resolve(t);
        this._backgroundLoader.add(Object.values(r))
    }
    async backgroundLoadBundle(t) {
        this._initialized || await this.init(),
        typeof t == "string" && (t = [t]);
        const r = this.resolver.resolveBundle(t);
        Object.values(r).forEach(i => {
            this._backgroundLoader.add(Object.values(i))
        }
        )
    }
    reset() {
        this.resolver.reset(),
        this.loader.reset(),
        this.cache.reset(),
        this._initialized = !1
    }
    get(t) {
        if (typeof t == "string")
            return ss.get(t);
        const r = {};
        for (let i = 0; i < t.length; i++)
            r[i] = ss.get(t[i]);
        return r
    }
    async _mapLoadToResolve(t, r) {
        const i = Object.values(t)
          , n = Object.keys(t);
        this._backgroundLoader.active = !1;
        const s = await this.loader.load(i, r);
        this._backgroundLoader.active = !0;
        const o = {};
        return i.forEach( (a, l) => {
            const h = s[a.src]
              , u = [a.src];
            a.alias && u.push(...a.alias),
            o[n[l]] = h,
            ss.set(u, h)
        }
        ),
        o
    }
    async unload(t) {
        this._initialized || await this.init();
        const r = qr(t).map(n => typeof n != "string" ? n.src : n)
          , i = this.resolver.resolve(r);
        await this._unloadFromResolved(i)
    }
    async unloadBundle(t) {
        this._initialized || await this.init(),
        t = qr(t);
        const r = this.resolver.resolveBundle(t)
          , i = Object.keys(r).map(n => this._unloadFromResolved(r[n]));
        await Promise.all(i)
    }
    async _unloadFromResolved(t) {
        const r = Object.values(t);
        r.forEach(i => {
            ss.remove(i.src)
        }
        ),
        await this.loader.unload(r)
    }
    async _detectFormats(t) {
        let r = [];
        t.preferredFormats && (r = Array.isArray(t.preferredFormats) ? t.preferredFormats : [t.preferredFormats]);
        for (const i of t.detections)
            t.skipDetections || await i.test() ? r = await i.add(r) : t.skipDetections || (r = await i.remove(r));
        return r = r.filter( (i, n) => r.indexOf(i) === n),
        r
    }
    get detections() {
        return this._detections
    }
    get preferWorkers() {
        return $u.config.preferWorkers
    }
    set preferWorkers(t) {
        et("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."),
        this.setPreferences({
            preferWorkers: t
        })
    }
    setPreferences(t) {
        this.loader.parsers.forEach(r => {
            r.config && Object.keys(r.config).filter(i => i in t).forEach(i => {
                r.config[i] = t[i]
            }
            )
        }
        )
    }
}
const vt = new AR;
Y.handleByList(G.LoadParser, vt.loader.parsers).handleByList(G.ResolveParser, vt.resolver.parsers).handleByList(G.CacheParser, vt.cache.parsers).handleByList(G.DetectionParser, vt.detections);
const bR = {
    extension: G.CacheParser,
    test: e => Array.isArray(e) && e.every(t => t instanceof F),
    getCacheableAssets: (e, t) => {
        const r = {};
        return e.forEach(i => {
            t.forEach( (n, s) => {
                r[i + (s === 0 ? "" : s + 1)] = n
            }
            )
        }
        ),
        r
    }
};
Y.add(bR);
const CR = {
    extension: {
        type: G.DetectionParser,
        priority: 1
    },
    test: async () => {
        const e = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
        return new Promise(t => {
            const r = new Image;
            r.onload = () => {
                t(!0)
            }
            ,
            r.onerror = () => {
                t(!1)
            }
            ,
            r.src = e
        }
        )
    }
    ,
    add: async e => [...e, "avif"],
    remove: async e => e.filter(t => t !== "avif")
};
Y.add(CR);
const PR = {
    extension: {
        type: G.DetectionParser,
        priority: 0
    },
    test: async () => {
        const e = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
        return new Promise(t => {
            const r = new Image;
            r.onload = () => {
                t(!0)
            }
            ,
            r.onerror = () => {
                t(!1)
            }
            ,
            r.src = e
        }
        )
    }
    ,
    add: async e => [...e, "webp"],
    remove: async e => e.filter(t => t !== "webp")
};
Y.add(PR);
const WS = ["png", "jpg", "jpeg"]
  , IR = {
    extension: {
        type: G.DetectionParser,
        priority: -1
    },
    test: () => Promise.resolve(!0),
    add: async e => [...e, ...WS],
    remove: async e => e.filter(t => !WS.includes(t))
};
Y.add(IR);
const oW = "WorkerGlobalScope"in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function Cx(e) {
    return oW ? !1 : document.createElement("video").canPlayType(e) !== ""
}
const RR = {
    extension: {
        type: G.DetectionParser,
        priority: 0
    },
    test: async () => Cx("video/webm"),
    add: async e => [...e, "webm"],
    remove: async e => e.filter(t => t !== "webm")
};
Y.add(RR);
const MR = {
    extension: {
        type: G.DetectionParser,
        priority: 0
    },
    test: async () => Cx("video/mp4"),
    add: async e => [...e, "mp4", "m4v"],
    remove: async e => e.filter(t => t !== "mp4" && t !== "m4v")
};
Y.add(MR);
const OR = {
    extension: {
        type: G.DetectionParser,
        priority: 0
    },
    test: async () => Cx("video/ogg"),
    add: async e => [...e, "ogv"],
    remove: async e => e.filter(t => t !== "ogv")
};
Y.add(OR);
const NR = {
    extension: G.ResolveParser,
    test: $u.test,
    parse: e => ({
        resolution: parseFloat(z.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
        format: e.split(".").pop(),
        src: e
    })
};
Y.add(NR);
const VS = e => {
    const t = e.src;
    return e?.alias?.[0] ?? fe.basename(t, fe.extname(t))
}
  , aW = {
    extension: G.Asset,
    detection: {
        test: async () => !0,
        add: async e => [...e, ...xf.filter(t => Ef[t])],
        remove: async e => e.filter(t => e.includes(t))
    },
    loader: {
        extension: {
            type: [G.LoadParser],
            priority: Gr.High
        },
        test(e) {
            const t = fe.extname(e).slice(1);
            return !!Ef[t] || Mz.some(r => e.startsWith(`data:${r}`))
        },
        async load(e, t) {
            const r = await new Promise( (i, n) => Tf.from({
                ...t.data,
                url: e,
                preload: !0,
                loaded(s, o) {
                    s ? n(s) : i(o),
                    t.data?.loaded?.(s, o)
                }
            }));
            return Kh().add(VS(t), r),
            r
        },
        async unload(e, t) {
            Kh().remove(VS(t))
        }
    }
};
Y.add(aW);
const vr = RH(new kz)
  , lW = e => e.startsWith("http")
  , cn = e => {
    const {cdnUrl: t} = Cp()
      , r = e.includes(`?v=${window.APP_VERSION}`);
    return `${lW(e) ? e : `${t}${e}`}${r ? "" : `?v=${window.APP_VERSION}`}`
}
  , hW = (e, t) => {
    const {path: r, name: i, ext: n="", search: s=""} = (e || "").match(/^(?<path>.*\/)(?<name>[^/.]+)?(?<ext>[^/?]+)?(?<search>\?.*)?/)?.groups || {};
    return `${r}${i}${t ? `@${t}x` : ""}${n}${s}`
}
  , _o = I5([hW, cn])
  , U = ie
  , sK = Ei
  , jS = zl
  , {MEDIA_BY_BREAKPOINTS: LR, COMMON_MEDIA_BY_BREAKPOINTS: DR, COMMON_MEDIA_DOWN_BY_BREAKPOINTS: BR} = IH
  , Bc = new ci
  , kR = {
    on: (e, t) => Bc.on(e, t),
    once: (e, t) => Bc.once(e, t),
    off: (e, t) => Bc.off(e, t),
    emit: (e, t) => Bc.emit(e, t),
    onChange: e => {
        kR.on("change", e)
    }
};
let XS, YS = [], _h, Na = [];
const uW = () => (Na = [],
Object.entries({
    ...DR,
    ...BR
}).forEach( ([e,t]) => window.matchMedia(t).matches ? (Na.push(e),
!0) : !1),
Na)
  , lu = () => (Object.entries(LR).some( ([e,t]) => window.matchMedia(t).matches ? (_h = e,
!0) : !1),
{
    main: _h,
    common: uW()
})
  , cW = () => {
    lu(),
    Object.values({
        ...LR,
        ...DR,
        ...BR
    }).forEach(e => {
        window.matchMedia(e).addEventListener("change", () => {
            lu(),
            (!V0(YS, Na) || !V0(_h, XS)) && (YS = Na,
            XS = _h,
            kR.emit("change", {
                main: _h,
                common: Na
            }))
        }
        )
    }
    )
}
;
cW();
const dW = 36
  , FR = {
    [U.MOBILE_S]: 12,
    [U.MOBILE]: 12,
    [U.TABLET]: 12,
    [U.TABLET_S]: 12,
    [U.TABLET_HOR]: -12,
    [U.M_LARGE]: -12,
    [U.L_LARGE]: -12,
    [U.XS_X_LARGE]: 12,
    [U.S_X_LARGE]: 12
}
  , UR = {
    [U.XS_MIN]: 0,
    [U.XS_X_LARGE]: 190,
    [U.S_X_LARGE]: 190,
    [U.L_LARGE]: 120,
    [U.M_LARGE]: 120,
    [U.MOBILE_S]: 252,
    [U.MOBILE]: 252,
    [U.DESKTOP]: 0,
    [U.TABLET]: 252,
    [U.TABLET_S]: 252,
    [U.TABLET_HOR]: 152
}
  , fW = {
    [U.XS_MIN]: 187,
    [U.S_MIN]: 187,
    [U.XS_MEDIUM]: 187,
    [U.XS_LARGE]: 187,
    [U.S_MEDIUM]: 187,
    [U.S_LARGE]: 187,
    [U.M_MIN]: 342,
    [U.M_MEDIUM]: 342,
    [U.L_MIN]: 360,
    [U.L_MEDIUM]: 360
}
  , pW = [U.MOBILE_S, U.MOBILE, U.TABLET, U.TABLET_S, U.XS_X_LARGE, U.S_X_LARGE]
  , mW = () => {
    const e = lu().main
      , t = UR[e] || 0
      , r = FR[e] || 0
      , i = fW[e] || 0
      , {clientWidth: n, clientHeight: s} = document.documentElement
      , o = n - i
      , a = s - dW - (pW.includes(e) ? 0 : t) - r;
    return document.documentElement.style.setProperty("--game-container-height", `${a}px`),
    document.documentElement.style.setProperty("--bet-panels-width", `${i}px`),
    document.documentElement.style.setProperty("--bet-panels-height", `${t}px`),
    {
        width: o,
        height: a
    }
}
  , KS = e => Math.round(Math.log(e) * 12 * 1e3)
  , GR = () => {
    const {mode: e} = Mu()
      , {state: {mode: t}={}} = CH(zB.SETTINGS) || {}
      , r = (e?.toString() || t)?.toLowerCase();
    return r && [Je.FULL, Je.LIGHT].includes(r) ? r : Je.FULL
}
  , gW = "settings"
  , _W = () => ({
    isGlobalSoundEnabled: !0,
    isMusicEnabled: !0,
    isGameSoundsEnabled: !0,
    isUiSoundsEnabled: !0,
    mode: Je.FULL,
    bgMusic: $h.DYNAMIC
})
  , yW = mH()(yH(SH(e => ({
    ..._W(),
    setGlobalSoundEnabled: t => {
        e({
            isGlobalSoundEnabled: t
        }),
        ot.setAllVolume(t ? 1 : 0)
    }
    ,
    setIsMusicEnabled: t => {
        e({
            isMusicEnabled: t
        }),
        ot.setVolumeByCategory(it.MUSIC, t ? 1 : 0)
    }
    ,
    setIsGameSoundsEnabled: t => {
        e({
            isGameSoundsEnabled: t
        }),
        ot.setVolumeByCategory(it.GAME, t ? 1 : 0)
    }
    ,
    setIsUiSoundsEnabled: t => {
        e({
            isUiSoundsEnabled: t
        }),
        ot.setVolumeByCategory(it.UI, t ? 1 : 0)
    }
    ,
    setAllSoundsCategoriesEnabled: t => {
        e({
            isMusicEnabled: t,
            isGameSoundsEnabled: t,
            isUiSoundsEnabled: t
        }),
        ot.setVolumeByCategory(it.MUSIC, t ? 1 : 0),
        ot.setVolumeByCategory(it.GAME, t ? 1 : 0),
        ot.setVolumeByCategory(it.UI, t ? 1 : 0)
    }
    ,
    setMode: t => {
        e({
            mode: t
        })
    }
    ,
    setBgMusic: t => {
        e({
            bgMusic: t
        })
    }
}), {
    name: gW,
    onRehydrateStorage: () => e => {
        const t = GR();
        e?.setMode(t)
    }
})));
let wf = [];
const vW = e => {
    if (!e)
        return null;
    const t = e.toUpperCase().split(",");
    if (qC) {
        const r = $B;
        return t.filter(i => r.includes(i))
    }
    return t
}
  , oK = () => wf
  , xr = e => wf.includes(e)
  , aK = e => {
    const {featFlags: t} = Mu()
      , r = vW(t);
    wf = e,
    r?.length && (wf = [...e, ...r].filter(i => !!i))
}
;
vr.disableAutoPause = !0;
const it = {
    UI: "ui",
    GAME: "game",
    MUSIC: "music"
}
  , xW = {
    bet: ["/game/sounds/bet.mp3", it.UI]
}
  , EW = {
    click: ["/sounds/click_general.mp3", it.UI, !0],
    countdown: ["/sounds/countdown.mp3", it.UI, !0],
    placeBet: ["/sounds/place_bet.mp3", it.UI, !0],
    claimBonus: ["/sounds/bonus_claim.mp3", it.UI],
    openBox: ["/sounds/open_box.mp3", it.UI]
}
  , TW = {
    bg: ["/game/sounds/music.mp3", it.MUSIC],
    start: ["/game/sounds/start.mp3", it.GAME],
    cashout: ["/game/sounds/cashout.mp3", it.UI],
    crash: ["/game/sounds/crash.mp3", it.GAME],
    propellerStart: ["/game/sounds/propeller_start.mp3", it.GAME],
    propellerFly: ["/game/sounds/propeller.mp3", it.GAME],
    turbineStart: ["/game/sounds/fire_start.mp3", it.GAME],
    turbineFly: ["/game/sounds/fire.mp3", it.GAME],
    bigWin: ["/game/sounds/win_big.mp3", it.GAME],
    superWin: ["/game/sounds/win_super.mp3", it.GAME],
    epicWin: ["/game/sounds/win_epic.mp3", it.GAME]
}
  , SW = {
    bg: ["/sounds/aviatrix_music.mp3", it.MUSIC],
    bgCalm: ["/sounds/aviatrix_calm_music.mp3", it.MUSIC],
    start: ["/sounds/round_start.mp3", it.GAME],
    cashout: ["/sounds/cashout.mp3", it.UI],
    mainLand: ["/sounds/plane_main_down.mp3", it.GAME],
    playerLand: ["/sounds/plane_small_down.mp3", it.GAME],
    crash: ["/sounds/crash.mp3", it.GAME],
    propellerStart: ["/sounds/plane_propeller_start.mp3", it.GAME],
    propellerFly: ["/sounds/plane_propeller_fly.mp3", it.GAME],
    propellerTakeOff: ["/sounds/plane_propeller_take_off.mp3", it.GAME],
    turbineStart: ["/sounds/plane_turbine_start.mp3", it.GAME],
    turbineFly: ["/sounds/plane_turbine_fly.mp3", it.GAME],
    turbineTakeOff: ["/sounds/plane_turbine_take_off.mp3", it.GAME],
    bigWin: ["/sounds/win_big.mp3", it.GAME],
    superWin: ["/sounds/win_super.mp3", it.GAME],
    epicWin: ["/sounds/win_epic.mp3", it.GAME],
    ambGeneral: ["/sounds/amb_general.mp3", it.GAME],
    ambWind: ["/sounds/amb_wind.mp3", it.GAME]
};
window.addEventListener("unhandledrejection", e => {
    e.stopPropagation()
}
);
class wW {
    constructor() {
        b(this, "sounds", {})
    }
    prepareSounds(t) {
        const r = Object.entries(t).reduce( (i, [n,s]) => (i[n] = {
            url: cn(s[0]),
            category: s[1],
            preload: !!s[2]
        },
        i), {});
        this.sounds = {
            ...this.sounds,
            ...r
        },
        vr.add(r, {
            singleInstance: !0
        })
    }
    initSounds() {
        this.prepareSounds(xr(me.NEW_SOUNDS) ? EW : xW)
    }
    initGameSounds() {
        this.prepareSounds(xr(me.NEW_SOUNDS) ? SW : TW)
    }
    async play(t, r) {
        if (!this.sounds[t])
            return;
        const i = vr.find(t);
        let n = (r?.volume ?? 1) * .7;
        if (!i)
            return;
        let s;
        t === "click" && xr(me.NEW_SOUNDS) && (n *= .7);
        try {
            s = await i.play({
                ...r,
                volume: n
            })
        } catch (o) {
            console.log(`ERROR ${t} ${o}`)
        }
        return s
    }
    stop(t) {
        vr.exists(t) && vr.stop(t)
    }
    volume(t, r) {
        vr.exists(t) && vr.volume(t, r)
    }
    mute(t) {
        t ? vr.muteAll() : vr.unmuteAll()
    }
    setAllVolume(t) {
        vr.volumeAll = t
    }
    stopAll() {
        vr.stopAll()
    }
    setVolumeByCategory(t, r) {
        Object.entries(this.sounds).forEach( ([i,{category: n}]) => {
            n === t && vr.exists(i) && vr.volume(i, r)
        }
        )
    }
}
const ot = new wW
  , lK = () => {
    const e = yW.getState()
      , {isGlobalSoundEnabled: t, isMusicEnabled: r, isGameSoundsEnabled: i, isUiSoundsEnabled: n} = e;
    ot.setVolumeByCategory(it.MUSIC, t && r ? 1 : 0),
    ot.setVolumeByCategory(it.GAME, t && i ? 1 : 0),
    ot.setVolumeByCategory(it.UI, t && n ? 1 : 0)
}
;
function AW(e, t) {
    if (Object.is(e, t))
        return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
    if (e instanceof Map && t instanceof Map) {
        if (e.size !== t.size)
            return !1;
        for (const [i,n] of e)
            if (!Object.is(n, t.get(i)))
                return !1;
        return !0
    }
    if (e instanceof Set && t instanceof Set) {
        if (e.size !== t.size)
            return !1;
        for (const i of e)
            if (!t.has(i))
                return !1;
        return !0
    }
    const r = Object.keys(e);
    if (r.length !== Object.keys(t).length)
        return !1;
    for (let i = 0; i < r.length; i++)
        if (!Object.prototype.hasOwnProperty.call(t, r[i]) || !Object.is(e[r[i]], t[r[i]]))
            return !1;
    return !0
}
var bW = 20
  , CW = 1
  , Mo = 1e6
  , qS = 1e6
  , PW = -7
  , IW = 21
  , RW = !1
  , zu = "[big.js] "
  , $o = zu + "Invalid "
  , Bp = $o + "decimal places"
  , MW = $o + "rounding mode"
  , HR = zu + "Division by zero"
  , wt = {}
  , an = void 0
  , OW = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function $R() {
    function e(t) {
        var r = this;
        if (!(r instanceof e))
            return t === an ? $R() : new e(t);
        if (t instanceof e)
            r.s = t.s,
            r.e = t.e,
            r.c = t.c.slice();
        else {
            if (typeof t != "string") {
                if (e.strict === !0 && typeof t != "bigint")
                    throw TypeError($o + "value");
                t = t === 0 && 1 / t < 0 ? "-0" : String(t)
            }
            NW(r, t)
        }
        r.constructor = e
    }
    return e.prototype = wt,
    e.DP = bW,
    e.RM = CW,
    e.NE = PW,
    e.PE = IW,
    e.strict = RW,
    e.roundDown = 0,
    e.roundHalfUp = 1,
    e.roundHalfEven = 2,
    e.roundUp = 3,
    e
}
function NW(e, t) {
    var r, i, n;
    if (!OW.test(t))
        throw Error($o + "number");
    for (e.s = t.charAt(0) == "-" ? (t = t.slice(1),
    -1) : 1,
    (r = t.indexOf(".")) > -1 && (t = t.replace(".", "")),
    (i = t.search(/e/i)) > 0 ? (r < 0 && (r = i),
    r += +t.slice(i + 1),
    t = t.substring(0, i)) : r < 0 && (r = t.length),
    n = t.length,
    i = 0; i < n && t.charAt(i) == "0"; )
        ++i;
    if (i == n)
        e.c = [e.e = 0];
    else {
        for (; n > 0 && t.charAt(--n) == "0"; )
            ;
        for (e.e = r - i - 1,
        e.c = [],
        r = 0; i <= n; )
            e.c[r++] = +t.charAt(i++)
    }
    return e
}
function zo(e, t, r, i) {
    var n = e.c;
    if (r === an && (r = e.constructor.RM),
    r !== 0 && r !== 1 && r !== 2 && r !== 3)
        throw Error(MW);
    if (t < 1)
        i = r === 3 && (i || !!n[0]) || t === 0 && (r === 1 && n[0] >= 5 || r === 2 && (n[0] > 5 || n[0] === 5 && (i || n[1] !== an))),
        n.length = 1,
        i ? (e.e = e.e - t + 1,
        n[0] = 1) : n[0] = e.e = 0;
    else if (t < n.length) {
        if (i = r === 1 && n[t] >= 5 || r === 2 && (n[t] > 5 || n[t] === 5 && (i || n[t + 1] !== an || n[t - 1] & 1)) || r === 3 && (i || !!n[0]),
        n.length = t,
        i) {
            for (; ++n[--t] > 9; )
                if (n[t] = 0,
                t === 0) {
                    ++e.e,
                    n.unshift(1);
                    break
                }
        }
        for (t = n.length; !n[--t]; )
            n.pop()
    }
    return e
}
function _l(e, t, r) {
    var i = e.e
      , n = e.c.join("")
      , s = n.length;
    if (t)
        n = n.charAt(0) + (s > 1 ? "." + n.slice(1) : "") + (i < 0 ? "e" : "e+") + i;
    else if (i < 0) {
        for (; ++i; )
            n = "0" + n;
        n = "0." + n
    } else if (i > 0)
        if (++i > s)
            for (i -= s; i--; )
                n += "0";
        else
            i < s && (n = n.slice(0, i) + "." + n.slice(i));
    else
        s > 1 && (n = n.charAt(0) + "." + n.slice(1));
    return e.s < 0 && r ? "-" + n : n
}
wt.abs = function() {
    var e = new this.constructor(this);
    return e.s = 1,
    e
}
;
wt.cmp = function(e) {
    var t, r = this, i = r.c, n = (e = new r.constructor(e)).c, s = r.s, o = e.s, a = r.e, l = e.e;
    if (!i[0] || !n[0])
        return i[0] ? s : n[0] ? -o : 0;
    if (s != o)
        return s;
    if (t = s < 0,
    a != l)
        return a > l ^ t ? 1 : -1;
    for (o = (a = i.length) < (l = n.length) ? a : l,
    s = -1; ++s < o; )
        if (i[s] != n[s])
            return i[s] > n[s] ^ t ? 1 : -1;
    return a == l ? 0 : a > l ^ t ? 1 : -1
}
;
wt.div = function(e) {
    var t = this
      , r = t.constructor
      , i = t.c
      , n = (e = new r(e)).c
      , s = t.s == e.s ? 1 : -1
      , o = r.DP;
    if (o !== ~~o || o < 0 || o > Mo)
        throw Error(Bp);
    if (!n[0])
        throw Error(HR);
    if (!i[0])
        return e.s = s,
        e.c = [e.e = 0],
        e;
    var a, l, h, u, c, d = n.slice(), f = a = n.length, g = i.length, p = i.slice(0, a), v = p.length, y = e, m = y.c = [], _ = 0, x = o + (y.e = t.e - e.e) + 1;
    for (y.s = s,
    s = x < 0 ? 0 : x,
    d.unshift(0); v++ < a; )
        p.push(0);
    do {
        for (h = 0; h < 10; h++) {
            if (a != (v = p.length))
                u = a > v ? 1 : -1;
            else
                for (c = -1,
                u = 0; ++c < a; )
                    if (n[c] != p[c]) {
                        u = n[c] > p[c] ? 1 : -1;
                        break
                    }
            if (u < 0) {
                for (l = v == a ? n : d; v; ) {
                    if (p[--v] < l[v]) {
                        for (c = v; c && !p[--c]; )
                            p[c] = 9;
                        --p[c],
                        p[v] += 10
                    }
                    p[v] -= l[v]
                }
                for (; !p[0]; )
                    p.shift()
            } else
                break
        }
        m[_++] = u ? h : ++h,
        p[0] && u ? p[v] = i[f] || 0 : p = [i[f]]
    } while ((f++ < g || p[0] !== an) && s--);
    return !m[0] && _ != 1 && (m.shift(),
    y.e--,
    x--),
    _ > x && zo(y, x, r.RM, p[0] !== an),
    y
}
;
wt.eq = function(e) {
    return this.cmp(e) === 0
}
;
wt.gt = function(e) {
    return this.cmp(e) > 0
}
;
wt.gte = function(e) {
    return this.cmp(e) > -1
}
;
wt.lt = function(e) {
    return this.cmp(e) < 0
}
;
wt.lte = function(e) {
    return this.cmp(e) < 1
}
;
wt.minus = wt.sub = function(e) {
    var t, r, i, n, s = this, o = s.constructor, a = s.s, l = (e = new o(e)).s;
    if (a != l)
        return e.s = -l,
        s.plus(e);
    var h = s.c.slice()
      , u = s.e
      , c = e.c
      , d = e.e;
    if (!h[0] || !c[0])
        return c[0] ? e.s = -l : h[0] ? e = new o(s) : e.s = 1,
        e;
    if (a = u - d) {
        for ((n = a < 0) ? (a = -a,
        i = h) : (d = u,
        i = c),
        i.reverse(),
        l = a; l--; )
            i.push(0);
        i.reverse()
    } else
        for (r = ((n = h.length < c.length) ? h : c).length,
        a = l = 0; l < r; l++)
            if (h[l] != c[l]) {
                n = h[l] < c[l];
                break
            }
    if (n && (i = h,
    h = c,
    c = i,
    e.s = -e.s),
    (l = (r = c.length) - (t = h.length)) > 0)
        for (; l--; )
            h[t++] = 0;
    for (l = t; r > a; ) {
        if (h[--r] < c[r]) {
            for (t = r; t && !h[--t]; )
                h[t] = 9;
            --h[t],
            h[r] += 10
        }
        h[r] -= c[r]
    }
    for (; h[--l] === 0; )
        h.pop();
    for (; h[0] === 0; )
        h.shift(),
        --d;
    return h[0] || (e.s = 1,
    h = [d = 0]),
    e.c = h,
    e.e = d,
    e
}
;
wt.mod = function(e) {
    var t, r = this, i = r.constructor, n = r.s, s = (e = new i(e)).s;
    if (!e.c[0])
        throw Error(HR);
    return r.s = e.s = 1,
    t = e.cmp(r) == 1,
    r.s = n,
    e.s = s,
    t ? new i(r) : (n = i.DP,
    s = i.RM,
    i.DP = i.RM = 0,
    r = r.div(e),
    i.DP = n,
    i.RM = s,
    this.minus(r.times(e)))
}
;
wt.neg = function() {
    var e = new this.constructor(this);
    return e.s = -e.s,
    e
}
;
wt.plus = wt.add = function(e) {
    var t, r, i, n = this, s = n.constructor;
    if (e = new s(e),
    n.s != e.s)
        return e.s = -e.s,
        n.minus(e);
    var o = n.e
      , a = n.c
      , l = e.e
      , h = e.c;
    if (!a[0] || !h[0])
        return h[0] || (a[0] ? e = new s(n) : e.s = n.s),
        e;
    if (a = a.slice(),
    t = o - l) {
        for (t > 0 ? (l = o,
        i = h) : (t = -t,
        i = a),
        i.reverse(); t--; )
            i.push(0);
        i.reverse()
    }
    for (a.length - h.length < 0 && (i = h,
    h = a,
    a = i),
    t = h.length,
    r = 0; t; a[t] %= 10)
        r = (a[--t] = a[t] + h[t] + r) / 10 | 0;
    for (r && (a.unshift(r),
    ++l),
    t = a.length; a[--t] === 0; )
        a.pop();
    return e.c = a,
    e.e = l,
    e
}
;
wt.pow = function(e) {
    var t = this
      , r = new t.constructor("1")
      , i = r
      , n = e < 0;
    if (e !== ~~e || e < -qS || e > qS)
        throw Error($o + "exponent");
    for (n && (e = -e); e & 1 && (i = i.times(t)),
    e >>= 1,
    !!e; )
        t = t.times(t);
    return n ? r.div(i) : i
}
;
wt.prec = function(e, t) {
    if (e !== ~~e || e < 1 || e > Mo)
        throw Error($o + "precision");
    return zo(new this.constructor(this), e, t)
}
;
wt.round = function(e, t) {
    if (e === an)
        e = 0;
    else if (e !== ~~e || e < -Mo || e > Mo)
        throw Error(Bp);
    return zo(new this.constructor(this), e + this.e + 1, t)
}
;
wt.sqrt = function() {
    var e, t, r, i = this, n = i.constructor, s = i.s, o = i.e, a = new n("0.5");
    if (!i.c[0])
        return new n(i);
    if (s < 0)
        throw Error(zu + "No square root");
    s = Math.sqrt(i + ""),
    s === 0 || s === 1 / 0 ? (t = i.c.join(""),
    t.length + o & 1 || (t += "0"),
    s = Math.sqrt(t),
    o = ((o + 1) / 2 | 0) - (o < 0 || o & 1),
    e = new n((s == 1 / 0 ? "5e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + o)) : e = new n(s + ""),
    o = e.e + (n.DP += 4);
    do
        r = e,
        e = a.times(r.plus(i.div(r)));
    while (r.c.slice(0, o).join("") !== e.c.slice(0, o).join(""));
    return zo(e, (n.DP -= 4) + e.e + 1, n.RM)
}
;
wt.times = wt.mul = function(e) {
    var t, r = this, i = r.constructor, n = r.c, s = (e = new i(e)).c, o = n.length, a = s.length, l = r.e, h = e.e;
    if (e.s = r.s == e.s ? 1 : -1,
    !n[0] || !s[0])
        return e.c = [e.e = 0],
        e;
    for (e.e = l + h,
    o < a && (t = n,
    n = s,
    s = t,
    h = o,
    o = a,
    a = h),
    t = new Array(h = o + a); h--; )
        t[h] = 0;
    for (l = a; l--; ) {
        for (a = 0,
        h = o + l; h > l; )
            a = t[h] + s[l] * n[h - l - 1] + a,
            t[h--] = a % 10,
            a = a / 10 | 0;
        t[h] = a
    }
    for (a ? ++e.e : t.shift(),
    l = t.length; !t[--l]; )
        t.pop();
    return e.c = t,
    e
}
;
wt.toExponential = function(e, t) {
    var r = this
      , i = r.c[0];
    if (e !== an) {
        if (e !== ~~e || e < 0 || e > Mo)
            throw Error(Bp);
        for (r = zo(new r.constructor(r), ++e, t); r.c.length < e; )
            r.c.push(0)
    }
    return _l(r, !0, !!i)
}
;
wt.toFixed = function(e, t) {
    var r = this
      , i = r.c[0];
    if (e !== an) {
        if (e !== ~~e || e < 0 || e > Mo)
            throw Error(Bp);
        for (r = zo(new r.constructor(r), e + r.e + 1, t),
        e = e + r.e + 1; r.c.length < e; )
            r.c.push(0)
    }
    return _l(r, !1, !!i)
}
;
wt[Symbol.for("nodejs.util.inspect.custom")] = wt.toJSON = wt.toString = function() {
    var e = this
      , t = e.constructor;
    return _l(e, e.e <= t.NE || e.e >= t.PE, !!e.c[0])
}
;
wt.toNumber = function() {
    var e = Number(_l(this, !0, !0));
    if (this.constructor.strict === !0 && !this.eq(e.toString()))
        throw Error(zu + "Imprecise conversion");
    return e
}
;
wt.toPrecision = function(e, t) {
    var r = this
      , i = r.constructor
      , n = r.c[0];
    if (e !== an) {
        if (e !== ~~e || e < 1 || e > Mo)
            throw Error($o + "precision");
        for (r = zo(new i(r), e, t); r.c.length < e; )
            r.c.push(0)
    }
    return _l(r, e <= r.e || r.e <= i.NE || r.e >= i.PE, !!n)
}
;
wt.valueOf = function() {
    var e = this
      , t = e.constructor;
    if (t.strict === !0)
        throw Error(zu + "valueOf disallowed");
    return _l(e, e.e <= t.NE || e.e >= t.PE, !0)
}
;
var ZS = $R();
const LW = (e, t, r="") => `${e}${r}${t}`
  , QS = e => e.map( ({value: t}) => t).join("").trim()
  , DW = (e, t) => {
    const r = _v().formatNumberToParts(Number(e), t)
      , i = QS(r.filter( ({type: s}) => s === "currency"));
    return {
        value: QS(r.filter( ({type: s}) => s !== "currency")) || e,
        currency: i || t.currency || ""
    }
}
  , Ed = (e, t, r="") => {
    const {value: i, currency: n} = DW(e, t);
    return LW(i, n, r)
}
  , lg = {
    [Z.TR]: Ed
}
  , hg = {
    [ce.KGS]: Ed,
    [ce.DOGE]: Ed,
    [ce.mETH]: Ed
}
  , hu = 1e3
  , b_ = "K"
  , yh = 1e6
  , C_ = "M";
function BW(e) {
    return typeof e == "number"
}
const zR = e => Number.parseFloat(String(e).replace(" SCR", ""))
  , hK = e => {
    const t = String(e);
    if (t.indexOf(".") !== -1) {
        const r = t.split(".");
        return r.length === 1 ? Number(t) : +`${r[0]}.${r[1].charAt(0)}${r[1].charAt(1)}`
    }
    return Number(t)
}
  , WR = (e, t=Xa) => {
    const r = new RegExp(`^-?\\d+(?:.\\d{0,${t || -1}})?`);
    return (Number(e.toString().match(r)?.[0]) || 0).toFixed(t)
}
  , uK = e => Number(e).toLocaleString(jB, {
    maximumFractionDigits: 5
})
  , Px = (e, t) => {
    const r = t || _p
      , {hasFractions: i, fractions: n} = jP(r);
    return WR(Number(e), i ? n : Xa)
}
  , kp = (e, t=1, r=4) => +(Math.floor(Number(e).toFixed(r) + `e${t}`) + `e-${t}`)
  , kW = (e, t=0) => e >= hu ? `${kp(e / hu, t)}${b_}` : Number.isInteger(e) ? String(e) : Math.floor(e)
  , cK = (e, t=0) => e >= yh ? `${kp(e / yh).toFixed(t)}${C_}` : kW(e, t)
  , Af = (e, t, r="currency", i=!0) => {
    const {lang: n} = document.documentElement
      , s = t || _p
      , {hasFractions: o, fractions: a} = jP(s);
    let l = {
        style: r,
        currency: t,
        currencyDisplay: "narrowSymbol"
    };
    i && (o && BW(a) && r === "currency" ? l = {
        ...l,
        minimumFractionDigits: a,
        maximumFractionDigits: a
    } : l = {
        ...l,
        minimumFractionDigits: Xa,
        maximumFractionDigits: Xa
    });
    let h = l;
    if (bm[t] || Cm[t] || hg[t] || lg[n]) {
        if (bm[t] && (h = {
            ...l,
            currency: Cm[t]
        }),
        !bm[t] && Cm[t] && (h = {
            ...l,
            currencyDisplay: "code"
        }),
        lg[n])
            return lg[n](e, h, " ");
        if (hg[t])
            return hg[t](e, h, " ")
    }
    return _v().formatNumber(Number(e), h)
}
  , VR = (e="", t="") => e.split(/(\s+)/).map( (r, i) => i === 0 ? `${r}${t}` : r).join("")
  , jR = (e, t, r, i) => {
    const n = Px(zR(e), t);
    let s = n;
    if (Number(n) >= hu) {
        if (s = kp(Number(n) / hu, 2, 4),
        r && t) {
            s = Af(s, t);
            const o = s.charAt(s.length - 1);
            if (s && Number.isNaN(Number(o)))
                return VR(s, b_)
        }
        return `${s}${b_}`
    }
    return r && t && (s = Af(n, t)),
    i && Number.isInteger(Number(s)) ? String(Number.parseInt(s, 10)) : String(s)
}
  , dK = (e, t, r) => {
    const i = Number(Px(zR(e), t));
    let n = i;
    if (i >= hu && i < yh)
        return jR(e, t, r);
    if (i >= yh) {
        if (n = kp(i / yh, 2, 4),
        r && t) {
            n = Af(n, t);
            const s = n.charAt(n.length - 1);
            if (n && Number.isNaN(Number(s)))
                return VR(n, C_)
        }
        return `${n}${C_}`
    }
    return r && t && (n = Af(i, t)),
    String(n)
}
  , fK = e => Number(parseFloat(String(e).split(" ")[0]))
  , FW = (e, t=1, r="") => {
    const i = new ZS(Number(Px(e, r)))
      , n = new ZS(Number(WR(t)));
    return i.times(n).toNumber()
}
  , UW = (e, t=1, r="") => {
    const i = FW(e, t, r);
    return jR(i, r)
}
;
class uu {
    constructor() {
        this.minX = 1 / 0,
        this.minY = 1 / 0,
        this.maxX = -1 / 0,
        this.maxY = -1 / 0,
        this.rect = null,
        this.updateID = -1
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }
    clear() {
        this.minX = 1 / 0,
        this.minY = 1 / 0,
        this.maxX = -1 / 0,
        this.maxY = -1 / 0
    }
    getRectangle(t) {
        return this.minX > this.maxX || this.minY > this.maxY ? lt.EMPTY : (t = t || new lt(0,0,1,1),
        t.x = this.minX,
        t.y = this.minY,
        t.width = this.maxX - this.minX,
        t.height = this.maxY - this.minY,
        t)
    }
    addPoint(t) {
        this.minX = Math.min(this.minX, t.x),
        this.maxX = Math.max(this.maxX, t.x),
        this.minY = Math.min(this.minY, t.y),
        this.maxY = Math.max(this.maxY, t.y)
    }
    addPointMatrix(t, r) {
        const {a: i, b: n, c: s, d: o, tx: a, ty: l} = t
          , h = i * r.x + s * r.y + a
          , u = n * r.x + o * r.y + l;
        this.minX = Math.min(this.minX, h),
        this.maxX = Math.max(this.maxX, h),
        this.minY = Math.min(this.minY, u),
        this.maxY = Math.max(this.maxY, u)
    }
    addQuad(t) {
        let r = this.minX
          , i = this.minY
          , n = this.maxX
          , s = this.maxY
          , o = t[0]
          , a = t[1];
        r = o < r ? o : r,
        i = a < i ? a : i,
        n = o > n ? o : n,
        s = a > s ? a : s,
        o = t[2],
        a = t[3],
        r = o < r ? o : r,
        i = a < i ? a : i,
        n = o > n ? o : n,
        s = a > s ? a : s,
        o = t[4],
        a = t[5],
        r = o < r ? o : r,
        i = a < i ? a : i,
        n = o > n ? o : n,
        s = a > s ? a : s,
        o = t[6],
        a = t[7],
        r = o < r ? o : r,
        i = a < i ? a : i,
        n = o > n ? o : n,
        s = a > s ? a : s,
        this.minX = r,
        this.minY = i,
        this.maxX = n,
        this.maxY = s
    }
    addFrame(t, r, i, n, s) {
        this.addFrameMatrix(t.worldTransform, r, i, n, s)
    }
    addFrameMatrix(t, r, i, n, s) {
        const o = t.a
          , a = t.b
          , l = t.c
          , h = t.d
          , u = t.tx
          , c = t.ty;
        let d = this.minX
          , f = this.minY
          , g = this.maxX
          , p = this.maxY
          , v = o * r + l * i + u
          , y = a * r + h * i + c;
        d = v < d ? v : d,
        f = y < f ? y : f,
        g = v > g ? v : g,
        p = y > p ? y : p,
        v = o * n + l * i + u,
        y = a * n + h * i + c,
        d = v < d ? v : d,
        f = y < f ? y : f,
        g = v > g ? v : g,
        p = y > p ? y : p,
        v = o * r + l * s + u,
        y = a * r + h * s + c,
        d = v < d ? v : d,
        f = y < f ? y : f,
        g = v > g ? v : g,
        p = y > p ? y : p,
        v = o * n + l * s + u,
        y = a * n + h * s + c,
        d = v < d ? v : d,
        f = y < f ? y : f,
        g = v > g ? v : g,
        p = y > p ? y : p,
        this.minX = d,
        this.minY = f,
        this.maxX = g,
        this.maxY = p
    }
    addVertexData(t, r, i) {
        let n = this.minX
          , s = this.minY
          , o = this.maxX
          , a = this.maxY;
        for (let l = r; l < i; l += 2) {
            const h = t[l]
              , u = t[l + 1];
            n = h < n ? h : n,
            s = u < s ? u : s,
            o = h > o ? h : o,
            a = u > a ? u : a
        }
        this.minX = n,
        this.minY = s,
        this.maxX = o,
        this.maxY = a
    }
    addVertices(t, r, i, n) {
        this.addVerticesMatrix(t.worldTransform, r, i, n)
    }
    addVerticesMatrix(t, r, i, n, s=0, o=s) {
        const a = t.a
          , l = t.b
          , h = t.c
          , u = t.d
          , c = t.tx
          , d = t.ty;
        let f = this.minX
          , g = this.minY
          , p = this.maxX
          , v = this.maxY;
        for (let y = i; y < n; y += 2) {
            const m = r[y]
              , _ = r[y + 1]
              , x = a * m + h * _ + c
              , E = u * _ + l * m + d;
            f = Math.min(f, x - s),
            p = Math.max(p, x + s),
            g = Math.min(g, E - o),
            v = Math.max(v, E + o)
        }
        this.minX = f,
        this.minY = g,
        this.maxX = p,
        this.maxY = v
    }
    addBounds(t) {
        const r = this.minX
          , i = this.minY
          , n = this.maxX
          , s = this.maxY;
        this.minX = t.minX < r ? t.minX : r,
        this.minY = t.minY < i ? t.minY : i,
        this.maxX = t.maxX > n ? t.maxX : n,
        this.maxY = t.maxY > s ? t.maxY : s
    }
    addBoundsMask(t, r) {
        const i = t.minX > r.minX ? t.minX : r.minX
          , n = t.minY > r.minY ? t.minY : r.minY
          , s = t.maxX < r.maxX ? t.maxX : r.maxX
          , o = t.maxY < r.maxY ? t.maxY : r.maxY;
        if (i <= s && n <= o) {
            const a = this.minX
              , l = this.minY
              , h = this.maxX
              , u = this.maxY;
            this.minX = i < a ? i : a,
            this.minY = n < l ? n : l,
            this.maxX = s > h ? s : h,
            this.maxY = o > u ? o : u
        }
    }
    addBoundsMatrix(t, r) {
        this.addFrameMatrix(r, t.minX, t.minY, t.maxX, t.maxY)
    }
    addBoundsArea(t, r) {
        const i = t.minX > r.x ? t.minX : r.x
          , n = t.minY > r.y ? t.minY : r.y
          , s = t.maxX < r.x + r.width ? t.maxX : r.x + r.width
          , o = t.maxY < r.y + r.height ? t.maxY : r.y + r.height;
        if (i <= s && n <= o) {
            const a = this.minX
              , l = this.minY
              , h = this.maxX
              , u = this.maxY;
            this.minX = i < a ? i : a,
            this.minY = n < l ? n : l,
            this.maxX = s > h ? s : h,
            this.maxY = o > u ? o : u
        }
    }
    pad(t=0, r=t) {
        this.isEmpty() || (this.minX -= t,
        this.maxX += t,
        this.minY -= r,
        this.maxY += r)
    }
    addFramePad(t, r, i, n, s, o) {
        t -= s,
        r -= o,
        i += s,
        n += o,
        this.minX = this.minX < t ? this.minX : t,
        this.maxX = this.maxX > i ? this.maxX : i,
        this.minY = this.minY < r ? this.minY : r,
        this.maxY = this.maxY > n ? this.maxY : n
    }
}
class zt extends ci {
    constructor() {
        super(),
        this.tempDisplayObjectParent = null,
        this.transform = new Gu,
        this.alpha = 1,
        this.visible = !0,
        this.renderable = !0,
        this.cullable = !1,
        this.cullArea = null,
        this.parent = null,
        this.worldAlpha = 1,
        this._lastSortedIndex = 0,
        this._zIndex = 0,
        this.filterArea = null,
        this.filters = null,
        this._enabledFilters = null,
        this._bounds = new uu,
        this._localBounds = null,
        this._boundsID = 0,
        this._boundsRect = null,
        this._localBoundsRect = null,
        this._mask = null,
        this._maskRefCount = 0,
        this._destroyed = !1,
        this.isSprite = !1,
        this.isMask = !1
    }
    static mixin(t) {
        const r = Object.keys(t);
        for (let i = 0; i < r.length; ++i) {
            const n = r[i];
            Object.defineProperty(zt.prototype, n, Object.getOwnPropertyDescriptor(t, n))
        }
    }
    get destroyed() {
        return this._destroyed
    }
    _recursivePostUpdateTransform() {
        this.parent ? (this.parent._recursivePostUpdateTransform(),
        this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
    }
    updateTransform() {
        this._boundsID++,
        this.transform.updateTransform(this.parent.transform),
        this.worldAlpha = this.alpha * this.parent.worldAlpha
    }
    getBounds(t, r) {
        return t || (this.parent ? (this._recursivePostUpdateTransform(),
        this.updateTransform()) : (this.parent = this._tempDisplayObjectParent,
        this.updateTransform(),
        this.parent = null)),
        this._bounds.updateID !== this._boundsID && (this.calculateBounds(),
        this._bounds.updateID = this._boundsID),
        r || (this._boundsRect || (this._boundsRect = new lt),
        r = this._boundsRect),
        this._bounds.getRectangle(r)
    }
    getLocalBounds(t) {
        t || (this._localBoundsRect || (this._localBoundsRect = new lt),
        t = this._localBoundsRect),
        this._localBounds || (this._localBounds = new uu);
        const r = this.transform
          , i = this.parent;
        this.parent = null,
        this._tempDisplayObjectParent.worldAlpha = i?.worldAlpha ?? 1,
        this.transform = this._tempDisplayObjectParent.transform;
        const n = this._bounds
          , s = this._boundsID;
        this._bounds = this._localBounds;
        const o = this.getBounds(!1, t);
        return this.parent = i,
        this.transform = r,
        this._bounds = n,
        this._bounds.updateID += this._boundsID - s,
        o
    }
    toGlobal(t, r, i=!1) {
        return i || (this._recursivePostUpdateTransform(),
        this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
        this.displayObjectUpdateTransform(),
        this.parent = null)),
        this.worldTransform.apply(t, r)
    }
    toLocal(t, r, i, n) {
        return r && (t = r.toGlobal(t, i, n)),
        n || (this._recursivePostUpdateTransform(),
        this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
        this.displayObjectUpdateTransform(),
        this.parent = null)),
        this.worldTransform.applyInverse(t, i)
    }
    setParent(t) {
        if (!t || !t.addChild)
            throw new Error("setParent: Argument must be a Container");
        return t.addChild(this),
        t
    }
    removeFromParent() {
        this.parent?.removeChild(this)
    }
    setTransform(t=0, r=0, i=1, n=1, s=0, o=0, a=0, l=0, h=0) {
        return this.position.x = t,
        this.position.y = r,
        this.scale.x = i || 1,
        this.scale.y = n || 1,
        this.rotation = s,
        this.skew.x = o,
        this.skew.y = a,
        this.pivot.x = l,
        this.pivot.y = h,
        this
    }
    destroy(t) {
        this.removeFromParent(),
        this._destroyed = !0,
        this.transform = null,
        this.parent = null,
        this._bounds = null,
        this.mask = null,
        this.cullArea = null,
        this.filters = null,
        this.filterArea = null,
        this.hitArea = null,
        this.eventMode = "auto",
        this.interactiveChildren = !1,
        this.emit("destroyed"),
        this.removeAllListeners()
    }
    get _tempDisplayObjectParent() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new XR),
        this.tempDisplayObjectParent
    }
    enableTempParent() {
        const t = this.parent;
        return this.parent = this._tempDisplayObjectParent,
        t
    }
    disableTempParent(t) {
        this.parent = t
    }
    get x() {
        return this.position.x
    }
    set x(t) {
        this.transform.position.x = t
    }
    get y() {
        return this.position.y
    }
    set y(t) {
        this.transform.position.y = t
    }
    get worldTransform() {
        return this.transform.worldTransform
    }
    get localTransform() {
        return this.transform.localTransform
    }
    get position() {
        return this.transform.position
    }
    set position(t) {
        this.transform.position.copyFrom(t)
    }
    get scale() {
        return this.transform.scale
    }
    set scale(t) {
        this.transform.scale.copyFrom(t)
    }
    get pivot() {
        return this.transform.pivot
    }
    set pivot(t) {
        this.transform.pivot.copyFrom(t)
    }
    get skew() {
        return this.transform.skew
    }
    set skew(t) {
        this.transform.skew.copyFrom(t)
    }
    get rotation() {
        return this.transform.rotation
    }
    set rotation(t) {
        this.transform.rotation = t
    }
    get angle() {
        return this.transform.rotation * MI
    }
    set angle(t) {
        this.transform.rotation = t * OI
    }
    get zIndex() {
        return this._zIndex
    }
    set zIndex(t) {
        this._zIndex = t,
        this.parent && (this.parent.sortDirty = !0)
    }
    get worldVisible() {
        let t = this;
        do {
            if (!t.visible)
                return !1;
            t = t.parent
        } while (t);
        return !0
    }
    get mask() {
        return this._mask
    }
    set mask(t) {
        if (this._mask !== t) {
            if (this._mask) {
                const r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                r && (r._maskRefCount--,
                r._maskRefCount === 0 && (r.renderable = !0,
                r.isMask = !1))
            }
            if (this._mask = t,
            this._mask) {
                const r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                r && (r._maskRefCount === 0 && (r.renderable = !1,
                r.isMask = !0),
                r._maskRefCount++)
            }
        }
    }
}
class XR extends zt {
    constructor() {
        super(...arguments),
        this.sortDirty = null
    }
}
zt.prototype.displayObjectUpdateTransform = zt.prototype.updateTransform;
const GW = new Mt;
function HW(e, t) {
    return e.zIndex === t.zIndex ? e._lastSortedIndex - t._lastSortedIndex : e.zIndex - t.zIndex
}
const YR = class P_ extends zt {
    constructor() {
        super(),
        this.children = [],
        this.sortableChildren = P_.defaultSortableChildren,
        this.sortDirty = !1
    }
    onChildrenChange(t) {}
    addChild(...t) {
        if (t.length > 1)
            for (let r = 0; r < t.length; r++)
                this.addChild(t[r]);
        else {
            const r = t[0];
            r.parent && r.parent.removeChild(r),
            r.parent = this,
            this.sortDirty = !0,
            r.transform._parentID = -1,
            this.children.push(r),
            this._boundsID++,
            this.onChildrenChange(this.children.length - 1),
            this.emit("childAdded", r, this, this.children.length - 1),
            r.emit("added", this)
        }
        return t[0]
    }
    addChildAt(t, r) {
        if (r < 0 || r > this.children.length)
            throw new Error(`${t}addChildAt: The index ${r} supplied is out of bounds ${this.children.length}`);
        return t.parent && t.parent.removeChild(t),
        t.parent = this,
        this.sortDirty = !0,
        t.transform._parentID = -1,
        this.children.splice(r, 0, t),
        this._boundsID++,
        this.onChildrenChange(r),
        t.emit("added", this),
        this.emit("childAdded", t, this, r),
        t
    }
    swapChildren(t, r) {
        if (t === r)
            return;
        const i = this.getChildIndex(t)
          , n = this.getChildIndex(r);
        this.children[i] = r,
        this.children[n] = t,
        this.onChildrenChange(i < n ? i : n)
    }
    getChildIndex(t) {
        const r = this.children.indexOf(t);
        if (r === -1)
            throw new Error("The supplied DisplayObject must be a child of the caller");
        return r
    }
    setChildIndex(t, r) {
        if (r < 0 || r >= this.children.length)
            throw new Error(`The index ${r} supplied is out of bounds ${this.children.length}`);
        const i = this.getChildIndex(t);
        mo(this.children, i, 1),
        this.children.splice(r, 0, t),
        this.onChildrenChange(r)
    }
    getChildAt(t) {
        if (t < 0 || t >= this.children.length)
            throw new Error(`getChildAt: Index (${t}) does not exist.`);
        return this.children[t]
    }
    removeChild(...t) {
        if (t.length > 1)
            for (let r = 0; r < t.length; r++)
                this.removeChild(t[r]);
        else {
            const r = t[0]
              , i = this.children.indexOf(r);
            if (i === -1)
                return null;
            r.parent = null,
            r.transform._parentID = -1,
            mo(this.children, i, 1),
            this._boundsID++,
            this.onChildrenChange(i),
            r.emit("removed", this),
            this.emit("childRemoved", r, this, i)
        }
        return t[0]
    }
    removeChildAt(t) {
        const r = this.getChildAt(t);
        return r.parent = null,
        r.transform._parentID = -1,
        mo(this.children, t, 1),
        this._boundsID++,
        this.onChildrenChange(t),
        r.emit("removed", this),
        this.emit("childRemoved", r, this, t),
        r
    }
    removeChildren(t=0, r=this.children.length) {
        const i = t
          , n = r
          , s = n - i;
        let o;
        if (s > 0 && s <= n) {
            o = this.children.splice(i, s);
            for (let a = 0; a < o.length; ++a)
                o[a].parent = null,
                o[a].transform && (o[a].transform._parentID = -1);
            this._boundsID++,
            this.onChildrenChange(t);
            for (let a = 0; a < o.length; ++a)
                o[a].emit("removed", this),
                this.emit("childRemoved", o[a], this, a);
            return o
        } else if (s === 0 && this.children.length === 0)
            return [];
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
    }
    sortChildren() {
        let t = !1;
        for (let r = 0, i = this.children.length; r < i; ++r) {
            const n = this.children[r];
            n._lastSortedIndex = r,
            !t && n.zIndex !== 0 && (t = !0)
        }
        t && this.children.length > 1 && this.children.sort(HW),
        this.sortDirty = !1
    }
    updateTransform() {
        this.sortableChildren && this.sortDirty && this.sortChildren(),
        this._boundsID++,
        this.transform.updateTransform(this.parent.transform),
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (let t = 0, r = this.children.length; t < r; ++t) {
            const i = this.children[t];
            i.visible && i.updateTransform()
        }
    }
    calculateBounds() {
        this._bounds.clear(),
        this._calculateBounds();
        for (let t = 0; t < this.children.length; t++) {
            const r = this.children[t];
            if (!(!r.visible || !r.renderable))
                if (r.calculateBounds(),
                r._mask) {
                    const i = r._mask.isMaskData ? r._mask.maskObject : r._mask;
                    i ? (i.calculateBounds(),
                    this._bounds.addBoundsMask(r._bounds, i._bounds)) : this._bounds.addBounds(r._bounds)
                } else
                    r.filterArea ? this._bounds.addBoundsArea(r._bounds, r.filterArea) : this._bounds.addBounds(r._bounds)
        }
        this._bounds.updateID = this._boundsID
    }
    getLocalBounds(t, r=!1) {
        const i = super.getLocalBounds(t);
        if (!r)
            for (let n = 0, s = this.children.length; n < s; ++n) {
                const o = this.children[n];
                o.visible && o.updateTransform()
            }
        return i
    }
    _calculateBounds() {}
    _renderWithCulling(t) {
        const r = t.renderTexture.sourceFrame;
        if (!(r.width > 0 && r.height > 0))
            return;
        let i, n;
        this.cullArea ? (i = this.cullArea,
        n = this.worldTransform) : this._render !== P_.prototype._render && (i = this.getBounds(!0));
        const s = t.projection.transform;
        if (s && (n ? (n = GW.copyFrom(n),
        n.prepend(s)) : n = s),
        i && r.intersects(i, n))
            this._render(t);
        else if (this.cullArea)
            return;
        for (let o = 0, a = this.children.length; o < a; ++o) {
            const l = this.children[o]
              , h = l.cullable;
            l.cullable = h || !this.cullArea,
            l.render(t),
            l.cullable = h
        }
    }
    render(t) {
        if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
            if (this._mask || this.filters?.length)
                this.renderAdvanced(t);
            else if (this.cullable)
                this._renderWithCulling(t);
            else {
                this._render(t);
                for (let r = 0, i = this.children.length; r < i; ++r)
                    this.children[r].render(t)
            }
    }
    renderAdvanced(t) {
        const r = this.filters
          , i = this._mask;
        if (r) {
            this._enabledFilters || (this._enabledFilters = []),
            this._enabledFilters.length = 0;
            for (let s = 0; s < r.length; s++)
                r[s].enabled && this._enabledFilters.push(r[s])
        }
        const n = r && this._enabledFilters?.length || i && (!i.isMaskData || i.enabled && (i.autoDetect || i.type !== he.NONE));
        if (n && t.batch.flush(),
        r && this._enabledFilters?.length && t.filter.push(this, this._enabledFilters),
        i && t.mask.push(this, this._mask),
        this.cullable)
            this._renderWithCulling(t);
        else {
            this._render(t);
            for (let s = 0, o = this.children.length; s < o; ++s)
                this.children[s].render(t)
        }
        n && t.batch.flush(),
        i && t.mask.pop(this),
        r && this._enabledFilters?.length && t.filter.pop()
    }
    _render(t) {}
    destroy(t) {
        super.destroy(),
        this.sortDirty = !1;
        const r = typeof t == "boolean" ? t : t?.children
          , i = this.removeChildren(0, this.children.length);
        if (r)
            for (let n = 0; n < i.length; ++n)
                i[n].destroy(t)
    }
    get width() {
        return this.scale.x * this.getLocalBounds().width
    }
    set width(t) {
        const r = this.getLocalBounds().width;
        r !== 0 ? this.scale.x = t / r : this.scale.x = 1,
        this._width = t
    }
    get height() {
        return this.scale.y * this.getLocalBounds().height
    }
    set height(t) {
        const r = this.getLocalBounds().height;
        r !== 0 ? this.scale.y = t / r : this.scale.y = 1,
        this._height = t
    }
}
;
YR.defaultSortableChildren = !1;
let J = YR;
J.prototype.containerUpdateTransform = J.prototype.updateTransform;
Object.defineProperties(z, {
    SORTABLE_CHILDREN: {
        get() {
            return J.defaultSortableChildren
        },
        set(e) {
            et("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"),
            J.defaultSortableChildren = e
        }
    }
});
const Nl = new st
  , $W = new Uint16Array([0, 1, 2, 0, 2, 3]);
class at extends J {
    constructor(t) {
        super(),
        this._anchor = new Ji(this._onAnchorUpdate,this,t ? t.defaultAnchor.x : 0,t ? t.defaultAnchor.y : 0),
        this._texture = null,
        this._width = 0,
        this._height = 0,
        this._tintColor = new xt(16777215),
        this._tintRGB = null,
        this.tint = 16777215,
        this.blendMode = tt.NORMAL,
        this._cachedTint = 16777215,
        this.uvs = null,
        this.texture = t || F.EMPTY,
        this.vertexData = new Float32Array(8),
        this.vertexTrimmedData = null,
        this._transformID = -1,
        this._textureID = -1,
        this._transformTrimmedID = -1,
        this._textureTrimmedID = -1,
        this.indices = $W,
        this.pluginName = "batch",
        this.isSprite = !0,
        this._roundPixels = z.ROUND_PIXELS
    }
    _onTextureUpdate() {
        this._textureID = -1,
        this._textureTrimmedID = -1,
        this._cachedTint = 16777215,
        this._width && (this.scale.x = In(this.scale.x) * this._width / this._texture.orig.width),
        this._height && (this.scale.y = In(this.scale.y) * this._height / this._texture.orig.height)
    }
    _onAnchorUpdate() {
        this._transformID = -1,
        this._transformTrimmedID = -1
    }
    calculateVertices() {
        const t = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === t._updateID)
            return;
        this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32),
        this._transformID = this.transform._worldID,
        this._textureID = t._updateID;
        const r = this.transform.worldTransform
          , i = r.a
          , n = r.b
          , s = r.c
          , o = r.d
          , a = r.tx
          , l = r.ty
          , h = this.vertexData
          , u = t.trim
          , c = t.orig
          , d = this._anchor;
        let f = 0
          , g = 0
          , p = 0
          , v = 0;
        if (u ? (g = u.x - d._x * c.width,
        f = g + u.width,
        v = u.y - d._y * c.height,
        p = v + u.height) : (g = -d._x * c.width,
        f = g + c.width,
        v = -d._y * c.height,
        p = v + c.height),
        h[0] = i * g + s * v + a,
        h[1] = o * v + n * g + l,
        h[2] = i * f + s * v + a,
        h[3] = o * v + n * f + l,
        h[4] = i * f + s * p + a,
        h[5] = o * p + n * f + l,
        h[6] = i * g + s * p + a,
        h[7] = o * p + n * g + l,
        this._roundPixels) {
            const y = z.RESOLUTION;
            for (let m = 0; m < h.length; ++m)
                h[m] = Math.round(h[m] * y) / y
        }
    }
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData)
            this.vertexTrimmedData = new Float32Array(8);
        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
            return;
        this._transformTrimmedID = this.transform._worldID,
        this._textureTrimmedID = this._texture._updateID;
        const t = this._texture
          , r = this.vertexTrimmedData
          , i = t.orig
          , n = this._anchor
          , s = this.transform.worldTransform
          , o = s.a
          , a = s.b
          , l = s.c
          , h = s.d
          , u = s.tx
          , c = s.ty
          , d = -n._x * i.width
          , f = d + i.width
          , g = -n._y * i.height
          , p = g + i.height;
        if (r[0] = o * d + l * g + u,
        r[1] = h * g + a * d + c,
        r[2] = o * f + l * g + u,
        r[3] = h * g + a * f + c,
        r[4] = o * f + l * p + u,
        r[5] = h * p + a * f + c,
        r[6] = o * d + l * p + u,
        r[7] = h * p + a * d + c,
        this._roundPixels) {
            const v = z.RESOLUTION;
            for (let y = 0; y < r.length; ++y)
                r[y] = Math.round(r[y] * v) / v
        }
    }
    _render(t) {
        this.calculateVertices(),
        t.batch.setObjectRenderer(t.plugins[this.pluginName]),
        t.plugins[this.pluginName].render(this)
    }
    _calculateBounds() {
        const t = this._texture.trim
          , r = this._texture.orig;
        !t || t.width === r.width && t.height === r.height ? (this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(),
        this._bounds.addQuad(this.vertexTrimmedData))
    }
    getLocalBounds(t) {
        return this.children.length === 0 ? (this._localBounds || (this._localBounds = new uu),
        this._localBounds.minX = this._texture.orig.width * -this._anchor._x,
        this._localBounds.minY = this._texture.orig.height * -this._anchor._y,
        this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x),
        this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y),
        t || (this._localBoundsRect || (this._localBoundsRect = new lt),
        t = this._localBoundsRect),
        this._localBounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, Nl);
        const r = this._texture.orig.width
          , i = this._texture.orig.height
          , n = -r * this.anchor.x;
        let s = 0;
        return Nl.x >= n && Nl.x < n + r && (s = -i * this.anchor.y,
        Nl.y >= s && Nl.y < s + i)
    }
    destroy(t) {
        if (super.destroy(t),
        this._texture.off("update", this._onTextureUpdate, this),
        this._anchor = null,
        typeof t == "boolean" ? t : t?.texture) {
            const r = typeof t == "boolean" ? t : t?.baseTexture;
            this._texture.destroy(!!r)
        }
        this._texture = null
    }
    static from(t, r) {
        const i = t instanceof F ? t : F.from(t, r);
        return new at(i)
    }
    set roundPixels(t) {
        this._roundPixels !== t && (this._transformID = -1,
        this._transformTrimmedID = -1),
        this._roundPixels = t
    }
    get roundPixels() {
        return this._roundPixels
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(t) {
        const r = In(this.scale.x) || 1;
        this.scale.x = r * t / this._texture.orig.width,
        this._width = t
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(t) {
        const r = In(this.scale.y) || 1;
        this.scale.y = r * t / this._texture.orig.height,
        this._height = t
    }
    get anchor() {
        return this._anchor
    }
    set anchor(t) {
        this._anchor.copyFrom(t)
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        this._tintColor.setValue(t),
        this._tintRGB = this._tintColor.toLittleEndianNumber()
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this),
        this._texture = t || F.EMPTY,
        this._cachedTint = 16777215,
        this._textureID = -1,
        this._textureTrimmedID = -1,
        t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
    }
}
const KR = new Mt;
zt.prototype._cacheAsBitmap = !1;
zt.prototype._cacheData = null;
zt.prototype._cacheAsBitmapResolution = null;
zt.prototype._cacheAsBitmapMultisample = null;
class zW {
    constructor() {
        this.textureCacheId = null,
        this.originalRender = null,
        this.originalRenderCanvas = null,
        this.originalCalculateBounds = null,
        this.originalGetLocalBounds = null,
        this.originalUpdateTransform = null,
        this.originalDestroy = null,
        this.originalMask = null,
        this.originalFilterArea = null,
        this.originalContainsPoint = null,
        this.sprite = null
    }
}
Object.defineProperties(zt.prototype, {
    cacheAsBitmapResolution: {
        get() {
            return this._cacheAsBitmapResolution
        },
        set(e) {
            e !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = e,
            this.cacheAsBitmap && (this.cacheAsBitmap = !1,
            this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmapMultisample: {
        get() {
            return this._cacheAsBitmapMultisample
        },
        set(e) {
            e !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = e,
            this.cacheAsBitmap && (this.cacheAsBitmap = !1,
            this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmap: {
        get() {
            return this._cacheAsBitmap
        },
        set(e) {
            if (this._cacheAsBitmap === e)
                return;
            this._cacheAsBitmap = e;
            let t;
            e ? (this._cacheData || (this._cacheData = new zW),
            t = this._cacheData,
            t.originalRender = this.render,
            t.originalRenderCanvas = this.renderCanvas,
            t.originalUpdateTransform = this.updateTransform,
            t.originalCalculateBounds = this.calculateBounds,
            t.originalGetLocalBounds = this.getLocalBounds,
            t.originalDestroy = this.destroy,
            t.originalContainsPoint = this.containsPoint,
            t.originalMask = this._mask,
            t.originalFilterArea = this.filterArea,
            this.render = this._renderCached,
            this.renderCanvas = this._renderCachedCanvas,
            this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData,
            t.sprite && this._destroyCachedDisplayObject(),
            this.render = t.originalRender,
            this.renderCanvas = t.originalRenderCanvas,
            this.calculateBounds = t.originalCalculateBounds,
            this.getLocalBounds = t.originalGetLocalBounds,
            this.destroy = t.originalDestroy,
            this.updateTransform = t.originalUpdateTransform,
            this.containsPoint = t.originalContainsPoint,
            this._mask = t.originalMask,
            this.filterArea = t.originalFilterArea)
        }
    }
});
zt.prototype._renderCached = function(e) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(e),
    this._cacheData.sprite.transform._worldID = this.transform._worldID,
    this._cacheData.sprite.worldAlpha = this.worldAlpha,
    this._cacheData.sprite._render(e))
}
;
zt.prototype._initCachedDisplayObject = function(e) {
    if (this._cacheData?.sprite)
        return;
    const t = this.alpha;
    this.alpha = 1,
    e.batch.flush();
    const r = this.getLocalBounds(new lt, !0);
    if (this.filters?.length) {
        const d = this.filters[0].padding;
        r.pad(d)
    }
    const i = this.cacheAsBitmapResolution || e.resolution;
    r.ceil(i),
    r.width = Math.max(r.width, 1 / i),
    r.height = Math.max(r.height, 1 / i);
    const n = e.renderTexture.current
      , s = e.renderTexture.sourceFrame.clone()
      , o = e.renderTexture.destinationFrame.clone()
      , a = e.projection.transform
      , l = Gs.create({
        width: r.width,
        height: r.height,
        resolution: i,
        multisample: this.cacheAsBitmapMultisample ?? e.multisample
    })
      , h = `cacheAsBitmap_${Is()}`;
    this._cacheData.textureCacheId = h,
    nt.addToCache(l.baseTexture, h),
    F.addToCache(l, h);
    const u = this.transform.localTransform.copyTo(KR).invert().translate(-r.x, -r.y);
    this.render = this._cacheData.originalRender,
    e.render(this, {
        renderTexture: l,
        clear: !0,
        transform: u,
        skipUpdateTransform: !1
    }),
    e.framebuffer.blit(),
    e.projection.transform = a,
    e.renderTexture.bind(n, s, o),
    this.render = this._renderCached,
    this.updateTransform = this.displayObjectUpdateTransform,
    this.calculateBounds = this._calculateCachedBounds,
    this.getLocalBounds = this._getCachedLocalBounds,
    this._mask = null,
    this.filterArea = null,
    this.alpha = t;
    const c = new at(l);
    c.transform.worldTransform = this.transform.worldTransform,
    c.anchor.x = -(r.x / r.width),
    c.anchor.y = -(r.y / r.height),
    c.alpha = t,
    c._bounds = this._bounds,
    this._cacheData.sprite = c,
    this.transform._parentID = -1,
    this.parent ? this.updateTransform() : (this.enableTempParent(),
    this.updateTransform(),
    this.disableTempParent(null)),
    this.containsPoint = c.containsPoint.bind(c)
}
;
zt.prototype._renderCachedCanvas = function(e) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(e),
    this._cacheData.sprite.worldAlpha = this.worldAlpha,
    this._cacheData.sprite._renderCanvas(e))
}
;
zt.prototype._initCachedDisplayObjectCanvas = function(e) {
    if (this._cacheData?.sprite)
        return;
    const t = this.getLocalBounds(new lt, !0)
      , r = this.alpha;
    this.alpha = 1;
    const i = e.canvasContext.activeContext
      , n = e._projTransform
      , s = this.cacheAsBitmapResolution || e.resolution;
    t.ceil(s),
    t.width = Math.max(t.width, 1 / s),
    t.height = Math.max(t.height, 1 / s);
    const o = Gs.create({
        width: t.width,
        height: t.height,
        resolution: s
    })
      , a = `cacheAsBitmap_${Is()}`;
    this._cacheData.textureCacheId = a,
    nt.addToCache(o.baseTexture, a),
    F.addToCache(o, a);
    const l = KR;
    this.transform.localTransform.copyTo(l),
    l.invert(),
    l.tx -= t.x,
    l.ty -= t.y,
    this.renderCanvas = this._cacheData.originalRenderCanvas,
    e.render(this, {
        renderTexture: o,
        clear: !0,
        transform: l,
        skipUpdateTransform: !1
    }),
    e.canvasContext.activeContext = i,
    e._projTransform = n,
    this.renderCanvas = this._renderCachedCanvas,
    this.updateTransform = this.displayObjectUpdateTransform,
    this.calculateBounds = this._calculateCachedBounds,
    this.getLocalBounds = this._getCachedLocalBounds,
    this._mask = null,
    this.filterArea = null,
    this.alpha = r;
    const h = new at(o);
    h.transform.worldTransform = this.transform.worldTransform,
    h.anchor.x = -(t.x / t.width),
    h.anchor.y = -(t.y / t.height),
    h.alpha = r,
    h._bounds = this._bounds,
    this._cacheData.sprite = h,
    this.transform._parentID = -1,
    this.parent ? this.updateTransform() : (this.parent = e._tempDisplayObjectParent,
    this.updateTransform(),
    this.parent = null),
    this.containsPoint = h.containsPoint.bind(h)
}
;
zt.prototype._calculateCachedBounds = function() {
    this._bounds.clear(),
    this._cacheData.sprite.transform._worldID = this.transform._worldID,
    this._cacheData.sprite._calculateBounds(),
    this._bounds.updateID = this._boundsID
}
;
zt.prototype._getCachedLocalBounds = function() {
    return this._cacheData.sprite.getLocalBounds(null)
}
;
zt.prototype._destroyCachedDisplayObject = function() {
    this._cacheData.sprite._texture.destroy(!0),
    this._cacheData.sprite = null,
    nt.removeFromCache(this._cacheData.textureCacheId),
    F.removeFromCache(this._cacheData.textureCacheId),
    this._cacheData.textureCacheId = null
}
;
zt.prototype._cacheAsBitmapDestroy = function(e) {
    this.cacheAsBitmap = !1,
    this.destroy(e)
}
;
zt.prototype.name = null;
J.prototype.getChildByName = function(e, t) {
    for (let r = 0, i = this.children.length; r < i; r++)
        if (this.children[r].name === e)
            return this.children[r];
    if (t)
        for (let r = 0, i = this.children.length; r < i; r++) {
            const n = this.children[r];
            if (!n.getChildByName)
                continue;
            const s = n.getChildByName(e, !0);
            if (s)
                return s
        }
    return null
}
;
zt.prototype.getGlobalPosition = function(e=new st, t=!1) {
    return this.parent ? this.parent.toGlobal(this.position, e, t) : (e.x = this.position.x,
    e.y = this.position.y),
    e
}
;
var WW = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
class Ix extends ze {
    constructor(t=1) {
        super(aR, WW, {
            uAlpha: 1
        }),
        this.alpha = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
const VW = {
    5: [.153388, .221461, .250301],
    7: [.071303, .131514, .189879, .214607],
    9: [.028532, .067234, .124009, .179044, .20236],
    11: [.0093, .028002, .065984, .121703, .175713, .198596],
    13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
    15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
}
  , jW = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join(`
`);
function XW(e) {
    const t = VW[e]
      , r = t.length;
    let i = jW
      , n = "";
    const s = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let a = 0; a < e; a++) {
        let l = s.replace("%index%", a.toString());
        o = a,
        a >= r && (o = e - a - 1),
        l = l.replace("%value%", t[o].toString()),
        n += l,
        n += `
`
    }
    return i = i.replace("%blur%", n),
    i = i.replace("%size%", e.toString()),
    i
}
const YW = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function KW(e, t) {
    const r = Math.ceil(e / 2);
    let i = YW, n = "", s;
    t ? s = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : s = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    for (let o = 0; o < e; o++) {
        let a = s.replace("%index%", o.toString());
        a = a.replace("%sampleIndex%", `${o - (r - 1)}.0`),
        n += a,
        n += `
`
    }
    return i = i.replace("%blur%", n),
    i = i.replace("%size%", e.toString()),
    i
}
class bf extends ze {
    constructor(t, r=8, i=4, n=ze.defaultResolution, s=5) {
        const o = KW(s, t)
          , a = XW(s);
        super(o, a),
        this.horizontal = t,
        this.resolution = n,
        this._quality = 0,
        this.quality = i,
        this.blur = r
    }
    apply(t, r, i, n) {
        if (i ? this.horizontal ? this.uniforms.strength = 1 / i.width * (i.width / r.width) : this.uniforms.strength = 1 / i.height * (i.height / r.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / r.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / r.height),
        this.uniforms.strength *= this.strength,
        this.uniforms.strength /= this.passes,
        this.passes === 1)
            t.applyFilter(this, r, i, n);
        else {
            const s = t.getFilterTexture()
              , o = t.renderer;
            let a = r
              , l = s;
            this.state.blend = !1,
            t.applyFilter(this, a, l, vi.CLEAR);
            for (let h = 1; h < this.passes - 1; h++) {
                t.bindAndClear(a, vi.BLIT),
                this.uniforms.uSampler = l;
                const u = l;
                l = a,
                a = u,
                o.shader.bind(this),
                o.geometry.draw(5)
            }
            this.state.blend = !0,
            t.applyFilter(this, l, i, n),
            t.returnFilterTexture(s)
        }
    }
    get blur() {
        return this.strength
    }
    set blur(t) {
        this.padding = 1 + Math.abs(t) * 2,
        this.strength = t
    }
    get quality() {
        return this._quality
    }
    set quality(t) {
        this._quality = t,
        this.passes = t
    }
}
class qR extends ze {
    constructor(t=8, r=4, i=ze.defaultResolution, n=5) {
        super(),
        this._repeatEdgePixels = !1,
        this.blurXFilter = new bf(!0,t,r,i,n),
        this.blurYFilter = new bf(!1,t,r,i,n),
        this.resolution = i,
        this.quality = r,
        this.blur = t,
        this.repeatEdgePixels = !1
    }
    apply(t, r, i, n) {
        const s = Math.abs(this.blurXFilter.strength)
          , o = Math.abs(this.blurYFilter.strength);
        if (s && o) {
            const a = t.getFilterTexture();
            this.blurXFilter.apply(t, r, a, vi.CLEAR),
            this.blurYFilter.apply(t, a, i, n),
            t.returnFilterTexture(a)
        } else
            o ? this.blurYFilter.apply(t, r, i, n) : this.blurXFilter.apply(t, r, i, n)
    }
    updatePadding() {
        this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2
    }
    get blur() {
        return this.blurXFilter.blur
    }
    set blur(t) {
        this.blurXFilter.blur = this.blurYFilter.blur = t,
        this.updatePadding()
    }
    get quality() {
        return this.blurXFilter.quality
    }
    set quality(t) {
        this.blurXFilter.quality = this.blurYFilter.quality = t
    }
    get blurX() {
        return this.blurXFilter.blur
    }
    set blurX(t) {
        this.blurXFilter.blur = t,
        this.updatePadding()
    }
    get blurY() {
        return this.blurYFilter.blur
    }
    set blurY(t) {
        this.blurYFilter.blur = t,
        this.updatePadding()
    }
    get blendMode() {
        return this.blurYFilter.blendMode
    }
    set blendMode(t) {
        this.blurYFilter.blendMode = t
    }
    get repeatEdgePixels() {
        return this._repeatEdgePixels
    }
    set repeatEdgePixels(t) {
        this._repeatEdgePixels = t,
        this.updatePadding()
    }
}
var qW = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
class Cf extends ze {
    constructor() {
        const t = {
            m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
            uAlpha: 1
        };
        super(Ex, qW, t),
        this.alpha = 1
    }
    _loadMatrix(t, r=!1) {
        let i = t;
        r && (this._multiply(i, this.uniforms.m, t),
        i = this._colorMatrix(i)),
        this.uniforms.m = i
    }
    _multiply(t, r, i) {
        return t[0] = r[0] * i[0] + r[1] * i[5] + r[2] * i[10] + r[3] * i[15],
        t[1] = r[0] * i[1] + r[1] * i[6] + r[2] * i[11] + r[3] * i[16],
        t[2] = r[0] * i[2] + r[1] * i[7] + r[2] * i[12] + r[3] * i[17],
        t[3] = r[0] * i[3] + r[1] * i[8] + r[2] * i[13] + r[3] * i[18],
        t[4] = r[0] * i[4] + r[1] * i[9] + r[2] * i[14] + r[3] * i[19] + r[4],
        t[5] = r[5] * i[0] + r[6] * i[5] + r[7] * i[10] + r[8] * i[15],
        t[6] = r[5] * i[1] + r[6] * i[6] + r[7] * i[11] + r[8] * i[16],
        t[7] = r[5] * i[2] + r[6] * i[7] + r[7] * i[12] + r[8] * i[17],
        t[8] = r[5] * i[3] + r[6] * i[8] + r[7] * i[13] + r[8] * i[18],
        t[9] = r[5] * i[4] + r[6] * i[9] + r[7] * i[14] + r[8] * i[19] + r[9],
        t[10] = r[10] * i[0] + r[11] * i[5] + r[12] * i[10] + r[13] * i[15],
        t[11] = r[10] * i[1] + r[11] * i[6] + r[12] * i[11] + r[13] * i[16],
        t[12] = r[10] * i[2] + r[11] * i[7] + r[12] * i[12] + r[13] * i[17],
        t[13] = r[10] * i[3] + r[11] * i[8] + r[12] * i[13] + r[13] * i[18],
        t[14] = r[10] * i[4] + r[11] * i[9] + r[12] * i[14] + r[13] * i[19] + r[14],
        t[15] = r[15] * i[0] + r[16] * i[5] + r[17] * i[10] + r[18] * i[15],
        t[16] = r[15] * i[1] + r[16] * i[6] + r[17] * i[11] + r[18] * i[16],
        t[17] = r[15] * i[2] + r[16] * i[7] + r[17] * i[12] + r[18] * i[17],
        t[18] = r[15] * i[3] + r[16] * i[8] + r[17] * i[13] + r[18] * i[18],
        t[19] = r[15] * i[4] + r[16] * i[9] + r[17] * i[14] + r[18] * i[19] + r[19],
        t
    }
    _colorMatrix(t) {
        const r = new Float32Array(t);
        return r[4] /= 255,
        r[9] /= 255,
        r[14] /= 255,
        r[19] /= 255,
        r
    }
    brightness(t, r) {
        const i = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, r)
    }
    tint(t, r) {
        const [i,n,s] = xt.shared.setValue(t).toArray()
          , o = [i, 0, 0, 0, 0, 0, n, 0, 0, 0, 0, 0, s, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(o, r)
    }
    greyscale(t, r) {
        const i = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, r)
    }
    blackAndWhite(t) {
        const r = [.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    hue(t, r) {
        t = (t || 0) / 180 * Math.PI;
        const i = Math.cos(t)
          , n = Math.sin(t)
          , s = Math.sqrt
          , o = 1 / 3
          , a = s(o)
          , l = i + (1 - i) * o
          , h = o * (1 - i) - a * n
          , u = o * (1 - i) + a * n
          , c = o * (1 - i) + a * n
          , d = i + o * (1 - i)
          , f = o * (1 - i) - a * n
          , g = o * (1 - i) - a * n
          , p = o * (1 - i) + a * n
          , v = i + o * (1 - i)
          , y = [l, h, u, 0, 0, c, d, f, 0, 0, g, p, v, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(y, r)
    }
    contrast(t, r) {
        const i = (t || 0) + 1
          , n = -.5 * (i - 1)
          , s = [i, 0, 0, 0, n, 0, i, 0, 0, n, 0, 0, i, 0, n, 0, 0, 0, 1, 0];
        this._loadMatrix(s, r)
    }
    saturate(t=0, r) {
        const i = t * 2 / 3 + 1
          , n = (i - 1) * -.5
          , s = [i, n, n, 0, 0, n, i, n, 0, 0, n, n, i, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, r)
    }
    desaturate() {
        this.saturate(-1)
    }
    negative(t) {
        const r = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    sepia(t) {
        const r = [.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    technicolor(t) {
        const r = [1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    polaroid(t) {
        const r = [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    toBGR(t) {
        const r = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    kodachrome(t) {
        const r = [1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    browni(t) {
        const r = [.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    vintage(t) {
        const r = [.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    colorTone(t, r, i, n, s) {
        t = t || .2,
        r = r || .15,
        i = i || 16770432,
        n = n || 3375104;
        const o = xt.shared
          , [a,l,h] = o.setValue(i).toArray()
          , [u,c,d] = o.setValue(n).toArray()
          , f = [.3, .59, .11, 0, 0, a, l, h, t, 0, u, c, d, r, 0, a - u, l - c, h - d, 0, 0];
        this._loadMatrix(f, s)
    }
    night(t, r) {
        t = t || .1;
        const i = [t * -2, -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, t * 2, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, r)
    }
    predator(t, r) {
        const i = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
        this._loadMatrix(i, r)
    }
    lsd(t) {
        const r = [2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    reset() {
        const t = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(t, !1)
    }
    get matrix() {
        return this.uniforms.m
    }
    set matrix(t) {
        this.uniforms.m = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
Cf.prototype.grayscale = Cf.prototype.greyscale;
var ZW = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`
  , QW = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
class Rx extends ze {
    constructor(t, r) {
        const i = new Mt;
        t.renderable = !1,
        super(QW, ZW, {
            mapSampler: t._texture,
            filterMatrix: i,
            scale: {
                x: 1,
                y: 1
            },
            rotation: new Float32Array([1, 0, 0, 1])
        }),
        this.maskSprite = t,
        this.maskMatrix = i,
        r == null && (r = 20),
        this.scale = new st(r,r)
    }
    apply(t, r, i, n) {
        this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite),
        this.uniforms.scale.x = this.scale.x,
        this.uniforms.scale.y = this.scale.y;
        const s = this.maskSprite.worldTransform
          , o = Math.sqrt(s.a * s.a + s.b * s.b)
          , a = Math.sqrt(s.c * s.c + s.d * s.d);
        o !== 0 && a !== 0 && (this.uniforms.rotation[0] = s.a / o,
        this.uniforms.rotation[1] = s.b / o,
        this.uniforms.rotation[2] = s.c / a,
        this.uniforms.rotation[3] = s.d / a),
        t.applyFilter(this, r, i, n)
    }
    get map() {
        return this.uniforms.mapSampler
    }
    set map(t) {
        this.uniforms.mapSampler = t
    }
}
var JW = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`
  , tV = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
class ZR extends ze {
    constructor() {
        super(tV, JW)
    }
}
var eV = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
class QR extends ze {
    constructor(t=.5, r=Math.random()) {
        super(Ex, eV, {
            uNoise: 0,
            uSeed: 0
        }),
        this.noise = t,
        this.seed = r
    }
    get noise() {
        return this.uniforms.uNoise
    }
    set noise(t) {
        this.uniforms.uNoise = t
    }
    get seed() {
        return this.uniforms.uSeed
    }
    set seed(t) {
        this.uniforms.uSeed = t
    }
}
const I_ = {
    AlphaFilter: Ix,
    BlurFilter: qR,
    BlurFilterPass: bf,
    ColorMatrixFilter: Cf,
    DisplacementFilter: Rx,
    FXAAFilter: ZR,
    NoiseFilter: QR
};
Object.entries(I_).forEach( ([e,t]) => {
    Object.defineProperty(I_, e, {
        get() {
            return et("7.1.0", `filters.${e} has moved to ${e}`),
            t
        }
    })
}
);
class rV {
    constructor() {
        this.interactionFrequency = 10,
        this._deltaTime = 0,
        this._didMove = !1,
        this.tickerAdded = !1,
        this._pauseUpdate = !0
    }
    init(t) {
        this.removeTickerListener(),
        this.events = t,
        this.interactionFrequency = 10,
        this._deltaTime = 0,
        this._didMove = !1,
        this.tickerAdded = !1,
        this._pauseUpdate = !0
    }
    get pauseUpdate() {
        return this._pauseUpdate
    }
    set pauseUpdate(t) {
        this._pauseUpdate = t
    }
    addTickerListener() {
        this.tickerAdded || !this.domElement || ($t.system.add(this.tickerUpdate, this, Hn.INTERACTION),
        this.tickerAdded = !0)
    }
    removeTickerListener() {
        this.tickerAdded && ($t.system.remove(this.tickerUpdate, this),
        this.tickerAdded = !1)
    }
    pointerMoved() {
        this._didMove = !0
    }
    update() {
        if (!this.domElement || this._pauseUpdate)
            return;
        if (this._didMove) {
            this._didMove = !1;
            return
        }
        const t = this.events.rootPointerEvent;
        this.events.supportsTouchEvents && t.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove",{
            clientX: t.clientX,
            clientY: t.clientY
        }))
    }
    tickerUpdate(t) {
        this._deltaTime += t,
        !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0,
        this.update())
    }
}
const os = new rV;
class yl {
    constructor(t) {
        this.bubbles = !0,
        this.cancelBubble = !0,
        this.cancelable = !1,
        this.composed = !1,
        this.defaultPrevented = !1,
        this.eventPhase = yl.prototype.NONE,
        this.propagationStopped = !1,
        this.propagationImmediatelyStopped = !1,
        this.layer = new st,
        this.page = new st,
        this.NONE = 0,
        this.CAPTURING_PHASE = 1,
        this.AT_TARGET = 2,
        this.BUBBLING_PHASE = 3,
        this.manager = t
    }
    get layerX() {
        return this.layer.x
    }
    get layerY() {
        return this.layer.y
    }
    get pageX() {
        return this.page.x
    }
    get pageY() {
        return this.page.y
    }
    get data() {
        return this
    }
    composedPath() {
        return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []),
        this.path
    }
    initEvent(t, r, i) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    initUIEvent(t, r, i, n, s) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(),
        this.defaultPrevented = !0
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
class cu extends yl {
    constructor() {
        super(...arguments),
        this.client = new st,
        this.movement = new st,
        this.offset = new st,
        this.global = new st,
        this.screen = new st
    }
    get clientX() {
        return this.client.x
    }
    get clientY() {
        return this.client.y
    }
    get x() {
        return this.clientX
    }
    get y() {
        return this.clientY
    }
    get movementX() {
        return this.movement.x
    }
    get movementY() {
        return this.movement.y
    }
    get offsetX() {
        return this.offset.x
    }
    get offsetY() {
        return this.offset.y
    }
    get globalX() {
        return this.global.x
    }
    get globalY() {
        return this.global.y
    }
    get screenX() {
        return this.screen.x
    }
    get screenY() {
        return this.screen.y
    }
    getLocalPosition(t, r, i) {
        return t.worldTransform.applyInverse(i || this.global, r)
    }
    getModifierState(t) {
        return "getModifierState"in this.nativeEvent && this.nativeEvent.getModifierState(t)
    }
    initMouseEvent(t, r, i, n, s, o, a, l, h, u, c, d, f, g, p) {
        throw new Error("Method not implemented.")
    }
}
class Hr extends cu {
    constructor() {
        super(...arguments),
        this.width = 0,
        this.height = 0,
        this.isPrimary = !1
    }
    getCoalescedEvents() {
        return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
    }
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!")
    }
}
class yo extends cu {
    constructor() {
        super(...arguments),
        this.DOM_DELTA_PIXEL = 0,
        this.DOM_DELTA_LINE = 1,
        this.DOM_DELTA_PAGE = 2
    }
}
yo.DOM_DELTA_PIXEL = 0,
yo.DOM_DELTA_LINE = 1,
yo.DOM_DELTA_PAGE = 2;
const iV = 2048
  , nV = new st
  , ug = new st;
class JR {
    constructor(t) {
        this.dispatch = new ci,
        this.moveOnAll = !1,
        this.enableGlobalMoveEvents = !0,
        this.mappingState = {
            trackingData: {}
        },
        this.eventPool = new Map,
        this._allInteractiveElements = [],
        this._hitElements = [],
        this._isPointerMoveEvent = !1,
        this.rootTarget = t,
        this.hitPruneFn = this.hitPruneFn.bind(this),
        this.hitTestFn = this.hitTestFn.bind(this),
        this.mapPointerDown = this.mapPointerDown.bind(this),
        this.mapPointerMove = this.mapPointerMove.bind(this),
        this.mapPointerOut = this.mapPointerOut.bind(this),
        this.mapPointerOver = this.mapPointerOver.bind(this),
        this.mapPointerUp = this.mapPointerUp.bind(this),
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this),
        this.mapWheel = this.mapWheel.bind(this),
        this.mappingTable = {},
        this.addEventMapping("pointerdown", this.mapPointerDown),
        this.addEventMapping("pointermove", this.mapPointerMove),
        this.addEventMapping("pointerout", this.mapPointerOut),
        this.addEventMapping("pointerleave", this.mapPointerOut),
        this.addEventMapping("pointerover", this.mapPointerOver),
        this.addEventMapping("pointerup", this.mapPointerUp),
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
        this.addEventMapping("wheel", this.mapWheel)
    }
    addEventMapping(t, r) {
        this.mappingTable[t] || (this.mappingTable[t] = []),
        this.mappingTable[t].push({
            fn: r,
            priority: 0
        }),
        this.mappingTable[t].sort( (i, n) => i.priority - n.priority)
    }
    dispatchEvent(t, r) {
        t.propagationStopped = !1,
        t.propagationImmediatelyStopped = !1,
        this.propagate(t, r),
        this.dispatch.emit(r || t.type, t)
    }
    mapEvent(t) {
        if (!this.rootTarget)
            return;
        const r = this.mappingTable[t.type];
        if (r)
            for (let i = 0, n = r.length; i < n; i++)
                r[i].fn(t);
        else
            console.warn(`[EventBoundary]: Event mapping not defined for ${t.type}`)
    }
    hitTest(t, r) {
        os.pauseUpdate = !0;
        const i = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"
          , n = this[i](this.rootTarget, this.rootTarget.eventMode, nV.set(t, r), this.hitTestFn, this.hitPruneFn);
        return n && n[0]
    }
    propagate(t, r) {
        if (!t.target)
            return;
        const i = t.composedPath();
        t.eventPhase = t.CAPTURING_PHASE;
        for (let n = 0, s = i.length - 1; n < s; n++)
            if (t.currentTarget = i[n],
            this.notifyTarget(t, r),
            t.propagationStopped || t.propagationImmediatelyStopped)
                return;
        if (t.eventPhase = t.AT_TARGET,
        t.currentTarget = t.target,
        this.notifyTarget(t, r),
        !(t.propagationStopped || t.propagationImmediatelyStopped)) {
            t.eventPhase = t.BUBBLING_PHASE;
            for (let n = i.length - 2; n >= 0; n--)
                if (t.currentTarget = i[n],
                this.notifyTarget(t, r),
                t.propagationStopped || t.propagationImmediatelyStopped)
                    return
        }
    }
    all(t, r, i=this._allInteractiveElements) {
        if (i.length === 0)
            return;
        t.eventPhase = t.BUBBLING_PHASE;
        const n = Array.isArray(r) ? r : [r];
        for (let s = i.length - 1; s >= 0; s--)
            n.forEach(o => {
                t.currentTarget = i[s],
                this.notifyTarget(t, o)
            }
            )
    }
    propagationPath(t) {
        const r = [t];
        for (let i = 0; i < iV && t !== this.rootTarget; i++) {
            if (!t.parent)
                throw new Error("Cannot find propagation path to disconnected target");
            r.push(t.parent),
            t = t.parent
        }
        return r.reverse(),
        r
    }
    hitTestMoveRecursive(t, r, i, n, s, o=!1) {
        let a = !1;
        if (this._interactivePrune(t))
            return null;
        if ((t.eventMode === "dynamic" || r === "dynamic") && (os.pauseUpdate = !1),
        t.interactiveChildren && t.children) {
            const u = t.children;
            for (let c = u.length - 1; c >= 0; c--) {
                const d = u[c]
                  , f = this.hitTestMoveRecursive(d, this._isInteractive(r) ? r : d.eventMode, i, n, s, o || s(t, i));
                if (f) {
                    if (f.length > 0 && !f[f.length - 1].parent)
                        continue;
                    const g = t.isInteractive();
                    (f.length > 0 || g) && (g && this._allInteractiveElements.push(t),
                    f.push(t)),
                    this._hitElements.length === 0 && (this._hitElements = f),
                    a = !0
                }
            }
        }
        const l = this._isInteractive(r)
          , h = t.isInteractive();
        return h && h && this._allInteractiveElements.push(t),
        o || this._hitElements.length > 0 ? null : a ? this._hitElements : l && !s(t, i) && n(t, i) ? h ? [t] : [] : null
    }
    hitTestRecursive(t, r, i, n, s) {
        if (this._interactivePrune(t) || s(t, i))
            return null;
        if ((t.eventMode === "dynamic" || r === "dynamic") && (os.pauseUpdate = !1),
        t.interactiveChildren && t.children) {
            const l = t.children;
            for (let h = l.length - 1; h >= 0; h--) {
                const u = l[h]
                  , c = this.hitTestRecursive(u, this._isInteractive(r) ? r : u.eventMode, i, n, s);
                if (c) {
                    if (c.length > 0 && !c[c.length - 1].parent)
                        continue;
                    const d = t.isInteractive();
                    return (c.length > 0 || d) && c.push(t),
                    c
                }
            }
        }
        const o = this._isInteractive(r)
          , a = t.isInteractive();
        return o && n(t, i) ? a ? [t] : [] : null
    }
    _isInteractive(t) {
        return t === "static" || t === "dynamic"
    }
    _interactivePrune(t) {
        return !!(!t || t.isMask || !t.visible || !t.renderable || t.eventMode === "none" || t.eventMode === "passive" && !t.interactiveChildren || t.isMask)
    }
    hitPruneFn(t, r) {
        if (t.hitArea && (t.worldTransform.applyInverse(r, ug),
        !t.hitArea.contains(ug.x, ug.y)))
            return !0;
        if (t._mask) {
            const i = t._mask.isMaskData ? t._mask.maskObject : t._mask;
            if (i && !i.containsPoint?.(r))
                return !0
        }
        return !1
    }
    hitTestFn(t, r) {
        return t.eventMode === "passive" ? !1 : t.hitArea ? !0 : t.containsPoint ? t.containsPoint(r) : !1
    }
    notifyTarget(t, r) {
        r = r ?? t.type;
        const i = `on${r}`;
        t.currentTarget[i]?.(t);
        const n = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${r}capture` : r;
        this.notifyListeners(t, n),
        t.eventPhase === t.AT_TARGET && this.notifyListeners(t, r)
    }
    mapPointerDown(t) {
        if (!(t instanceof Hr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const r = this.createPointerEvent(t);
        if (this.dispatchEvent(r, "pointerdown"),
        r.pointerType === "touch")
            this.dispatchEvent(r, "touchstart");
        else if (r.pointerType === "mouse" || r.pointerType === "pen") {
            const n = r.button === 2;
            this.dispatchEvent(r, n ? "rightdown" : "mousedown")
        }
        const i = this.trackingData(t.pointerId);
        i.pressTargetsByButton[t.button] = r.composedPath(),
        this.freeEvent(r)
    }
    mapPointerMove(t) {
        if (!(t instanceof Hr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        this._allInteractiveElements.length = 0,
        this._hitElements.length = 0,
        this._isPointerMoveEvent = !0;
        const r = this.createPointerEvent(t);
        this._isPointerMoveEvent = !1;
        const i = r.pointerType === "mouse" || r.pointerType === "pen"
          , n = this.trackingData(t.pointerId)
          , s = this.findMountedTarget(n.overTargets);
        if (n.overTargets?.length > 0 && s !== r.target) {
            const l = t.type === "mousemove" ? "mouseout" : "pointerout"
              , h = this.createPointerEvent(t, l, s);
            if (this.dispatchEvent(h, "pointerout"),
            i && this.dispatchEvent(h, "mouseout"),
            !r.composedPath().includes(s)) {
                const u = this.createPointerEvent(t, "pointerleave", s);
                for (u.eventPhase = u.AT_TARGET; u.target && !r.composedPath().includes(u.target); )
                    u.currentTarget = u.target,
                    this.notifyTarget(u),
                    i && this.notifyTarget(u, "mouseleave"),
                    u.target = u.target.parent;
                this.freeEvent(u)
            }
            this.freeEvent(h)
        }
        if (s !== r.target) {
            const l = t.type === "mousemove" ? "mouseover" : "pointerover"
              , h = this.clonePointerEvent(r, l);
            this.dispatchEvent(h, "pointerover"),
            i && this.dispatchEvent(h, "mouseover");
            let u = s?.parent;
            for (; u && u !== this.rootTarget.parent && u !== r.target; )
                u = u.parent;
            if (!u || u === this.rootTarget.parent) {
                const c = this.clonePointerEvent(r, "pointerenter");
                for (c.eventPhase = c.AT_TARGET; c.target && c.target !== s && c.target !== this.rootTarget.parent; )
                    c.currentTarget = c.target,
                    this.notifyTarget(c),
                    i && this.notifyTarget(c, "mouseenter"),
                    c.target = c.target.parent;
                this.freeEvent(c)
            }
            this.freeEvent(h)
        }
        const o = []
          , a = this.enableGlobalMoveEvents ?? !0;
        this.moveOnAll ? o.push("pointermove") : this.dispatchEvent(r, "pointermove"),
        a && o.push("globalpointermove"),
        r.pointerType === "touch" && (this.moveOnAll ? o.splice(1, 0, "touchmove") : this.dispatchEvent(r, "touchmove"),
        a && o.push("globaltouchmove")),
        i && (this.moveOnAll ? o.splice(1, 0, "mousemove") : this.dispatchEvent(r, "mousemove"),
        a && o.push("globalmousemove"),
        this.cursor = r.target?.cursor),
        o.length > 0 && this.all(r, o),
        this._allInteractiveElements.length = 0,
        this._hitElements.length = 0,
        n.overTargets = r.composedPath(),
        this.freeEvent(r)
    }
    mapPointerOver(t) {
        if (!(t instanceof Hr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const r = this.trackingData(t.pointerId)
          , i = this.createPointerEvent(t)
          , n = i.pointerType === "mouse" || i.pointerType === "pen";
        this.dispatchEvent(i, "pointerover"),
        n && this.dispatchEvent(i, "mouseover"),
        i.pointerType === "mouse" && (this.cursor = i.target?.cursor);
        const s = this.clonePointerEvent(i, "pointerenter");
        for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent; )
            s.currentTarget = s.target,
            this.notifyTarget(s),
            n && this.notifyTarget(s, "mouseenter"),
            s.target = s.target.parent;
        r.overTargets = i.composedPath(),
        this.freeEvent(i),
        this.freeEvent(s)
    }
    mapPointerOut(t) {
        if (!(t instanceof Hr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const r = this.trackingData(t.pointerId);
        if (r.overTargets) {
            const i = t.pointerType === "mouse" || t.pointerType === "pen"
              , n = this.findMountedTarget(r.overTargets)
              , s = this.createPointerEvent(t, "pointerout", n);
            this.dispatchEvent(s),
            i && this.dispatchEvent(s, "mouseout");
            const o = this.createPointerEvent(t, "pointerleave", n);
            for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent; )
                o.currentTarget = o.target,
                this.notifyTarget(o),
                i && this.notifyTarget(o, "mouseleave"),
                o.target = o.target.parent;
            r.overTargets = null,
            this.freeEvent(s),
            this.freeEvent(o)
        }
        this.cursor = null
    }
    mapPointerUp(t) {
        if (!(t instanceof Hr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const r = performance.now()
          , i = this.createPointerEvent(t);
        if (this.dispatchEvent(i, "pointerup"),
        i.pointerType === "touch")
            this.dispatchEvent(i, "touchend");
        else if (i.pointerType === "mouse" || i.pointerType === "pen") {
            const a = i.button === 2;
            this.dispatchEvent(i, a ? "rightup" : "mouseup")
        }
        const n = this.trackingData(t.pointerId)
          , s = this.findMountedTarget(n.pressTargetsByButton[t.button]);
        let o = s;
        if (s && !i.composedPath().includes(s)) {
            let a = s;
            for (; a && !i.composedPath().includes(a); ) {
                if (i.currentTarget = a,
                this.notifyTarget(i, "pointerupoutside"),
                i.pointerType === "touch")
                    this.notifyTarget(i, "touchendoutside");
                else if (i.pointerType === "mouse" || i.pointerType === "pen") {
                    const l = i.button === 2;
                    this.notifyTarget(i, l ? "rightupoutside" : "mouseupoutside")
                }
                a = a.parent
            }
            delete n.pressTargetsByButton[t.button],
            o = a
        }
        if (o) {
            const a = this.clonePointerEvent(i, "click");
            a.target = o,
            a.path = null,
            n.clicksByButton[t.button] || (n.clicksByButton[t.button] = {
                clickCount: 0,
                target: a.target,
                timeStamp: r
            });
            const l = n.clicksByButton[t.button];
            if (l.target === a.target && r - l.timeStamp < 200 ? ++l.clickCount : l.clickCount = 1,
            l.target = a.target,
            l.timeStamp = r,
            a.detail = l.clickCount,
            a.pointerType === "mouse") {
                const h = a.button === 2;
                this.dispatchEvent(a, h ? "rightclick" : "click")
            } else
                a.pointerType === "touch" && this.dispatchEvent(a, "tap");
            this.dispatchEvent(a, "pointertap"),
            this.freeEvent(a)
        }
        this.freeEvent(i)
    }
    mapPointerUpOutside(t) {
        if (!(t instanceof Hr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const r = this.trackingData(t.pointerId)
          , i = this.findMountedTarget(r.pressTargetsByButton[t.button])
          , n = this.createPointerEvent(t);
        if (i) {
            let s = i;
            for (; s; )
                n.currentTarget = s,
                this.notifyTarget(n, "pointerupoutside"),
                n.pointerType === "touch" ? this.notifyTarget(n, "touchendoutside") : (n.pointerType === "mouse" || n.pointerType === "pen") && this.notifyTarget(n, n.button === 2 ? "rightupoutside" : "mouseupoutside"),
                s = s.parent;
            delete r.pressTargetsByButton[t.button]
        }
        this.freeEvent(n)
    }
    mapWheel(t) {
        if (!(t instanceof yo)) {
            console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return
        }
        const r = this.createWheelEvent(t);
        this.dispatchEvent(r),
        this.freeEvent(r)
    }
    findMountedTarget(t) {
        if (!t)
            return null;
        let r = t[0];
        for (let i = 1; i < t.length && t[i].parent === r; i++)
            r = t[i];
        return r
    }
    createPointerEvent(t, r, i) {
        const n = this.allocateEvent(Hr);
        return this.copyPointerData(t, n),
        this.copyMouseData(t, n),
        this.copyData(t, n),
        n.nativeEvent = t.nativeEvent,
        n.originalEvent = t,
        n.target = i ?? this.hitTest(n.global.x, n.global.y) ?? this._hitElements[0],
        typeof r == "string" && (n.type = r),
        n
    }
    createWheelEvent(t) {
        const r = this.allocateEvent(yo);
        return this.copyWheelData(t, r),
        this.copyMouseData(t, r),
        this.copyData(t, r),
        r.nativeEvent = t.nativeEvent,
        r.originalEvent = t,
        r.target = this.hitTest(r.global.x, r.global.y),
        r
    }
    clonePointerEvent(t, r) {
        const i = this.allocateEvent(Hr);
        return i.nativeEvent = t.nativeEvent,
        i.originalEvent = t.originalEvent,
        this.copyPointerData(t, i),
        this.copyMouseData(t, i),
        this.copyData(t, i),
        i.target = t.target,
        i.path = t.composedPath().slice(),
        i.type = r ?? i.type,
        i
    }
    copyWheelData(t, r) {
        r.deltaMode = t.deltaMode,
        r.deltaX = t.deltaX,
        r.deltaY = t.deltaY,
        r.deltaZ = t.deltaZ
    }
    copyPointerData(t, r) {
        t instanceof Hr && r instanceof Hr && (r.pointerId = t.pointerId,
        r.width = t.width,
        r.height = t.height,
        r.isPrimary = t.isPrimary,
        r.pointerType = t.pointerType,
        r.pressure = t.pressure,
        r.tangentialPressure = t.tangentialPressure,
        r.tiltX = t.tiltX,
        r.tiltY = t.tiltY,
        r.twist = t.twist)
    }
    copyMouseData(t, r) {
        t instanceof cu && r instanceof cu && (r.altKey = t.altKey,
        r.button = t.button,
        r.buttons = t.buttons,
        r.client.copyFrom(t.client),
        r.ctrlKey = t.ctrlKey,
        r.metaKey = t.metaKey,
        r.movement.copyFrom(t.movement),
        r.screen.copyFrom(t.screen),
        r.shiftKey = t.shiftKey,
        r.global.copyFrom(t.global))
    }
    copyData(t, r) {
        r.isTrusted = t.isTrusted,
        r.srcElement = t.srcElement,
        r.timeStamp = performance.now(),
        r.type = t.type,
        r.detail = t.detail,
        r.view = t.view,
        r.which = t.which,
        r.layer.copyFrom(t.layer),
        r.page.copyFrom(t.page)
    }
    trackingData(t) {
        return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }),
        this.mappingState.trackingData[t]
    }
    allocateEvent(t) {
        this.eventPool.has(t) || this.eventPool.set(t, []);
        const r = this.eventPool.get(t).pop() || new t(this);
        return r.eventPhase = r.NONE,
        r.currentTarget = null,
        r.path = null,
        r.target = null,
        r
    }
    freeEvent(t) {
        if (t.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const r = t.constructor;
        this.eventPool.has(r) || this.eventPool.set(r, []),
        this.eventPool.get(r).push(t)
    }
    notifyListeners(t, r) {
        const i = t.currentTarget._events[r];
        if (i && t.currentTarget.isInteractive())
            if ("fn"in i)
                i.once && t.currentTarget.removeListener(r, i.fn, void 0, !0),
                i.fn.call(i.context, t);
            else
                for (let n = 0, s = i.length; n < s && !t.propagationImmediatelyStopped; n++)
                    i[n].once && t.currentTarget.removeListener(r, i[n].fn, void 0, !0),
                    i[n].fn.call(i[n].context, t)
    }
}
const sV = 1
  , oV = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
}
  , R_ = class M_ {
    constructor(t) {
        this.supportsTouchEvents = "ontouchstart"in globalThis,
        this.supportsPointerEvents = !!globalThis.PointerEvent,
        this.domElement = null,
        this.resolution = 1,
        this.renderer = t,
        this.rootBoundary = new JR(null),
        os.init(this),
        this.autoPreventDefault = !0,
        this.eventsAdded = !1,
        this.rootPointerEvent = new Hr(null),
        this.rootWheelEvent = new yo(null),
        this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
        },
        this.features = new Proxy({
            ...M_.defaultEventFeatures
        },{
            set: (r, i, n) => (i === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = n),
            r[i] = n,
            !0)
        }),
        this.onPointerDown = this.onPointerDown.bind(this),
        this.onPointerMove = this.onPointerMove.bind(this),
        this.onPointerUp = this.onPointerUp.bind(this),
        this.onPointerOverOut = this.onPointerOverOut.bind(this),
        this.onWheel = this.onWheel.bind(this)
    }
    static get defaultEventMode() {
        return this._defaultEventMode
    }
    init(t) {
        const {view: r, resolution: i} = this.renderer;
        this.setTargetElement(r),
        this.resolution = i,
        M_._defaultEventMode = t.eventMode ?? "auto",
        Object.assign(this.features, t.eventFeatures ?? {}),
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
    }
    resolutionChange(t) {
        this.resolution = t
    }
    destroy() {
        this.setTargetElement(null),
        this.renderer = null
    }
    setCursor(t) {
        t = t || "default";
        let r = !0;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (r = !1),
        this.currentCursor === t)
            return;
        this.currentCursor = t;
        const i = this.cursorStyles[t];
        if (i)
            switch (typeof i) {
            case "string":
                r && (this.domElement.style.cursor = i);
                break;
            case "function":
                i(t);
                break;
            case "object":
                r && Object.assign(this.domElement.style, i);
                break
            }
        else
            r && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t)
    }
    get pointer() {
        return this.rootPointerEvent
    }
    onPointerDown(t) {
        if (!this.features.click)
            return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const r = this.normalizeToPointerData(t);
        this.autoPreventDefault && r[0].isNormalized && (t.cancelable || !("cancelable"in t)) && t.preventDefault();
        for (let i = 0, n = r.length; i < n; i++) {
            const s = r[i]
              , o = this.bootstrapEvent(this.rootPointerEvent, s);
            this.rootBoundary.mapEvent(o)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerMove(t) {
        if (!this.features.move)
            return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        os.pointerMoved();
        const r = this.normalizeToPointerData(t);
        for (let i = 0, n = r.length; i < n; i++) {
            const s = this.bootstrapEvent(this.rootPointerEvent, r[i]);
            this.rootBoundary.mapEvent(s)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerUp(t) {
        if (!this.features.click)
            return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let r = t.target;
        t.composedPath && t.composedPath().length > 0 && (r = t.composedPath()[0]);
        const i = r !== this.domElement ? "outside" : ""
          , n = this.normalizeToPointerData(t);
        for (let s = 0, o = n.length; s < o; s++) {
            const a = this.bootstrapEvent(this.rootPointerEvent, n[s]);
            a.type += i,
            this.rootBoundary.mapEvent(a)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerOverOut(t) {
        if (!this.features.click)
            return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const r = this.normalizeToPointerData(t);
        for (let i = 0, n = r.length; i < n; i++) {
            const s = this.bootstrapEvent(this.rootPointerEvent, r[i]);
            this.rootBoundary.mapEvent(s)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onWheel(t) {
        if (!this.features.wheel)
            return;
        const r = this.normalizeWheelEvent(t);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.rootBoundary.mapEvent(r)
    }
    setTargetElement(t) {
        this.removeEvents(),
        this.domElement = t,
        os.domElement = t,
        this.addEvents()
    }
    addEvents() {
        if (this.eventsAdded || !this.domElement)
            return;
        os.addTickerListener();
        const t = this.domElement.style;
        t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none",
        t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")),
        this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0),
        this.domElement.addEventListener("pointerdown", this.onPointerDown, !0),
        this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0),
        this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0),
        globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0),
        this.domElement.addEventListener("mousedown", this.onPointerDown, !0),
        this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0),
        this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0),
        globalThis.addEventListener("mouseup", this.onPointerUp, !0),
        this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0),
        this.domElement.addEventListener("touchend", this.onPointerUp, !0),
        this.domElement.addEventListener("touchmove", this.onPointerMove, !0))),
        this.domElement.addEventListener("wheel", this.onWheel, {
            passive: !0,
            capture: !0
        }),
        this.eventsAdded = !0
    }
    removeEvents() {
        if (!this.eventsAdded || !this.domElement)
            return;
        os.removeTickerListener();
        const t = this.domElement.style;
        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "",
        t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""),
        this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0),
        this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0),
        this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0),
        this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0),
        globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0),
        this.domElement.removeEventListener("mousedown", this.onPointerDown, !0),
        this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0),
        this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0),
        globalThis.removeEventListener("mouseup", this.onPointerUp, !0),
        this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0),
        this.domElement.removeEventListener("touchend", this.onPointerUp, !0),
        this.domElement.removeEventListener("touchmove", this.onPointerMove, !0))),
        this.domElement.removeEventListener("wheel", this.onWheel, !0),
        this.domElement = null,
        this.eventsAdded = !1
    }
    mapPositionToPoint(t, r, i) {
        const n = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
        }
          , s = 1 / this.resolution;
        t.x = (r - n.left) * (this.domElement.width / n.width) * s,
        t.y = (i - n.top) * (this.domElement.height / n.height) * s
    }
    normalizeToPointerData(t) {
        const r = [];
        if (this.supportsTouchEvents && t instanceof TouchEvent)
            for (let i = 0, n = t.changedTouches.length; i < n; i++) {
                const s = t.changedTouches[i];
                typeof s.button > "u" && (s.button = 0),
                typeof s.buttons > "u" && (s.buttons = 1),
                typeof s.isPrimary > "u" && (s.isPrimary = t.touches.length === 1 && t.type === "touchstart"),
                typeof s.width > "u" && (s.width = s.radiusX || 1),
                typeof s.height > "u" && (s.height = s.radiusY || 1),
                typeof s.tiltX > "u" && (s.tiltX = 0),
                typeof s.tiltY > "u" && (s.tiltY = 0),
                typeof s.pointerType > "u" && (s.pointerType = "touch"),
                typeof s.pointerId > "u" && (s.pointerId = s.identifier || 0),
                typeof s.pressure > "u" && (s.pressure = s.force || .5),
                typeof s.twist > "u" && (s.twist = 0),
                typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0),
                typeof s.layerX > "u" && (s.layerX = s.offsetX = s.clientX),
                typeof s.layerY > "u" && (s.layerY = s.offsetY = s.clientY),
                s.isNormalized = !0,
                s.type = t.type,
                r.push(s)
            }
        else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
            const i = t;
            typeof i.isPrimary > "u" && (i.isPrimary = !0),
            typeof i.width > "u" && (i.width = 1),
            typeof i.height > "u" && (i.height = 1),
            typeof i.tiltX > "u" && (i.tiltX = 0),
            typeof i.tiltY > "u" && (i.tiltY = 0),
            typeof i.pointerType > "u" && (i.pointerType = "mouse"),
            typeof i.pointerId > "u" && (i.pointerId = sV),
            typeof i.pressure > "u" && (i.pressure = .5),
            typeof i.twist > "u" && (i.twist = 0),
            typeof i.tangentialPressure > "u" && (i.tangentialPressure = 0),
            i.isNormalized = !0,
            r.push(i)
        } else
            r.push(t);
        return r
    }
    normalizeWheelEvent(t) {
        const r = this.rootWheelEvent;
        return this.transferMouseData(r, t),
        r.deltaX = t.deltaX,
        r.deltaY = t.deltaY,
        r.deltaZ = t.deltaZ,
        r.deltaMode = t.deltaMode,
        this.mapPositionToPoint(r.screen, t.clientX, t.clientY),
        r.global.copyFrom(r.screen),
        r.offset.copyFrom(r.screen),
        r.nativeEvent = t,
        r.type = t.type,
        r
    }
    bootstrapEvent(t, r) {
        return t.originalEvent = null,
        t.nativeEvent = r,
        t.pointerId = r.pointerId,
        t.width = r.width,
        t.height = r.height,
        t.isPrimary = r.isPrimary,
        t.pointerType = r.pointerType,
        t.pressure = r.pressure,
        t.tangentialPressure = r.tangentialPressure,
        t.tiltX = r.tiltX,
        t.tiltY = r.tiltY,
        t.twist = r.twist,
        this.transferMouseData(t, r),
        this.mapPositionToPoint(t.screen, r.clientX, r.clientY),
        t.global.copyFrom(t.screen),
        t.offset.copyFrom(t.screen),
        t.isTrusted = r.isTrusted,
        t.type === "pointerleave" && (t.type = "pointerout"),
        t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")),
        t.type.startsWith("touch") && (t.type = oV[t.type] || t.type),
        t
    }
    transferMouseData(t, r) {
        t.isTrusted = r.isTrusted,
        t.srcElement = r.srcElement,
        t.timeStamp = performance.now(),
        t.type = r.type,
        t.altKey = r.altKey,
        t.button = r.button,
        t.buttons = r.buttons,
        t.client.x = r.clientX,
        t.client.y = r.clientY,
        t.ctrlKey = r.ctrlKey,
        t.metaKey = r.metaKey,
        t.movement.x = r.movementX,
        t.movement.y = r.movementY,
        t.page.x = r.pageX,
        t.page.y = r.pageY,
        t.relatedTarget = null,
        t.shiftKey = r.shiftKey
    }
}
;
R_.extension = {
    name: "events",
    type: [G.RendererSystem, G.CanvasRendererSystem]
},
R_.defaultEventFeatures = {
    move: !0,
    globalMove: !0,
    click: !0,
    wheel: !0
};
let Pf = R_;
Y.add(Pf);
function JS(e) {
    return e === "dynamic" || e === "static"
}
const tM = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    _internalInteractive: void 0,
    get interactive() {
        return this._internalInteractive ?? JS(Pf.defaultEventMode)
    },
    set interactive(e) {
        et("7.2.0", "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."),
        this._internalInteractive = e,
        this.eventMode = e ? "static" : "auto"
    },
    _internalEventMode: void 0,
    get eventMode() {
        return this._internalEventMode ?? Pf.defaultEventMode
    },
    set eventMode(e) {
        this._internalInteractive = JS(e),
        this._internalEventMode = e
    },
    isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic"
    },
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(e, t, r) {
        const i = typeof r == "boolean" && r || typeof r == "object" && r.capture
          , n = typeof t == "function" ? void 0 : t;
        e = i ? `${e}capture` : e,
        t = typeof t == "function" ? t : t.handleEvent,
        this.on(e, t, n)
    },
    removeEventListener(e, t, r) {
        const i = typeof r == "boolean" && r || typeof r == "object" && r.capture
          , n = typeof t == "function" ? void 0 : t;
        e = i ? `${e}capture` : e,
        t = typeof t == "function" ? t : t.handleEvent,
        this.off(e, t, n)
    },
    dispatchEvent(e) {
        if (!(e instanceof yl))
            throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        return e.defaultPrevented = !1,
        e.path = null,
        e.target = this,
        e.manager.dispatchEvent(e),
        !e.defaultPrevented
    }
};
zt.mixin(tM);
const eM = {
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    renderId: -1
};
zt.mixin(eM);
const aV = 9
  , kc = 100
  , lV = 0
  , hV = 0
  , tw = 2
  , ew = 1
  , uV = -1e3
  , cV = -1e3
  , dV = 2;
class Mx {
    constructor(t) {
        this.debug = !1,
        this._isActive = !1,
        this._isMobileAccessibility = !1,
        this.pool = [],
        this.renderId = 0,
        this.children = [],
        this.androidUpdateCount = 0,
        this.androidUpdateFrequency = 500,
        this._hookDiv = null,
        (Si.tablet || Si.phone) && this.createTouchHook();
        const r = document.createElement("div");
        r.style.width = `${kc}px`,
        r.style.height = `${kc}px`,
        r.style.position = "absolute",
        r.style.top = `${lV}px`,
        r.style.left = `${hV}px`,
        r.style.zIndex = tw.toString(),
        this.div = r,
        this.renderer = t,
        this._onKeyDown = this._onKeyDown.bind(this),
        this._onMouseMove = this._onMouseMove.bind(this),
        globalThis.addEventListener("keydown", this._onKeyDown, !1)
    }
    get isActive() {
        return this._isActive
    }
    get isMobileAccessibility() {
        return this._isMobileAccessibility
    }
    createTouchHook() {
        const t = document.createElement("button");
        t.style.width = `${ew}px`,
        t.style.height = `${ew}px`,
        t.style.position = "absolute",
        t.style.top = `${uV}px`,
        t.style.left = `${cV}px`,
        t.style.zIndex = dV.toString(),
        t.style.backgroundColor = "#FF0000",
        t.title = "select to enable accessibility for this content",
        t.addEventListener("focus", () => {
            this._isMobileAccessibility = !0,
            this.activate(),
            this.destroyTouchHook()
        }
        ),
        document.body.appendChild(t),
        this._hookDiv = t
    }
    destroyTouchHook() {
        this._hookDiv && (document.body.removeChild(this._hookDiv),
        this._hookDiv = null)
    }
    activate() {
        this._isActive || (this._isActive = !0,
        globalThis.document.addEventListener("mousemove", this._onMouseMove, !0),
        globalThis.removeEventListener("keydown", this._onKeyDown, !1),
        this.renderer.on("postrender", this.update, this),
        this.renderer.view.parentNode?.appendChild(this.div))
    }
    deactivate() {
        !this._isActive || this._isMobileAccessibility || (this._isActive = !1,
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
        globalThis.addEventListener("keydown", this._onKeyDown, !1),
        this.renderer.off("postrender", this.update),
        this.div.parentNode?.removeChild(this.div))
    }
    updateAccessibleObjects(t) {
        if (!t.visible || !t.accessibleChildren)
            return;
        t.accessible && t.isInteractive() && (t._accessibleActive || this.addChild(t),
        t.renderId = this.renderId);
        const r = t.children;
        if (r)
            for (let i = 0; i < r.length; i++)
                this.updateAccessibleObjects(r[i])
    }
    update() {
        const t = performance.now();
        if (Si.android.device && t < this.androidUpdateCount || (this.androidUpdateCount = t + this.androidUpdateFrequency,
        !this.renderer.renderingToScreen))
            return;
        this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
        const {x: r, y: i, width: n, height: s} = this.renderer.view.getBoundingClientRect()
          , {width: o, height: a, resolution: l} = this.renderer
          , h = n / o * l
          , u = s / a * l;
        let c = this.div;
        c.style.left = `${r}px`,
        c.style.top = `${i}px`,
        c.style.width = `${o}px`,
        c.style.height = `${a}px`;
        for (let d = 0; d < this.children.length; d++) {
            const f = this.children[d];
            if (f.renderId !== this.renderId)
                f._accessibleActive = !1,
                mo(this.children, d, 1),
                this.div.removeChild(f._accessibleDiv),
                this.pool.push(f._accessibleDiv),
                f._accessibleDiv = null,
                d--;
            else {
                c = f._accessibleDiv;
                let g = f.hitArea;
                const p = f.worldTransform;
                f.hitArea ? (c.style.left = `${(p.tx + g.x * p.a) * h}px`,
                c.style.top = `${(p.ty + g.y * p.d) * u}px`,
                c.style.width = `${g.width * p.a * h}px`,
                c.style.height = `${g.height * p.d * u}px`) : (g = f.getBounds(),
                this.capHitArea(g),
                c.style.left = `${g.x * h}px`,
                c.style.top = `${g.y * u}px`,
                c.style.width = `${g.width * h}px`,
                c.style.height = `${g.height * u}px`,
                c.title !== f.accessibleTitle && f.accessibleTitle !== null && (c.title = f.accessibleTitle),
                c.getAttribute("aria-label") !== f.accessibleHint && f.accessibleHint !== null && c.setAttribute("aria-label", f.accessibleHint)),
                (f.accessibleTitle !== c.title || f.tabIndex !== c.tabIndex) && (c.title = f.accessibleTitle,
                c.tabIndex = f.tabIndex,
                this.debug && this.updateDebugHTML(c))
            }
        }
        this.renderId++
    }
    updateDebugHTML(t) {
        t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
    }
    capHitArea(t) {
        t.x < 0 && (t.width += t.x,
        t.x = 0),
        t.y < 0 && (t.height += t.y,
        t.y = 0);
        const {width: r, height: i} = this.renderer;
        t.x + t.width > r && (t.width = r - t.x),
        t.y + t.height > i && (t.height = i - t.y)
    }
    addChild(t) {
        let r = this.pool.pop();
        r || (r = document.createElement("button"),
        r.style.width = `${kc}px`,
        r.style.height = `${kc}px`,
        r.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent",
        r.style.position = "absolute",
        r.style.zIndex = tw.toString(),
        r.style.borderStyle = "none",
        navigator.userAgent.toLowerCase().includes("chrome") ? r.setAttribute("aria-live", "off") : r.setAttribute("aria-live", "polite"),
        navigator.userAgent.match(/rv:.*Gecko\//) ? r.setAttribute("aria-relevant", "additions") : r.setAttribute("aria-relevant", "text"),
        r.addEventListener("click", this._onClick.bind(this)),
        r.addEventListener("focus", this._onFocus.bind(this)),
        r.addEventListener("focusout", this._onFocusOut.bind(this))),
        r.style.pointerEvents = t.accessiblePointerEvents,
        r.type = t.accessibleType,
        t.accessibleTitle && t.accessibleTitle !== null ? r.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (r.title = `displayObject ${t.tabIndex}`),
        t.accessibleHint && t.accessibleHint !== null && r.setAttribute("aria-label", t.accessibleHint),
        this.debug && this.updateDebugHTML(r),
        t._accessibleActive = !0,
        t._accessibleDiv = r,
        r.displayObject = t,
        this.children.push(t),
        this.div.appendChild(t._accessibleDiv),
        t._accessibleDiv.tabIndex = t.tabIndex
    }
    _dispatchEvent(t, r) {
        const {displayObject: i} = t.target
          , n = this.renderer.events.rootBoundary
          , s = Object.assign(new yl(n), {
            target: i
        });
        n.rootTarget = this.renderer.lastObjectRendered,
        r.forEach(o => n.dispatchEvent(s, o))
    }
    _onClick(t) {
        this._dispatchEvent(t, ["click", "pointertap", "tap"])
    }
    _onFocus(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"),
        this._dispatchEvent(t, ["mouseover"])
    }
    _onFocusOut(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"),
        this._dispatchEvent(t, ["mouseout"])
    }
    _onKeyDown(t) {
        t.keyCode === aV && this.activate()
    }
    _onMouseMove(t) {
        t.movementX === 0 && t.movementY === 0 || this.deactivate()
    }
    destroy() {
        this.destroyTouchHook(),
        this.div = null,
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
        globalThis.removeEventListener("keydown", this._onKeyDown),
        this.pool = null,
        this.children = null,
        this.renderer = null
    }
}
Mx.extension = {
    name: "accessibility",
    type: [G.RendererPlugin, G.CanvasRendererPlugin]
};
Y.add(Mx);
const rM = class O_ {
    constructor(t) {
        this.stage = new J,
        t = Object.assign({
            forceCanvas: !1
        }, t),
        this.renderer = oR(t),
        O_._plugins.forEach(r => {
            r.init.call(this, t)
        }
        )
    }
    render() {
        this.renderer.render(this.stage)
    }
    get view() {
        return this.renderer?.view
    }
    get screen() {
        return this.renderer?.screen
    }
    destroy(t, r) {
        const i = O_._plugins.slice(0);
        i.reverse(),
        i.forEach(n => {
            n.destroy.call(this)
        }
        ),
        this.stage.destroy(r),
        this.stage = null,
        this.renderer.destroy(t),
        this.renderer = null
    }
}
;
rM._plugins = [];
let Ox = rM;
Y.handleByList(G.Application, Ox._plugins);
class Nx {
    static init(t) {
        Object.defineProperty(this, "resizeTo", {
            set(r) {
                globalThis.removeEventListener("resize", this.queueResize),
                this._resizeTo = r,
                r && (globalThis.addEventListener("resize", this.queueResize),
                this.resize())
            },
            get() {
                return this._resizeTo
            }
        }),
        this.queueResize = () => {
            this._resizeTo && (this.cancelResize(),
            this._resizeId = requestAnimationFrame( () => this.resize()))
        }
        ,
        this.cancelResize = () => {
            this._resizeId && (cancelAnimationFrame(this._resizeId),
            this._resizeId = null)
        }
        ,
        this.resize = () => {
            if (!this._resizeTo)
                return;
            this.cancelResize();
            let r, i;
            if (this._resizeTo === globalThis.window)
                r = globalThis.innerWidth,
                i = globalThis.innerHeight;
            else {
                const {clientWidth: n, clientHeight: s} = this._resizeTo;
                r = n,
                i = s
            }
            this.renderer.resize(r, i),
            this.render()
        }
        ,
        this._resizeId = null,
        this._resizeTo = null,
        this.resizeTo = t.resizeTo || null
    }
    static destroy() {
        globalThis.removeEventListener("resize", this.queueResize),
        this.cancelResize(),
        this.cancelResize = null,
        this.queueResize = null,
        this.resizeTo = null,
        this.resize = null
    }
}
Nx.extension = G.Application;
Y.add(Nx);
var or = (e => (e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT",
e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT",
e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT",
e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT",
e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",
e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",
e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",
e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT",
e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC",
e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC",
e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC",
e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC",
e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2",
e[e.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC",
e[e.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2",
e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG",
e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",
e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG",
e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",
e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL",
e[e.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL",
e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",
e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL",
e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR",
e))(or || {});
const du = {
    33776: .5,
    33777: .5,
    33778: 1,
    33779: 1,
    35916: .5,
    35917: .5,
    35918: 1,
    35919: 1,
    37488: .5,
    37489: .5,
    37490: 1,
    37491: 1,
    37492: .5,
    37496: 1,
    37493: .5,
    37497: 1,
    37494: .5,
    37495: .5,
    35840: .5,
    35842: .5,
    35841: .25,
    35843: .25,
    36196: .5,
    35986: .5,
    35986: 1,
    34798: 1,
    37808: 1
};
let _n, sa;
function rw() {
    sa = {
        s3tc: _n.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: _n.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: _n.getExtension("WEBGL_compressed_texture_etc"),
        etc1: _n.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: _n.getExtension("WEBGL_compressed_texture_pvrtc") || _n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: _n.getExtension("WEBGL_compressed_texture_atc"),
        astc: _n.getExtension("WEBGL_compressed_texture_astc")
    }
}
const iM = {
    extension: {
        type: G.DetectionParser,
        priority: 2
    },
    test: async () => {
        const e = z.ADAPTER.createCanvas().getContext("webgl");
        return e ? (_n = e,
        !0) : (console.warn("WebGL not available for compressed textures."),
        !1)
    }
    ,
    add: async e => {
        sa || rw();
        const t = [];
        for (const r in sa)
            sa[r] && t.push(r);
        return [...t, ...e]
    }
    ,
    remove: async e => (sa || rw(),
    e.filter(t => !(t in sa)))
};
Y.add(iM);
class nM extends Bu {
    constructor(t, r={
        width: 1,
        height: 1,
        autoLoad: !0
    }) {
        let i, n;
        typeof t == "string" ? (i = t,
        n = new Uint8Array) : (i = null,
        n = t),
        super(n, r),
        this.origin = i,
        this.buffer = n ? new pf(n) : null,
        this._load = null,
        this.loaded = !1,
        this.origin !== null && r.autoLoad !== !1 && this.load(),
        this.origin === null && this.buffer && (this._load = Promise.resolve(this),
        this.loaded = !0,
        this.onBlobLoaded(this.buffer.rawBinaryData))
    }
    onBlobLoaded(t) {}
    load() {
        return this._load ? this._load : (this._load = fetch(this.origin).then(t => t.blob()).then(t => t.arrayBuffer()).then(t => (this.data = new Uint32Array(t),
        this.buffer = new pf(t),
        this.loaded = !0,
        this.onBlobLoaded(t),
        this.update(),
        this)),
        this._load)
    }
}
class Ss extends nM {
    constructor(t, r) {
        super(t, r),
        this.format = r.format,
        this.levels = r.levels || 1,
        this._width = r.width,
        this._height = r.height,
        this._extension = Ss._formatToExtension(this.format),
        (r.levelBuffers || this.buffer) && (this._levelBuffers = r.levelBuffers || Ss._createLevelBuffers(t instanceof Uint8Array ? t : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
    }
    upload(t, r, i) {
        const n = t.gl;
        if (!t.context.extensions[this._extension])
            throw new Error(`${this._extension} textures are not supported on the current machine`);
        if (!this._levelBuffers)
            return !1;
        n.pixelStorei(n.UNPACK_ALIGNMENT, 4);
        for (let s = 0, o = this.levels; s < o; s++) {
            const {levelID: a, levelWidth: l, levelHeight: h, levelBuffer: u} = this._levelBuffers[s];
            n.compressedTexImage2D(n.TEXTURE_2D, a, this.format, l, h, 0, u)
        }
        return !0
    }
    onBlobLoaded() {
        this._levelBuffers = Ss._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
    }
    static _formatToExtension(t) {
        if (t >= 33776 && t <= 33779)
            return "s3tc";
        if (t >= 37488 && t <= 37497)
            return "etc";
        if (t >= 35840 && t <= 35843)
            return "pvrtc";
        if (t >= 36196)
            return "etc1";
        if (t >= 35986 && t <= 34798)
            return "atc";
        throw new Error("Invalid (compressed) texture format given!")
    }
    static _createLevelBuffers(t, r, i, n, s, o, a) {
        const l = new Array(i);
        let h = t.byteOffset
          , u = o
          , c = a
          , d = u + n - 1 & ~(n - 1)
          , f = c + s - 1 & ~(s - 1)
          , g = d * f * du[r];
        for (let p = 0; p < i; p++)
            l[p] = {
                levelID: p,
                levelWidth: i > 1 ? u : d,
                levelHeight: i > 1 ? c : f,
                levelBuffer: new Uint8Array(t.buffer,h,g)
            },
            h += g,
            u = u >> 1 || 1,
            c = c >> 1 || 1,
            d = u + n - 1 & ~(n - 1),
            f = c + s - 1 & ~(s - 1),
            g = d * f * du[r];
        return l
    }
}
const cg = 4
  , Fc = 124
  , fV = 32
  , iw = 20
  , pV = 542327876
  , Uc = {
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19
}
  , mV = {
    SIZE: 0,
    FLAGS: 1,
    FOURCC: 2,
    RGB_BITCOUNT: 3,
    R_BIT_MASK: 4,
    G_BIT_MASK: 5,
    B_BIT_MASK: 6,
    A_BIT_MASK: 7
}
  , Gc = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4
}
  , gV = 1
  , _V = 2
  , yV = 4
  , vV = 64
  , xV = 512
  , EV = 131072
  , TV = 827611204
  , SV = 861165636
  , wV = 894720068
  , AV = 808540228
  , bV = 4
  , CV = {
    [TV]: or.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [SV]: or.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [wV]: or.COMPRESSED_RGBA_S3TC_DXT5_EXT
}
  , PV = {
    70: or.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    71: or.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    73: or.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    74: or.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    76: or.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    77: or.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    72: or.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
    75: or.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
    78: or.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
function sM(e) {
    const t = new Uint32Array(e);
    if (t[0] !== pV)
        throw new Error("Invalid DDS file magic word");
    const r = new Uint32Array(e,0,Fc / Uint32Array.BYTES_PER_ELEMENT)
      , i = r[Uc.HEIGHT]
      , n = r[Uc.WIDTH]
      , s = r[Uc.MIPMAP_COUNT]
      , o = new Uint32Array(e,Uc.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,fV / Uint32Array.BYTES_PER_ELEMENT)
      , a = o[gV];
    if (a & yV) {
        const l = o[mV.FOURCC];
        if (l !== AV) {
            const m = CV[l]
              , _ = cg + Fc
              , x = new Uint8Array(e,_);
            return [new Ss(x,{
                format: m,
                width: n,
                height: i,
                levels: s
            })]
        }
        const h = cg + Fc
          , u = new Uint32Array(t.buffer,h,iw / Uint32Array.BYTES_PER_ELEMENT)
          , c = u[Gc.DXGI_FORMAT]
          , d = u[Gc.RESOURCE_DIMENSION]
          , f = u[Gc.MISC_FLAG]
          , g = u[Gc.ARRAY_SIZE]
          , p = PV[c];
        if (p === void 0)
            throw new Error(`DDSParser cannot parse texture data with DXGI format ${c}`);
        if (f === bV)
            throw new Error("DDSParser does not support cubemap textures");
        if (d === 6)
            throw new Error("DDSParser does not supported 3D texture data");
        const v = new Array
          , y = cg + Fc + iw;
        if (g === 1)
            v.push(new Uint8Array(e,y));
        else {
            const m = du[p];
            let _ = 0
              , x = n
              , E = i;
            for (let w = 0; w < s; w++) {
                const T = Math.max(1, x + 3 & -4)
                  , C = Math.max(1, E + 3 & -4)
                  , R = T * C * m;
                _ += R,
                x = x >>> 1,
                E = E >>> 1
            }
            let S = y;
            for (let w = 0; w < g; w++)
                v.push(new Uint8Array(e,S,_)),
                S += _
        }
        return v.map(m => new Ss(m,{
            format: p,
            width: n,
            height: i,
            levels: s
        }))
    }
    throw a & vV ? new Error("DDSParser does not support uncompressed texture data.") : a & xV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : a & EV ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : a & _V ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!")
}
const nw = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]
  , IV = 67305985
  , pi = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60
}
  , N_ = 64
  , L_ = {
    [Q.UNSIGNED_BYTE]: 1,
    [Q.UNSIGNED_SHORT]: 2,
    [Q.INT]: 4,
    [Q.UNSIGNED_INT]: 4,
    [Q.FLOAT]: 4,
    [Q.HALF_FLOAT]: 8
}
  , oM = {
    [B.RGBA]: 4,
    [B.RGB]: 3,
    [B.RG]: 2,
    [B.RED]: 1,
    [B.LUMINANCE]: 1,
    [B.LUMINANCE_ALPHA]: 2,
    [B.ALPHA]: 1
}
  , aM = {
    [Q.UNSIGNED_SHORT_4_4_4_4]: 2,
    [Q.UNSIGNED_SHORT_5_5_5_1]: 2,
    [Q.UNSIGNED_SHORT_5_6_5]: 2
};
function lM(e, t, r=!1) {
    const i = new DataView(t);
    if (!RV(e, i))
        return null;
    const n = i.getUint32(pi.ENDIANNESS, !0) === IV
      , s = i.getUint32(pi.GL_TYPE, n)
      , o = i.getUint32(pi.GL_FORMAT, n)
      , a = i.getUint32(pi.GL_INTERNAL_FORMAT, n)
      , l = i.getUint32(pi.PIXEL_WIDTH, n)
      , h = i.getUint32(pi.PIXEL_HEIGHT, n) || 1
      , u = i.getUint32(pi.PIXEL_DEPTH, n) || 1
      , c = i.getUint32(pi.NUMBER_OF_ARRAY_ELEMENTS, n) || 1
      , d = i.getUint32(pi.NUMBER_OF_FACES, n)
      , f = i.getUint32(pi.NUMBER_OF_MIPMAP_LEVELS, n)
      , g = i.getUint32(pi.BYTES_OF_KEY_VALUE_DATA, n);
    if (h === 0 || u !== 1)
        throw new Error("Only 2D textures are supported");
    if (d !== 1)
        throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (c !== 1)
        throw new Error("WebGL does not support array textures");
    const p = 4
      , v = 4
      , y = l + 3 & -4
      , m = h + 3 & -4
      , _ = new Array(c);
    let x = l * h;
    s === 0 && (x = y * m);
    let E;
    if (s !== 0 ? L_[s] ? E = L_[s] * oM[o] : E = aM[s] : E = du[a],
    E === void 0)
        throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    const S = r ? OV(i, g, n) : null;
    let w = x * E
      , T = l
      , C = h
      , R = y
      , O = m
      , N = N_ + g;
    for (let P = 0; P < f; P++) {
        const M = i.getUint32(N, n);
        let V = N + 4;
        for (let X = 0; X < c; X++) {
            let k = _[X];
            k || (k = _[X] = new Array(f)),
            k[P] = {
                levelID: P,
                levelWidth: f > 1 || s !== 0 ? T : R,
                levelHeight: f > 1 || s !== 0 ? C : O,
                levelBuffer: new Uint8Array(t,V,w)
            },
            V += w
        }
        N += M + 4,
        N = N % 4 !== 0 ? N + 4 - N % 4 : N,
        T = T >> 1 || 1,
        C = C >> 1 || 1,
        R = T + p - 1 & ~(p - 1),
        O = C + v - 1 & ~(v - 1),
        w = R * O * E
    }
    return s !== 0 ? {
        uncompressed: _.map(P => {
            let M = P[0].levelBuffer
              , V = !1;
            return s === Q.FLOAT ? M = new Float32Array(P[0].levelBuffer.buffer,P[0].levelBuffer.byteOffset,P[0].levelBuffer.byteLength / 4) : s === Q.UNSIGNED_INT ? (V = !0,
            M = new Uint32Array(P[0].levelBuffer.buffer,P[0].levelBuffer.byteOffset,P[0].levelBuffer.byteLength / 4)) : s === Q.INT && (V = !0,
            M = new Int32Array(P[0].levelBuffer.buffer,P[0].levelBuffer.byteOffset,P[0].levelBuffer.byteLength / 4)),
            {
                resource: new Bu(M,{
                    width: P[0].levelWidth,
                    height: P[0].levelHeight
                }),
                type: s,
                format: V ? MV(o) : o
            }
        }
        ),
        kvData: S
    } : {
        compressed: _.map(P => new Ss(null,{
            format: a,
            width: l,
            height: h,
            levels: f,
            levelBuffers: P
        })),
        kvData: S
    }
}
function RV(e, t) {
    for (let r = 0; r < nw.length; r++)
        if (t.getUint8(r) !== nw[r])
            return console.error(`${e} is not a valid *.ktx file!`),
            !1;
    return !0
}
function MV(e) {
    switch (e) {
    case B.RGBA:
        return B.RGBA_INTEGER;
    case B.RGB:
        return B.RGB_INTEGER;
    case B.RG:
        return B.RG_INTEGER;
    case B.RED:
        return B.RED_INTEGER;
    default:
        return e
    }
}
function OV(e, t, r) {
    const i = new Map;
    let n = 0;
    for (; n < t; ) {
        const s = e.getUint32(N_ + n, r)
          , o = N_ + n + 4
          , a = 3 - (s + 3) % 4;
        if (s === 0 || s > t - n) {
            console.error("KTXLoader: keyAndValueByteSize out of bounds");
            break
        }
        let l = 0;
        for (; l < s && e.getUint8(o + l) !== 0; l++)
            ;
        if (l === -1) {
            console.error("KTXLoader: Failed to find null byte terminating kvData key");
            break
        }
        const h = new TextDecoder().decode(new Uint8Array(e.buffer,o,l))
          , u = new DataView(e.buffer,o + l + 1,s - l - 1);
        i.set(h, u),
        n += 4 + s + a
    }
    return i
}
const hM = {
    extension: {
        type: G.LoadParser,
        priority: Gr.High
    },
    name: "loadDDS",
    test(e) {
        return Xn(e, ".dds")
    },
    async load(e, t, r) {
        const i = await (await z.ADAPTER.fetch(e)).arrayBuffer()
          , n = sM(i).map(s => {
            const o = new nt(s,{
                mipmap: Ni.OFF,
                alphaMode: tr.NO_PREMULTIPLIED_ALPHA,
                resolution: un(e),
                ...t.data
            });
            return gl(o, r, e)
        }
        );
        return n.length === 1 ? n[0] : n
    },
    unload(e) {
        Array.isArray(e) ? e.forEach(t => t.destroy(!0)) : e.destroy(!0)
    }
};
Y.add(hM);
const uM = {
    extension: {
        type: G.LoadParser,
        priority: Gr.High
    },
    name: "loadKTX",
    test(e) {
        return Xn(e, ".ktx")
    },
    async load(e, t, r) {
        const i = await (await z.ADAPTER.fetch(e)).arrayBuffer()
          , {compressed: n, uncompressed: s, kvData: o} = lM(e, i)
          , a = n ?? s
          , l = {
            mipmap: Ni.OFF,
            alphaMode: tr.NO_PREMULTIPLIED_ALPHA,
            resolution: un(e),
            ...t.data
        }
          , h = a.map(u => {
            a === s && Object.assign(l, {
                type: u.type,
                format: u.format
            });
            const c = u.resource ?? u
              , d = new nt(c,l);
            return d.ktxKeyValueData = o,
            gl(d, r, e)
        }
        );
        return h.length === 1 ? h[0] : h
    },
    unload(e) {
        Array.isArray(e) ? e.forEach(t => t.destroy(!0)) : e.destroy(!0)
    }
};
Y.add(uM);
const cM = {
    extension: G.ResolveParser,
    test: e => {
        const t = e.split("?")[0].split(".").pop();
        return ["basis", "ktx", "dds"].includes(t)
    }
    ,
    parse: e => {
        if (e.split("?")[0].split(".").pop() === "ktx") {
            const t = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx"];
            if (t.some(r => e.endsWith(r)))
                return {
                    resolution: parseFloat(z.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
                    format: t.find(r => e.endsWith(r)),
                    src: e
                }
        }
        return {
            resolution: parseFloat(z.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
            format: e.split(".").pop(),
            src: e
        }
    }
};
Y.add(cM);
const Hc = new lt
  , NV = 4
  , dM = class Yl {
    constructor(t) {
        this.renderer = t,
        this._rendererPremultipliedAlpha = !1
    }
    contextChange() {
        const t = this.renderer?.gl.getContextAttributes();
        this._rendererPremultipliedAlpha = !!(t && t.alpha && t.premultipliedAlpha)
    }
    async image(t, r, i, n) {
        const s = new Image;
        return s.src = await this.base64(t, r, i, n),
        s
    }
    async base64(t, r, i, n) {
        const s = this.canvas(t, n);
        if (s.toBlob !== void 0)
            return new Promise( (o, a) => {
                s.toBlob(l => {
                    if (!l) {
                        a(new Error("ICanvas.toBlob failed!"));
                        return
                    }
                    const h = new FileReader;
                    h.onload = () => o(h.result),
                    h.onerror = a,
                    h.readAsDataURL(l)
                }
                , r, i)
            }
            );
        if (s.toDataURL !== void 0)
            return s.toDataURL(r, i);
        if (s.convertToBlob !== void 0) {
            const o = await s.convertToBlob({
                type: r,
                quality: i
            });
            return new Promise( (a, l) => {
                const h = new FileReader;
                h.onload = () => a(h.result),
                h.onerror = l,
                h.readAsDataURL(o)
            }
            )
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")
    }
    canvas(t, r) {
        const {pixels: i, width: n, height: s, flipY: o, premultipliedAlpha: a} = this._rawPixels(t, r);
        o && Yl._flipY(i, n, s),
        a && Yl._unpremultiplyAlpha(i);
        const l = new bI(n,s,1)
          , h = new ImageData(new Uint8ClampedArray(i.buffer),n,s);
        return l.context.putImageData(h, 0, 0),
        l.canvas
    }
    pixels(t, r) {
        const {pixels: i, width: n, height: s, flipY: o, premultipliedAlpha: a} = this._rawPixels(t, r);
        return o && Yl._flipY(i, n, s),
        a && Yl._unpremultiplyAlpha(i),
        i
    }
    _rawPixels(t, r) {
        const i = this.renderer;
        if (!i)
            throw new Error("The Extract has already been destroyed");
        let n, s = !1, o = !1, a, l = !1;
        t && (t instanceof Gs ? a = t : (a = i.generateTexture(t, {
            region: r,
            resolution: i.resolution,
            multisample: i.multisample
        }),
        l = !0,
        r && (Hc.width = r.width,
        Hc.height = r.height,
        r = Hc)));
        const h = i.gl;
        if (a) {
            if (n = a.baseTexture.resolution,
            r = r ?? a.frame,
            s = !1,
            o = a.baseTexture.alphaMode > 0 && a.baseTexture.format === B.RGBA,
            !l) {
                i.renderTexture.bind(a);
                const f = a.framebuffer.glFramebuffers[i.CONTEXT_UID];
                f.blitFramebuffer && i.framebuffer.bind(f.blitFramebuffer)
            }
        } else
            n = i.resolution,
            r || (r = Hc,
            r.width = i.width / n,
            r.height = i.height / n),
            s = !0,
            o = this._rendererPremultipliedAlpha,
            i.renderTexture.bind();
        const u = Math.max(Math.round(r.width * n), 1)
          , c = Math.max(Math.round(r.height * n), 1)
          , d = new Uint8Array(NV * u * c);
        return h.readPixels(Math.round(r.x * n), Math.round(r.y * n), u, c, h.RGBA, h.UNSIGNED_BYTE, d),
        l && a?.destroy(!0),
        {
            pixels: d,
            width: u,
            height: c,
            flipY: s,
            premultipliedAlpha: o
        }
    }
    destroy() {
        this.renderer = null
    }
    static _flipY(t, r, i) {
        const n = r << 2
          , s = i >> 1
          , o = new Uint8Array(n);
        for (let a = 0; a < s; a++) {
            const l = a * n
              , h = (i - a - 1) * n;
            o.set(t.subarray(l, l + n)),
            t.copyWithin(l, h, h + n),
            t.set(o, h)
        }
    }
    static _unpremultiplyAlpha(t) {
        t instanceof Uint8ClampedArray && (t = new Uint8Array(t.buffer));
        const r = t.length;
        for (let i = 0; i < r; i += 4) {
            const n = t[i + 3];
            if (n !== 0) {
                const s = 255.001 / n;
                t[i] = t[i] * s + .5,
                t[i + 1] = t[i + 1] * s + .5,
                t[i + 2] = t[i + 2] * s + .5
            }
        }
    }
}
;
dM.extension = {
    name: "extract",
    type: G.RendererSystem
};
let fM = dM;
Y.add(fM);
const fu = {
    build(e) {
        const t = e.points;
        let r, i, n, s, o, a;
        if (e.type === we.CIRC) {
            const g = e.shape;
            r = g.x,
            i = g.y,
            o = a = g.radius,
            n = s = 0
        } else if (e.type === we.ELIP) {
            const g = e.shape;
            r = g.x,
            i = g.y,
            o = g.width,
            a = g.height,
            n = s = 0
        } else {
            const g = e.shape
              , p = g.width / 2
              , v = g.height / 2;
            r = g.x + p,
            i = g.y + v,
            o = a = Math.max(0, Math.min(g.radius, Math.min(p, v))),
            n = p - o,
            s = v - a
        }
        if (!(o >= 0 && a >= 0 && n >= 0 && s >= 0)) {
            t.length = 0;
            return
        }
        const l = Math.ceil(2.3 * Math.sqrt(o + a))
          , h = l * 8 + (n ? 4 : 0) + (s ? 4 : 0);
        if (t.length = h,
        h === 0)
            return;
        if (l === 0) {
            t.length = 8,
            t[0] = t[6] = r + n,
            t[1] = t[3] = i + s,
            t[2] = t[4] = r - n,
            t[5] = t[7] = i - s;
            return
        }
        let u = 0
          , c = l * 4 + (n ? 2 : 0) + 2
          , d = c
          , f = h;
        {
            const g = n + o
              , p = s
              , v = r + g
              , y = r - g
              , m = i + p;
            if (t[u++] = v,
            t[u++] = m,
            t[--c] = m,
            t[--c] = y,
            s) {
                const _ = i - p;
                t[d++] = y,
                t[d++] = _,
                t[--f] = _,
                t[--f] = v
            }
        }
        for (let g = 1; g < l; g++) {
            const p = Math.PI / 2 * (g / l)
              , v = n + Math.cos(p) * o
              , y = s + Math.sin(p) * a
              , m = r + v
              , _ = r - v
              , x = i + y
              , E = i - y;
            t[u++] = m,
            t[u++] = x,
            t[--c] = x,
            t[--c] = _,
            t[d++] = _,
            t[d++] = E,
            t[--f] = E,
            t[--f] = m
        }
        {
            const g = n
              , p = s + a
              , v = r + g
              , y = r - g
              , m = i + p
              , _ = i - p;
            t[u++] = v,
            t[u++] = m,
            t[--f] = _,
            t[--f] = v,
            n && (t[u++] = y,
            t[u++] = m,
            t[--f] = _,
            t[--f] = y)
        }
    },
    triangulate(e, t) {
        const r = e.points
          , i = t.points
          , n = t.indices;
        if (r.length === 0)
            return;
        let s = i.length / 2;
        const o = s;
        let a, l;
        if (e.type !== we.RREC) {
            const u = e.shape;
            a = u.x,
            l = u.y
        } else {
            const u = e.shape;
            a = u.x + u.width / 2,
            l = u.y + u.height / 2
        }
        const h = e.matrix;
        i.push(e.matrix ? h.a * a + h.c * l + h.tx : a, e.matrix ? h.b * a + h.d * l + h.ty : l),
        s++,
        i.push(r[0], r[1]);
        for (let u = 2; u < r.length; u += 2)
            i.push(r[u], r[u + 1]),
            n.push(s++, o, s);
        n.push(o + 1, o, s)
    }
};
function sw(e, t=!1) {
    const r = e.length;
    if (r < 6)
        return;
    let i = 0;
    for (let n = 0, s = e[r - 2], o = e[r - 1]; n < r; n += 2) {
        const a = e[n]
          , l = e[n + 1];
        i += (a - s) * (l + o),
        s = a,
        o = l
    }
    if (!t && i > 0 || t && i <= 0) {
        const n = r / 2;
        for (let s = n + n % 2; s < r; s += 2) {
            const o = r - s - 2
              , a = r - s - 1
              , l = s
              , h = s + 1;
            [e[o],e[l]] = [e[l], e[o]],
            [e[a],e[h]] = [e[h], e[a]]
        }
    }
}
const Lx = {
    build(e) {
        e.points = e.shape.points.slice()
    },
    triangulate(e, t) {
        let r = e.points;
        const i = e.holes
          , n = t.points
          , s = t.indices;
        if (r.length >= 6) {
            sw(r, !1);
            const o = [];
            for (let h = 0; h < i.length; h++) {
                const u = i[h];
                sw(u.points, !0),
                o.push(r.length / 2),
                r = r.concat(u.points)
            }
            const a = eI(r, o, 2);
            if (!a)
                return;
            const l = n.length / 2;
            for (let h = 0; h < a.length; h += 3)
                s.push(a[h] + l),
                s.push(a[h + 1] + l),
                s.push(a[h + 2] + l);
            for (let h = 0; h < r.length; h++)
                n.push(r[h])
        }
    }
}
  , pM = {
    build(e) {
        const t = e.shape
          , r = t.x
          , i = t.y
          , n = t.width
          , s = t.height
          , o = e.points;
        o.length = 0,
        n >= 0 && s >= 0 && o.push(r, i, r + n, i, r + n, i + s, r, i + s)
    },
    triangulate(e, t) {
        const r = e.points
          , i = t.points;
        if (r.length === 0)
            return;
        const n = i.length / 2;
        i.push(r[0], r[1], r[2], r[3], r[6], r[7], r[4], r[5]),
        t.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3)
    }
}
  , mM = {
    build(e) {
        fu.build(e)
    },
    triangulate(e, t) {
        fu.triangulate(e, t)
    }
};
var Sr = (e => (e.MITER = "miter",
e.BEVEL = "bevel",
e.ROUND = "round",
e))(Sr || {})
  , Rn = (e => (e.BUTT = "butt",
e.ROUND = "round",
e.SQUARE = "square",
e))(Rn || {});
const Rs = {
    adaptive: !0,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(e, t=20) {
        if (!this.adaptive || !e || isNaN(e))
            return t;
        let r = Math.ceil(e / this.maxLength);
        return r < this.minSegments ? r = this.minSegments : r > this.maxSegments && (r = this.maxSegments),
        r
    }
}
  , LV = Rs;
class D_ {
    static curveTo(t, r, i, n, s, o) {
        const a = o[o.length - 2]
          , l = o[o.length - 1] - r
          , h = a - t
          , u = n - r
          , c = i - t
          , d = Math.abs(l * c - h * u);
        if (d < 1e-8 || s === 0)
            return (o[o.length - 2] !== t || o[o.length - 1] !== r) && o.push(t, r),
            null;
        const f = l * l + h * h
          , g = u * u + c * c
          , p = l * u + h * c
          , v = s * Math.sqrt(f) / d
          , y = s * Math.sqrt(g) / d
          , m = v * p / f
          , _ = y * p / g
          , x = v * c + y * h
          , E = v * u + y * l
          , S = h * (y + m)
          , w = l * (y + m)
          , T = c * (v + _)
          , C = u * (v + _)
          , R = Math.atan2(w - E, S - x)
          , O = Math.atan2(C - E, T - x);
        return {
            cx: x + t,
            cy: E + r,
            radius: s,
            startAngle: R,
            endAngle: O,
            anticlockwise: h * u > c * l
        }
    }
    static arc(t, r, i, n, s, o, a, l, h) {
        const u = a - o
          , c = Rs._segmentsCount(Math.abs(u) * s, Math.ceil(Math.abs(u) / eu) * 40)
          , d = u / (c * 2)
          , f = d * 2
          , g = Math.cos(d)
          , p = Math.sin(d)
          , v = c - 1
          , y = v % 1 / v;
        for (let m = 0; m <= v; ++m) {
            const _ = m + y * m
              , x = d + o + f * _
              , E = Math.cos(x)
              , S = -Math.sin(x);
            h.push((g * E + p * S) * s + i, (g * -S + p * E) * s + n)
        }
    }
}
class gM {
    constructor() {
        this.reset()
    }
    begin(t, r, i) {
        this.reset(),
        this.style = t,
        this.start = r,
        this.attribStart = i
    }
    end(t, r) {
        this.attribSize = r - this.attribStart,
        this.size = t - this.start
    }
    reset() {
        this.style = null,
        this.size = 0,
        this.start = 0,
        this.attribStart = 0,
        this.attribSize = 0
    }
}
class Fp {
    static curveLength(t, r, i, n, s, o, a, l) {
        let h = 0
          , u = 0
          , c = 0
          , d = 0
          , f = 0
          , g = 0
          , p = 0
          , v = 0
          , y = 0
          , m = 0
          , _ = 0
          , x = t
          , E = r;
        for (let S = 1; S <= 10; ++S)
            u = S / 10,
            c = u * u,
            d = c * u,
            f = 1 - u,
            g = f * f,
            p = g * f,
            v = p * t + 3 * g * u * i + 3 * f * c * s + d * a,
            y = p * r + 3 * g * u * n + 3 * f * c * o + d * l,
            m = x - v,
            _ = E - y,
            x = v,
            E = y,
            h += Math.sqrt(m * m + _ * _);
        return h
    }
    static curveTo(t, r, i, n, s, o, a) {
        const l = a[a.length - 2]
          , h = a[a.length - 1];
        a.length -= 2;
        const u = Rs._segmentsCount(Fp.curveLength(l, h, t, r, i, n, s, o));
        let c = 0
          , d = 0
          , f = 0
          , g = 0
          , p = 0;
        a.push(l, h);
        for (let v = 1, y = 0; v <= u; ++v)
            y = v / u,
            c = 1 - y,
            d = c * c,
            f = d * c,
            g = y * y,
            p = g * y,
            a.push(f * l + 3 * d * y * t + 3 * c * g * i + p * s, f * h + 3 * d * y * r + 3 * c * g * n + p * o)
    }
}
function ow(e, t, r, i, n, s, o, a) {
    const l = e - r * n
      , h = t - i * n
      , u = e + r * s
      , c = t + i * s;
    let d, f;
    o ? (d = i,
    f = -r) : (d = -i,
    f = r);
    const g = l + d
      , p = h + f
      , v = u + d
      , y = c + f;
    return a.push(g, p, v, y),
    2
}
function Ws(e, t, r, i, n, s, o, a) {
    const l = r - e
      , h = i - t;
    let u = Math.atan2(l, h)
      , c = Math.atan2(n - e, s - t);
    a && u < c ? u += Math.PI * 2 : !a && u > c && (c += Math.PI * 2);
    let d = u;
    const f = c - u
      , g = Math.abs(f)
      , p = Math.sqrt(l * l + h * h)
      , v = (15 * g * Math.sqrt(p) / Math.PI >> 0) + 1
      , y = f / v;
    if (d += y,
    a) {
        o.push(e, t, r, i);
        for (let m = 1, _ = d; m < v; m++,
        _ += y)
            o.push(e, t, e + Math.sin(_) * p, t + Math.cos(_) * p);
        o.push(e, t, n, s)
    } else {
        o.push(r, i, e, t);
        for (let m = 1, _ = d; m < v; m++,
        _ += y)
            o.push(e + Math.sin(_) * p, t + Math.cos(_) * p, e, t);
        o.push(n, s, e, t)
    }
    return v * 2
}
function DV(e, t) {
    const r = e.shape;
    let i = e.points || r.points.slice();
    const n = t.closePointEps;
    if (i.length === 0)
        return;
    const s = e.lineStyle
      , o = new st(i[0],i[1])
      , a = new st(i[i.length - 2],i[i.length - 1])
      , l = r.type !== we.POLY || r.closeStroke
      , h = Math.abs(o.x - a.x) < n && Math.abs(o.y - a.y) < n;
    if (l) {
        i = i.slice(),
        h && (i.pop(),
        i.pop(),
        a.set(i[i.length - 2], i[i.length - 1]));
        const k = (o.x + a.x) * .5
          , L = (a.y + o.y) * .5;
        i.unshift(k, L),
        i.push(k, L)
    }
    const u = t.points
      , c = i.length / 2;
    let d = i.length;
    const f = u.length / 2
      , g = s.width / 2
      , p = g * g
      , v = s.miterLimit * s.miterLimit;
    let y = i[0]
      , m = i[1]
      , _ = i[2]
      , x = i[3]
      , E = 0
      , S = 0
      , w = -(m - x)
      , T = y - _
      , C = 0
      , R = 0
      , O = Math.sqrt(w * w + T * T);
    w /= O,
    T /= O,
    w *= g,
    T *= g;
    const N = s.alignment
      , P = (1 - N) * 2
      , M = N * 2;
    l || (s.cap === Rn.ROUND ? d += Ws(y - w * (P - M) * .5, m - T * (P - M) * .5, y - w * P, m - T * P, y + w * M, m + T * M, u, !0) + 2 : s.cap === Rn.SQUARE && (d += ow(y, m, w, T, P, M, !0, u))),
    u.push(y - w * P, m - T * P, y + w * M, m + T * M);
    for (let k = 1; k < c - 1; ++k) {
        y = i[(k - 1) * 2],
        m = i[(k - 1) * 2 + 1],
        _ = i[k * 2],
        x = i[k * 2 + 1],
        E = i[(k + 1) * 2],
        S = i[(k + 1) * 2 + 1],
        w = -(m - x),
        T = y - _,
        O = Math.sqrt(w * w + T * T),
        w /= O,
        T /= O,
        w *= g,
        T *= g,
        C = -(x - S),
        R = _ - E,
        O = Math.sqrt(C * C + R * R),
        C /= O,
        R /= O,
        C *= g,
        R *= g;
        const L = _ - y
          , $ = m - x
          , I = _ - E
          , H = S - x
          , K = L * I + $ * H
          , ct = $ * I - H * L
          , rt = ct < 0;
        if (Math.abs(ct) < .001 * Math.abs(K)) {
            u.push(_ - w * P, x - T * P, _ + w * M, x + T * M),
            K >= 0 && (s.join === Sr.ROUND ? d += Ws(_, x, _ - w * P, x - T * P, _ - C * P, x - R * P, u, !1) + 4 : d += 2,
            u.push(_ - C * M, x - R * M, _ + C * P, x + R * P));
            continue
        }
        const Et = (-w + y) * (-T + x) - (-w + _) * (-T + m)
          , bt = (-C + E) * (-R + x) - (-C + _) * (-R + S)
          , Wt = (L * bt - I * Et) / ct
          , Be = (H * Et - $ * bt) / ct
          , gr = (Wt - _) * (Wt - _) + (Be - x) * (Be - x)
          , Ie = _ + (Wt - _) * P
          , kt = x + (Be - x) * P
          , le = _ - (Wt - _) * M
          , pe = x - (Be - x) * M
          , ki = Math.min(L * L + $ * $, I * I + H * H)
          , Fi = rt ? P : M
          , vl = ki + Fi * Fi * p
          , f2 = gr <= vl;
        let qu = s.join;
        if (qu === Sr.MITER && gr / p > v && (qu = Sr.BEVEL),
        f2)
            switch (qu) {
            case Sr.MITER:
                {
                    u.push(Ie, kt, le, pe);
                    break
                }
            case Sr.BEVEL:
                {
                    rt ? u.push(Ie, kt, _ + w * M, x + T * M, Ie, kt, _ + C * M, x + R * M) : u.push(_ - w * P, x - T * P, le, pe, _ - C * P, x - R * P, le, pe),
                    d += 2;
                    break
                }
            case Sr.ROUND:
                {
                    rt ? (u.push(Ie, kt, _ + w * M, x + T * M),
                    d += Ws(_, x, _ + w * M, x + T * M, _ + C * M, x + R * M, u, !0) + 4,
                    u.push(Ie, kt, _ + C * M, x + R * M)) : (u.push(_ - w * P, x - T * P, le, pe),
                    d += Ws(_, x, _ - w * P, x - T * P, _ - C * P, x - R * P, u, !1) + 4,
                    u.push(_ - C * P, x - R * P, le, pe));
                    break
                }
            }
        else {
            switch (u.push(_ - w * P, x - T * P, _ + w * M, x + T * M),
            qu) {
            case Sr.MITER:
                {
                    rt ? u.push(le, pe, le, pe) : u.push(Ie, kt, Ie, kt),
                    d += 2;
                    break
                }
            case Sr.ROUND:
                {
                    rt ? d += Ws(_, x, _ + w * M, x + T * M, _ + C * M, x + R * M, u, !0) + 2 : d += Ws(_, x, _ - w * P, x - T * P, _ - C * P, x - R * P, u, !1) + 2;
                    break
                }
            }
            u.push(_ - C * P, x - R * P, _ + C * M, x + R * M),
            d += 2
        }
    }
    y = i[(c - 2) * 2],
    m = i[(c - 2) * 2 + 1],
    _ = i[(c - 1) * 2],
    x = i[(c - 1) * 2 + 1],
    w = -(m - x),
    T = y - _,
    O = Math.sqrt(w * w + T * T),
    w /= O,
    T /= O,
    w *= g,
    T *= g,
    u.push(_ - w * P, x - T * P, _ + w * M, x + T * M),
    l || (s.cap === Rn.ROUND ? d += Ws(_ - w * (P - M) * .5, x - T * (P - M) * .5, _ - w * P, x - T * P, _ + w * M, x + T * M, u, !1) + 2 : s.cap === Rn.SQUARE && (d += ow(_, x, w, T, P, M, !1, u)));
    const V = t.indices
      , X = Rs.epsilon * Rs.epsilon;
    for (let k = f; k < d + f - 2; ++k)
        y = u[k * 2],
        m = u[k * 2 + 1],
        _ = u[(k + 1) * 2],
        x = u[(k + 1) * 2 + 1],
        E = u[(k + 2) * 2],
        S = u[(k + 2) * 2 + 1],
        !(Math.abs(y * (x - S) + _ * (S - m) + E * (m - x)) < X) && V.push(k, k + 1, k + 2)
}
function BV(e, t) {
    let r = 0;
    const i = e.shape
      , n = e.points || i.points
      , s = i.type !== we.POLY || i.closeStroke;
    if (n.length === 0)
        return;
    const o = t.points
      , a = t.indices
      , l = n.length / 2
      , h = o.length / 2;
    let u = h;
    for (o.push(n[0], n[1]),
    r = 1; r < l; r++)
        o.push(n[r * 2], n[r * 2 + 1]),
        a.push(u, u + 1),
        u++;
    s && a.push(u, h)
}
function B_(e, t) {
    e.lineStyle.native ? BV(e, t) : DV(e, t)
}
class Up {
    static curveLength(t, r, i, n, s, o) {
        const a = t - 2 * i + s
          , l = r - 2 * n + o
          , h = 2 * i - 2 * t
          , u = 2 * n - 2 * r
          , c = 4 * (a * a + l * l)
          , d = 4 * (a * h + l * u)
          , f = h * h + u * u
          , g = 2 * Math.sqrt(c + d + f)
          , p = Math.sqrt(c)
          , v = 2 * c * p
          , y = 2 * Math.sqrt(f)
          , m = d / p;
        return (v * g + p * d * (g - y) + (4 * f * c - d * d) * Math.log((2 * p + m + g) / (m + y))) / (4 * v)
    }
    static curveTo(t, r, i, n, s) {
        const o = s[s.length - 2]
          , a = s[s.length - 1]
          , l = Rs._segmentsCount(Up.curveLength(o, a, t, r, i, n));
        let h = 0
          , u = 0;
        for (let c = 1; c <= l; ++c) {
            const d = c / l;
            h = o + (t - o) * d,
            u = a + (r - a) * d,
            s.push(h + (t + (i - t) * d - h) * d, u + (r + (n - r) * d - u) * d)
        }
    }
}
const Td = {
    [we.POLY]: Lx,
    [we.CIRC]: fu,
    [we.ELIP]: fu,
    [we.RECT]: pM,
    [we.RREC]: mM
}
  , k_ = []
  , Kl = [];
class pu {
    constructor(t, r=null, i=null, n=null) {
        this.points = [],
        this.holes = [],
        this.shape = t,
        this.lineStyle = i,
        this.fillStyle = r,
        this.matrix = n,
        this.type = t.type
    }
    clone() {
        return new pu(this.shape,this.fillStyle,this.lineStyle,this.matrix)
    }
    destroy() {
        this.shape = null,
        this.holes.length = 0,
        this.holes = null,
        this.points.length = 0,
        this.points = null,
        this.lineStyle = null,
        this.fillStyle = null
    }
}
const Zo = new st
  , _M = class yM extends rx {
    constructor() {
        super(),
        this.closePointEps = 1e-4,
        this.boundsPadding = 0,
        this.uvsFloat32 = null,
        this.indicesUint16 = null,
        this.batchable = !1,
        this.points = [],
        this.colors = [],
        this.uvs = [],
        this.indices = [],
        this.textureIds = [],
        this.graphicsData = [],
        this.drawCalls = [],
        this.batchDirty = -1,
        this.batches = [],
        this.dirty = 0,
        this.cacheDirty = -1,
        this.clearDirty = 0,
        this.shapeIndex = 0,
        this._bounds = new uu,
        this.boundsDirty = -1
    }
    get bounds() {
        return this.updateBatches(),
        this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty,
        this.calculateBounds()),
        this._bounds
    }
    invalidate() {
        this.boundsDirty = -1,
        this.dirty++,
        this.batchDirty++,
        this.shapeIndex = 0,
        this.points.length = 0,
        this.colors.length = 0,
        this.uvs.length = 0,
        this.indices.length = 0,
        this.textureIds.length = 0;
        for (let t = 0; t < this.drawCalls.length; t++)
            this.drawCalls[t].texArray.clear(),
            Kl.push(this.drawCalls[t]);
        this.drawCalls.length = 0;
        for (let t = 0; t < this.batches.length; t++) {
            const r = this.batches[t];
            r.reset(),
            k_.push(r)
        }
        this.batches.length = 0
    }
    clear() {
        return this.graphicsData.length > 0 && (this.invalidate(),
        this.clearDirty++,
        this.graphicsData.length = 0),
        this
    }
    drawShape(t, r=null, i=null, n=null) {
        const s = new pu(t,r,i,n);
        return this.graphicsData.push(s),
        this.dirty++,
        this
    }
    drawHole(t, r=null) {
        if (!this.graphicsData.length)
            return null;
        const i = new pu(t,null,null,r)
          , n = this.graphicsData[this.graphicsData.length - 1];
        return i.lineStyle = n.lineStyle,
        n.holes.push(i),
        this.dirty++,
        this
    }
    destroy() {
        super.destroy();
        for (let t = 0; t < this.graphicsData.length; ++t)
            this.graphicsData[t].destroy();
        this.points.length = 0,
        this.points = null,
        this.colors.length = 0,
        this.colors = null,
        this.uvs.length = 0,
        this.uvs = null,
        this.indices.length = 0,
        this.indices = null,
        this.indexBuffer.destroy(),
        this.indexBuffer = null,
        this.graphicsData.length = 0,
        this.graphicsData = null,
        this.drawCalls.length = 0,
        this.drawCalls = null,
        this.batches.length = 0,
        this.batches = null,
        this._bounds = null
    }
    containsPoint(t) {
        const r = this.graphicsData;
        for (let i = 0; i < r.length; ++i) {
            const n = r[i];
            if (n.fillStyle.visible && n.shape && (n.matrix ? n.matrix.applyInverse(t, Zo) : Zo.copyFrom(t),
            n.shape.contains(Zo.x, Zo.y))) {
                let s = !1;
                if (n.holes) {
                    for (let o = 0; o < n.holes.length; o++)
                        if (n.holes[o].shape.contains(Zo.x, Zo.y)) {
                            s = !0;
                            break
                        }
                }
                if (!s)
                    return !0
            }
        }
        return !1
    }
    updateBatches() {
        if (!this.graphicsData.length) {
            this.batchable = !0;
            return
        }
        if (!this.validateBatching())
            return;
        this.cacheDirty = this.dirty;
        const t = this.uvs
          , r = this.graphicsData;
        let i = null
          , n = null;
        this.batches.length > 0 && (i = this.batches[this.batches.length - 1],
        n = i.style);
        for (let l = this.shapeIndex; l < r.length; l++) {
            this.shapeIndex++;
            const h = r[l]
              , u = h.fillStyle
              , c = h.lineStyle;
            Td[h.type].build(h),
            h.matrix && this.transformPoints(h.points, h.matrix),
            (u.visible || c.visible) && this.processHoles(h.holes);
            for (let d = 0; d < 2; d++) {
                const f = d === 0 ? u : c;
                if (!f.visible)
                    continue;
                const g = f.texture.baseTexture
                  , p = this.indices.length
                  , v = this.points.length / 2;
                g.wrapMode = Ci.REPEAT,
                d === 0 ? this.processFill(h) : this.processLine(h);
                const y = this.points.length / 2 - v;
                y !== 0 && (i && !this._compareStyles(n, f) && (i.end(p, v),
                i = null),
                i || (i = k_.pop() || new gM,
                i.begin(f, p, v),
                this.batches.push(i),
                n = f),
                this.addUvs(this.points, t, f.texture, v, y, f.matrix))
            }
        }
        const s = this.indices.length
          , o = this.points.length / 2;
        if (i && i.end(s, o),
        this.batches.length === 0) {
            this.batchable = !0;
            return
        }
        const a = o > 65535;
        this.indicesUint16 && this.indices.length === this.indicesUint16.length && a === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = a ? new Uint32Array(this.indices) : new Uint16Array(this.indices),
        this.batchable = this.isBatchable(),
        this.batchable ? this.packBatches() : this.buildDrawCalls()
    }
    _compareStyles(t, r) {
        return !(!t || !r || t.texture.baseTexture !== r.texture.baseTexture || t.color + t.alpha !== r.color + r.alpha || !!t.native != !!r.native)
    }
    validateBatching() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length)
            return !1;
        for (let t = 0, r = this.graphicsData.length; t < r; t++) {
            const i = this.graphicsData[t]
              , n = i.fillStyle
              , s = i.lineStyle;
            if (n && !n.texture.baseTexture.valid || s && !s.texture.baseTexture.valid)
                return !1
        }
        return !0
    }
    packBatches() {
        this.batchDirty++,
        this.uvsFloat32 = new Float32Array(this.uvs);
        const t = this.batches;
        for (let r = 0, i = t.length; r < i; r++) {
            const n = t[r];
            for (let s = 0; s < n.size; s++) {
                const o = n.start + s;
                this.indicesUint16[o] = this.indicesUint16[o] - n.attribStart
            }
        }
    }
    isBatchable() {
        if (this.points.length > 65535 * 2)
            return !1;
        const t = this.batches;
        for (let r = 0; r < t.length; r++)
            if (t[r].style.native)
                return !1;
        return this.points.length < yM.BATCHABLE_SIZE * 2
    }
    buildDrawCalls() {
        let t = ++nt._globalBatch;
        for (let c = 0; c < this.drawCalls.length; c++)
            this.drawCalls[c].texArray.clear(),
            Kl.push(this.drawCalls[c]);
        this.drawCalls.length = 0;
        const r = this.colors
          , i = this.textureIds;
        let n = Kl.pop();
        n || (n = new gf,
        n.texArray = new _f),
        n.texArray.count = 0,
        n.start = 0,
        n.size = 0,
        n.type = Ti.TRIANGLES;
        let s = 0
          , o = null
          , a = 0
          , l = !1
          , h = Ti.TRIANGLES
          , u = 0;
        this.drawCalls.push(n);
        for (let c = 0; c < this.batches.length; c++) {
            const d = this.batches[c]
              , f = 8
              , g = d.style
              , p = g.texture.baseTexture;
            l !== !!g.native && (l = !!g.native,
            h = l ? Ti.LINES : Ti.TRIANGLES,
            o = null,
            s = f,
            t++),
            o !== p && (o = p,
            p._batchEnabled !== t && (s === f && (t++,
            s = 0,
            n.size > 0 && (n = Kl.pop(),
            n || (n = new gf,
            n.texArray = new _f),
            this.drawCalls.push(n)),
            n.start = u,
            n.size = 0,
            n.texArray.count = 0,
            n.type = h),
            p.touched = 1,
            p._batchEnabled = t,
            p._batchLocation = s,
            p.wrapMode = Ci.REPEAT,
            n.texArray.elements[n.texArray.count++] = p,
            s++)),
            n.size += d.size,
            u += d.size,
            a = p._batchLocation,
            this.addColors(r, g.color, g.alpha, d.attribSize, d.attribStart),
            this.addTextureIds(i, a, d.attribSize, d.attribStart)
        }
        nt._globalBatch = t,
        this.packAttributes()
    }
    packAttributes() {
        const t = this.points
          , r = this.uvs
          , i = this.colors
          , n = this.textureIds
          , s = new ArrayBuffer(t.length * 3 * 4)
          , o = new Float32Array(s)
          , a = new Uint32Array(s);
        let l = 0;
        for (let h = 0; h < t.length / 2; h++)
            o[l++] = t[h * 2],
            o[l++] = t[h * 2 + 1],
            o[l++] = r[h * 2],
            o[l++] = r[h * 2 + 1],
            a[l++] = i[h],
            o[l++] = n[h];
        this._buffer.update(s),
        this._indexBuffer.update(this.indicesUint16)
    }
    processFill(t) {
        t.holes.length ? Lx.triangulate(t, this) : Td[t.type].triangulate(t, this)
    }
    processLine(t) {
        B_(t, this);
        for (let r = 0; r < t.holes.length; r++)
            B_(t.holes[r], this)
    }
    processHoles(t) {
        for (let r = 0; r < t.length; r++) {
            const i = t[r];
            Td[i.type].build(i),
            i.matrix && this.transformPoints(i.points, i.matrix)
        }
    }
    calculateBounds() {
        const t = this._bounds;
        t.clear(),
        t.addVertexData(this.points, 0, this.points.length),
        t.pad(this.boundsPadding, this.boundsPadding)
    }
    transformPoints(t, r) {
        for (let i = 0; i < t.length / 2; i++) {
            const n = t[i * 2]
              , s = t[i * 2 + 1];
            t[i * 2] = r.a * n + r.c * s + r.tx,
            t[i * 2 + 1] = r.b * n + r.d * s + r.ty
        }
    }
    addColors(t, r, i, n, s=0) {
        const o = xt.shared.setValue(r).toLittleEndianNumber()
          , a = xt.shared.setValue(o).toPremultiplied(i);
        t.length = Math.max(t.length, s + n);
        for (let l = 0; l < n; l++)
            t[s + l] = a
    }
    addTextureIds(t, r, i, n=0) {
        t.length = Math.max(t.length, n + i);
        for (let s = 0; s < i; s++)
            t[n + s] = r
    }
    addUvs(t, r, i, n, s, o=null) {
        let a = 0;
        const l = r.length
          , h = i.frame;
        for (; a < s; ) {
            let c = t[(n + a) * 2]
              , d = t[(n + a) * 2 + 1];
            if (o) {
                const f = o.a * c + o.c * d + o.tx;
                d = o.b * c + o.d * d + o.ty,
                c = f
            }
            a++,
            r.push(c / h.width, d / h.height)
        }
        const u = i.baseTexture;
        (h.width < u.width || h.height < u.height) && this.adjustUvs(r, i, l, s)
    }
    adjustUvs(t, r, i, n) {
        const s = r.baseTexture
          , o = 1e-6
          , a = i + n * 2
          , l = r.frame
          , h = l.width / s.width
          , u = l.height / s.height;
        let c = l.x / l.width
          , d = l.y / l.height
          , f = Math.floor(t[i] + o)
          , g = Math.floor(t[i + 1] + o);
        for (let p = i + 2; p < a; p += 2)
            f = Math.min(f, Math.floor(t[p] + o)),
            g = Math.min(g, Math.floor(t[p + 1] + o));
        c -= f,
        d -= g;
        for (let p = i; p < a; p += 2)
            t[p] = (t[p] + c) * h,
            t[p + 1] = (t[p + 1] + d) * u
    }
}
;
_M.BATCHABLE_SIZE = 100;
let vM = _M;
class Wu {
    constructor() {
        this.color = 16777215,
        this.alpha = 1,
        this.texture = F.WHITE,
        this.matrix = null,
        this.visible = !1,
        this.reset()
    }
    clone() {
        const t = new Wu;
        return t.color = this.color,
        t.alpha = this.alpha,
        t.texture = this.texture,
        t.matrix = this.matrix,
        t.visible = this.visible,
        t
    }
    reset() {
        this.color = 16777215,
        this.alpha = 1,
        this.texture = F.WHITE,
        this.matrix = null,
        this.visible = !1
    }
    destroy() {
        this.texture = null,
        this.matrix = null
    }
}
class Gp extends Wu {
    constructor() {
        super(...arguments),
        this.width = 0,
        this.alignment = .5,
        this.native = !1,
        this.cap = Rn.BUTT,
        this.join = Sr.MITER,
        this.miterLimit = 10
    }
    clone() {
        const t = new Gp;
        return t.color = this.color,
        t.alpha = this.alpha,
        t.texture = this.texture,
        t.matrix = this.matrix,
        t.visible = this.visible,
        t.width = this.width,
        t.alignment = this.alignment,
        t.native = this.native,
        t.cap = this.cap,
        t.join = this.join,
        t.miterLimit = this.miterLimit,
        t
    }
    reset() {
        super.reset(),
        this.color = 0,
        this.alignment = .5,
        this.width = 0,
        this.native = !1,
        this.cap = Rn.BUTT,
        this.join = Sr.MITER,
        this.miterLimit = 10
    }
}
const dg = {}
  , F_ = class Sd extends J {
    constructor(t=null) {
        super(),
        this.shader = null,
        this.pluginName = "batch",
        this.currentPath = null,
        this.batches = [],
        this.batchTint = -1,
        this.batchDirty = -1,
        this.vertexData = null,
        this._fillStyle = new Wu,
        this._lineStyle = new Gp,
        this._matrix = null,
        this._holeMode = !1,
        this.state = Bi.for2d(),
        this._geometry = t || new vM,
        this._geometry.refCount++,
        this._transformID = -1,
        this._tintColor = new xt(16777215),
        this.blendMode = tt.NORMAL
    }
    get geometry() {
        return this._geometry
    }
    clone() {
        return this.finishPoly(),
        new Sd(this._geometry)
    }
    set blendMode(t) {
        this.state.blendMode = t
    }
    get blendMode() {
        return this.state.blendMode
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        this._tintColor.setValue(t)
    }
    get fill() {
        return this._fillStyle
    }
    get line() {
        return this._lineStyle
    }
    lineStyle(t=null, r=0, i, n=.5, s=!1) {
        return typeof t == "number" && (t = {
            width: t,
            color: r,
            alpha: i,
            alignment: n,
            native: s
        }),
        this.lineTextureStyle(t)
    }
    lineTextureStyle(t) {
        const r = {
            width: 0,
            texture: F.WHITE,
            color: t?.texture ? 16777215 : 0,
            matrix: null,
            alignment: .5,
            native: !1,
            cap: Rn.BUTT,
            join: Sr.MITER,
            miterLimit: 10
        };
        t = Object.assign(r, t),
        this.normalizeColor(t),
        this.currentPath && this.startPoly();
        const i = t.width > 0 && t.alpha > 0;
        return i ? (t.matrix && (t.matrix = t.matrix.clone(),
        t.matrix.invert()),
        Object.assign(this._lineStyle, {
            visible: i
        }, t)) : this._lineStyle.reset(),
        this
    }
    startPoly() {
        if (this.currentPath) {
            const t = this.currentPath.points
              , r = this.currentPath.points.length;
            r > 2 && (this.drawShape(this.currentPath),
            this.currentPath = new Ts,
            this.currentPath.closeStroke = !1,
            this.currentPath.points.push(t[r - 2], t[r - 1]))
        } else
            this.currentPath = new Ts,
            this.currentPath.closeStroke = !1
    }
    finishPoly() {
        this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath),
        this.currentPath = null) : this.currentPath.points.length = 0)
    }
    moveTo(t, r) {
        return this.startPoly(),
        this.currentPath.points[0] = t,
        this.currentPath.points[1] = r,
        this
    }
    lineTo(t, r) {
        this.currentPath || this.moveTo(0, 0);
        const i = this.currentPath.points
          , n = i[i.length - 2]
          , s = i[i.length - 1];
        return (n !== t || s !== r) && i.push(t, r),
        this
    }
    _initCurve(t=0, r=0) {
        this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [t, r]) : this.moveTo(t, r)
    }
    quadraticCurveTo(t, r, i, n) {
        this._initCurve();
        const s = this.currentPath.points;
        return s.length === 0 && this.moveTo(0, 0),
        Up.curveTo(t, r, i, n, s),
        this
    }
    bezierCurveTo(t, r, i, n, s, o) {
        return this._initCurve(),
        Fp.curveTo(t, r, i, n, s, o, this.currentPath.points),
        this
    }
    arcTo(t, r, i, n, s) {
        this._initCurve(t, r);
        const o = this.currentPath.points
          , a = D_.curveTo(t, r, i, n, s, o);
        if (a) {
            const {cx: l, cy: h, radius: u, startAngle: c, endAngle: d, anticlockwise: f} = a;
            this.arc(l, h, u, c, d, f)
        }
        return this
    }
    arc(t, r, i, n, s, o=!1) {
        if (n === s)
            return this;
        if (!o && s <= n ? s += eu : o && n <= s && (n += eu),
        s - n === 0)
            return this;
        const a = t + Math.cos(n) * i
          , l = r + Math.sin(n) * i
          , h = this._geometry.closePointEps;
        let u = this.currentPath ? this.currentPath.points : null;
        if (u) {
            const c = Math.abs(u[u.length - 2] - a)
              , d = Math.abs(u[u.length - 1] - l);
            c < h && d < h || u.push(a, l)
        } else
            this.moveTo(a, l),
            u = this.currentPath.points;
        return D_.arc(a, l, t, r, i, n, s, o, u),
        this
    }
    beginFill(t=0, r) {
        return this.beginTextureFill({
            texture: F.WHITE,
            color: t,
            alpha: r
        })
    }
    normalizeColor(t) {
        const r = xt.shared.setValue(t.color ?? 0);
        t.color = r.toNumber(),
        t.alpha ?? (t.alpha = r.alpha)
    }
    beginTextureFill(t) {
        const r = {
            texture: F.WHITE,
            color: 16777215,
            matrix: null
        };
        t = Object.assign(r, t),
        this.normalizeColor(t),
        this.currentPath && this.startPoly();
        const i = t.alpha > 0;
        return i ? (t.matrix && (t.matrix = t.matrix.clone(),
        t.matrix.invert()),
        Object.assign(this._fillStyle, {
            visible: i
        }, t)) : this._fillStyle.reset(),
        this
    }
    endFill() {
        return this.finishPoly(),
        this._fillStyle.reset(),
        this
    }
    drawRect(t, r, i, n) {
        return this.drawShape(new lt(t,r,i,n))
    }
    drawRoundedRect(t, r, i, n, s) {
        return this.drawShape(new Uu(t,r,i,n,s))
    }
    drawCircle(t, r, i) {
        return this.drawShape(new ku(t,r,i))
    }
    drawEllipse(t, r, i, n) {
        return this.drawShape(new Fu(t,r,i,n))
    }
    drawPolygon(...t) {
        let r, i = !0;
        const n = t[0];
        n.points ? (i = n.closeStroke,
        r = n.points) : Array.isArray(t[0]) ? r = t[0] : r = t;
        const s = new Ts(r);
        return s.closeStroke = i,
        this.drawShape(s),
        this
    }
    drawShape(t) {
        return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix),
        this
    }
    clear() {
        return this._geometry.clear(),
        this._lineStyle.reset(),
        this._fillStyle.reset(),
        this._boundsID++,
        this._matrix = null,
        this._holeMode = !1,
        this.currentPath = null,
        this
    }
    isFastRect() {
        const t = this._geometry.graphicsData;
        return t.length === 1 && t[0].shape.type === we.RECT && !t[0].matrix && !t[0].holes.length && !(t[0].lineStyle.visible && t[0].lineStyle.width)
    }
    _render(t) {
        this.finishPoly();
        const r = this._geometry;
        r.updateBatches(),
        r.batchable ? (this.batchDirty !== r.batchDirty && this._populateBatches(),
        this._renderBatched(t)) : (t.batch.flush(),
        this._renderDirect(t))
    }
    _populateBatches() {
        const t = this._geometry
          , r = this.blendMode
          , i = t.batches.length;
        this.batchTint = -1,
        this._transformID = -1,
        this.batchDirty = t.batchDirty,
        this.batches.length = i,
        this.vertexData = new Float32Array(t.points);
        for (let n = 0; n < i; n++) {
            const s = t.batches[n]
              , o = s.style.color
              , a = new Float32Array(this.vertexData.buffer,s.attribStart * 4 * 2,s.attribSize * 2)
              , l = new Float32Array(t.uvsFloat32.buffer,s.attribStart * 4 * 2,s.attribSize * 2)
              , h = new Uint16Array(t.indicesUint16.buffer,s.start * 2,s.size)
              , u = {
                vertexData: a,
                blendMode: r,
                indices: h,
                uvs: l,
                _batchRGB: xt.shared.setValue(o).toRgbArray(),
                _tintRGB: o,
                _texture: s.style.texture,
                alpha: s.style.alpha,
                worldAlpha: 1
            };
            this.batches[n] = u
        }
    }
    _renderBatched(t) {
        if (this.batches.length) {
            t.batch.setObjectRenderer(t.plugins[this.pluginName]),
            this.calculateVertices(),
            this.calculateTints();
            for (let r = 0, i = this.batches.length; r < i; r++) {
                const n = this.batches[r];
                n.worldAlpha = this.worldAlpha * n.alpha,
                t.plugins[this.pluginName].render(n)
            }
        }
    }
    _renderDirect(t) {
        const r = this._resolveDirectShader(t)
          , i = this._geometry
          , n = this.worldAlpha
          , s = r.uniforms
          , o = i.drawCalls;
        s.translationMatrix = this.transform.worldTransform,
        xt.shared.setValue(this._tintColor).premultiply(n).toArray(s.tint),
        t.shader.bind(r),
        t.geometry.bind(i, r),
        t.state.set(this.state);
        for (let a = 0, l = o.length; a < l; a++)
            this._renderDrawCallDirect(t, i.drawCalls[a])
    }
    _renderDrawCallDirect(t, r) {
        const {texArray: i, type: n, size: s, start: o} = r
          , a = i.count;
        for (let l = 0; l < a; l++)
            t.texture.bind(i.elements[l], l);
        t.geometry.draw(n, s, o)
    }
    _resolveDirectShader(t) {
        let r = this.shader;
        const i = this.pluginName;
        if (!r) {
            if (!dg[i]) {
                const {maxTextures: n} = t.plugins[i]
                  , s = new Int32Array(n);
                for (let l = 0; l < n; l++)
                    s[l] = l;
                const o = {
                    tint: new Float32Array([1, 1, 1, 1]),
                    translationMatrix: new Mt,
                    default: ni.from({
                        uSamplers: s
                    }, !0)
                }
                  , a = t.plugins[i]._shader.program;
                dg[i] = new Ri(a,o)
            }
            r = dg[i]
        }
        return r
    }
    _calculateBounds() {
        this.finishPoly();
        const t = this._geometry;
        if (!t.graphicsData.length)
            return;
        const {minX: r, minY: i, maxX: n, maxY: s} = t.bounds;
        this._bounds.addFrame(this.transform, r, i, n, s)
    }
    containsPoint(t) {
        return this.worldTransform.applyInverse(t, Sd._TEMP_POINT),
        this._geometry.containsPoint(Sd._TEMP_POINT)
    }
    calculateTints() {
        if (this.batchTint !== this.tint) {
            this.batchTint = this._tintColor.toNumber();
            for (let t = 0; t < this.batches.length; t++) {
                const r = this.batches[t];
                r._tintRGB = xt.shared.setValue(this._tintColor).multiply(r._batchRGB).toLittleEndianNumber()
            }
        }
    }
    calculateVertices() {
        const t = this.transform._worldID;
        if (this._transformID === t)
            return;
        this._transformID = t;
        const r = this.transform.worldTransform
          , i = r.a
          , n = r.b
          , s = r.c
          , o = r.d
          , a = r.tx
          , l = r.ty
          , h = this._geometry.points
          , u = this.vertexData;
        let c = 0;
        for (let d = 0; d < h.length; d += 2) {
            const f = h[d]
              , g = h[d + 1];
            u[c++] = i * f + s * g + a,
            u[c++] = o * g + n * f + l
        }
    }
    closePath() {
        const t = this.currentPath;
        return t && (t.closeStroke = !0,
        this.finishPoly()),
        this
    }
    setMatrix(t) {
        return this._matrix = t,
        this
    }
    beginHole() {
        return this.finishPoly(),
        this._holeMode = !0,
        this
    }
    endHole() {
        return this.finishPoly(),
        this._holeMode = !1,
        this
    }
    destroy(t) {
        this._geometry.refCount--,
        this._geometry.refCount === 0 && this._geometry.dispose(),
        this._matrix = null,
        this.currentPath = null,
        this._lineStyle.destroy(),
        this._lineStyle = null,
        this._fillStyle.destroy(),
        this._fillStyle = null,
        this._geometry = null,
        this.shader = null,
        this.vertexData = null,
        this.batches.length = 0,
        this.batches = null,
        super.destroy(t)
    }
}
;
F_.curves = Rs,
F_._TEMP_POINT = new st;
let Dx = F_;
const kV = {
    buildPoly: Lx,
    buildCircle: fu,
    buildRectangle: pM,
    buildRoundedRectangle: mM,
    buildLine: B_,
    ArcUtils: D_,
    BezierUtils: Fp,
    QuadraticUtils: Up,
    BatchPart: gM,
    FILL_COMMANDS: Td,
    BATCH_POOL: k_,
    DRAW_CALL_POOL: Kl
};
class xM {
    constructor(t, r) {
        this.uvBuffer = t,
        this.uvMatrix = r,
        this.data = null,
        this._bufferUpdateId = -1,
        this._textureUpdateId = -1,
        this._updateID = 0
    }
    update(t) {
        if (!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)
            return;
        this._bufferUpdateId = this.uvBuffer._updateID,
        this._textureUpdateId = this.uvMatrix._updateID;
        const r = this.uvBuffer.data;
        (!this.data || this.data.length !== r.length) && (this.data = new Float32Array(r.length)),
        this.uvMatrix.multiplyUvs(r, this.data),
        this._updateID++
    }
}
const fg = new st
  , aw = new Ts
  , EM = class TM extends J {
    constructor(t, r, i, n=Ti.TRIANGLES) {
        super(),
        this.geometry = t,
        this.shader = r,
        this.state = i || Bi.for2d(),
        this.drawMode = n,
        this.start = 0,
        this.size = 0,
        this.uvs = null,
        this.indices = null,
        this.vertexData = new Float32Array(1),
        this.vertexDirty = -1,
        this._transformID = -1,
        this._roundPixels = z.ROUND_PIXELS,
        this.batchUvs = null
    }
    get geometry() {
        return this._geometry
    }
    set geometry(t) {
        this._geometry !== t && (this._geometry && (this._geometry.refCount--,
        this._geometry.refCount === 0 && this._geometry.dispose()),
        this._geometry = t,
        this._geometry && this._geometry.refCount++,
        this.vertexDirty = -1)
    }
    get uvBuffer() {
        return this.geometry.buffers[1]
    }
    get verticesBuffer() {
        return this.geometry.buffers[0]
    }
    set material(t) {
        this.shader = t
    }
    get material() {
        return this.shader
    }
    set blendMode(t) {
        this.state.blendMode = t
    }
    get blendMode() {
        return this.state.blendMode
    }
    set roundPixels(t) {
        this._roundPixels !== t && (this._transformID = -1),
        this._roundPixels = t
    }
    get roundPixels() {
        return this._roundPixels
    }
    get tint() {
        return "tint"in this.shader ? this.shader.tint : null
    }
    set tint(t) {
        this.shader.tint = t
    }
    get tintValue() {
        return this.shader.tintValue
    }
    get texture() {
        return "texture"in this.shader ? this.shader.texture : null
    }
    set texture(t) {
        this.shader.texture = t
    }
    _render(t) {
        const r = this.geometry.buffers[0].data;
        this.shader.batchable && this.drawMode === Ti.TRIANGLES && r.length < TM.BATCHABLE_SIZE * 2 ? this._renderToBatch(t) : this._renderDefault(t)
    }
    _renderDefault(t) {
        const r = this.shader;
        r.alpha = this.worldAlpha,
        r.update && r.update(),
        t.batch.flush(),
        r.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0),
        t.shader.bind(r),
        t.state.set(this.state),
        t.geometry.bind(this.geometry, r),
        t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
    }
    _renderToBatch(t) {
        const r = this.geometry
          , i = this.shader;
        i.uvMatrix && (i.uvMatrix.update(),
        this.calculateUvs()),
        this.calculateVertices(),
        this.indices = r.indexBuffer.data,
        this._tintRGB = i._tintRGB,
        this._texture = i.texture;
        const n = this.material.pluginName;
        t.batch.setObjectRenderer(t.plugins[n]),
        t.plugins[n].render(this)
    }
    calculateVertices() {
        const t = this.geometry.buffers[0]
          , r = t.data
          , i = t._updateID;
        if (i === this.vertexDirty && this._transformID === this.transform._worldID)
            return;
        this._transformID = this.transform._worldID,
        this.vertexData.length !== r.length && (this.vertexData = new Float32Array(r.length));
        const n = this.transform.worldTransform
          , s = n.a
          , o = n.b
          , a = n.c
          , l = n.d
          , h = n.tx
          , u = n.ty
          , c = this.vertexData;
        for (let d = 0; d < c.length / 2; d++) {
            const f = r[d * 2]
              , g = r[d * 2 + 1];
            c[d * 2] = s * f + a * g + h,
            c[d * 2 + 1] = o * f + l * g + u
        }
        if (this._roundPixels) {
            const d = z.RESOLUTION;
            for (let f = 0; f < c.length; ++f)
                c[f] = Math.round(c[f] * d) / d
        }
        this.vertexDirty = i
    }
    calculateUvs() {
        const t = this.geometry.buffers[1]
          , r = this.shader;
        r.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new xM(t,r.uvMatrix)),
        this.batchUvs.update(),
        this.uvs = this.batchUvs.data)
    }
    _calculateBounds() {
        this.calculateVertices(),
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
    }
    containsPoint(t) {
        if (!this.getBounds().contains(t.x, t.y))
            return !1;
        this.worldTransform.applyInverse(t, fg);
        const r = this.geometry.getBuffer("aVertexPosition").data
          , i = aw.points
          , n = this.geometry.getIndex().data
          , s = n.length
          , o = this.drawMode === 4 ? 3 : 1;
        for (let a = 0; a + 2 < s; a += o) {
            const l = n[a] * 2
              , h = n[a + 1] * 2
              , u = n[a + 2] * 2;
            if (i[0] = r[l],
            i[1] = r[l + 1],
            i[2] = r[h],
            i[3] = r[h + 1],
            i[4] = r[u],
            i[5] = r[u + 1],
            aw.contains(fg.x, fg.y))
                return !0
        }
        return !1
    }
    destroy(t) {
        super.destroy(t),
        this._cachedTexture && (this._cachedTexture.destroy(),
        this._cachedTexture = null),
        this.geometry = null,
        this.shader = null,
        this.state = null,
        this.uvs = null,
        this.indices = null,
        this.vertexData = null
    }
}
;
EM.BATCHABLE_SIZE = 100;
let rl = EM;
class Vu extends Un {
    constructor(t, r, i) {
        super();
        const n = new te(t)
          , s = new te(r,!0)
          , o = new te(i,!0,!0);
        this.addAttribute("aVertexPosition", n, 2, !1, Q.FLOAT).addAttribute("aTextureCoord", s, 2, !1, Q.FLOAT).addIndex(o),
        this._updateId = -1
    }
    get vertexDirtyId() {
        return this.buffers[0]._updateID
    }
}
var FV = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`
  , UV = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
class il extends Ri {
    constructor(t, r) {
        const i = {
            uSampler: t,
            alpha: 1,
            uTextureMatrix: Mt.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1])
        };
        r = Object.assign({
            tint: 16777215,
            alpha: 1,
            pluginName: "batch"
        }, r),
        r.uniforms && Object.assign(i, r.uniforms),
        super(r.program || tn.from(UV, FV), i),
        this._colorDirty = !1,
        this.uvMatrix = new Lp(t),
        this.batchable = r.program === void 0,
        this.pluginName = r.pluginName,
        this._tintColor = new xt(r.tint),
        this._tintRGB = this._tintColor.toLittleEndianNumber(),
        this._colorDirty = !0,
        this.alpha = r.alpha
    }
    get texture() {
        return this.uniforms.uSampler
    }
    set texture(t) {
        this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode != !t.baseTexture.alphaMode && (this._colorDirty = !0),
        this.uniforms.uSampler = t,
        this.uvMatrix.texture = t)
    }
    set alpha(t) {
        t !== this._alpha && (this._alpha = t,
        this._colorDirty = !0)
    }
    get alpha() {
        return this._alpha
    }
    set tint(t) {
        t !== this.tint && (this._tintColor.setValue(t),
        this._tintRGB = this._tintColor.toLittleEndianNumber(),
        this._colorDirty = !0)
    }
    get tint() {
        return this._tintColor.value
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    update() {
        if (this._colorDirty) {
            this._colorDirty = !1;
            const t = this.texture.baseTexture.alphaMode;
            xt.shared.setValue(this._tintColor).premultiply(this._alpha, t).toArray(this.uniforms.uColor)
        }
        this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
    }
}
class SM extends Vu {
    constructor(t=100, r=100, i=10, n=10) {
        super(),
        this.segWidth = i,
        this.segHeight = n,
        this.width = t,
        this.height = r,
        this.build()
    }
    build() {
        const t = this.segWidth * this.segHeight
          , r = []
          , i = []
          , n = []
          , s = this.segWidth - 1
          , o = this.segHeight - 1
          , a = this.width / s
          , l = this.height / o;
        for (let u = 0; u < t; u++) {
            const c = u % this.segWidth
              , d = u / this.segWidth | 0;
            r.push(c * a, d * l),
            i.push(c / s, d / o)
        }
        const h = s * o;
        for (let u = 0; u < h; u++) {
            const c = u % s
              , d = u / s | 0
              , f = d * this.segWidth + c
              , g = d * this.segWidth + c + 1
              , p = (d + 1) * this.segWidth + c
              , v = (d + 1) * this.segWidth + c + 1;
            n.push(f, g, p, g, v, p)
        }
        this.buffers[0].data = new Float32Array(r),
        this.buffers[1].data = new Float32Array(i),
        this.indexBuffer.data = new Uint16Array(n),
        this.buffers[0].update(),
        this.buffers[1].update(),
        this.indexBuffer.update()
    }
}
class wM extends Vu {
    constructor(t=200, r, i=0) {
        super(new Float32Array(r.length * 4), new Float32Array(r.length * 4), new Uint16Array((r.length - 1) * 6)),
        this.points = r,
        this._width = t,
        this.textureScale = i,
        this.build()
    }
    get width() {
        return this._width
    }
    build() {
        const t = this.points;
        if (!t)
            return;
        const r = this.getBuffer("aVertexPosition")
          , i = this.getBuffer("aTextureCoord")
          , n = this.getIndex();
        if (t.length < 1)
            return;
        r.data.length / 4 !== t.length && (r.data = new Float32Array(t.length * 4),
        i.data = new Float32Array(t.length * 4),
        n.data = new Uint16Array((t.length - 1) * 6));
        const s = i.data
          , o = n.data;
        s[0] = 0,
        s[1] = 0,
        s[2] = 0,
        s[3] = 1;
        let a = 0
          , l = t[0];
        const h = this._width * this.textureScale
          , u = t.length;
        for (let d = 0; d < u; d++) {
            const f = d * 4;
            if (this.textureScale > 0) {
                const g = l.x - t[d].x
                  , p = l.y - t[d].y
                  , v = Math.sqrt(g * g + p * p);
                l = t[d],
                a += v / h
            } else
                a = d / (u - 1);
            s[f] = a,
            s[f + 1] = 0,
            s[f + 2] = a,
            s[f + 3] = 1
        }
        let c = 0;
        for (let d = 0; d < u - 1; d++) {
            const f = d * 2;
            o[c++] = f,
            o[c++] = f + 1,
            o[c++] = f + 2,
            o[c++] = f + 2,
            o[c++] = f + 1,
            o[c++] = f + 3
        }
        i.update(),
        n.update(),
        this.updateVertices()
    }
    updateVertices() {
        const t = this.points;
        if (t.length < 1)
            return;
        let r = t[0], i, n = 0, s = 0;
        const o = this.buffers[0].data
          , a = t.length
          , l = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        for (let h = 0; h < a; h++) {
            const u = t[h]
              , c = h * 4;
            h < t.length - 1 ? i = t[h + 1] : i = u,
            s = -(i.x - r.x),
            n = i.y - r.y;
            const d = Math.sqrt(n * n + s * s);
            d < 1e-6 ? (n = 0,
            s = 0) : (n /= d,
            s /= d,
            n *= l,
            s *= l),
            o[c] = u.x + n,
            o[c + 1] = u.y + s,
            o[c + 2] = u.x - n,
            o[c + 3] = u.y - s,
            r = u
        }
        this.buffers[0].update()
    }
    update() {
        this.textureScale > 0 ? this.build() : this.updateVertices()
    }
}
class AM extends rl {
    constructor(t, r, i) {
        const n = new SM(t.width,t.height,r,i)
          , s = new il(F.WHITE);
        super(n, s),
        this.texture = t,
        this.autoResize = !0
    }
    textureUpdated() {
        this._textureID = this.shader.texture._updateID;
        const t = this.geometry
          , {width: r, height: i} = this.shader.texture;
        this.autoResize && (t.width !== r || t.height !== i) && (t.width = this.shader.texture.width,
        t.height = this.shader.texture.height,
        t.build())
    }
    set texture(t) {
        this.shader.texture !== t && (this.shader.texture = t,
        this._textureID = -1,
        t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this))
    }
    get texture() {
        return this.shader.texture
    }
    _render(t) {
        this._textureID !== this.shader.texture._updateID && this.textureUpdated(),
        super._render(t)
    }
    destroy(t) {
        this.shader.texture.off("update", this.textureUpdated, this),
        super.destroy(t)
    }
}
const $c = 10;
class bM extends AM {
    constructor(t, r, i, n, s) {
        super(F.WHITE, 4, 4),
        this._origWidth = t.orig.width,
        this._origHeight = t.orig.height,
        this._width = this._origWidth,
        this._height = this._origHeight,
        this._leftWidth = r ?? t.defaultBorders?.left ?? $c,
        this._rightWidth = n ?? t.defaultBorders?.right ?? $c,
        this._topHeight = i ?? t.defaultBorders?.top ?? $c,
        this._bottomHeight = s ?? t.defaultBorders?.bottom ?? $c,
        this.texture = t
    }
    textureUpdated() {
        this._textureID = this.shader.texture._updateID,
        this._refresh()
    }
    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }
    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }
    updateHorizontalVertices() {
        const t = this.vertices
          , r = this._getMinScale();
        t[9] = t[11] = t[13] = t[15] = this._topHeight * r,
        t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * r,
        t[25] = t[27] = t[29] = t[31] = this._height
    }
    updateVerticalVertices() {
        const t = this.vertices
          , r = this._getMinScale();
        t[2] = t[10] = t[18] = t[26] = this._leftWidth * r,
        t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * r,
        t[6] = t[14] = t[22] = t[30] = this._width
    }
    _getMinScale() {
        const t = this._leftWidth + this._rightWidth
          , r = this._width > t ? 1 : this._width / t
          , i = this._topHeight + this._bottomHeight
          , n = this._height > i ? 1 : this._height / i;
        return Math.min(r, n)
    }
    get width() {
        return this._width
    }
    set width(t) {
        this._width = t,
        this._refresh()
    }
    get height() {
        return this._height
    }
    set height(t) {
        this._height = t,
        this._refresh()
    }
    get leftWidth() {
        return this._leftWidth
    }
    set leftWidth(t) {
        this._leftWidth = t,
        this._refresh()
    }
    get rightWidth() {
        return this._rightWidth
    }
    set rightWidth(t) {
        this._rightWidth = t,
        this._refresh()
    }
    get topHeight() {
        return this._topHeight
    }
    set topHeight(t) {
        this._topHeight = t,
        this._refresh()
    }
    get bottomHeight() {
        return this._bottomHeight
    }
    set bottomHeight(t) {
        this._bottomHeight = t,
        this._refresh()
    }
    _refresh() {
        const t = this.texture
          , r = this.geometry.buffers[1].data;
        this._origWidth = t.orig.width,
        this._origHeight = t.orig.height;
        const i = 1 / this._origWidth
          , n = 1 / this._origHeight;
        r[0] = r[8] = r[16] = r[24] = 0,
        r[1] = r[3] = r[5] = r[7] = 0,
        r[6] = r[14] = r[22] = r[30] = 1,
        r[25] = r[27] = r[29] = r[31] = 1,
        r[2] = r[10] = r[18] = r[26] = i * this._leftWidth,
        r[4] = r[12] = r[20] = r[28] = 1 - i * this._rightWidth,
        r[9] = r[11] = r[13] = r[15] = n * this._topHeight,
        r[17] = r[19] = r[21] = r[23] = 1 - n * this._bottomHeight,
        this.updateHorizontalVertices(),
        this.updateVerticalVertices(),
        this.geometry.buffers[0].update(),
        this.geometry.buffers[1].update()
    }
}
class GV extends rl {
    constructor(t=F.EMPTY, r, i, n, s) {
        const o = new Vu(r,i,n);
        o.getBuffer("aVertexPosition").static = !1;
        const a = new il(t);
        super(o, a, null, s),
        this.autoUpdate = !0
    }
    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }
    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }
    _render(t) {
        this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(),
        super._render(t)
    }
}
class HV extends rl {
    constructor(t, r, i=0) {
        const n = new wM(t.height,r,i)
          , s = new il(t);
        i > 0 && (t.baseTexture.wrapMode = Ci.REPEAT),
        super(n, s),
        this.autoUpdate = !0
    }
    _render(t) {
        const r = this.geometry;
        (this.autoUpdate || r._width !== this.shader.texture.height) && (r._width = this.shader.texture.height,
        r.update()),
        super._render(t)
    }
}
class If extends J {
    constructor(t=1500, r, i=16384, n=!1) {
        super();
        const s = 16384;
        i > s && (i = s),
        this._properties = [!1, !0, !1, !1, !1],
        this._maxSize = t,
        this._batchSize = i,
        this._buffers = null,
        this._bufferUpdateIDs = [],
        this._updateID = 0,
        this.interactiveChildren = !1,
        this.blendMode = tt.NORMAL,
        this.autoResize = n,
        this.roundPixels = !0,
        this.baseTexture = null,
        this.setProperties(r),
        this._tintColor = new xt(0),
        this.tintRgb = new Float32Array(3),
        this.tint = 16777215
    }
    setProperties(t) {
        t && (this._properties[0] = "vertices"in t || "scale"in t ? !!t.vertices || !!t.scale : this._properties[0],
        this._properties[1] = "position"in t ? !!t.position : this._properties[1],
        this._properties[2] = "rotation"in t ? !!t.rotation : this._properties[2],
        this._properties[3] = "uvs"in t ? !!t.uvs : this._properties[3],
        this._properties[4] = "tint"in t || "alpha"in t ? !!t.tint || !!t.alpha : this._properties[4])
    }
    updateTransform() {
        this.displayObjectUpdateTransform()
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        this._tintColor.setValue(t),
        this._tintColor.toRgbArray(this.tintRgb)
    }
    render(t) {
        !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture,
        this.baseTexture.valid || this.baseTexture.once("update", () => this.onChildrenChange(0))),
        t.batch.setObjectRenderer(t.plugins.particle),
        t.plugins.particle.render(this))
    }
    onChildrenChange(t) {
        const r = Math.floor(t / this._batchSize);
        for (; this._bufferUpdateIDs.length < r; )
            this._bufferUpdateIDs.push(0);
        this._bufferUpdateIDs[r] = ++this._updateID
    }
    dispose() {
        if (this._buffers) {
            for (let t = 0; t < this._buffers.length; ++t)
                this._buffers[t].destroy();
            this._buffers = null
        }
    }
    destroy(t) {
        super.destroy(t),
        this.dispose(),
        this._properties = null,
        this._buffers = null,
        this._bufferUpdateIDs = null
    }
}
class lw {
    constructor(t, r, i) {
        this.geometry = new Un,
        this.indexBuffer = null,
        this.size = i,
        this.dynamicProperties = [],
        this.staticProperties = [];
        for (let n = 0; n < t.length; ++n) {
            let s = t[n];
            s = {
                attributeName: s.attributeName,
                size: s.size,
                uploadFunction: s.uploadFunction,
                type: s.type || Q.FLOAT,
                offset: s.offset
            },
            r[n] ? this.dynamicProperties.push(s) : this.staticProperties.push(s)
        }
        this.staticStride = 0,
        this.staticBuffer = null,
        this.staticData = null,
        this.staticDataUint32 = null,
        this.dynamicStride = 0,
        this.dynamicBuffer = null,
        this.dynamicData = null,
        this.dynamicDataUint32 = null,
        this._updateID = 0,
        this.initBuffers()
    }
    initBuffers() {
        const t = this.geometry;
        let r = 0;
        this.indexBuffer = new te(AI(this.size),!0,!0),
        t.addIndex(this.indexBuffer),
        this.dynamicStride = 0;
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            a.offset = r,
            r += a.size,
            this.dynamicStride += a.size
        }
        const i = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(i),
        this.dynamicDataUint32 = new Uint32Array(i),
        this.dynamicBuffer = new te(this.dynamicData,!1,!1);
        let n = 0;
        this.staticStride = 0;
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            a.offset = n,
            n += a.size,
            this.staticStride += a.size
        }
        const s = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(s),
        this.staticDataUint32 = new Uint32Array(s),
        this.staticBuffer = new te(this.staticData,!0,!1);
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            t.addAttribute(a.attributeName, this.dynamicBuffer, 0, a.type === Q.UNSIGNED_BYTE, a.type, this.dynamicStride * 4, a.offset * 4)
        }
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            t.addAttribute(a.attributeName, this.staticBuffer, 0, a.type === Q.UNSIGNED_BYTE, a.type, this.staticStride * 4, a.offset * 4)
        }
    }
    uploadDynamic(t, r, i) {
        for (let n = 0; n < this.dynamicProperties.length; n++) {
            const s = this.dynamicProperties[n];
            s.uploadFunction(t, r, i, s.type === Q.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, s.offset)
        }
        this.dynamicBuffer._updateID++
    }
    uploadStatic(t, r, i) {
        for (let n = 0; n < this.staticProperties.length; n++) {
            const s = this.staticProperties[n];
            s.uploadFunction(t, r, i, s.type === Q.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, s.offset)
        }
        this.staticBuffer._updateID++
    }
    destroy() {
        this.indexBuffer = null,
        this.dynamicProperties = null,
        this.dynamicBuffer = null,
        this.dynamicData = null,
        this.dynamicDataUint32 = null,
        this.staticProperties = null,
        this.staticBuffer = null,
        this.staticData = null,
        this.staticDataUint32 = null,
        this.geometry.destroy()
    }
}
var $V = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`
  , zV = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
class Bx extends Hu {
    constructor(t) {
        super(t),
        this.shader = null,
        this.properties = null,
        this.tempMatrix = new Mt,
        this.properties = [{
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: this.uploadVertices,
            offset: 0
        }, {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: this.uploadPosition,
            offset: 0
        }, {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: this.uploadRotation,
            offset: 0
        }, {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: this.uploadUvs,
            offset: 0
        }, {
            attributeName: "aColor",
            size: 1,
            type: Q.UNSIGNED_BYTE,
            uploadFunction: this.uploadTint,
            offset: 0
        }],
        this.shader = Ri.from(zV, $V, {}),
        this.state = Bi.for2d()
    }
    render(t) {
        const r = t.children
          , i = t._maxSize
          , n = t._batchSize
          , s = this.renderer;
        let o = r.length;
        if (o === 0)
            return;
        o > i && !t.autoResize && (o = i);
        let a = t._buffers;
        a || (a = t._buffers = this.generateBuffers(t));
        const l = r[0]._texture.baseTexture
          , h = l.alphaMode > 0;
        this.state.blendMode = tx(t.blendMode, h),
        s.state.set(this.state);
        const u = s.gl
          , c = t.worldTransform.copyTo(this.tempMatrix);
        c.prepend(s.globalUniforms.uniforms.projectionMatrix),
        this.shader.uniforms.translationMatrix = c.toArray(!0),
        this.shader.uniforms.uColor = xt.shared.setValue(t.tintRgb).premultiply(t.worldAlpha, h).toArray(this.shader.uniforms.uColor),
        this.shader.uniforms.uSampler = l,
        this.renderer.shader.bind(this.shader);
        let d = !1;
        for (let f = 0, g = 0; f < o; f += n,
        g += 1) {
            let p = o - f;
            p > n && (p = n),
            g >= a.length && a.push(this._generateOneMoreBuffer(t));
            const v = a[g];
            v.uploadDynamic(r, f, p);
            const y = t._bufferUpdateIDs[g] || 0;
            d = d || v._updateID < y,
            d && (v._updateID = t._updateID,
            v.uploadStatic(r, f, p)),
            s.geometry.bind(v.geometry),
            u.drawElements(u.TRIANGLES, p * 6, u.UNSIGNED_SHORT, 0)
        }
    }
    generateBuffers(t) {
        const r = []
          , i = t._maxSize
          , n = t._batchSize
          , s = t._properties;
        for (let o = 0; o < i; o += n)
            r.push(new lw(this.properties,s,n));
        return r
    }
    _generateOneMoreBuffer(t) {
        const r = t._batchSize
          , i = t._properties;
        return new lw(this.properties,i,r)
    }
    uploadVertices(t, r, i, n, s, o) {
        let a = 0
          , l = 0
          , h = 0
          , u = 0;
        for (let c = 0; c < i; ++c) {
            const d = t[r + c]
              , f = d._texture
              , g = d.scale.x
              , p = d.scale.y
              , v = f.trim
              , y = f.orig;
            v ? (l = v.x - d.anchor.x * y.width,
            a = l + v.width,
            u = v.y - d.anchor.y * y.height,
            h = u + v.height) : (a = y.width * (1 - d.anchor.x),
            l = y.width * -d.anchor.x,
            h = y.height * (1 - d.anchor.y),
            u = y.height * -d.anchor.y),
            n[o] = l * g,
            n[o + 1] = u * p,
            n[o + s] = a * g,
            n[o + s + 1] = u * p,
            n[o + s * 2] = a * g,
            n[o + s * 2 + 1] = h * p,
            n[o + s * 3] = l * g,
            n[o + s * 3 + 1] = h * p,
            o += s * 4
        }
    }
    uploadPosition(t, r, i, n, s, o) {
        for (let a = 0; a < i; a++) {
            const l = t[r + a].position;
            n[o] = l.x,
            n[o + 1] = l.y,
            n[o + s] = l.x,
            n[o + s + 1] = l.y,
            n[o + s * 2] = l.x,
            n[o + s * 2 + 1] = l.y,
            n[o + s * 3] = l.x,
            n[o + s * 3 + 1] = l.y,
            o += s * 4
        }
    }
    uploadRotation(t, r, i, n, s, o) {
        for (let a = 0; a < i; a++) {
            const l = t[r + a].rotation;
            n[o] = l,
            n[o + s] = l,
            n[o + s * 2] = l,
            n[o + s * 3] = l,
            o += s * 4
        }
    }
    uploadUvs(t, r, i, n, s, o) {
        for (let a = 0; a < i; ++a) {
            const l = t[r + a]._texture._uvs;
            l ? (n[o] = l.x0,
            n[o + 1] = l.y0,
            n[o + s] = l.x1,
            n[o + s + 1] = l.y1,
            n[o + s * 2] = l.x2,
            n[o + s * 2 + 1] = l.y2,
            n[o + s * 3] = l.x3,
            n[o + s * 3 + 1] = l.y3,
            o += s * 4) : (n[o] = 0,
            n[o + 1] = 0,
            n[o + s] = 0,
            n[o + s + 1] = 0,
            n[o + s * 2] = 0,
            n[o + s * 2 + 1] = 0,
            n[o + s * 3] = 0,
            n[o + s * 3 + 1] = 0,
            o += s * 4)
        }
    }
    uploadTint(t, r, i, n, s, o) {
        for (let a = 0; a < i; ++a) {
            const l = t[r + a]
              , h = xt.shared.setValue(l._tintRGB).toPremultiplied(l.alpha, l.texture.baseTexture.alphaMode > 0);
            n[o] = h,
            n[o + s] = h,
            n[o + s * 2] = h,
            n[o + s * 3] = h,
            o += s * 4
        }
    }
    destroy() {
        super.destroy(),
        this.shader && (this.shader.destroy(),
        this.shader = null),
        this.tempMatrix = null
    }
}
Bx.extension = {
    name: "particle",
    type: G.RendererPlugin
};
Y.add(Bx);
var ju = (e => (e[e.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL",
e[e.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL",
e))(ju || {});
const zc = {
    willReadFrequently: !0
}
  , $i = class q {
    static get experimentalLetterSpacingSupported() {
        let t = q._experimentalLetterSpacingSupported;
        if (t !== void 0) {
            const r = z.ADAPTER.getCanvasRenderingContext2D().prototype;
            t = q._experimentalLetterSpacingSupported = "letterSpacing"in r || "textLetterSpacing"in r
        }
        return t
    }
    constructor(t, r, i, n, s, o, a, l, h) {
        this.text = t,
        this.style = r,
        this.width = i,
        this.height = n,
        this.lines = s,
        this.lineWidths = o,
        this.lineHeight = a,
        this.maxLineWidth = l,
        this.fontProperties = h
    }
    static measureText(t, r, i, n=q._canvas) {
        i = i ?? r.wordWrap;
        const s = r.toFontString()
          , o = q.measureFont(s);
        o.fontSize === 0 && (o.fontSize = r.fontSize,
        o.ascent = r.fontSize);
        const a = n.getContext("2d", zc);
        a.font = s;
        const l = (i ? q.wordWrap(t, r, n) : t).split(/(?:\r\n|\r|\n)/)
          , h = new Array(l.length);
        let u = 0;
        for (let g = 0; g < l.length; g++) {
            const p = q._measureText(l[g], r.letterSpacing, a);
            h[g] = p,
            u = Math.max(u, p)
        }
        let c = u + r.strokeThickness;
        r.dropShadow && (c += r.dropShadowDistance);
        const d = r.lineHeight || o.fontSize + r.strokeThickness;
        let f = Math.max(d, o.fontSize + r.strokeThickness * 2) + r.leading + (l.length - 1) * (d + r.leading);
        return r.dropShadow && (f += r.dropShadowDistance),
        new q(t,r,c,f,l,h,d + r.leading,u,o)
    }
    static _measureText(t, r, i) {
        let n = !1;
        q.experimentalLetterSpacingSupported && (q.experimentalLetterSpacing ? (i.letterSpacing = `${r}px`,
        i.textLetterSpacing = `${r}px`,
        n = !0) : (i.letterSpacing = "0px",
        i.textLetterSpacing = "0px"));
        let s = i.measureText(t).width;
        return s > 0 && (n ? s -= r : s += (q.graphemeSegmenter(t).length - 1) * r),
        s
    }
    static wordWrap(t, r, i=q._canvas) {
        const n = i.getContext("2d", zc);
        let s = 0
          , o = ""
          , a = "";
        const l = Object.create(null)
          , {letterSpacing: h, whiteSpace: u} = r
          , c = q.collapseSpaces(u)
          , d = q.collapseNewlines(u);
        let f = !c;
        const g = r.wordWrapWidth + h
          , p = q.tokenize(t);
        for (let v = 0; v < p.length; v++) {
            let y = p[v];
            if (q.isNewline(y)) {
                if (!d) {
                    a += q.addLine(o),
                    f = !c,
                    o = "",
                    s = 0;
                    continue
                }
                y = " "
            }
            if (c) {
                const _ = q.isBreakingSpace(y)
                  , x = q.isBreakingSpace(o[o.length - 1]);
                if (_ && x)
                    continue
            }
            const m = q.getFromCache(y, h, l, n);
            if (m > g)
                if (o !== "" && (a += q.addLine(o),
                o = "",
                s = 0),
                q.canBreakWords(y, r.breakWords)) {
                    const _ = q.wordWrapSplit(y);
                    for (let x = 0; x < _.length; x++) {
                        let E = _[x]
                          , S = E
                          , w = 1;
                        for (; _[x + w]; ) {
                            const C = _[x + w];
                            if (!q.canBreakChars(S, C, y, x, r.breakWords))
                                E += C;
                            else
                                break;
                            S = C,
                            w++
                        }
                        x += w - 1;
                        const T = q.getFromCache(E, h, l, n);
                        T + s > g && (a += q.addLine(o),
                        f = !1,
                        o = "",
                        s = 0),
                        o += E,
                        s += T
                    }
                } else {
                    o.length > 0 && (a += q.addLine(o),
                    o = "",
                    s = 0);
                    const _ = v === p.length - 1;
                    a += q.addLine(y, !_),
                    f = !1,
                    o = "",
                    s = 0
                }
            else
                m + s > g && (f = !1,
                a += q.addLine(o),
                o = "",
                s = 0),
                (o.length > 0 || !q.isBreakingSpace(y) || f) && (o += y,
                s += m)
        }
        return a += q.addLine(o, !1),
        a
    }
    static addLine(t, r=!0) {
        return t = q.trimRight(t),
        t = r ? `${t}
` : t,
        t
    }
    static getFromCache(t, r, i, n) {
        let s = i[t];
        return typeof s != "number" && (s = q._measureText(t, r, n) + r,
        i[t] = s),
        s
    }
    static collapseSpaces(t) {
        return t === "normal" || t === "pre-line"
    }
    static collapseNewlines(t) {
        return t === "normal"
    }
    static trimRight(t) {
        if (typeof t != "string")
            return "";
        for (let r = t.length - 1; r >= 0; r--) {
            const i = t[r];
            if (!q.isBreakingSpace(i))
                break;
            t = t.slice(0, -1)
        }
        return t
    }
    static isNewline(t) {
        return typeof t != "string" ? !1 : q._newlines.includes(t.charCodeAt(0))
    }
    static isBreakingSpace(t, r) {
        return typeof t != "string" ? !1 : q._breakingSpaces.includes(t.charCodeAt(0))
    }
    static tokenize(t) {
        const r = [];
        let i = "";
        if (typeof t != "string")
            return r;
        for (let n = 0; n < t.length; n++) {
            const s = t[n]
              , o = t[n + 1];
            if (q.isBreakingSpace(s, o) || q.isNewline(s)) {
                i !== "" && (r.push(i),
                i = ""),
                r.push(s);
                continue
            }
            i += s
        }
        return i !== "" && r.push(i),
        r
    }
    static canBreakWords(t, r) {
        return r
    }
    static canBreakChars(t, r, i, n, s) {
        return !0
    }
    static wordWrapSplit(t) {
        return q.graphemeSegmenter(t)
    }
    static measureFont(t) {
        if (q._fonts[t])
            return q._fonts[t];
        const r = {
            ascent: 0,
            descent: 0,
            fontSize: 0
        }
          , i = q._canvas
          , n = q._context;
        n.font = t;
        const s = q.METRICS_STRING + q.BASELINE_SYMBOL
          , o = Math.ceil(n.measureText(s).width);
        let a = Math.ceil(n.measureText(q.BASELINE_SYMBOL).width);
        const l = Math.ceil(q.HEIGHT_MULTIPLIER * a);
        if (a = a * q.BASELINE_MULTIPLIER | 0,
        o === 0 || l === 0)
            return q._fonts[t] = r,
            r;
        i.width = o,
        i.height = l,
        n.fillStyle = "#f00",
        n.fillRect(0, 0, o, l),
        n.font = t,
        n.textBaseline = "alphabetic",
        n.fillStyle = "#000",
        n.fillText(s, 0, a);
        const h = n.getImageData(0, 0, o, l).data
          , u = h.length
          , c = o * 4;
        let d = 0
          , f = 0
          , g = !1;
        for (d = 0; d < a; ++d) {
            for (let p = 0; p < c; p += 4)
                if (h[f + p] !== 255) {
                    g = !0;
                    break
                }
            if (!g)
                f += c;
            else
                break
        }
        for (r.ascent = a - d,
        f = u - c,
        g = !1,
        d = l; d > a; --d) {
            for (let p = 0; p < c; p += 4)
                if (h[f + p] !== 255) {
                    g = !0;
                    break
                }
            if (!g)
                f -= c;
            else
                break
        }
        return r.descent = d - a,
        r.fontSize = r.ascent + r.descent,
        q._fonts[t] = r,
        r
    }
    static clearMetrics(t="") {
        t ? delete q._fonts[t] : q._fonts = {}
    }
    static get _canvas() {
        if (!q.__canvas) {
            let t;
            try {
                const r = new OffscreenCanvas(0,0);
                if (r.getContext("2d", zc)?.measureText)
                    return q.__canvas = r,
                    r;
                t = z.ADAPTER.createCanvas()
            } catch {
                t = z.ADAPTER.createCanvas()
            }
            t.width = t.height = 10,
            q.__canvas = t
        }
        return q.__canvas
    }
    static get _context() {
        return q.__context || (q.__context = q._canvas.getContext("2d", zc)),
        q.__context
    }
}
;
$i.METRICS_STRING = "|ÉqÅ",
$i.BASELINE_SYMBOL = "M",
$i.BASELINE_MULTIPLIER = 1.4,
$i.HEIGHT_MULTIPLIER = 2,
$i.graphemeSegmenter = ( () => {
    if (typeof Intl?.Segmenter == "function") {
        const e = new Intl.Segmenter;
        return t => [...e.segment(t)].map(r => r.segment)
    }
    return e => [...e]
}
)(),
$i.experimentalLetterSpacing = !1,
$i._fonts = {},
$i._newlines = [10, 13],
$i._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
let Sn = $i;
const WV = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]
  , CM = class ql {
    constructor(t) {
        this.styleID = 0,
        this.reset(),
        mg(this, t, t)
    }
    clone() {
        const t = {};
        return mg(t, this, ql.defaultStyle),
        new ql(t)
    }
    reset() {
        mg(this, ql.defaultStyle, ql.defaultStyle)
    }
    get align() {
        return this._align
    }
    set align(t) {
        this._align !== t && (this._align = t,
        this.styleID++)
    }
    get breakWords() {
        return this._breakWords
    }
    set breakWords(t) {
        this._breakWords !== t && (this._breakWords = t,
        this.styleID++)
    }
    get dropShadow() {
        return this._dropShadow
    }
    set dropShadow(t) {
        this._dropShadow !== t && (this._dropShadow = t,
        this.styleID++)
    }
    get dropShadowAlpha() {
        return this._dropShadowAlpha
    }
    set dropShadowAlpha(t) {
        this._dropShadowAlpha !== t && (this._dropShadowAlpha = t,
        this.styleID++)
    }
    get dropShadowAngle() {
        return this._dropShadowAngle
    }
    set dropShadowAngle(t) {
        this._dropShadowAngle !== t && (this._dropShadowAngle = t,
        this.styleID++)
    }
    get dropShadowBlur() {
        return this._dropShadowBlur
    }
    set dropShadowBlur(t) {
        this._dropShadowBlur !== t && (this._dropShadowBlur = t,
        this.styleID++)
    }
    get dropShadowColor() {
        return this._dropShadowColor
    }
    set dropShadowColor(t) {
        const r = pg(t);
        this._dropShadowColor !== r && (this._dropShadowColor = r,
        this.styleID++)
    }
    get dropShadowDistance() {
        return this._dropShadowDistance
    }
    set dropShadowDistance(t) {
        this._dropShadowDistance !== t && (this._dropShadowDistance = t,
        this.styleID++)
    }
    get fill() {
        return this._fill
    }
    set fill(t) {
        const r = pg(t);
        this._fill !== r && (this._fill = r,
        this.styleID++)
    }
    get fillGradientType() {
        return this._fillGradientType
    }
    set fillGradientType(t) {
        this._fillGradientType !== t && (this._fillGradientType = t,
        this.styleID++)
    }
    get fillGradientStops() {
        return this._fillGradientStops
    }
    set fillGradientStops(t) {
        VV(this._fillGradientStops, t) || (this._fillGradientStops = t,
        this.styleID++)
    }
    get fontFamily() {
        return this._fontFamily
    }
    set fontFamily(t) {
        this.fontFamily !== t && (this._fontFamily = t,
        this.styleID++)
    }
    get fontSize() {
        return this._fontSize
    }
    set fontSize(t) {
        this._fontSize !== t && (this._fontSize = t,
        this.styleID++)
    }
    get fontStyle() {
        return this._fontStyle
    }
    set fontStyle(t) {
        this._fontStyle !== t && (this._fontStyle = t,
        this.styleID++)
    }
    get fontVariant() {
        return this._fontVariant
    }
    set fontVariant(t) {
        this._fontVariant !== t && (this._fontVariant = t,
        this.styleID++)
    }
    get fontWeight() {
        return this._fontWeight
    }
    set fontWeight(t) {
        this._fontWeight !== t && (this._fontWeight = t,
        this.styleID++)
    }
    get letterSpacing() {
        return this._letterSpacing
    }
    set letterSpacing(t) {
        this._letterSpacing !== t && (this._letterSpacing = t,
        this.styleID++)
    }
    get lineHeight() {
        return this._lineHeight
    }
    set lineHeight(t) {
        this._lineHeight !== t && (this._lineHeight = t,
        this.styleID++)
    }
    get leading() {
        return this._leading
    }
    set leading(t) {
        this._leading !== t && (this._leading = t,
        this.styleID++)
    }
    get lineJoin() {
        return this._lineJoin
    }
    set lineJoin(t) {
        this._lineJoin !== t && (this._lineJoin = t,
        this.styleID++)
    }
    get miterLimit() {
        return this._miterLimit
    }
    set miterLimit(t) {
        this._miterLimit !== t && (this._miterLimit = t,
        this.styleID++)
    }
    get padding() {
        return this._padding
    }
    set padding(t) {
        this._padding !== t && (this._padding = t,
        this.styleID++)
    }
    get stroke() {
        return this._stroke
    }
    set stroke(t) {
        const r = pg(t);
        this._stroke !== r && (this._stroke = r,
        this.styleID++)
    }
    get strokeThickness() {
        return this._strokeThickness
    }
    set strokeThickness(t) {
        this._strokeThickness !== t && (this._strokeThickness = t,
        this.styleID++)
    }
    get textBaseline() {
        return this._textBaseline
    }
    set textBaseline(t) {
        this._textBaseline !== t && (this._textBaseline = t,
        this.styleID++)
    }
    get trim() {
        return this._trim
    }
    set trim(t) {
        this._trim !== t && (this._trim = t,
        this.styleID++)
    }
    get whiteSpace() {
        return this._whiteSpace
    }
    set whiteSpace(t) {
        this._whiteSpace !== t && (this._whiteSpace = t,
        this.styleID++)
    }
    get wordWrap() {
        return this._wordWrap
    }
    set wordWrap(t) {
        this._wordWrap !== t && (this._wordWrap = t,
        this.styleID++)
    }
    get wordWrapWidth() {
        return this._wordWrapWidth
    }
    set wordWrapWidth(t) {
        this._wordWrapWidth !== t && (this._wordWrapWidth = t,
        this.styleID++)
    }
    toFontString() {
        const t = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
        let r = this.fontFamily;
        Array.isArray(this.fontFamily) || (r = this.fontFamily.split(","));
        for (let i = r.length - 1; i >= 0; i--) {
            let n = r[i].trim();
            !/([\"\'])[^\'\"]+\1/.test(n) && !WV.includes(n) && (n = `"${n}"`),
            r[i] = n
        }
        return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${t} ${r.join(",")}`
    }
}
;
CM.defaultStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: ju.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100
};
let Li = CM;
function pg(e) {
    const t = xt.shared
      , r = i => {
        const n = t.setValue(i);
        return n.alpha === 1 ? n.toHex() : n.toRgbaString()
    }
    ;
    return Array.isArray(e) ? e.map(r) : r(e)
}
function VV(e, t) {
    if (!Array.isArray(e) || !Array.isArray(t) || e.length !== t.length)
        return !1;
    for (let r = 0; r < e.length; ++r)
        if (e[r] !== t[r])
            return !1;
    return !0
}
function mg(e, t, r) {
    for (const i in r)
        Array.isArray(t[i]) ? e[i] = t[i].slice() : e[i] = t[i]
}
const jV = {
    texture: !0,
    children: !1,
    baseTexture: !0
}
  , PM = class U_ extends at {
    constructor(t, r, i) {
        let n = !1;
        i || (i = z.ADAPTER.createCanvas(),
        n = !0),
        i.width = 3,
        i.height = 3;
        const s = F.from(i);
        s.orig = new lt,
        s.trim = new lt,
        super(s),
        this._ownCanvas = n,
        this.canvas = i,
        this.context = i.getContext("2d", {
            willReadFrequently: !0
        }),
        this._resolution = U_.defaultResolution ?? z.RESOLUTION,
        this._autoResolution = U_.defaultAutoResolution,
        this._text = null,
        this._style = null,
        this._styleListener = null,
        this._font = "",
        this.text = t,
        this.style = r,
        this.localStyleID = -1
    }
    static get experimentalLetterSpacing() {
        return Sn.experimentalLetterSpacing
    }
    static set experimentalLetterSpacing(t) {
        et("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"),
        Sn.experimentalLetterSpacing = t
    }
    updateText(t) {
        const r = this._style;
        if (this.localStyleID !== r.styleID && (this.dirty = !0,
        this.localStyleID = r.styleID),
        !this.dirty && t)
            return;
        this._font = this._style.toFontString();
        const i = this.context
          , n = Sn.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas)
          , s = n.width
          , o = n.height
          , a = n.lines
          , l = n.lineHeight
          , h = n.lineWidths
          , u = n.maxLineWidth
          , c = n.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, s) + r.padding * 2) * this._resolution),
        this.canvas.height = Math.ceil(Math.ceil(Math.max(1, o) + r.padding * 2) * this._resolution),
        i.scale(this._resolution, this._resolution),
        i.clearRect(0, 0, this.canvas.width, this.canvas.height),
        i.font = this._font,
        i.lineWidth = r.strokeThickness,
        i.textBaseline = r.textBaseline,
        i.lineJoin = r.lineJoin,
        i.miterLimit = r.miterLimit;
        let d, f;
        const g = r.dropShadow ? 2 : 1;
        for (let p = 0; p < g; ++p) {
            const v = r.dropShadow && p === 0
              , y = v ? Math.ceil(Math.max(1, o) + r.padding * 2) : 0
              , m = y * this._resolution;
            if (v) {
                i.fillStyle = "black",
                i.strokeStyle = "black";
                const x = r.dropShadowColor
                  , E = r.dropShadowBlur * this._resolution
                  , S = r.dropShadowDistance * this._resolution;
                i.shadowColor = xt.shared.setValue(x).setAlpha(r.dropShadowAlpha).toRgbaString(),
                i.shadowBlur = E,
                i.shadowOffsetX = Math.cos(r.dropShadowAngle) * S,
                i.shadowOffsetY = Math.sin(r.dropShadowAngle) * S + m
            } else
                i.fillStyle = this._generateFillStyle(r, a, n),
                i.strokeStyle = r.stroke,
                i.shadowColor = "black",
                i.shadowBlur = 0,
                i.shadowOffsetX = 0,
                i.shadowOffsetY = 0;
            let _ = (l - c.fontSize) / 2;
            l - c.fontSize < 0 && (_ = 0);
            for (let x = 0; x < a.length; x++)
                d = r.strokeThickness / 2,
                f = r.strokeThickness / 2 + x * l + c.ascent + _,
                r.align === "right" ? d += u - h[x] : r.align === "center" && (d += (u - h[x]) / 2),
                r.stroke && r.strokeThickness && this.drawLetterSpacing(a[x], d + r.padding, f + r.padding - y, !0),
                r.fill && this.drawLetterSpacing(a[x], d + r.padding, f + r.padding - y)
        }
        this.updateTexture()
    }
    drawLetterSpacing(t, r, i, n=!1) {
        const s = this._style.letterSpacing;
        let o = !1;
        if (Sn.experimentalLetterSpacingSupported && (Sn.experimentalLetterSpacing ? (this.context.letterSpacing = `${s}px`,
        this.context.textLetterSpacing = `${s}px`,
        o = !0) : (this.context.letterSpacing = "0px",
        this.context.textLetterSpacing = "0px")),
        s === 0 || o) {
            n ? this.context.strokeText(t, r, i) : this.context.fillText(t, r, i);
            return
        }
        let a = r;
        const l = Sn.graphemeSegmenter(t);
        let h = this.context.measureText(t).width
          , u = 0;
        for (let c = 0; c < l.length; ++c) {
            const d = l[c];
            n ? this.context.strokeText(d, a, i) : this.context.fillText(d, a, i);
            let f = "";
            for (let g = c + 1; g < l.length; ++g)
                f += l[g];
            u = this.context.measureText(f).width,
            a += h - u + s,
            h = u
        }
    }
    updateTexture() {
        const t = this.canvas;
        if (this._style.trim) {
            const o = PI(t);
            o.data && (t.width = o.width,
            t.height = o.height,
            this.context.putImageData(o.data, 0, 0))
        }
        const r = this._texture
          , i = this._style
          , n = i.trim ? 0 : i.padding
          , s = r.baseTexture;
        r.trim.width = r._frame.width = t.width / this._resolution,
        r.trim.height = r._frame.height = t.height / this._resolution,
        r.trim.x = -n,
        r.trim.y = -n,
        r.orig.width = r._frame.width - n * 2,
        r.orig.height = r._frame.height - n * 2,
        this._onTextureUpdate(),
        s.setRealSize(t.width, t.height, this._resolution),
        r.updateUvs(),
        this.dirty = !1
    }
    _render(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0),
        this.updateText(!0),
        super._render(t)
    }
    updateTransform() {
        this.updateText(!0),
        super.updateTransform()
    }
    getBounds(t, r) {
        return this.updateText(!0),
        this._textureID === -1 && (t = !1),
        super.getBounds(t, r)
    }
    getLocalBounds(t) {
        return this.updateText(!0),
        super.getLocalBounds.call(this, t)
    }
    _calculateBounds() {
        this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)
    }
    _generateFillStyle(t, r, i) {
        const n = t.fill;
        if (Array.isArray(n)) {
            if (n.length === 1)
                return n[0]
        } else
            return n;
        let s;
        const o = t.dropShadow ? t.dropShadowDistance : 0
          , a = t.padding || 0
          , l = this.canvas.width / this._resolution - o - a * 2
          , h = this.canvas.height / this._resolution - o - a * 2
          , u = n.slice()
          , c = t.fillGradientStops.slice();
        if (!c.length) {
            const d = u.length + 1;
            for (let f = 1; f < d; ++f)
                c.push(f / d)
        }
        if (u.unshift(n[0]),
        c.unshift(0),
        u.push(n[n.length - 1]),
        c.push(1),
        t.fillGradientType === ju.LINEAR_VERTICAL) {
            s = this.context.createLinearGradient(l / 2, a, l / 2, h + a);
            const d = i.fontProperties.fontSize + t.strokeThickness;
            for (let f = 0; f < r.length; f++) {
                const g = i.lineHeight * (f - 1) + d
                  , p = i.lineHeight * f;
                let v = p;
                f > 0 && g > p && (v = (p + g) / 2);
                const y = p + d
                  , m = i.lineHeight * (f + 1);
                let _ = y;
                f + 1 < r.length && m < y && (_ = (y + m) / 2);
                const x = (_ - v) / h;
                for (let E = 0; E < u.length; E++) {
                    let S = 0;
                    typeof c[E] == "number" ? S = c[E] : S = E / u.length;
                    let w = Math.min(1, Math.max(0, v / h + S * x));
                    w = Number(w.toFixed(5)),
                    s.addColorStop(w, u[E])
                }
            }
        } else {
            s = this.context.createLinearGradient(a, h / 2, l + a, h / 2);
            const d = u.length + 1;
            let f = 1;
            for (let g = 0; g < u.length; g++) {
                let p;
                typeof c[g] == "number" ? p = c[g] : p = f / d,
                s.addColorStop(p, u[g]),
                f++
            }
        }
        return s
    }
    destroy(t) {
        typeof t == "boolean" && (t = {
            children: t
        }),
        t = Object.assign({}, jV, t),
        super.destroy(t),
        this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
        this.context = null,
        this.canvas = null,
        this._style = null
    }
    get width() {
        return this.updateText(!0),
        Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(t) {
        this.updateText(!0);
        const r = In(this.scale.x) || 1;
        this.scale.x = r * t / this._texture.orig.width,
        this._width = t
    }
    get height() {
        return this.updateText(!0),
        Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(t) {
        this.updateText(!0);
        const r = In(this.scale.y) || 1;
        this.scale.y = r * t / this._texture.orig.height,
        this._height = t
    }
    get style() {
        return this._style
    }
    set style(t) {
        t = t || {},
        t instanceof Li ? this._style = t : this._style = new Li(t),
        this.localStyleID = -1,
        this.dirty = !0
    }
    get text() {
        return this._text
    }
    set text(t) {
        t = String(t ?? ""),
        this._text !== t && (this._text = t,
        this.dirty = !0)
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._autoResolution = !1,
        this._resolution !== t && (this._resolution = t,
        this.dirty = !0)
    }
}
;
PM.defaultAutoResolution = !0;
let Oo = PM;
class IM {
    constructor(t) {
        this.maxItemsPerFrame = t,
        this.itemsLeft = 0
    }
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame
    }
    allowedToUpload() {
        return this.itemsLeft-- > 0
    }
}
function XV(e, t) {
    let r = !1;
    if (e?._textures?.length) {
        for (let i = 0; i < e._textures.length; i++)
            if (e._textures[i]instanceof F) {
                const n = e._textures[i].baseTexture;
                t.includes(n) || (t.push(n),
                r = !0)
            }
    }
    return r
}
function YV(e, t) {
    if (e.baseTexture instanceof nt) {
        const r = e.baseTexture;
        return t.includes(r) || t.push(r),
        !0
    }
    return !1
}
function KV(e, t) {
    if (e._texture && e._texture instanceof F) {
        const r = e._texture.baseTexture;
        return t.includes(r) || t.push(r),
        !0
    }
    return !1
}
function qV(e, t) {
    return t instanceof Oo ? (t.updateText(!0),
    !0) : !1
}
function ZV(e, t) {
    if (t instanceof Li) {
        const r = t.toFontString();
        return Sn.measureFont(r),
        !0
    }
    return !1
}
function QV(e, t) {
    if (e instanceof Oo) {
        t.includes(e.style) || t.push(e.style),
        t.includes(e) || t.push(e);
        const r = e._texture.baseTexture;
        return t.includes(r) || t.push(r),
        !0
    }
    return !1
}
function JV(e, t) {
    return e instanceof Li ? (t.includes(e) || t.push(e),
    !0) : !1
}
const RM = class MM {
    constructor(t) {
        this.limiter = new IM(MM.uploadsPerFrame),
        this.renderer = t,
        this.uploadHookHelper = null,
        this.queue = [],
        this.addHooks = [],
        this.uploadHooks = [],
        this.completes = [],
        this.ticking = !1,
        this.delayedTick = () => {
            this.queue && this.prepareItems()
        }
        ,
        this.registerFindHook(QV),
        this.registerFindHook(JV),
        this.registerFindHook(XV),
        this.registerFindHook(YV),
        this.registerFindHook(KV),
        this.registerUploadHook(qV),
        this.registerUploadHook(ZV)
    }
    upload(t) {
        return new Promise(r => {
            t && this.add(t),
            this.queue.length ? (this.completes.push(r),
            this.ticking || (this.ticking = !0,
            $t.system.addOnce(this.tick, this, Hn.UTILITY))) : r()
        }
        )
    }
    tick() {
        setTimeout(this.delayedTick, 0)
    }
    prepareItems() {
        for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
            const t = this.queue[0];
            let r = !1;
            if (t && !t._destroyed) {
                for (let i = 0, n = this.uploadHooks.length; i < n; i++)
                    if (this.uploadHooks[i](this.uploadHookHelper, t)) {
                        this.queue.shift(),
                        r = !0;
                        break
                    }
            }
            r || this.queue.shift()
        }
        if (this.queue.length)
            $t.system.addOnce(this.tick, this, Hn.UTILITY);
        else {
            this.ticking = !1;
            const t = this.completes.slice(0);
            this.completes.length = 0;
            for (let r = 0, i = t.length; r < i; r++)
                t[r]()
        }
    }
    registerFindHook(t) {
        return t && this.addHooks.push(t),
        this
    }
    registerUploadHook(t) {
        return t && this.uploadHooks.push(t),
        this
    }
    add(t) {
        for (let r = 0, i = this.addHooks.length; r < i && !this.addHooks[r](t, this.queue); r++)
            ;
        if (t instanceof J)
            for (let r = t.children.length - 1; r >= 0; r--)
                this.add(t.children[r]);
        return this
    }
    destroy() {
        this.ticking && $t.system.remove(this.tick, this),
        this.ticking = !1,
        this.addHooks = null,
        this.uploadHooks = null,
        this.renderer = null,
        this.completes = null,
        this.queue = null,
        this.limiter = null,
        this.uploadHookHelper = null
    }
}
;
RM.uploadsPerFrame = 4;
let Rf = RM;
Object.defineProperties(z, {
    UPLOADS_PER_FRAME: {
        get() {
            return Rf.uploadsPerFrame
        },
        set(e) {
            et("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"),
            Rf.uploadsPerFrame = e
        }
    }
});
function OM(e, t) {
    return t instanceof nt ? (t._glTextures[e.CONTEXT_UID] || e.texture.bind(t),
    !0) : !1
}
function t7(e, t) {
    if (!(t instanceof Dx))
        return !1;
    const {geometry: r} = t;
    t.finishPoly(),
    r.updateBatches();
    const {batches: i} = r;
    for (let n = 0; n < i.length; n++) {
        const {texture: s} = i[n].style;
        s && OM(e, s.baseTexture)
    }
    return r.batchable || e.geometry.bind(r, t._resolveDirectShader(e)),
    !0
}
function e7(e, t) {
    return e instanceof Dx ? (t.push(e),
    !0) : !1
}
class kx extends Rf {
    constructor(t) {
        super(t),
        this.uploadHookHelper = this.renderer,
        this.registerFindHook(e7),
        this.registerUploadHook(OM),
        this.registerUploadHook(t7)
    }
}
kx.extension = {
    name: "prepare",
    type: G.RendererSystem
};
Y.add(kx);
class r7 {
    constructor(t) {
        this.maxMilliseconds = t,
        this.frameStart = 0
    }
    beginFrame() {
        this.frameStart = Date.now()
    }
    allowedToUpload() {
        return Date.now() - this.frameStart < this.maxMilliseconds
    }
}
class Le extends at {
    constructor(t, r=!0) {
        super(t[0]instanceof F ? t[0] : t[0].texture),
        this._textures = null,
        this._durations = null,
        this._autoUpdate = r,
        this._isConnectedToTicker = !1,
        this.animationSpeed = 1,
        this.loop = !0,
        this.updateAnchor = !1,
        this.onComplete = null,
        this.onFrameChange = null,
        this.onLoop = null,
        this._currentTime = 0,
        this._playing = !1,
        this._previousFrame = null,
        this.textures = t
    }
    stop() {
        this._playing && (this._playing = !1,
        this._autoUpdate && this._isConnectedToTicker && ($t.shared.remove(this.update, this),
        this._isConnectedToTicker = !1))
    }
    play() {
        this._playing || (this._playing = !0,
        this._autoUpdate && !this._isConnectedToTicker && ($t.shared.add(this.update, this, Hn.HIGH),
        this._isConnectedToTicker = !0))
    }
    gotoAndStop(t) {
        this.stop(),
        this.currentFrame = t
    }
    gotoAndPlay(t) {
        this.currentFrame = t,
        this.play()
    }
    update(t) {
        if (!this._playing)
            return;
        const r = this.animationSpeed * t
          , i = this.currentFrame;
        if (this._durations !== null) {
            let n = this._currentTime % 1 * this._durations[this.currentFrame];
            for (n += r / 60 * 1e3; n < 0; )
                this._currentTime--,
                n += this._durations[this.currentFrame];
            const s = Math.sign(this.animationSpeed * t);
            for (this._currentTime = Math.floor(this._currentTime); n >= this._durations[this.currentFrame]; )
                n -= this._durations[this.currentFrame] * s,
                this._currentTime += s;
            this._currentTime += n / this._durations[this.currentFrame]
        } else
            this._currentTime += r;
        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0),
        this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1),
        this.onComplete && this.onComplete()) : i !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < i || this.animationSpeed < 0 && this.currentFrame > i) && this.onLoop(),
        this.updateTexture())
    }
    updateTexture() {
        const t = this.currentFrame;
        this._previousFrame !== t && (this._previousFrame = t,
        this._texture = this._textures[t],
        this._textureID = -1,
        this._textureTrimmedID = -1,
        this._cachedTint = 16777215,
        this.uvs = this._texture._uvs.uvsFloat32,
        this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor),
        this.onFrameChange && this.onFrameChange(this.currentFrame))
    }
    destroy(t) {
        this.stop(),
        super.destroy(t),
        this.onComplete = null,
        this.onFrameChange = null,
        this.onLoop = null
    }
    static fromFrames(t) {
        const r = [];
        for (let i = 0; i < t.length; ++i)
            r.push(F.from(t[i]));
        return new Le(r)
    }
    static fromImages(t) {
        const r = [];
        for (let i = 0; i < t.length; ++i)
            r.push(F.from(t[i]));
        return new Le(r)
    }
    get totalFrames() {
        return this._textures.length
    }
    get textures() {
        return this._textures
    }
    set textures(t) {
        if (t[0]instanceof F)
            this._textures = t,
            this._durations = null;
        else {
            this._textures = [],
            this._durations = [];
            for (let r = 0; r < t.length; r++)
                this._textures.push(t[r].texture),
                this._durations.push(t[r].time)
        }
        this._previousFrame = null,
        this.gotoAndStop(0),
        this.updateTexture()
    }
    get currentFrame() {
        let t = Math.floor(this._currentTime) % this._textures.length;
        return t < 0 && (t += this._textures.length),
        t
    }
    set currentFrame(t) {
        if (t < 0 || t > this.totalFrames - 1)
            throw new Error(`[AnimatedSprite]: Invalid frame index value ${t}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
        const r = this.currentFrame;
        this._currentTime = t,
        r !== this.currentFrame && this.updateTexture()
    }
    get playing() {
        return this._playing
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        t !== this._autoUpdate && (this._autoUpdate = t,
        !this._autoUpdate && this._isConnectedToTicker ? ($t.shared.remove(this.update, this),
        this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && ($t.shared.add(this.update, this),
        this._isConnectedToTicker = !0))
    }
}
const Ll = new st;
class wi extends at {
    constructor(t, r=100, i=100) {
        super(t),
        this.tileTransform = new Gu,
        this._width = r,
        this._height = i,
        this.uvMatrix = this.texture.uvMatrix || new Lp(t),
        this.pluginName = "tilingSprite",
        this.uvRespectAnchor = !1
    }
    get clampMargin() {
        return this.uvMatrix.clampMargin
    }
    set clampMargin(t) {
        this.uvMatrix.clampMargin = t,
        this.uvMatrix.update(!0)
    }
    get tileScale() {
        return this.tileTransform.scale
    }
    set tileScale(t) {
        this.tileTransform.scale.copyFrom(t)
    }
    get tilePosition() {
        return this.tileTransform.position
    }
    set tilePosition(t) {
        this.tileTransform.position.copyFrom(t)
    }
    _onTextureUpdate() {
        this.uvMatrix && (this.uvMatrix.texture = this._texture),
        this._cachedTint = 16777215
    }
    _render(t) {
        const r = this._texture;
        !r || !r.valid || (this.tileTransform.updateLocalTransform(),
        this.uvMatrix.update(),
        t.batch.setObjectRenderer(t.plugins[this.pluginName]),
        t.plugins[this.pluginName].render(this))
    }
    _calculateBounds() {
        const t = this._width * -this._anchor._x
          , r = this._height * -this._anchor._y
          , i = this._width * (1 - this._anchor._x)
          , n = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, t, r, i, n)
    }
    getLocalBounds(t) {
        return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x,
        this._bounds.minY = this._height * -this._anchor._y,
        this._bounds.maxX = this._width * (1 - this._anchor._x),
        this._bounds.maxY = this._height * (1 - this._anchor._y),
        t || (this._localBoundsRect || (this._localBoundsRect = new lt),
        t = this._localBoundsRect),
        this._bounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, Ll);
        const r = this._width
          , i = this._height
          , n = -r * this.anchor._x;
        if (Ll.x >= n && Ll.x < n + r) {
            const s = -i * this.anchor._y;
            if (Ll.y >= s && Ll.y < s + i)
                return !0
        }
        return !1
    }
    destroy(t) {
        super.destroy(t),
        this.tileTransform = null,
        this.uvMatrix = null
    }
    static from(t, r) {
        const i = t instanceof F ? t : F.from(t, r);
        return new wi(i,r.width,r.height)
    }
    get width() {
        return this._width
    }
    set width(t) {
        this._width = t
    }
    get height() {
        return this._height
    }
    set height(t) {
        this._height = t
    }
}
var i7 = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`
  , n7 = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`
  , s7 = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`
  , hw = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`
  , o7 = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
const Wc = new Mt;
class Fx extends Hu {
    constructor(t) {
        super(t),
        t.runners.contextChange.add(this),
        this.quad = new ax,
        this.state = Bi.for2d()
    }
    contextChange() {
        const t = this.renderer
          , r = {
            globals: t.globalUniforms
        };
        this.simpleShader = Ri.from(hw, o7, r),
        this.shader = t.context.webGLVersion > 1 ? Ri.from(n7, i7, r) : Ri.from(hw, s7, r)
    }
    render(t) {
        const r = this.renderer
          , i = this.quad;
        let n = i.vertices;
        n[0] = n[6] = t._width * -t.anchor.x,
        n[1] = n[3] = t._height * -t.anchor.y,
        n[2] = n[4] = t._width * (1 - t.anchor.x),
        n[5] = n[7] = t._height * (1 - t.anchor.y);
        const s = t.uvRespectAnchor ? t.anchor.x : 0
          , o = t.uvRespectAnchor ? t.anchor.y : 0;
        n = i.uvs,
        n[0] = n[6] = -s,
        n[1] = n[3] = -o,
        n[2] = n[4] = 1 - s,
        n[5] = n[7] = 1 - o,
        i.invalidate();
        const a = t._texture
          , l = a.baseTexture
          , h = l.alphaMode > 0
          , u = t.tileTransform.localTransform
          , c = t.uvMatrix;
        let d = l.isPowerOfTwo && a.frame.width === l.width && a.frame.height === l.height;
        d && (l._glTextures[r.CONTEXT_UID] ? d = l.wrapMode !== Ci.CLAMP : l.wrapMode === Ci.CLAMP && (l.wrapMode = Ci.REPEAT));
        const f = d ? this.simpleShader : this.shader
          , g = a.width
          , p = a.height
          , v = t._width
          , y = t._height;
        Wc.set(u.a * g / v, u.b * g / y, u.c * p / v, u.d * p / y, u.tx / v, u.ty / y),
        Wc.invert(),
        d ? Wc.prepend(c.mapCoord) : (f.uniforms.uMapCoord = c.mapCoord.toArray(!0),
        f.uniforms.uClampFrame = c.uClampFrame,
        f.uniforms.uClampOffset = c.uClampOffset),
        f.uniforms.uTransform = Wc.toArray(!0),
        f.uniforms.uColor = xt.shared.setValue(t.tint).premultiply(t.worldAlpha, h).toArray(f.uniforms.uColor),
        f.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0),
        f.uniforms.uSampler = a,
        r.shader.bind(f),
        r.geometry.bind(i),
        this.state.blendMode = tx(t.blendMode, h),
        r.state.set(this.state),
        r.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
    }
}
Fx.extension = {
    name: "tilingSprite",
    type: G.RendererPlugin
};
Y.add(Fx);
const NM = class Zl {
    constructor(t, r, i=null) {
        this.linkedSheets = [],
        this._texture = t instanceof F ? t : null,
        this.baseTexture = t instanceof nt ? t : this._texture.baseTexture,
        this.textures = {},
        this.animations = {},
        this.data = r;
        const n = this.baseTexture.resource;
        this.resolution = this._updateResolution(i || (n ? n.url : null)),
        this._frames = this.data.frames,
        this._frameKeys = Object.keys(this._frames),
        this._batchIndex = 0,
        this._callback = null
    }
    _updateResolution(t=null) {
        const {scale: r} = this.data.meta;
        let i = un(t, null);
        return i === null && (i = parseFloat(r ?? "1")),
        i !== 1 && this.baseTexture.setResolution(i),
        i
    }
    parse() {
        return new Promise(t => {
            this._callback = t,
            this._batchIndex = 0,
            this._frameKeys.length <= Zl.BATCH_SIZE ? (this._processFrames(0),
            this._processAnimations(),
            this._parseComplete()) : this._nextBatch()
        }
        )
    }
    _processFrames(t) {
        let r = t;
        const i = Zl.BATCH_SIZE;
        for (; r - t < i && r < this._frameKeys.length; ) {
            const n = this._frameKeys[r]
              , s = this._frames[n]
              , o = s.frame;
            if (o) {
                let a = null
                  , l = null;
                const h = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame
                  , u = new lt(0,0,Math.floor(h.w) / this.resolution,Math.floor(h.h) / this.resolution);
                s.rotated ? a = new lt(Math.floor(o.x) / this.resolution,Math.floor(o.y) / this.resolution,Math.floor(o.h) / this.resolution,Math.floor(o.w) / this.resolution) : a = new lt(Math.floor(o.x) / this.resolution,Math.floor(o.y) / this.resolution,Math.floor(o.w) / this.resolution,Math.floor(o.h) / this.resolution),
                s.trimmed !== !1 && s.spriteSourceSize && (l = new lt(Math.floor(s.spriteSourceSize.x) / this.resolution,Math.floor(s.spriteSourceSize.y) / this.resolution,Math.floor(o.w) / this.resolution,Math.floor(o.h) / this.resolution)),
                this.textures[n] = new F(this.baseTexture,a,u,l,s.rotated ? 2 : 0,s.anchor,s.borders),
                F.addToCache(this.textures[n], n.toString())
            }
            r++
        }
    }
    _processAnimations() {
        const t = this.data.animations || {};
        for (const r in t) {
            this.animations[r] = [];
            for (let i = 0; i < t[r].length; i++) {
                const n = t[r][i];
                this.animations[r].push(this.textures[n])
            }
        }
    }
    _parseComplete() {
        const t = this._callback;
        this._callback = null,
        this._batchIndex = 0,
        t.call(this, this.textures)
    }
    _nextBatch() {
        this._processFrames(this._batchIndex * Zl.BATCH_SIZE),
        this._batchIndex++,
        setTimeout( () => {
            this._batchIndex * Zl.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(),
            this._parseComplete())
        }
        , 0)
    }
    destroy(t=!1) {
        for (const r in this.textures)
            this.textures[r].destroy();
        this._frames = null,
        this._frameKeys = null,
        this.data = null,
        this.textures = null,
        t && (this._texture?.destroy(),
        this.baseTexture.destroy()),
        this._texture = null,
        this.baseTexture = null,
        this.linkedSheets = []
    }
}
;
NM.BATCH_SIZE = 1e3;
let G_ = NM;
const a7 = ["jpg", "png", "jpeg", "avif", "webp"];
function LM(e, t, r) {
    const i = {};
    if (e.forEach(n => {
        i[n] = t
    }
    ),
    Object.keys(t.textures).forEach(n => {
        i[n] = t.textures[n]
    }
    ),
    !r) {
        const n = fe.dirname(e[0]);
        t.linkedSheets.forEach( (s, o) => {
            const a = LM([`${n}/${t.data.meta.related_multi_packs[o]}`], s, !0);
            Object.assign(i, a)
        }
        )
    }
    return i
}
const DM = {
    extension: G.Asset,
    cache: {
        test: e => e instanceof G_,
        getCacheableAssets: (e, t) => LM(e, t, !1)
    },
    resolver: {
        test: e => {
            const t = e.split("?")[0].split(".")
              , r = t.pop()
              , i = t.pop();
            return r === "json" && a7.includes(i)
        }
        ,
        parse: e => {
            const t = e.split(".");
            return {
                resolution: parseFloat(z.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
                format: t[t.length - 2],
                src: e
            }
        }
    },
    loader: {
        name: "spritesheetLoader",
        extension: {
            type: G.LoadParser,
            priority: Gr.Normal
        },
        async testParse(e, t) {
            return fe.extname(t.src).toLowerCase() === ".json" && !!e.frames
        },
        async parse(e, t, r) {
            let i = fe.dirname(t.src);
            i && i.lastIndexOf("/") !== i.length - 1 && (i += "/");
            let n = i + e.meta.image;
            n = Sf(n, t.src);
            const s = (await r.load([n]))[n]
              , o = new G_(s.baseTexture,e,t.src);
            await o.parse();
            const a = e?.meta?.related_multi_packs;
            if (Array.isArray(a)) {
                const l = [];
                for (const u of a) {
                    if (typeof u != "string")
                        continue;
                    let c = i + u;
                    t.data?.ignoreMultiPack || (c = Sf(c, t.src),
                    l.push(r.load({
                        src: c,
                        data: {
                            ignoreMultiPack: !0
                        }
                    })))
                }
                const h = await Promise.all(l);
                o.linkedSheets = h,
                h.forEach(u => {
                    u.linkedSheets = [o].concat(o.linkedSheets.filter(c => c !== u))
                }
                )
            }
            return o
        },
        unload(e) {
            e.destroy(!0)
        }
    }
};
Y.add(DM);
class mu {
    constructor() {
        this.info = [],
        this.common = [],
        this.page = [],
        this.char = [],
        this.kerning = [],
        this.distanceField = []
    }
}
class vh {
    static test(t) {
        return typeof t == "string" && t.startsWith("info face=")
    }
    static parse(t) {
        const r = t.match(/^[a-z]+\s+.+$/gm)
          , i = {
            info: [],
            common: [],
            page: [],
            char: [],
            chars: [],
            kerning: [],
            kernings: [],
            distanceField: []
        };
        for (const s in r) {
            const o = r[s].match(/^[a-z]+/gm)[0]
              , a = r[s].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm)
              , l = {};
            for (const h in a) {
                const u = a[h].split("=")
                  , c = u[0]
                  , d = u[1].replace(/"/gm, "")
                  , f = parseFloat(d)
                  , g = isNaN(f) ? d : f;
                l[c] = g
            }
            i[o].push(l)
        }
        const n = new mu;
        return i.info.forEach(s => n.info.push({
            face: s.face,
            size: parseInt(s.size, 10)
        })),
        i.common.forEach(s => n.common.push({
            lineHeight: parseInt(s.lineHeight, 10)
        })),
        i.page.forEach(s => n.page.push({
            id: parseInt(s.id, 10),
            file: s.file
        })),
        i.char.forEach(s => n.char.push({
            id: parseInt(s.id, 10),
            page: parseInt(s.page, 10),
            x: parseInt(s.x, 10),
            y: parseInt(s.y, 10),
            width: parseInt(s.width, 10),
            height: parseInt(s.height, 10),
            xoffset: parseInt(s.xoffset, 10),
            yoffset: parseInt(s.yoffset, 10),
            xadvance: parseInt(s.xadvance, 10)
        })),
        i.kerning.forEach(s => n.kerning.push({
            first: parseInt(s.first, 10),
            second: parseInt(s.second, 10),
            amount: parseInt(s.amount, 10)
        })),
        i.distanceField.forEach(s => n.distanceField.push({
            distanceRange: parseInt(s.distanceRange, 10),
            fieldType: s.fieldType
        })),
        n
    }
}
class Mf {
    static test(t) {
        const r = t;
        return typeof t != "string" && "getElementsByTagName"in t && r.getElementsByTagName("page").length && r.getElementsByTagName("info")[0].getAttribute("face") !== null
    }
    static parse(t) {
        const r = new mu
          , i = t.getElementsByTagName("info")
          , n = t.getElementsByTagName("common")
          , s = t.getElementsByTagName("page")
          , o = t.getElementsByTagName("char")
          , a = t.getElementsByTagName("kerning")
          , l = t.getElementsByTagName("distanceField");
        for (let h = 0; h < i.length; h++)
            r.info.push({
                face: i[h].getAttribute("face"),
                size: parseInt(i[h].getAttribute("size"), 10)
            });
        for (let h = 0; h < n.length; h++)
            r.common.push({
                lineHeight: parseInt(n[h].getAttribute("lineHeight"), 10)
            });
        for (let h = 0; h < s.length; h++)
            r.page.push({
                id: parseInt(s[h].getAttribute("id"), 10) || 0,
                file: s[h].getAttribute("file")
            });
        for (let h = 0; h < o.length; h++) {
            const u = o[h];
            r.char.push({
                id: parseInt(u.getAttribute("id"), 10),
                page: parseInt(u.getAttribute("page"), 10) || 0,
                x: parseInt(u.getAttribute("x"), 10),
                y: parseInt(u.getAttribute("y"), 10),
                width: parseInt(u.getAttribute("width"), 10),
                height: parseInt(u.getAttribute("height"), 10),
                xoffset: parseInt(u.getAttribute("xoffset"), 10),
                yoffset: parseInt(u.getAttribute("yoffset"), 10),
                xadvance: parseInt(u.getAttribute("xadvance"), 10)
            })
        }
        for (let h = 0; h < a.length; h++)
            r.kerning.push({
                first: parseInt(a[h].getAttribute("first"), 10),
                second: parseInt(a[h].getAttribute("second"), 10),
                amount: parseInt(a[h].getAttribute("amount"), 10)
            });
        for (let h = 0; h < l.length; h++)
            r.distanceField.push({
                fieldType: l[h].getAttribute("fieldType"),
                distanceRange: parseInt(l[h].getAttribute("distanceRange"), 10)
            });
        return r
    }
}
class Of {
    static test(t) {
        return typeof t == "string" && t.includes("<font>") ? Mf.test(z.ADAPTER.parseXML(t)) : !1
    }
    static parse(t) {
        return Mf.parse(z.ADAPTER.parseXML(t))
    }
}
const gg = [vh, Mf, Of];
function BM(e) {
    for (let t = 0; t < gg.length; t++)
        if (gg[t].test(e))
            return gg[t];
    return null
}
function l7(e, t, r, i, n, s) {
    const o = r.fill;
    if (Array.isArray(o)) {
        if (o.length === 1)
            return o[0]
    } else
        return o;
    let a;
    const l = r.dropShadow ? r.dropShadowDistance : 0
      , h = r.padding || 0
      , u = e.width / i - l - h * 2
      , c = e.height / i - l - h * 2
      , d = o.slice()
      , f = r.fillGradientStops.slice();
    if (!f.length) {
        const g = d.length + 1;
        for (let p = 1; p < g; ++p)
            f.push(p / g)
    }
    if (d.unshift(o[0]),
    f.unshift(0),
    d.push(o[o.length - 1]),
    f.push(1),
    r.fillGradientType === ju.LINEAR_VERTICAL) {
        a = t.createLinearGradient(u / 2, h, u / 2, c + h);
        let g = 0;
        const p = (s.fontProperties.fontSize + r.strokeThickness) / c;
        for (let v = 0; v < n.length; v++) {
            const y = s.lineHeight * v;
            for (let m = 0; m < d.length; m++) {
                let _ = 0;
                typeof f[m] == "number" ? _ = f[m] : _ = m / d.length;
                const x = y / c + _ * p;
                let E = Math.max(g, x);
                E = Math.min(E, 1),
                a.addColorStop(E, d[m]),
                g = E
            }
        }
    } else {
        a = t.createLinearGradient(h, c / 2, u + h, c / 2);
        const g = d.length + 1;
        let p = 1;
        for (let v = 0; v < d.length; v++) {
            let y;
            typeof f[v] == "number" ? y = f[v] : y = p / g,
            a.addColorStop(y, d[v]),
            p++
        }
    }
    return a
}
function h7(e, t, r, i, n, s, o) {
    const a = r.text
      , l = r.fontProperties;
    t.translate(i, n),
    t.scale(s, s);
    const h = o.strokeThickness / 2
      , u = -(o.strokeThickness / 2);
    if (t.font = o.toFontString(),
    t.lineWidth = o.strokeThickness,
    t.textBaseline = o.textBaseline,
    t.lineJoin = o.lineJoin,
    t.miterLimit = o.miterLimit,
    t.fillStyle = l7(e, t, o, s, [a], r),
    t.strokeStyle = o.stroke,
    o.dropShadow) {
        const c = o.dropShadowColor
          , d = o.dropShadowBlur * s
          , f = o.dropShadowDistance * s;
        t.shadowColor = xt.shared.setValue(c).setAlpha(o.dropShadowAlpha).toRgbaString(),
        t.shadowBlur = d,
        t.shadowOffsetX = Math.cos(o.dropShadowAngle) * f,
        t.shadowOffsetY = Math.sin(o.dropShadowAngle) * f
    } else
        t.shadowColor = "black",
        t.shadowBlur = 0,
        t.shadowOffsetX = 0,
        t.shadowOffsetY = 0;
    o.stroke && o.strokeThickness && t.strokeText(a, h, u + r.lineHeight - l.descent),
    o.fill && t.fillText(a, h, u + r.lineHeight - l.descent),
    t.setTransform(1, 0, 0, 1, 0, 0),
    t.fillStyle = "rgba(0, 0, 0, 0)"
}
function wd(e) {
    return e.codePointAt ? e.codePointAt(0) : e.charCodeAt(0)
}
function kM(e) {
    return Array.from ? Array.from(e) : e.split("")
}
function u7(e) {
    typeof e == "string" && (e = [e]);
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
        const n = e[r];
        if (Array.isArray(n)) {
            if (n.length !== 2)
                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${n.length}.`);
            const s = n[0].charCodeAt(0)
              , o = n[1].charCodeAt(0);
            if (o < s)
                throw new Error("[BitmapFont]: Invalid character range.");
            for (let a = s, l = o; a <= l; a++)
                t.push(String.fromCharCode(a))
        } else
            t.push(...kM(n))
    }
    if (t.length === 0)
        throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return t
}
const Zn = class zi {
    constructor(t, r, i) {
        const [n] = t.info
          , [s] = t.common
          , [o] = t.page
          , [a] = t.distanceField
          , l = un(o.file)
          , h = {};
        this._ownsTextures = i,
        this.font = n.face,
        this.size = n.size,
        this.lineHeight = s.lineHeight / l,
        this.chars = {},
        this.pageTextures = h;
        for (let u = 0; u < t.page.length; u++) {
            const {id: c, file: d} = t.page[u];
            h[c] = r instanceof Array ? r[u] : r[d],
            a?.fieldType && a.fieldType !== "none" && (h[c].baseTexture.alphaMode = tr.NO_PREMULTIPLIED_ALPHA,
            h[c].baseTexture.mipmap = Ni.OFF)
        }
        for (let u = 0; u < t.char.length; u++) {
            const {id: c, page: d} = t.char[u];
            let {x: f, y: g, width: p, height: v, xoffset: y, yoffset: m, xadvance: _} = t.char[u];
            f /= l,
            g /= l,
            p /= l,
            v /= l,
            y /= l,
            m /= l,
            _ /= l;
            const x = new lt(f + h[d].frame.x / l,g + h[d].frame.y / l,p,v);
            this.chars[c] = {
                xOffset: y,
                yOffset: m,
                xAdvance: _,
                kerning: {},
                texture: new F(h[d].baseTexture,x),
                page: d
            }
        }
        for (let u = 0; u < t.kerning.length; u++) {
            let {first: c, second: d, amount: f} = t.kerning[u];
            c /= l,
            d /= l,
            f /= l,
            this.chars[d] && (this.chars[d].kerning[c] = f)
        }
        this.distanceFieldRange = a?.distanceRange,
        this.distanceFieldType = a?.fieldType?.toLowerCase() ?? "none"
    }
    destroy() {
        for (const t in this.chars)
            this.chars[t].texture.destroy(),
            this.chars[t].texture = null;
        for (const t in this.pageTextures)
            this._ownsTextures && this.pageTextures[t].destroy(!0),
            this.pageTextures[t] = null;
        this.chars = null,
        this.pageTextures = null
    }
    static install(t, r, i) {
        let n;
        if (t instanceof mu)
            n = t;
        else {
            const o = BM(t);
            if (!o)
                throw new Error("Unrecognized data format for font.");
            n = o.parse(t)
        }
        r instanceof F && (r = [r]);
        const s = new zi(n,r,i);
        return zi.available[s.font] = s,
        s
    }
    static uninstall(t) {
        const r = zi.available[t];
        if (!r)
            throw new Error(`No font found named '${t}'`);
        r.destroy(),
        delete zi.available[t]
    }
    static from(t, r, i) {
        if (!t)
            throw new Error("[BitmapFont] Property `name` is required.");
        const {chars: n, padding: s, resolution: o, textureWidth: a, textureHeight: l, ...h} = Object.assign({}, zi.defaultOptions, i)
          , u = u7(n)
          , c = r instanceof Li ? r : new Li(r)
          , d = a
          , f = new mu;
        f.info[0] = {
            face: c.fontFamily,
            size: c.fontSize
        },
        f.common[0] = {
            lineHeight: c.fontSize
        };
        let g = 0, p = 0, v, y, m, _ = 0;
        const x = [];
        for (let S = 0; S < u.length; S++) {
            v || (v = z.ADAPTER.createCanvas(),
            v.width = a,
            v.height = l,
            y = v.getContext("2d"),
            m = new nt(v,{
                resolution: o,
                ...h
            }),
            x.push(new F(m)),
            f.page.push({
                id: x.length - 1,
                file: ""
            }));
            const w = u[S]
              , T = Sn.measureText(w, c, !1, v)
              , C = T.width
              , R = Math.ceil(T.height)
              , O = Math.ceil((c.fontStyle === "italic" ? 2 : 1) * C);
            if (p >= l - R * o) {
                if (p === 0)
                    throw new Error(`[BitmapFont] textureHeight ${l}px is too small (fontFamily: '${c.fontFamily}', fontSize: ${c.fontSize}px, char: '${w}')`);
                --S,
                v = null,
                y = null,
                m = null,
                p = 0,
                g = 0,
                _ = 0;
                continue
            }
            if (_ = Math.max(R + T.fontProperties.descent, _),
            O * o + g >= d) {
                if (g === 0)
                    throw new Error(`[BitmapFont] textureWidth ${a}px is too small (fontFamily: '${c.fontFamily}', fontSize: ${c.fontSize}px, char: '${w}')`);
                --S,
                p += _ * o,
                p = Math.ceil(p),
                g = 0,
                _ = 0;
                continue
            }
            h7(v, y, T, g, p, o, c);
            const N = wd(T.text);
            f.char.push({
                id: N,
                page: x.length - 1,
                x: g / o,
                y: p / o,
                width: O,
                height: R,
                xoffset: 0,
                yoffset: 0,
                xadvance: C - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0)
            }),
            g += (O + 2 * s) * o,
            g = Math.ceil(g)
        }
        if (!i?.skipKerning)
            for (let S = 0, w = u.length; S < w; S++) {
                const T = u[S];
                for (let C = 0; C < w; C++) {
                    const R = u[C]
                      , O = y.measureText(T).width
                      , N = y.measureText(R).width
                      , P = y.measureText(T + R).width - (O + N);
                    P && f.kerning.push({
                        first: wd(T),
                        second: wd(R),
                        amount: P
                    })
                }
            }
        const E = new zi(f,x,!0);
        return zi.available[t] !== void 0 && zi.uninstall(t),
        zi.available[t] = E,
        E
    }
}
;
Zn.ALPHA = [["a", "z"], ["A", "Z"], " "],
Zn.NUMERIC = [["0", "9"]],
Zn.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "],
Zn.ASCII = [[" ", "~"]],
Zn.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: Zn.ALPHANUMERIC
},
Zn.available = {};
let vn = Zn;
var c7 = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // Gamma correction for coverage-like alpha\r
  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r
  float gamma = mix(1.0, 1.0 / 2.2, luma);\r
  float coverage = pow(uColor.a * alpha, gamma);  \r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, coverage);\r
}\r
`
  , d7 = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
const uw = []
  , cw = []
  , dw = []
  , FM = class UM extends J {
    constructor(t, r={}) {
        super();
        const {align: i, tint: n, maxWidth: s, letterSpacing: o, fontName: a, fontSize: l} = Object.assign({}, UM.styleDefaults, r);
        if (!vn.available[a])
            throw new Error(`Missing BitmapFont "${a}"`);
        this._activePagesMeshData = [],
        this._textWidth = 0,
        this._textHeight = 0,
        this._align = i,
        this._tintColor = new xt(n),
        this._font = void 0,
        this._fontName = a,
        this._fontSize = l,
        this.text = t,
        this._maxWidth = s,
        this._maxLineHeight = 0,
        this._letterSpacing = o,
        this._anchor = new Ji( () => {
            this.dirty = !0
        }
        ,this,0,0),
        this._roundPixels = z.ROUND_PIXELS,
        this.dirty = !0,
        this._resolution = z.RESOLUTION,
        this._autoResolution = !0,
        this._textureCache = {}
    }
    updateText() {
        const t = vn.available[this._fontName]
          , r = this.fontSize
          , i = r / t.size
          , n = new st
          , s = []
          , o = []
          , a = []
          , l = this._text.replace(/(?:\r\n|\r)/g, `
`) || " "
          , h = kM(l)
          , u = this._maxWidth * t.size / r
          , c = t.distanceFieldType === "none" ? uw : cw;
        let d = null
          , f = 0
          , g = 0
          , p = 0
          , v = -1
          , y = 0
          , m = 0
          , _ = 0
          , x = 0;
        for (let O = 0; O < h.length; O++) {
            const N = h[O]
              , P = wd(N);
            if (/(?:\s)/.test(N) && (v = O,
            y = f,
            x++),
            N === "\r" || N === `
`) {
                o.push(f),
                a.push(-1),
                g = Math.max(g, f),
                ++p,
                ++m,
                n.x = 0,
                n.y += t.lineHeight,
                d = null,
                x = 0;
                continue
            }
            const M = t.chars[P];
            if (!M)
                continue;
            d && M.kerning[d] && (n.x += M.kerning[d]);
            const V = dw.pop() || {
                texture: F.EMPTY,
                line: 0,
                charCode: 0,
                prevSpaces: 0,
                position: new st
            };
            V.texture = M.texture,
            V.line = p,
            V.charCode = P,
            V.position.x = Math.round(n.x + M.xOffset + this._letterSpacing / 2),
            V.position.y = Math.round(n.y + M.yOffset),
            V.prevSpaces = x,
            s.push(V),
            f = V.position.x + Math.max(M.xAdvance - M.xOffset, M.texture.orig.width),
            n.x += M.xAdvance + this._letterSpacing,
            _ = Math.max(_, M.yOffset + M.texture.height),
            d = P,
            v !== -1 && u > 0 && n.x > u && (++m,
            mo(s, 1 + v - m, 1 + O - v),
            O = v,
            v = -1,
            o.push(y),
            a.push(s.length > 0 ? s[s.length - 1].prevSpaces : 0),
            g = Math.max(g, y),
            p++,
            n.x = 0,
            n.y += t.lineHeight,
            d = null,
            x = 0)
        }
        const E = h[h.length - 1];
        E !== "\r" && E !== `
` && (/(?:\s)/.test(E) && (f = y),
        o.push(f),
        g = Math.max(g, f),
        a.push(-1));
        const S = [];
        for (let O = 0; O <= p; O++) {
            let N = 0;
            this._align === "right" ? N = g - o[O] : this._align === "center" ? N = (g - o[O]) / 2 : this._align === "justify" && (N = a[O] < 0 ? 0 : (g - o[O]) / a[O]),
            S.push(N)
        }
        const w = s.length
          , T = {}
          , C = []
          , R = this._activePagesMeshData;
        c.push(...R);
        for (let O = 0; O < w; O++) {
            const N = s[O].texture
              , P = N.baseTexture.uid;
            if (!T[P]) {
                let M = c.pop();
                if (!M) {
                    const X = new Vu;
                    let k, L;
                    t.distanceFieldType === "none" ? (k = new il(F.EMPTY),
                    L = tt.NORMAL) : (k = new il(F.EMPTY,{
                        program: tn.from(d7, c7),
                        uniforms: {
                            uFWidth: 0
                        }
                    }),
                    L = tt.NORMAL_NPM);
                    const $ = new rl(X,k);
                    $.blendMode = L,
                    M = {
                        index: 0,
                        indexCount: 0,
                        vertexCount: 0,
                        uvsCount: 0,
                        total: 0,
                        mesh: $,
                        vertices: null,
                        uvs: null,
                        indices: null
                    }
                }
                M.index = 0,
                M.indexCount = 0,
                M.vertexCount = 0,
                M.uvsCount = 0,
                M.total = 0;
                const {_textureCache: V} = this;
                V[P] = V[P] || new F(N.baseTexture),
                M.mesh.texture = V[P],
                M.mesh.tint = this._tintColor.value,
                C.push(M),
                T[P] = M
            }
            T[P].total++
        }
        for (let O = 0; O < R.length; O++)
            C.includes(R[O]) || this.removeChild(R[O].mesh);
        for (let O = 0; O < C.length; O++)
            C[O].mesh.parent !== this && this.addChild(C[O].mesh);
        this._activePagesMeshData = C;
        for (const O in T) {
            const N = T[O]
              , P = N.total;
            if (!(N.indices?.length > 6 * P) || N.vertices.length < rl.BATCHABLE_SIZE * 2)
                N.vertices = new Float32Array(4 * 2 * P),
                N.uvs = new Float32Array(4 * 2 * P),
                N.indices = new Uint16Array(6 * P);
            else {
                const M = N.total
                  , V = N.vertices;
                for (let X = M * 4 * 2; X < V.length; X++)
                    V[X] = 0
            }
            N.mesh.size = 6 * P
        }
        for (let O = 0; O < w; O++) {
            const N = s[O];
            let P = N.position.x + S[N.line] * (this._align === "justify" ? N.prevSpaces : 1);
            this._roundPixels && (P = Math.round(P));
            const M = P * i
              , V = N.position.y * i
              , X = N.texture
              , k = T[X.baseTexture.uid]
              , L = X.frame
              , $ = X._uvs
              , I = k.index++;
            k.indices[I * 6 + 0] = 0 + I * 4,
            k.indices[I * 6 + 1] = 1 + I * 4,
            k.indices[I * 6 + 2] = 2 + I * 4,
            k.indices[I * 6 + 3] = 0 + I * 4,
            k.indices[I * 6 + 4] = 2 + I * 4,
            k.indices[I * 6 + 5] = 3 + I * 4,
            k.vertices[I * 8 + 0] = M,
            k.vertices[I * 8 + 1] = V,
            k.vertices[I * 8 + 2] = M + L.width * i,
            k.vertices[I * 8 + 3] = V,
            k.vertices[I * 8 + 4] = M + L.width * i,
            k.vertices[I * 8 + 5] = V + L.height * i,
            k.vertices[I * 8 + 6] = M,
            k.vertices[I * 8 + 7] = V + L.height * i,
            k.uvs[I * 8 + 0] = $.x0,
            k.uvs[I * 8 + 1] = $.y0,
            k.uvs[I * 8 + 2] = $.x1,
            k.uvs[I * 8 + 3] = $.y1,
            k.uvs[I * 8 + 4] = $.x2,
            k.uvs[I * 8 + 5] = $.y2,
            k.uvs[I * 8 + 6] = $.x3,
            k.uvs[I * 8 + 7] = $.y3
        }
        this._textWidth = g * i,
        this._textHeight = (n.y + t.lineHeight) * i;
        for (const O in T) {
            const N = T[O];
            if (this.anchor.x !== 0 || this.anchor.y !== 0) {
                let X = 0;
                const k = this._textWidth * this.anchor.x
                  , L = this._textHeight * this.anchor.y;
                for (let $ = 0; $ < N.total; $++)
                    N.vertices[X++] -= k,
                    N.vertices[X++] -= L,
                    N.vertices[X++] -= k,
                    N.vertices[X++] -= L,
                    N.vertices[X++] -= k,
                    N.vertices[X++] -= L,
                    N.vertices[X++] -= k,
                    N.vertices[X++] -= L
            }
            this._maxLineHeight = _ * i;
            const P = N.mesh.geometry.getBuffer("aVertexPosition")
              , M = N.mesh.geometry.getBuffer("aTextureCoord")
              , V = N.mesh.geometry.getIndex();
            P.data = N.vertices,
            M.data = N.uvs,
            V.data = N.indices,
            P.update(),
            M.update(),
            V.update()
        }
        for (let O = 0; O < s.length; O++)
            dw.push(s[O]);
        this._font = t,
        this.dirty = !1
    }
    updateTransform() {
        this.validate(),
        this.containerUpdateTransform()
    }
    _render(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0);
        const {distanceFieldRange: r, distanceFieldType: i, size: n} = vn.available[this._fontName];
        if (i !== "none") {
            const {a: s, b: o, c: a, d: l} = this.worldTransform
              , h = Math.sqrt(s * s + o * o)
              , u = Math.sqrt(a * a + l * l)
              , c = (Math.abs(h) + Math.abs(u)) / 2
              , d = this.fontSize / n
              , f = t._view.resolution;
            for (const g of this._activePagesMeshData)
                g.mesh.shader.uniforms.uFWidth = c * r * d * f
        }
        super._render(t)
    }
    getLocalBounds() {
        return this.validate(),
        super.getLocalBounds()
    }
    validate() {
        const t = vn.available[this._fontName];
        if (!t)
            throw new Error(`Missing BitmapFont "${this._fontName}"`);
        this._font !== t && (this.dirty = !0),
        this.dirty && this.updateText()
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        if (this.tint !== t) {
            this._tintColor.setValue(t);
            for (let r = 0; r < this._activePagesMeshData.length; r++)
                this._activePagesMeshData[r].mesh.tint = t
        }
    }
    get align() {
        return this._align
    }
    set align(t) {
        this._align !== t && (this._align = t,
        this.dirty = !0)
    }
    get fontName() {
        return this._fontName
    }
    set fontName(t) {
        if (!vn.available[t])
            throw new Error(`Missing BitmapFont "${t}"`);
        this._fontName !== t && (this._fontName = t,
        this.dirty = !0)
    }
    get fontSize() {
        return this._fontSize ?? vn.available[this._fontName].size
    }
    set fontSize(t) {
        this._fontSize !== t && (this._fontSize = t,
        this.dirty = !0)
    }
    get anchor() {
        return this._anchor
    }
    set anchor(t) {
        typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t)
    }
    get text() {
        return this._text
    }
    set text(t) {
        t = String(t ?? ""),
        this._text !== t && (this._text = t,
        this.dirty = !0)
    }
    get maxWidth() {
        return this._maxWidth
    }
    set maxWidth(t) {
        this._maxWidth !== t && (this._maxWidth = t,
        this.dirty = !0)
    }
    get maxLineHeight() {
        return this.validate(),
        this._maxLineHeight
    }
    get textWidth() {
        return this.validate(),
        this._textWidth
    }
    get letterSpacing() {
        return this._letterSpacing
    }
    set letterSpacing(t) {
        this._letterSpacing !== t && (this._letterSpacing = t,
        this.dirty = !0)
    }
    get roundPixels() {
        return this._roundPixels
    }
    set roundPixels(t) {
        t !== this._roundPixels && (this._roundPixels = t,
        this.dirty = !0)
    }
    get textHeight() {
        return this.validate(),
        this._textHeight
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._autoResolution = !1,
        this._resolution !== t && (this._resolution = t,
        this.dirty = !0)
    }
    destroy(t) {
        const {_textureCache: r} = this
          , i = vn.available[this._fontName].distanceFieldType === "none" ? uw : cw;
        i.push(...this._activePagesMeshData);
        for (const n of this._activePagesMeshData)
            this.removeChild(n.mesh);
        this._activePagesMeshData = [],
        i.filter(n => r[n.mesh.texture.baseTexture.uid]).forEach(n => {
            n.mesh.texture = F.EMPTY
        }
        );
        for (const n in r)
            r[n].destroy(),
            delete r[n];
        this._font = null,
        this._tintColor = null,
        this._textureCache = null,
        super.destroy(t)
    }
}
;
FM.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
};
let f7 = FM;
const p7 = [".xml", ".fnt"]
  , GM = {
    extension: {
        type: G.LoadParser,
        priority: Gr.Normal
    },
    name: "loadBitmapFont",
    test(e) {
        return p7.includes(fe.extname(e).toLowerCase())
    },
    async testParse(e) {
        return vh.test(e) || Of.test(e)
    },
    async parse(e, t, r) {
        const i = vh.test(e) ? vh.parse(e) : Of.parse(e)
          , {src: n} = t
          , {page: s} = i
          , o = [];
        for (let h = 0; h < s.length; ++h) {
            const u = s[h].file;
            let c = fe.join(fe.dirname(n), u);
            c = Sf(c, n),
            o.push(c)
        }
        const a = await r.load(o)
          , l = o.map(h => a[h]);
        return vn.install(i, l, !0)
    },
    async load(e, t) {
        return (await z.ADAPTER.fetch(e)).text()
    },
    unload(e) {
        e.destroy()
    }
};
Y.add(GM);
const H_ = class oa extends Li {
    constructor() {
        super(...arguments),
        this._fonts = [],
        this._overrides = [],
        this._stylesheet = "",
        this.fontsDirty = !1
    }
    static from(t) {
        return new oa(Object.keys(oa.defaultOptions).reduce( (r, i) => ({
            ...r,
            [i]: t[i]
        }), {}))
    }
    cleanFonts() {
        this._fonts.length > 0 && (this._fonts.forEach(t => {
            URL.revokeObjectURL(t.src),
            t.refs--,
            t.refs === 0 && (t.fontFace && document.fonts.delete(t.fontFace),
            delete oa.availableFonts[t.originalUrl])
        }
        ),
        this.fontFamily = "Arial",
        this._fonts.length = 0,
        this.styleID++,
        this.fontsDirty = !0)
    }
    loadFont(t, r={}) {
        const {availableFonts: i} = oa;
        if (i[t]) {
            const n = i[t];
            return this._fonts.push(n),
            n.refs++,
            this.styleID++,
            this.fontsDirty = !0,
            Promise.resolve()
        }
        return z.ADAPTER.fetch(t).then(n => n.blob()).then(async n => new Promise( (s, o) => {
            const a = URL.createObjectURL(n)
              , l = new FileReader;
            l.onload = () => s([a, l.result]),
            l.onerror = o,
            l.readAsDataURL(n)
        }
        )).then(async ([n,s]) => {
            const o = Object.assign({
                family: fe.basename(t, fe.extname(t)),
                weight: "normal",
                style: "normal",
                display: "auto",
                src: n,
                dataSrc: s,
                refs: 1,
                originalUrl: t,
                fontFace: null
            }, r);
            i[t] = o,
            this._fonts.push(o),
            this.styleID++;
            const a = new FontFace(o.family,`url(${o.src})`,{
                weight: o.weight,
                style: o.style,
                display: o.display
            });
            o.fontFace = a,
            await a.load(),
            document.fonts.add(a),
            await document.fonts.ready,
            this.styleID++,
            this.fontsDirty = !0
        }
        )
    }
    addOverride(...t) {
        const r = t.filter(i => !this._overrides.includes(i));
        r.length > 0 && (this._overrides.push(...r),
        this.styleID++)
    }
    removeOverride(...t) {
        const r = t.filter(i => this._overrides.includes(i));
        r.length > 0 && (this._overrides = this._overrides.filter(i => !r.includes(i)),
        this.styleID++)
    }
    toCSS(t) {
        return [`transform: scale(${t})`, "transform-origin: top left", "display: inline-block", `color: ${this.normalizeColor(this.fill)}`, `font-size: ${this.fontSize}px`, `font-family: ${this.fontFamily}`, `font-weight: ${this.fontWeight}`, `font-style: ${this.fontStyle}`, `font-variant: ${this.fontVariant}`, `letter-spacing: ${this.letterSpacing}px`, `text-align: ${this.align}`, `padding: ${this.padding}px`, `white-space: ${this.whiteSpace}`, ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [], ...this.wordWrap ? [`word-wrap: ${this.breakWords ? "break-all" : "break-word"}`, `max-width: ${this.wordWrapWidth}px`] : [], ...this.strokeThickness ? [`-webkit-text-stroke-width: ${this.strokeThickness}px`, `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`, `text-stroke-width: ${this.strokeThickness}px`, `text-stroke-color: ${this.normalizeColor(this.stroke)}`, "paint-order: stroke"] : [], ...this.dropShadow ? [this.dropShadowToCSS()] : [], ...this._overrides].join(";")
    }
    toGlobalCSS() {
        return this._fonts.reduce( (t, r) => `${t}
            @font-face {
                font-family: "${r.family}";
                src: url('${r.dataSrc}');
                font-weight: ${r.weight};
                font-style: ${r.style};
                font-display: ${r.display};
            }`, this._stylesheet)
    }
    get stylesheet() {
        return this._stylesheet
    }
    set stylesheet(t) {
        this._stylesheet !== t && (this._stylesheet = t,
        this.styleID++)
    }
    normalizeColor(t) {
        return Array.isArray(t) && (t = SI(t)),
        typeof t == "number" ? TI(t) : t
    }
    dropShadowToCSS() {
        let t = this.normalizeColor(this.dropShadowColor);
        const r = this.dropShadowAlpha
          , i = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance)
          , n = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
        t.startsWith("#") && r < 1 && (t += (r * 255 | 0).toString(16).padStart(2, "0"));
        const s = `${i}px ${n}px`;
        return this.dropShadowBlur > 0 ? `text-shadow: ${s} ${this.dropShadowBlur}px ${t}` : `text-shadow: ${s} ${t}`
    }
    reset() {
        Object.assign(this, oa.defaultOptions)
    }
    onBeforeDraw() {
        const {fontsDirty: t} = this;
        return this.fontsDirty = !1,
        this.isSafari && this._fonts.length > 0 && t ? new Promise(r => setTimeout(r, 100)) : Promise.resolve()
    }
    get isSafari() {
        const {userAgent: t} = z.ADAPTER.getNavigator();
        return /^((?!chrome|android).)*safari/i.test(t)
    }
    set fillGradientStops(t) {
        console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText")
    }
    get fillGradientStops() {
        return super.fillGradientStops
    }
    set fillGradientType(t) {
        console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText")
    }
    get fillGradientType() {
        return super.fillGradientType
    }
    set miterLimit(t) {
        console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText")
    }
    get miterLimit() {
        return super.miterLimit
    }
    set trim(t) {
        console.warn("[HTMLTextStyle] trim is not supported by HTMLText")
    }
    get trim() {
        return super.trim
    }
    set textBaseline(t) {
        console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText")
    }
    get textBaseline() {
        return super.textBaseline
    }
    set leading(t) {
        console.warn("[HTMLTextStyle] leading is not supported by HTMLText")
    }
    get leading() {
        return super.leading
    }
    set lineJoin(t) {
        console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText")
    }
    get lineJoin() {
        return super.lineJoin
    }
}
;
H_.availableFonts = {},
H_.defaultOptions = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    whiteSpace: "normal",
    wordWrap: !1,
    wordWrapWidth: 100
};
let Ad = H_;
const Ql = class aa extends at {
    constructor(t="", r={}) {
        super(F.EMPTY),
        this._text = null,
        this._style = null,
        this._autoResolution = !0,
        this.localStyleID = -1,
        this.dirty = !1,
        this._updateID = 0,
        this.ownsStyle = !1;
        const i = new Image
          , n = F.from(i, {
            scaleMode: z.SCALE_MODE,
            resourceOptions: {
                autoLoad: !1
            }
        });
        n.orig = new lt,
        n.trim = new lt,
        this.texture = n;
        const s = "http://www.w3.org/2000/svg"
          , o = "http://www.w3.org/1999/xhtml"
          , a = document.createElementNS(s, "svg")
          , l = document.createElementNS(s, "foreignObject")
          , h = document.createElementNS(o, "div")
          , u = document.createElementNS(o, "style");
        l.setAttribute("width", "10000"),
        l.setAttribute("height", "10000"),
        l.style.overflow = "hidden",
        a.appendChild(l),
        this.maxWidth = aa.defaultMaxWidth,
        this.maxHeight = aa.defaultMaxHeight,
        this._domElement = h,
        this._styleElement = u,
        this._svgRoot = a,
        this._foreignObject = l,
        this._foreignObject.appendChild(u),
        this._foreignObject.appendChild(h),
        this._image = i,
        this._loadImage = new Image,
        this._autoResolution = aa.defaultAutoResolution,
        this._resolution = aa.defaultResolution ?? z.RESOLUTION,
        this.text = t,
        this.style = r
    }
    measureText(t) {
        const {text: r, style: i, resolution: n} = Object.assign({
            text: this._text,
            style: this._style,
            resolution: this._resolution
        }, t);
        Object.assign(this._domElement, {
            innerHTML: r,
            style: i.toCSS(n)
        }),
        this._styleElement.textContent = i.toGlobalCSS(),
        document.body.appendChild(this._svgRoot);
        const s = this._domElement.getBoundingClientRect();
        this._svgRoot.remove();
        const {width: o, height: a} = s;
        (o > this.maxWidth || a > this.maxHeight) && console.warn("[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.");
        const l = Math.min(this.maxWidth, Math.ceil(o))
          , h = Math.min(this.maxHeight, Math.ceil(a));
        return this._svgRoot.setAttribute("width", l.toString()),
        this._svgRoot.setAttribute("height", h.toString()),
        r !== this._text && (this._domElement.innerHTML = this._text),
        i !== this._style && (Object.assign(this._domElement, {
            style: this._style?.toCSS(n)
        }),
        this._styleElement.textContent = this._style?.toGlobalCSS()),
        {
            width: l + i.padding * 2,
            height: h + i.padding * 2
        }
    }
    async updateText(t=!0) {
        const {style: r, _image: i, _loadImage: n} = this;
        if (this.localStyleID !== r.styleID && (this.dirty = !0,
        this.localStyleID = r.styleID),
        !this.dirty && t)
            return;
        const {width: s, height: o} = this.measureText();
        i.width = n.width = Math.ceil(Math.max(1, s)),
        i.height = n.height = Math.ceil(Math.max(1, o)),
        this._updateID++;
        const a = this._updateID;
        await new Promise(l => {
            n.onload = async () => {
                if (a < this._updateID) {
                    l();
                    return
                }
                await r.onBeforeDraw(),
                i.src = n.src,
                n.onload = null,
                n.src = "",
                this.updateTexture(),
                l()
            }
            ;
            const h = new XMLSerializer().serializeToString(this._svgRoot);
            n.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(h)}`
        }
        )
    }
    get source() {
        return this._image
    }
    updateTexture() {
        const {style: t, texture: r, _image: i, resolution: n} = this
          , {padding: s} = t
          , {baseTexture: o} = r;
        r.trim.width = r._frame.width = i.width / n,
        r.trim.height = r._frame.height = i.height / n,
        r.trim.x = -s,
        r.trim.y = -s,
        r.orig.width = r._frame.width - s * 2,
        r.orig.height = r._frame.height - s * 2,
        this._onTextureUpdate(),
        o.setRealSize(i.width, i.height, n),
        this.dirty = !1
    }
    _render(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0),
        this.updateText(!0),
        super._render(t)
    }
    _renderCanvas(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0),
        this.updateText(!0),
        super._renderCanvas(t)
    }
    getLocalBounds(t) {
        return this.updateText(!0),
        super.getLocalBounds(t)
    }
    _calculateBounds() {
        this.updateText(!0),
        this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)
    }
    _onStyleChange() {
        this.dirty = !0
    }
    destroy(t) {
        typeof t == "boolean" && (t = {
            children: t
        }),
        t = Object.assign({}, aa.defaultDestroyOptions, t),
        super.destroy(t);
        const r = null;
        this.ownsStyle && this._style?.cleanFonts(),
        this._style = r,
        this._svgRoot?.remove(),
        this._svgRoot = r,
        this._domElement?.remove(),
        this._domElement = r,
        this._foreignObject?.remove(),
        this._foreignObject = r,
        this._styleElement?.remove(),
        this._styleElement = r,
        this._loadImage.src = "",
        this._loadImage.onload = null,
        this._loadImage = r,
        this._image.src = "",
        this._image = r
    }
    get width() {
        return this.updateText(!0),
        Math.abs(this.scale.x) * this._image.width / this.resolution
    }
    set width(t) {
        this.updateText(!0);
        const r = In(this.scale.x) || 1;
        this.scale.x = r * t / this._image.width / this.resolution,
        this._width = t
    }
    get height() {
        return this.updateText(!0),
        Math.abs(this.scale.y) * this._image.height / this.resolution
    }
    set height(t) {
        this.updateText(!0);
        const r = In(this.scale.y) || 1;
        this.scale.y = r * t / this._image.height / this.resolution,
        this._height = t
    }
    get style() {
        return this._style
    }
    set style(t) {
        this._style !== t && (t = t || {},
        t instanceof Ad ? (this.ownsStyle = !1,
        this._style = t) : t instanceof Li ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"),
        this.ownsStyle = !0,
        this._style = Ad.from(t)) : (this.ownsStyle = !0,
        this._style = new Ad(t)),
        this.localStyleID = -1,
        this.dirty = !0)
    }
    get text() {
        return this._text
    }
    set text(t) {
        t = String(t === "" || t === null || t === void 0 ? " " : t),
        t = this.sanitiseText(t),
        this._text !== t && (this._text = t,
        this.dirty = !0)
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._autoResolution = !1,
        this._resolution !== t && (this._resolution = t,
        this.dirty = !0)
    }
    sanitiseText(t) {
        return t.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;")
    }
}
;
Ql.defaultDestroyOptions = {
    texture: !0,
    children: !1,
    baseTexture: !0
},
Ql.defaultMaxWidth = 2024,
Ql.defaultMaxHeight = 2024,
Ql.defaultAutoResolution = !0;
let m7 = Ql;
const g7 = Object.freeze(Object.defineProperty({
    __proto__: null,
    ALPHA_MODES: tr,
    AbstractMultiResource: Ax,
    AccessibilityManager: Mx,
    AlphaFilter: Ix,
    AnimatedSprite: Le,
    Application: Ox,
    ArrayResource: lR,
    Assets: vt,
    AssetsClass: AR,
    Attribute: tu,
    BLEND_MODES: tt,
    BUFFER_BITS: lf,
    BUFFER_TYPE: Pi,
    BackgroundSystem: ru,
    BaseImageResource: Gn,
    BasePrepare: Rf,
    BaseRenderTexture: nx,
    BaseTexture: nt,
    BatchDrawCall: gf,
    BatchGeometry: rx,
    BatchRenderer: es,
    BatchShaderGenerator: GI,
    BatchSystem: ix,
    BatchTextureArray: _f,
    BitmapFont: vn,
    BitmapFontData: mu,
    BitmapText: f7,
    BlobResource: nM,
    BlurFilter: qR,
    BlurFilterPass: bf,
    Bounds: uu,
    BrowserAdapter: ZP,
    Buffer: te,
    BufferResource: Bu,
    BufferSystem: Sx,
    CLEAR_MODES: vi,
    COLOR_MASK_BITS: qP,
    Cache: ss,
    CanvasResource: hR,
    Circle: ku,
    Color: xt,
    ColorMatrixFilter: Cf,
    CompressedTextureResource: Ss,
    Container: J,
    ContextSystem: iu,
    CountLimiter: IM,
    CubeResource: cR,
    DEG_TO_RAD: OI,
    DRAW_MODES: Ti,
    DisplacementFilter: Rx,
    DisplayObject: zt,
    ENV: Fs,
    Ellipse: Fu,
    EventBoundary: JR,
    EventSystem: Pf,
    ExtensionType: G,
    Extract: fM,
    FORMATS: B,
    FORMATS_TO_COMPONENTS: oM,
    FXAAFilter: ZR,
    FederatedDisplayObject: tM,
    FederatedEvent: yl,
    FederatedMouseEvent: cu,
    FederatedPointerEvent: Hr,
    FederatedWheelEvent: yo,
    FillStyle: Wu,
    Filter: ze,
    FilterState: $I,
    FilterSystem: lx,
    Framebuffer: yf,
    FramebufferSystem: hx,
    GC_MODES: Pp,
    GLFramebuffer: zI,
    GLProgram: KI,
    GLTexture: yd,
    GRAPHICS_CURVES: LV,
    GenerateTextureSystem: mx,
    Geometry: Un,
    GeometrySystem: ux,
    Graphics: Dx,
    GraphicsData: pu,
    GraphicsGeometry: vM,
    HTMLText: m7,
    HTMLTextStyle: Ad,
    IGLUniformData: lz,
    INSTALLED: mf,
    INTERNAL_FORMATS: or,
    INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: du,
    ImageBitmapResource: ao,
    ImageResource: sx,
    LINE_CAP: Rn,
    LINE_JOIN: Sr,
    LineStyle: Gp,
    LoaderParserPriority: Gr,
    MASK_TYPES: he,
    MIPMAP_MODES: Ni,
    MSAA_QUALITY: se,
    MaskData: VI,
    MaskSystem: cx,
    Matrix: Mt,
    Mesh: rl,
    MeshBatchUvs: xM,
    MeshGeometry: Vu,
    MeshMaterial: il,
    MultisampleSystem: Tx,
    NineSlicePlane: bM,
    NoiseFilter: QR,
    ObjectRenderer: Hu,
    ObjectRendererSystem: wx,
    ObservablePoint: Ji,
    PI_2: eu,
    PRECISION: Ir,
    ParticleContainer: If,
    ParticleRenderer: Bx,
    PlaneGeometry: SM,
    PluginSystem: fx,
    Point: st,
    Polygon: Ts,
    Prepare: kx,
    Program: tn,
    ProjectionSystem: px,
    Quad: HI,
    QuadUv: ax,
    RAD_TO_DEG: MI,
    RENDERER_TYPE: zv,
    Rectangle: lt,
    RenderTexture: Gs,
    RenderTexturePool: ox,
    RenderTextureSystem: gx,
    Renderer: Dp,
    ResizePlugin: Nx,
    Resource: el,
    RopeGeometry: wM,
    RoundedRectangle: Uu,
    Runner: Nr,
    SAMPLER_TYPES: W,
    SCALE_MODES: Qi,
    SHAPES: we,
    SVGResource: vf,
    ScissorSystem: YI,
    Shader: Ri,
    ShaderSystem: _x,
    SimpleMesh: GV,
    SimplePlane: AM,
    SimpleRope: HV,
    Sprite: at,
    SpriteMaskFilter: WI,
    Spritesheet: G_,
    StartupSystem: nu,
    State: Bi,
    StateSystem: rR,
    StencilSystem: dx,
    SystemManager: iR,
    TARGETS: co,
    TEXT_GRADIENT: ju,
    TYPES: Q,
    TYPES_TO_BYTES_PER_COMPONENT: L_,
    TYPES_TO_BYTES_PER_PIXEL: aM,
    TemporaryDisplayObject: XR,
    Text: Oo,
    TextFormat: vh,
    TextMetrics: Sn,
    TextStyle: Li,
    Texture: F,
    TextureGCSystem: rs,
    TextureMatrix: Lp,
    TextureSystem: yx,
    TextureUvs: Np,
    Ticker: $t,
    TickerPlugin: xx,
    TilingSprite: wi,
    TilingSpriteRenderer: Fx,
    TimeLimiter: r7,
    Transform: Gu,
    TransformFeedback: bz,
    TransformFeedbackSystem: vx,
    UPDATE_PRIORITY: Hn,
    UniformGroup: ni,
    VERSION: Cz,
    VideoResource: bx,
    ViewSystem: su,
    ViewableBuffer: pf,
    WRAP_MODES: Ci,
    XMLFormat: Mf,
    XMLStringFormat: Of,
    accessibleTarget: eM,
    autoDetectFormat: BM,
    autoDetectRenderer: oR,
    autoDetectResource: ex,
    cacheTextureArray: bR,
    checkDataUrl: Ho,
    checkExtension: Xn,
    checkMaxIfStatementsInShader: RI,
    convertToList: qr,
    copySearchParams: Sf,
    createStringVariations: _R,
    createTexture: gl,
    createUBOElements: QI,
    curves: Rs,
    defaultFilterVertex: Ex,
    defaultVertex: aR,
    detectAvif: CR,
    detectCompressedTextures: iM,
    detectDefaults: IR,
    detectMp4: MR,
    detectOgv: OR,
    detectWebm: RR,
    detectWebp: PR,
    extensions: Y,
    filters: I_,
    generateProgram: qI,
    generateUniformBufferSync: tR,
    getFontFamilyName: xR,
    getTestContext: BI,
    getUBOData: JI,
    graphicsUtils: kV,
    groupD8: Ut,
    isMobile: Si,
    isSingleItem: au,
    loadBitmapFont: GM,
    loadDDS: hM,
    loadImageBitmap: TR,
    loadJson: yR,
    loadKTX: uM,
    loadSVG: SR,
    loadTextures: $u,
    loadTxt: vR,
    loadVideo: wR,
    loadWebFont: ER,
    parseDDS: sM,
    parseKTX: lM,
    resolveCompressedTextureUrl: cM,
    resolveTextureUrl: NR,
    settings: z,
    spritesheetAsset: DM,
    uniformParsers: go,
    unsafeEvalSupported: UI,
    utils: O8
}, Symbol.toStringTag, {
    value: "Module"
}));
function xn(e) {
    if (e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}
function HM(e, t) {
    e.prototype = Object.create(t.prototype),
    e.prototype.constructor = e,
    e.__proto__ = t
}
/*!
 * GSAP 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Lr = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, nl = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, Ux, We, ee, Jr = 1e8, Pt = 1 / Jr, $_ = Math.PI * 2, _7 = $_ / 4, y7 = 0, $M = Math.sqrt, v7 = Math.cos, x7 = Math.sin, Ce = function(t) {
    return typeof t == "string"
}, re = function(t) {
    return typeof t == "function"
}, $n = function(t) {
    return typeof t == "number"
}, Gx = function(t) {
    return typeof t > "u"
}, dn = function(t) {
    return typeof t == "object"
}, dr = function(t) {
    return t !== !1
}, Hx = function() {
    return typeof window < "u"
}, Vc = function(t) {
    return re(t) || Ce(t)
}, zM = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, Ve = Array.isArray, z_ = /(?:-?\.?\d|\.)+/gi, WM = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Ta = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, _g = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, VM = /[+-]=-?[.\d]+/, jM = /[^,'"\[\]\s]+/gi, E7 = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Xt, zr, W_, $x, Br = {}, Nf = {}, XM, YM = function(t) {
    return (Nf = No(t, Br)) && mr
}, zx = function(t, r) {
    return console.warn("Invalid property", t, "set to", r, "Missing plugin? gsap.registerPlugin()")
}, Lf = function(t, r) {
    return !r && console.warn(t)
}, KM = function(t, r) {
    return t && (Br[t] = r) && Nf && (Nf[t] = r) || Br
}, gu = function() {
    return 0
}, T7 = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, bd = {
    suppressEvents: !0,
    kill: !1
}, S7 = {
    suppressEvents: !0
}, Wx = {}, ws = [], V_ = {}, qM, wr = {}, yg = {}, fw = 30, Cd = [], Vx = "", jx = function(t) {
    var r = t[0], i, n;
    if (dn(r) || re(r) || (t = [t]),
    !(i = (r._gsap || {}).harness)) {
        for (n = Cd.length; n-- && !Cd[n].targetTest(r); )
            ;
        i = Cd[n]
    }
    for (n = t.length; n--; )
        t[n] && (t[n]._gsap || (t[n]._gsap = new xO(t[n],i))) || t.splice(n, 1);
    return t
}, vo = function(t) {
    return t._gsap || jx(ti(t))[0]._gsap
}, ZM = function(t, r, i) {
    return (i = t[r]) && re(i) ? t[r]() : Gx(i) && t.getAttribute && t.getAttribute(r) || i
}, fr = function(t, r) {
    return (t = t.split(",")).forEach(r) || t
}, ne = function(t) {
    return Math.round(t * 1e5) / 1e5 || 0
}, Oe = function(t) {
    return Math.round(t * 1e7) / 1e7 || 0
}, La = function(t, r) {
    var i = r.charAt(0)
      , n = parseFloat(r.substr(2));
    return t = parseFloat(t),
    i === "+" ? t + n : i === "-" ? t - n : i === "*" ? t * n : t / n
}, w7 = function(t, r) {
    for (var i = r.length, n = 0; t.indexOf(r[n]) < 0 && ++n < i; )
        ;
    return n < i
}, Df = function() {
    var t = ws.length, r = ws.slice(0), i, n;
    for (V_ = {},
    ws.length = 0,
    i = 0; i < t; i++)
        n = r[i],
        n && n._lazy && (n.render(n._lazy[0], n._lazy[1], !0)._lazy = 0)
}, QM = function(t, r, i, n) {
    ws.length && !We && Df(),
    t.render(r, i, n || We && r < 0 && (t._initted || t._startAt)),
    ws.length && !We && Df()
}, JM = function(t) {
    var r = parseFloat(t);
    return (r || r === 0) && (t + "").match(jM).length < 2 ? r : Ce(t) ? t.trim() : t
}, tO = function(t) {
    return t
}, hi = function(t, r) {
    for (var i in r)
        i in t || (t[i] = r[i]);
    return t
}, A7 = function(t) {
    return function(r, i) {
        for (var n in i)
            n in r || n === "duration" && t || n === "ease" || (r[n] = i[n])
    }
}, No = function(t, r) {
    for (var i in r)
        t[i] = r[i];
    return t
}, pw = function e(t, r) {
    for (var i in r)
        i !== "__proto__" && i !== "constructor" && i !== "prototype" && (t[i] = dn(r[i]) ? e(t[i] || (t[i] = {}), r[i]) : r[i]);
    return t
}, Bf = function(t, r) {
    var i = {}, n;
    for (n in t)
        n in r || (i[n] = t[n]);
    return i
}, xh = function(t) {
    var r = t.parent || Xt
      , i = t.keyframes ? A7(Ve(t.keyframes)) : hi;
    if (dr(t.inherit))
        for (; r; )
            i(t, r.vars.defaults),
            r = r.parent || r._dp;
    return t
}, b7 = function(t, r) {
    for (var i = t.length, n = i === r.length; n && i-- && t[i] === r[i]; )
        ;
    return i < 0
}, eO = function(t, r, i, n, s) {
    i === void 0 && (i = "_first"),
    n === void 0 && (n = "_last");
    var o = t[n], a;
    if (s)
        for (a = r[s]; o && o[s] > a; )
            o = o._prev;
    return o ? (r._next = o._next,
    o._next = r) : (r._next = t[i],
    t[i] = r),
    r._next ? r._next._prev = r : t[n] = r,
    r._prev = o,
    r.parent = r._dp = t,
    r
}, Hp = function(t, r, i, n) {
    i === void 0 && (i = "_first"),
    n === void 0 && (n = "_last");
    var s = r._prev
      , o = r._next;
    s ? s._next = o : t[i] === r && (t[i] = o),
    o ? o._prev = s : t[n] === r && (t[n] = s),
    r._next = r._prev = r.parent = null
}, Ms = function(t, r) {
    t.parent && (!r || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t),
    t._act = 0
}, xo = function(t, r) {
    if (t && (!r || r._end > t._dur || r._start < 0))
        for (var i = t; i; )
            i._dirty = 1,
            i = i.parent;
    return t
}, C7 = function(t) {
    for (var r = t.parent; r && r.parent; )
        r._dirty = 1,
        r.totalDuration(),
        r = r.parent;
    return t
}, j_ = function(t, r, i, n) {
    return t._startAt && (We ? t._startAt.revert(bd) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(r, !0, n))
}, P7 = function e(t) {
    return !t || t._ts && e(t.parent)
}, mw = function(t) {
    return t._repeat ? sl(t._tTime, t = t.duration() + t._rDelay) * t : 0
}, sl = function(t, r) {
    var i = Math.floor(t /= r);
    return t && i === t ? i - 1 : i
}, kf = function(t, r) {
    return (t - r._start) * r._ts + (r._ts >= 0 ? 0 : r._dirty ? r.totalDuration() : r._tDur)
}, $p = function(t) {
    return t._end = Oe(t._start + (t._tDur / Math.abs(t._ts || t._rts || Pt) || 0))
}, zp = function(t, r) {
    var i = t._dp;
    return i && i.smoothChildTiming && t._ts && (t._start = Oe(i._time - (t._ts > 0 ? r / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - r) / -t._ts)),
    $p(t),
    i._dirty || xo(i, t)),
    t
}, rO = function(t, r) {
    var i;
    if ((r._time || r._initted && !r._dur) && (i = kf(t.rawTime(), r),
    (!r._dur || Xu(0, r.totalDuration(), i) - r._tTime > Pt) && r.render(i, !0)),
    xo(t, r)._dp && t._initted && t._time >= t._dur && t._ts) {
        if (t._dur < t.duration())
            for (i = t; i._dp; )
                i.rawTime() >= 0 && i.totalTime(i._tTime),
                i = i._dp;
        t._zTime = -Pt
    }
}, qi = function(t, r, i, n) {
    return r.parent && Ms(r),
    r._start = Oe(($n(i) ? i : i || t !== Xt ? $r(t, i, r) : t._time) + r._delay),
    r._end = Oe(r._start + (r.totalDuration() / Math.abs(r.timeScale()) || 0)),
    eO(t, r, "_first", "_last", t._sort ? "_start" : 0),
    X_(r) || (t._recent = r),
    n || rO(t, r),
    t._ts < 0 && zp(t, t._tTime),
    t
}, iO = function(t, r) {
    return (Br.ScrollTrigger || zx("scrollTrigger", r)) && Br.ScrollTrigger.create(r, t)
}, nO = function(t, r, i, n, s) {
    if (Yx(t, r, s),
    !t._initted)
        return 1;
    if (!i && t._pt && !We && (t._dur && t.vars.lazy !== !1 || !t._dur && t.vars.lazy) && qM !== br.frame)
        return ws.push(t),
        t._lazy = [s, n],
        1
}, I7 = function e(t) {
    var r = t.parent;
    return r && r._ts && r._initted && !r._lock && (r.rawTime() < 0 || e(r))
}, X_ = function(t) {
    var r = t.data;
    return r === "isFromStart" || r === "isStart"
}, R7 = function(t, r, i, n) {
    var s = t.ratio, o = r < 0 || !r && (!t._start && I7(t) && !(!t._initted && X_(t)) || (t._ts < 0 || t._dp._ts < 0) && !X_(t)) ? 0 : 1, a = t._rDelay, l = 0, h, u, c;
    if (a && t._repeat && (l = Xu(0, t._tDur, r),
    u = sl(l, a),
    t._yoyo && u & 1 && (o = 1 - o),
    u !== sl(t._tTime, a) && (s = 1 - o,
    t.vars.repeatRefresh && t._initted && t.invalidate())),
    o !== s || We || n || t._zTime === Pt || !r && t._zTime) {
        if (!t._initted && nO(t, r, n, i, l))
            return;
        for (c = t._zTime,
        t._zTime = r || (i ? Pt : 0),
        i || (i = r && !c),
        t.ratio = o,
        t._from && (o = 1 - o),
        t._time = 0,
        t._tTime = l,
        h = t._pt; h; )
            h.r(o, h.d),
            h = h._next;
        r < 0 && j_(t, r, i, !0),
        t._onUpdate && !i && ei(t, "onUpdate"),
        l && t._repeat && !i && t.parent && ei(t, "onRepeat"),
        (r >= t._tDur || r < 0) && t.ratio === o && (o && Ms(t, 1),
        !i && !We && (ei(t, o ? "onComplete" : "onReverseComplete", !0),
        t._prom && t._prom()))
    } else
        t._zTime || (t._zTime = r)
}, M7 = function(t, r, i) {
    var n;
    if (i > r)
        for (n = t._first; n && n._start <= i; ) {
            if (n.data === "isPause" && n._start > r)
                return n;
            n = n._next
        }
    else
        for (n = t._last; n && n._start >= i; ) {
            if (n.data === "isPause" && n._start < r)
                return n;
            n = n._prev
        }
}, ol = function(t, r, i, n) {
    var s = t._repeat
      , o = Oe(r) || 0
      , a = t._tTime / t._tDur;
    return a && !n && (t._time *= o / t._dur),
    t._dur = o,
    t._tDur = s ? s < 0 ? 1e10 : Oe(o * (s + 1) + t._rDelay * s) : o,
    a > 0 && !n && zp(t, t._tTime = t._tDur * a),
    t.parent && $p(t),
    i || xo(t.parent, t),
    t
}, gw = function(t) {
    return t instanceof Qe ? xo(t) : ol(t, t._dur)
}, O7 = {
    _start: 0,
    endTime: gu,
    totalDuration: gu
}, $r = function e(t, r, i) {
    var n = t.labels, s = t._recent || O7, o = t.duration() >= Jr ? s.endTime(!1) : t._dur, a, l, h;
    return Ce(r) && (isNaN(r) || r in n) ? (l = r.charAt(0),
    h = r.substr(-1) === "%",
    a = r.indexOf("="),
    l === "<" || l === ">" ? (a >= 0 && (r = r.replace(/=/, "")),
    (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(r.substr(1)) || 0) * (h ? (a < 0 ? s : i).totalDuration() / 100 : 1)) : a < 0 ? (r in n || (n[r] = o),
    n[r]) : (l = parseFloat(r.charAt(a - 1) + r.substr(a + 1)),
    h && i && (l = l / 100 * (Ve(i) ? i[0] : i).totalDuration()),
    a > 1 ? e(t, r.substr(0, a - 1), i) + l : o + l)) : r == null ? o : +r
}, Eh = function(t, r, i) {
    var n = $n(r[1]), s = (n ? 2 : 1) + (t < 2 ? 0 : 1), o = r[s], a, l;
    if (n && (o.duration = r[1]),
    o.parent = i,
    t) {
        for (a = o,
        l = i; l && !("immediateRender"in a); )
            a = l.vars.defaults || {},
            l = dr(l.vars.inherit) && l.parent;
        o.immediateRender = dr(a.immediateRender),
        t < 2 ? o.runBackwards = 1 : o.startAt = r[s - 1]
    }
    return new ue(r[0],o,r[s + 1])
}, Hs = function(t, r) {
    return t || t === 0 ? r(t) : r
}, Xu = function(t, r, i) {
    return i < t ? t : i > r ? r : i
}, $e = function(t, r) {
    return !Ce(t) || !(r = E7.exec(t)) ? "" : r[1]
}, N7 = function(t, r, i) {
    return Hs(i, function(n) {
        return Xu(t, r, n)
    })
}, Y_ = [].slice, sO = function(t, r) {
    return t && dn(t) && "length"in t && (!r && !t.length || t.length - 1 in t && dn(t[0])) && !t.nodeType && t !== zr
}, L7 = function(t, r, i) {
    return i === void 0 && (i = []),
    t.forEach(function(n) {
        var s;
        return Ce(n) && !r || sO(n, 1) ? (s = i).push.apply(s, ti(n)) : i.push(n)
    }) || i
}, ti = function(t, r, i) {
    return ee && !r && ee.selector ? ee.selector(t) : Ce(t) && !i && (W_ || !al()) ? Y_.call((r || $x).querySelectorAll(t), 0) : Ve(t) ? L7(t, i) : sO(t) ? Y_.call(t, 0) : t ? [t] : []
}, K_ = function(t) {
    return t = ti(t)[0] || Lf("Invalid scope") || {},
    function(r) {
        var i = t.current || t.nativeElement || t;
        return ti(r, i.querySelectorAll ? i : i === t ? Lf("Invalid scope") || $x.createElement("div") : t)
    }
}, oO = function(t) {
    return t.sort(function() {
        return .5 - Math.random()
    })
}, aO = function(t) {
    if (re(t))
        return t;
    var r = dn(t) ? t : {
        each: t
    }
      , i = Eo(r.ease)
      , n = r.from || 0
      , s = parseFloat(r.base) || 0
      , o = {}
      , a = n > 0 && n < 1
      , l = isNaN(n) || a
      , h = r.axis
      , u = n
      , c = n;
    return Ce(n) ? u = c = {
        center: .5,
        edges: .5,
        end: 1
    }[n] || 0 : !a && l && (u = n[0],
    c = n[1]),
    function(d, f, g) {
        var p = (g || r).length, v = o[p], y, m, _, x, E, S, w, T, C;
        if (!v) {
            if (C = r.grid === "auto" ? 0 : (r.grid || [1, Jr])[1],
            !C) {
                for (w = -Jr; w < (w = g[C++].getBoundingClientRect().left) && C < p; )
                    ;
                C--
            }
            for (v = o[p] = [],
            y = l ? Math.min(C, p) * u - .5 : n % C,
            m = C === Jr ? 0 : l ? p * c / C - .5 : n / C | 0,
            w = 0,
            T = Jr,
            S = 0; S < p; S++)
                _ = S % C - y,
                x = m - (S / C | 0),
                v[S] = E = h ? Math.abs(h === "y" ? x : _) : $M(_ * _ + x * x),
                E > w && (w = E),
                E < T && (T = E);
            n === "random" && oO(v),
            v.max = w - T,
            v.min = T,
            v.v = p = (parseFloat(r.amount) || parseFloat(r.each) * (C > p ? p - 1 : h ? h === "y" ? p / C : C : Math.max(C, p / C)) || 0) * (n === "edges" ? -1 : 1),
            v.b = p < 0 ? s - p : s,
            v.u = $e(r.amount || r.each) || 0,
            i = i && p < 0 ? _O(i) : i
        }
        return p = (v[d] - v.min) / v.max || 0,
        Oe(v.b + (i ? i(p) : p) * v.v) + v.u
    }
}, q_ = function(t) {
    var r = Math.pow(10, ((t + "").split(".")[1] || "").length);
    return function(i) {
        var n = Oe(Math.round(parseFloat(i) / t) * t * r);
        return (n - n % 1) / r + ($n(i) ? 0 : $e(i))
    }
}, lO = function(t, r) {
    var i = Ve(t), n, s;
    return !i && dn(t) && (n = i = t.radius || Jr,
    t.values ? (t = ti(t.values),
    (s = !$n(t[0])) && (n *= n)) : t = q_(t.increment)),
    Hs(r, i ? re(t) ? function(o) {
        return s = t(o),
        Math.abs(s - o) <= n ? s : o
    }
    : function(o) {
        for (var a = parseFloat(s ? o.x : o), l = parseFloat(s ? o.y : 0), h = Jr, u = 0, c = t.length, d, f; c--; )
            s ? (d = t[c].x - a,
            f = t[c].y - l,
            d = d * d + f * f) : d = Math.abs(t[c] - a),
            d < h && (h = d,
            u = c);
        return u = !n || h <= n ? t[u] : o,
        s || u === o || $n(o) ? u : u + $e(o)
    }
    : q_(t))
}, hO = function(t, r, i, n) {
    return Hs(Ve(t) ? !r : i === !0 ? !!(i = 0) : !n, function() {
        return Ve(t) ? t[~~(Math.random() * t.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((t - i / 2 + Math.random() * (r - t + i * .99)) / i) * i * n) / n
    })
}, D7 = function() {
    for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
    return function(n) {
        return r.reduce(function(s, o) {
            return o(s)
        }, n)
    }
}, B7 = function(t, r) {
    return function(i) {
        return t(parseFloat(i)) + (r || $e(i))
    }
}, k7 = function(t, r, i) {
    return cO(t, r, 0, 1, i)
}, uO = function(t, r, i) {
    return Hs(i, function(n) {
        return t[~~r(n)]
    })
}, F7 = function e(t, r, i) {
    var n = r - t;
    return Ve(t) ? uO(t, e(0, t.length), r) : Hs(i, function(s) {
        return (n + (s - t) % n) % n + t
    })
}, U7 = function e(t, r, i) {
    var n = r - t
      , s = n * 2;
    return Ve(t) ? uO(t, e(0, t.length - 1), r) : Hs(i, function(o) {
        return o = (s + (o - t) % s) % s || 0,
        t + (o > n ? s - o : o)
    })
}, _u = function(t) {
    for (var r = 0, i = "", n, s, o, a; ~(n = t.indexOf("random(", r)); )
        o = t.indexOf(")", n),
        a = t.charAt(n + 7) === "[",
        s = t.substr(n + 7, o - n - 7).match(a ? jM : z_),
        i += t.substr(r, n - r) + hO(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5),
        r = o + 1;
    return i + t.substr(r, t.length - r)
}, cO = function(t, r, i, n, s) {
    var o = r - t
      , a = n - i;
    return Hs(s, function(l) {
        return i + ((l - t) / o * a || 0)
    })
}, G7 = function e(t, r, i, n) {
    var s = isNaN(t + r) ? 0 : function(f) {
        return (1 - f) * t + f * r
    }
    ;
    if (!s) {
        var o = Ce(t), a = {}, l, h, u, c, d;
        if (i === !0 && (n = 1) && (i = null),
        o)
            t = {
                p: t
            },
            r = {
                p: r
            };
        else if (Ve(t) && !Ve(r)) {
            for (u = [],
            c = t.length,
            d = c - 2,
            h = 1; h < c; h++)
                u.push(e(t[h - 1], t[h]));
            c--,
            s = function(g) {
                g *= c;
                var p = Math.min(d, ~~g);
                return u[p](g - p)
            }
            ,
            i = r
        } else
            n || (t = No(Ve(t) ? [] : {}, t));
        if (!u) {
            for (l in r)
                Xx.call(a, t, l, "get", r[l]);
            s = function(g) {
                return Zx(g, a) || (o ? t.p : t)
            }
        }
    }
    return Hs(i, s)
}, _w = function(t, r, i) {
    var n = t.labels, s = Jr, o, a, l;
    for (o in n)
        a = n[o] - r,
        a < 0 == !!i && a && s > (a = Math.abs(a)) && (l = o,
        s = a);
    return l
}, ei = function(t, r, i) {
    var n = t.vars, s = n[r], o = ee, a = t._ctx, l, h, u;
    if (s)
        return l = n[r + "Params"],
        h = n.callbackScope || t,
        i && ws.length && Df(),
        a && (ee = a),
        u = l ? s.apply(h, l) : s.call(h),
        ee = o,
        u
}, Jl = function(t) {
    return Ms(t),
    t.scrollTrigger && t.scrollTrigger.kill(!!We),
    t.progress() < 1 && ei(t, "onInterrupt"),
    t
}, Sa, dO = [], fO = function(t) {
    if (Hx() && t) {
        t = !t.name && t.default || t;
        var r = t.name
          , i = re(t)
          , n = r && !i && t.init ? function() {
            this._props = []
        }
        : t
          , s = {
            init: gu,
            render: Zx,
            add: Xx,
            kill: rj,
            modifier: ej,
            rawVars: 0
        }
          , o = {
            targetTest: 0,
            get: 0,
            getSetter: qx,
            aliases: {},
            register: 0
        };
        if (al(),
        t !== n) {
            if (wr[r])
                return;
            hi(n, hi(Bf(t, s), o)),
            No(n.prototype, No(s, Bf(t, o))),
            wr[n.prop = r] = n,
            t.targetTest && (Cd.push(n),
            Wx[r] = 1),
            r = (r === "css" ? "CSS" : r.charAt(0).toUpperCase() + r.substr(1)) + "Plugin"
        }
        KM(r, n),
        t.register && t.register(mr, n, pr)
    } else
        t && dO.push(t)
}, Ct = 255, th = {
    aqua: [0, Ct, Ct],
    lime: [0, Ct, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, Ct],
    navy: [0, 0, 128],
    white: [Ct, Ct, Ct],
    olive: [128, 128, 0],
    yellow: [Ct, Ct, 0],
    orange: [Ct, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [Ct, 0, 0],
    pink: [Ct, 192, 203],
    cyan: [0, Ct, Ct],
    transparent: [Ct, Ct, Ct, 0]
}, vg = function(t, r, i) {
    return t += t < 0 ? 1 : t > 1 ? -1 : 0,
    (t * 6 < 1 ? r + (i - r) * t * 6 : t < .5 ? i : t * 3 < 2 ? r + (i - r) * (2 / 3 - t) * 6 : r) * Ct + .5 | 0
}, pO = function(t, r, i) {
    var n = t ? $n(t) ? [t >> 16, t >> 8 & Ct, t & Ct] : 0 : th.black, s, o, a, l, h, u, c, d, f, g;
    if (!n) {
        if (t.substr(-1) === "," && (t = t.substr(0, t.length - 1)),
        th[t])
            n = th[t];
        else if (t.charAt(0) === "#") {
            if (t.length < 6 && (s = t.charAt(1),
            o = t.charAt(2),
            a = t.charAt(3),
            t = "#" + s + s + o + o + a + a + (t.length === 5 ? t.charAt(4) + t.charAt(4) : "")),
            t.length === 9)
                return n = parseInt(t.substr(1, 6), 16),
                [n >> 16, n >> 8 & Ct, n & Ct, parseInt(t.substr(7), 16) / 255];
            t = parseInt(t.substr(1), 16),
            n = [t >> 16, t >> 8 & Ct, t & Ct]
        } else if (t.substr(0, 3) === "hsl") {
            if (n = g = t.match(z_),
            !r)
                l = +n[0] % 360 / 360,
                h = +n[1] / 100,
                u = +n[2] / 100,
                o = u <= .5 ? u * (h + 1) : u + h - u * h,
                s = u * 2 - o,
                n.length > 3 && (n[3] *= 1),
                n[0] = vg(l + 1 / 3, s, o),
                n[1] = vg(l, s, o),
                n[2] = vg(l - 1 / 3, s, o);
            else if (~t.indexOf("="))
                return n = t.match(WM),
                i && n.length < 4 && (n[3] = 1),
                n
        } else
            n = t.match(z_) || th.transparent;
        n = n.map(Number)
    }
    return r && !g && (s = n[0] / Ct,
    o = n[1] / Ct,
    a = n[2] / Ct,
    c = Math.max(s, o, a),
    d = Math.min(s, o, a),
    u = (c + d) / 2,
    c === d ? l = h = 0 : (f = c - d,
    h = u > .5 ? f / (2 - c - d) : f / (c + d),
    l = c === s ? (o - a) / f + (o < a ? 6 : 0) : c === o ? (a - s) / f + 2 : (s - o) / f + 4,
    l *= 60),
    n[0] = ~~(l + .5),
    n[1] = ~~(h * 100 + .5),
    n[2] = ~~(u * 100 + .5)),
    i && n.length < 4 && (n[3] = 1),
    n
}, mO = function(t) {
    var r = []
      , i = []
      , n = -1;
    return t.split(As).forEach(function(s) {
        var o = s.match(Ta) || [];
        r.push.apply(r, o),
        i.push(n += o.length + 1)
    }),
    r.c = i,
    r
}, yw = function(t, r, i) {
    var n = "", s = (t + n).match(As), o = r ? "hsla(" : "rgba(", a = 0, l, h, u, c;
    if (!s)
        return t;
    if (s = s.map(function(d) {
        return (d = pO(d, r, 1)) && o + (r ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")"
    }),
    i && (u = mO(t),
    l = i.c,
    l.join(n) !== u.c.join(n)))
        for (h = t.replace(As, "1").split(Ta),
        c = h.length - 1; a < c; a++)
            n += h[a] + (~l.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (u.length ? u : s.length ? s : i).shift());
    if (!h)
        for (h = t.split(As),
        c = h.length - 1; a < c; a++)
            n += h[a] + s[a];
    return n + h[c]
}, As = function() {
    var e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", t;
    for (t in th)
        e += "|" + t + "\\b";
    return new RegExp(e + ")","gi")
}(), H7 = /hsl[a]?\(/, gO = function(t) {
    var r = t.join(" "), i;
    if (As.lastIndex = 0,
    As.test(r))
        return i = H7.test(r),
        t[1] = yw(t[1], i),
        t[0] = yw(t[0], i, mO(t[1])),
        !0
}, yu, br = function() {
    var e = Date.now, t = 500, r = 33, i = e(), n = i, s = 1e3 / 240, o = s, a = [], l, h, u, c, d, f, g = function p(v) {
        var y = e() - n, m = v === !0, _, x, E, S;
        if (y > t && (i += y - r),
        n += y,
        E = n - i,
        _ = E - o,
        (_ > 0 || m) && (S = ++c.frame,
        d = E - c.time * 1e3,
        c.time = E = E / 1e3,
        o += _ + (_ >= s ? 4 : s - _),
        x = 1),
        m || (l = h(p)),
        x)
            for (f = 0; f < a.length; f++)
                a[f](E, d, S, v)
    };
    return c = {
        time: 0,
        frame: 0,
        tick: function() {
            g(!0)
        },
        deltaRatio: function(v) {
            return d / (1e3 / (v || 60))
        },
        wake: function() {
            XM && (!W_ && Hx() && (zr = W_ = window,
            $x = zr.document || {},
            Br.gsap = mr,
            (zr.gsapVersions || (zr.gsapVersions = [])).push(mr.version),
            YM(Nf || zr.GreenSockGlobals || !zr.gsap && zr || {}),
            u = zr.requestAnimationFrame,
            dO.forEach(fO)),
            l && c.sleep(),
            h = u || function(v) {
                return setTimeout(v, o - c.time * 1e3 + 1 | 0)
            }
            ,
            yu = 1,
            g(2))
        },
        sleep: function() {
            (u ? zr.cancelAnimationFrame : clearTimeout)(l),
            yu = 0,
            h = gu
        },
        lagSmoothing: function(v, y) {
            t = v || 1 / 0,
            r = Math.min(y || 33, t)
        },
        fps: function(v) {
            s = 1e3 / (v || 240),
            o = c.time * 1e3 + s
        },
        add: function(v, y, m) {
            var _ = y ? function(x, E, S, w) {
                v(x, E, S, w),
                c.remove(_)
            }
            : v;
            return c.remove(v),
            a[m ? "unshift" : "push"](_),
            al(),
            _
        },
        remove: function(v, y) {
            ~(y = a.indexOf(v)) && a.splice(y, 1) && f >= y && f--
        },
        _listeners: a
    },
    c
}(), al = function() {
    return !yu && br.wake()
}, gt = {}, $7 = /^[\d.\-M][\d.\-,\s]/, z7 = /["']/g, W7 = function(t) {
    for (var r = {}, i = t.substr(1, t.length - 3).split(":"), n = i[0], s = 1, o = i.length, a, l, h; s < o; s++)
        l = i[s],
        a = s !== o - 1 ? l.lastIndexOf(",") : l.length,
        h = l.substr(0, a),
        r[n] = isNaN(h) ? h.replace(z7, "").trim() : +h,
        n = l.substr(a + 1).trim();
    return r
}, V7 = function(t) {
    var r = t.indexOf("(") + 1
      , i = t.indexOf(")")
      , n = t.indexOf("(", r);
    return t.substring(r, ~n && n < i ? t.indexOf(")", i + 1) : i)
}, j7 = function(t) {
    var r = (t + "").split("(")
      , i = gt[r[0]];
    return i && r.length > 1 && i.config ? i.config.apply(null, ~t.indexOf("{") ? [W7(r[1])] : V7(t).split(",").map(JM)) : gt._CE && $7.test(t) ? gt._CE("", t) : i
}, _O = function(t) {
    return function(r) {
        return 1 - t(1 - r)
    }
}, yO = function e(t, r) {
    for (var i = t._first, n; i; )
        i instanceof Qe ? e(i, r) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== r && (i.timeline ? e(i.timeline, r) : (n = i._ease,
        i._ease = i._yEase,
        i._yEase = n,
        i._yoyo = r)),
        i = i._next
}, Eo = function(t, r) {
    return t && (re(t) ? t : gt[t] || j7(t)) || r
}, Wo = function(t, r, i, n) {
    i === void 0 && (i = function(l) {
        return 1 - r(1 - l)
    }
    ),
    n === void 0 && (n = function(l) {
        return l < .5 ? r(l * 2) / 2 : 1 - r((1 - l) * 2) / 2
    }
    );
    var s = {
        easeIn: r,
        easeOut: i,
        easeInOut: n
    }, o;
    return fr(t, function(a) {
        gt[a] = Br[a] = s,
        gt[o = a.toLowerCase()] = i;
        for (var l in s)
            gt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = gt[a + "." + l] = s[l]
    }),
    s
}, vO = function(t) {
    return function(r) {
        return r < .5 ? (1 - t(1 - r * 2)) / 2 : .5 + t((r - .5) * 2) / 2
    }
}, xg = function e(t, r, i) {
    var n = r >= 1 ? r : 1
      , s = (i || (t ? .3 : .45)) / (r < 1 ? r : 1)
      , o = s / $_ * (Math.asin(1 / n) || 0)
      , a = function(u) {
        return u === 1 ? 1 : n * Math.pow(2, -10 * u) * x7((u - o) * s) + 1
    }
      , l = t === "out" ? a : t === "in" ? function(h) {
        return 1 - a(1 - h)
    }
    : vO(a);
    return s = $_ / s,
    l.config = function(h, u) {
        return e(t, h, u)
    }
    ,
    l
}, Eg = function e(t, r) {
    r === void 0 && (r = 1.70158);
    var i = function(o) {
        return o ? --o * o * ((r + 1) * o + r) + 1 : 0
    }
      , n = t === "out" ? i : t === "in" ? function(s) {
        return 1 - i(1 - s)
    }
    : vO(i);
    return n.config = function(s) {
        return e(t, s)
    }
    ,
    n
};
fr("Linear,Quad,Cubic,Quart,Quint,Strong", function(e, t) {
    var r = t < 5 ? t + 1 : t;
    Wo(e + ",Power" + (r - 1), t ? function(i) {
        return Math.pow(i, r)
    }
    : function(i) {
        return i
    }
    , function(i) {
        return 1 - Math.pow(1 - i, r)
    }, function(i) {
        return i < .5 ? Math.pow(i * 2, r) / 2 : 1 - Math.pow((1 - i) * 2, r) / 2
    })
});
gt.Linear.easeNone = gt.none = gt.Linear.easeIn;
Wo("Elastic", xg("in"), xg("out"), xg());
(function(e, t) {
    var r = 1 / t
      , i = 2 * r
      , n = 2.5 * r
      , s = function(a) {
        return a < r ? e * a * a : a < i ? e * Math.pow(a - 1.5 / t, 2) + .75 : a < n ? e * (a -= 2.25 / t) * a + .9375 : e * Math.pow(a - 2.625 / t, 2) + .984375
    };
    Wo("Bounce", function(o) {
        return 1 - s(1 - o)
    }, s)
}
)(7.5625, 2.75);
Wo("Expo", function(e) {
    return e ? Math.pow(2, 10 * (e - 1)) : 0
});
Wo("Circ", function(e) {
    return -($M(1 - e * e) - 1)
});
Wo("Sine", function(e) {
    return e === 1 ? 1 : -v7(e * _7) + 1
});
Wo("Back", Eg("in"), Eg("out"), Eg());
gt.SteppedEase = gt.steps = Br.SteppedEase = {
    config: function(t, r) {
        t === void 0 && (t = 1);
        var i = 1 / t
          , n = t + (r ? 0 : 1)
          , s = r ? 1 : 0
          , o = 1 - Pt;
        return function(a) {
            return ((n * Xu(0, o, a) | 0) + s) * i
        }
    }
};
nl.ease = gt["quad.out"];
fr("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(e) {
    return Vx += e + "," + e + "Params,"
});
var xO = function(t, r) {
    this.id = y7++,
    t._gsap = this,
    this.target = t,
    this.harness = r,
    this.get = r ? r.get : ZM,
    this.set = r ? r.getSetter : qx
}
  , vu = function() {
    function e(r) {
        this.vars = r,
        this._delay = +r.delay || 0,
        (this._repeat = r.repeat === 1 / 0 ? -2 : r.repeat || 0) && (this._rDelay = r.repeatDelay || 0,
        this._yoyo = !!r.yoyo || !!r.yoyoEase),
        this._ts = 1,
        ol(this, +r.duration, 1, 1),
        this.data = r.data,
        ee && (this._ctx = ee,
        ee.data.push(this)),
        yu || br.wake()
    }
    var t = e.prototype;
    return t.delay = function(i) {
        return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay),
        this._delay = i,
        this) : this._delay
    }
    ,
    t.duration = function(i) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur
    }
    ,
    t.totalDuration = function(i) {
        return arguments.length ? (this._dirty = 0,
        ol(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    t.totalTime = function(i, n) {
        if (al(),
        !arguments.length)
            return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
            for (zp(this, i),
            !s._dp || s.parent || rO(s, this); s && s.parent; )
                s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0),
                s = s.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && qi(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== i || !this._dur && !n || this._initted && Math.abs(this._zTime) === Pt || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i),
        QM(this, i, n)),
        this
    }
    ,
    t.time = function(i, n) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + mw(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), n) : this._time
    }
    ,
    t.totalProgress = function(i, n) {
        return arguments.length ? this.totalTime(this.totalDuration() * i, n) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
    }
    ,
    t.progress = function(i, n) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + mw(this), n) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
    }
    ,
    t.iteration = function(i, n) {
        var s = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (i - 1) * s, n) : this._repeat ? sl(this._tTime, s) + 1 : 1
    }
    ,
    t.timeScale = function(i) {
        if (!arguments.length)
            return this._rts === -Pt ? 0 : this._rts;
        if (this._rts === i)
            return this;
        var n = this.parent && this._ts ? kf(this.parent._time, this) : this._tTime;
        return this._rts = +i || 0,
        this._ts = this._ps || i === -Pt ? 0 : this._rts,
        this.totalTime(Xu(-Math.abs(this._delay), this._tDur, n), !0),
        $p(this),
        C7(this)
    }
    ,
    t.paused = function(i) {
        return arguments.length ? (this._ps !== i && (this._ps = i,
        i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (al(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Pt && (this._tTime -= Pt)))),
        this) : this._ps
    }
    ,
    t.startTime = function(i) {
        if (arguments.length) {
            this._start = i;
            var n = this.parent || this._dp;
            return n && (n._sort || !this.parent) && qi(n, this, i - this._delay),
            this
        }
        return this._start
    }
    ,
    t.endTime = function(i) {
        return this._start + (dr(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    t.rawTime = function(i) {
        var n = this.parent || this._dp;
        return n ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? kf(n.rawTime(i), this) : this._tTime : this._tTime
    }
    ,
    t.revert = function(i) {
        i === void 0 && (i = S7);
        var n = We;
        return We = i,
        (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i),
        this.totalTime(-.01, i.suppressEvents)),
        this.data !== "nested" && i.kill !== !1 && this.kill(),
        We = n,
        this
    }
    ,
    t.globalTime = function(i) {
        for (var n = this, s = arguments.length ? i : n.rawTime(); n; )
            s = n._start + s / (n._ts || 1),
            n = n._dp;
        return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(i) : s
    }
    ,
    t.repeat = function(i) {
        return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i,
        gw(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    }
    ,
    t.repeatDelay = function(i) {
        if (arguments.length) {
            var n = this._time;
            return this._rDelay = i,
            gw(this),
            n ? this.time(n) : this
        }
        return this._rDelay
    }
    ,
    t.yoyo = function(i) {
        return arguments.length ? (this._yoyo = i,
        this) : this._yoyo
    }
    ,
    t.seek = function(i, n) {
        return this.totalTime($r(this, i), dr(n))
    }
    ,
    t.restart = function(i, n) {
        return this.play().totalTime(i ? -this._delay : 0, dr(n))
    }
    ,
    t.play = function(i, n) {
        return i != null && this.seek(i, n),
        this.reversed(!1).paused(!1)
    }
    ,
    t.reverse = function(i, n) {
        return i != null && this.seek(i || this.totalDuration(), n),
        this.reversed(!0).paused(!1)
    }
    ,
    t.pause = function(i, n) {
        return i != null && this.seek(i, n),
        this.paused(!0)
    }
    ,
    t.resume = function() {
        return this.paused(!1)
    }
    ,
    t.reversed = function(i) {
        return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -Pt : 0)),
        this) : this._rts < 0
    }
    ,
    t.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -Pt,
        this
    }
    ,
    t.isActive = function() {
        var i = this.parent || this._dp, n = this._start, s;
        return !!(!i || this._ts && this._initted && i.isActive() && (s = i.rawTime(!0)) >= n && s < this.endTime(!0) - Pt)
    }
    ,
    t.eventCallback = function(i, n, s) {
        var o = this.vars;
        return arguments.length > 1 ? (n ? (o[i] = n,
        s && (o[i + "Params"] = s),
        i === "onUpdate" && (this._onUpdate = n)) : delete o[i],
        this) : o[i]
    }
    ,
    t.then = function(i) {
        var n = this;
        return new Promise(function(s) {
            var o = re(i) ? i : tO
              , a = function() {
                var h = n.then;
                n.then = null,
                re(o) && (o = o(n)) && (o.then || o === n) && (n.then = h),
                s(o),
                n.then = h
            };
            n._initted && n.totalProgress() === 1 && n._ts >= 0 || !n._tTime && n._ts < 0 ? a() : n._prom = a
        }
        )
    }
    ,
    t.kill = function() {
        Jl(this)
    }
    ,
    e
}();
hi(vu.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -Pt,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var Qe = function(e) {
    HM(t, e);
    function t(i, n) {
        var s;
        return i === void 0 && (i = {}),
        s = e.call(this, i) || this,
        s.labels = {},
        s.smoothChildTiming = !!i.smoothChildTiming,
        s.autoRemoveChildren = !!i.autoRemoveChildren,
        s._sort = dr(i.sortChildren),
        Xt && qi(i.parent || Xt, xn(s), n),
        i.reversed && s.reverse(),
        i.paused && s.paused(!0),
        i.scrollTrigger && iO(xn(s), i.scrollTrigger),
        s
    }
    var r = t.prototype;
    return r.to = function(n, s, o) {
        return Eh(0, arguments, this),
        this
    }
    ,
    r.from = function(n, s, o) {
        return Eh(1, arguments, this),
        this
    }
    ,
    r.fromTo = function(n, s, o, a) {
        return Eh(2, arguments, this),
        this
    }
    ,
    r.set = function(n, s, o) {
        return s.duration = 0,
        s.parent = this,
        xh(s).repeatDelay || (s.repeat = 0),
        s.immediateRender = !!s.immediateRender,
        new ue(n,s,$r(this, o),1),
        this
    }
    ,
    r.call = function(n, s, o) {
        return qi(this, ue.delayedCall(0, n, s), o)
    }
    ,
    r.staggerTo = function(n, s, o, a, l, h, u) {
        return o.duration = s,
        o.stagger = o.stagger || a,
        o.onComplete = h,
        o.onCompleteParams = u,
        o.parent = this,
        new ue(n,o,$r(this, l)),
        this
    }
    ,
    r.staggerFrom = function(n, s, o, a, l, h, u) {
        return o.runBackwards = 1,
        xh(o).immediateRender = dr(o.immediateRender),
        this.staggerTo(n, s, o, a, l, h, u)
    }
    ,
    r.staggerFromTo = function(n, s, o, a, l, h, u, c) {
        return a.startAt = o,
        xh(a).immediateRender = dr(a.immediateRender),
        this.staggerTo(n, s, a, l, h, u, c)
    }
    ,
    r.render = function(n, s, o) {
        var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, h = this._dur, u = n <= 0 ? 0 : Oe(n), c = this._zTime < 0 != n < 0 && (this._initted || !h), d, f, g, p, v, y, m, _, x, E, S, w;
        if (this !== Xt && u > l && n >= 0 && (u = l),
        u !== this._tTime || o || c) {
            if (a !== this._time && h && (u += this._time - a,
            n += this._time - a),
            d = u,
            x = this._start,
            _ = this._ts,
            y = !_,
            c && (h || (a = this._zTime),
            (n || !s) && (this._zTime = n)),
            this._repeat) {
                if (S = this._yoyo,
                v = h + this._rDelay,
                this._repeat < -1 && n < 0)
                    return this.totalTime(v * 100 + n, s, o);
                if (d = Oe(u % v),
                u === l ? (p = this._repeat,
                d = h) : (p = ~~(u / v),
                p && p === u / v && (d = h,
                p--),
                d > h && (d = h)),
                E = sl(this._tTime, v),
                !a && this._tTime && E !== p && this._tTime - E * v - this._dur <= 0 && (E = p),
                S && p & 1 && (d = h - d,
                w = 1),
                p !== E && !this._lock) {
                    var T = S && E & 1
                      , C = T === (S && p & 1);
                    if (p < E && (T = !T),
                    a = T ? 0 : h,
                    this._lock = 1,
                    this.render(a || (w ? 0 : Oe(p * v)), s, !h)._lock = 0,
                    this._tTime = u,
                    !s && this.parent && ei(this, "onRepeat"),
                    this.vars.repeatRefresh && !w && (this.invalidate()._lock = 1),
                    a && a !== this._time || y !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (h = this._dur,
                    l = this._tDur,
                    C && (this._lock = 2,
                    a = T ? h : -1e-4,
                    this.render(a, !0),
                    this.vars.repeatRefresh && !w && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !y)
                        return this;
                    yO(this, w)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (m = M7(this, Oe(a), Oe(d)),
            m && (u -= d - (d = m._start))),
            this._tTime = u,
            this._time = d,
            this._act = !_,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = n,
            a = 0),
            !a && d && !s && !p && (ei(this, "onStart"),
            this._tTime !== u))
                return this;
            if (d >= a && n >= 0)
                for (f = this._first; f; ) {
                    if (g = f._next,
                    (f._act || d >= f._start) && f._ts && m !== f) {
                        if (f.parent !== this)
                            return this.render(n, s, o);
                        if (f.render(f._ts > 0 ? (d - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (d - f._start) * f._ts, s, o),
                        d !== this._time || !this._ts && !y) {
                            m = 0,
                            g && (u += this._zTime = -Pt);
                            break
                        }
                    }
                    f = g
                }
            else {
                f = this._last;
                for (var R = n < 0 ? n : d; f; ) {
                    if (g = f._prev,
                    (f._act || R <= f._end) && f._ts && m !== f) {
                        if (f.parent !== this)
                            return this.render(n, s, o);
                        if (f.render(f._ts > 0 ? (R - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (R - f._start) * f._ts, s, o || We && (f._initted || f._startAt)),
                        d !== this._time || !this._ts && !y) {
                            m = 0,
                            g && (u += this._zTime = R ? -Pt : Pt);
                            break
                        }
                    }
                    f = g
                }
            }
            if (m && !s && (this.pause(),
            m.render(d >= a ? 0 : -Pt)._zTime = d >= a ? 1 : -1,
            this._ts))
                return this._start = x,
                $p(this),
                this.render(n, s, o);
            this._onUpdate && !s && ei(this, "onUpdate", !0),
            (u === l && this._tTime >= this.totalDuration() || !u && a) && (x === this._start || Math.abs(_) !== Math.abs(this._ts)) && (this._lock || ((n || !h) && (u === l && this._ts > 0 || !u && this._ts < 0) && Ms(this, 1),
            !s && !(n < 0 && !a) && (u || a || !l) && (ei(this, u === l && n >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(u < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    r.add = function(n, s) {
        var o = this;
        if ($n(s) || (s = $r(this, s, n)),
        !(n instanceof vu)) {
            if (Ve(n))
                return n.forEach(function(a) {
                    return o.add(a, s)
                }),
                this;
            if (Ce(n))
                return this.addLabel(n, s);
            if (re(n))
                n = ue.delayedCall(0, n);
            else
                return this
        }
        return this !== n ? qi(this, n, s) : this
    }
    ,
    r.getChildren = function(n, s, o, a) {
        n === void 0 && (n = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -Jr);
        for (var l = [], h = this._first; h; )
            h._start >= a && (h instanceof ue ? s && l.push(h) : (o && l.push(h),
            n && l.push.apply(l, h.getChildren(!0, s, o)))),
            h = h._next;
        return l
    }
    ,
    r.getById = function(n) {
        for (var s = this.getChildren(1, 1, 1), o = s.length; o--; )
            if (s[o].vars.id === n)
                return s[o]
    }
    ,
    r.remove = function(n) {
        return Ce(n) ? this.removeLabel(n) : re(n) ? this.killTweensOf(n) : (Hp(this, n),
        n === this._recent && (this._recent = this._last),
        xo(this))
    }
    ,
    r.totalTime = function(n, s) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = Oe(br.time - (this._ts > 0 ? n / this._ts : (this.totalDuration() - n) / -this._ts))),
        e.prototype.totalTime.call(this, n, s),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    r.addLabel = function(n, s) {
        return this.labels[n] = $r(this, s),
        this
    }
    ,
    r.removeLabel = function(n) {
        return delete this.labels[n],
        this
    }
    ,
    r.addPause = function(n, s, o) {
        var a = ue.delayedCall(0, s || gu, o);
        return a.data = "isPause",
        this._hasPause = 1,
        qi(this, a, $r(this, n))
    }
    ,
    r.removePause = function(n) {
        var s = this._first;
        for (n = $r(this, n); s; )
            s._start === n && s.data === "isPause" && Ms(s),
            s = s._next
    }
    ,
    r.killTweensOf = function(n, s, o) {
        for (var a = this.getTweensOf(n, o), l = a.length; l--; )
            us !== a[l] && a[l].kill(n, s);
        return this
    }
    ,
    r.getTweensOf = function(n, s) {
        for (var o = [], a = ti(n), l = this._first, h = $n(s), u; l; )
            l instanceof ue ? w7(l._targets, a) && (h ? (!us || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && o.push(l) : (u = l.getTweensOf(a, s)).length && o.push.apply(o, u),
            l = l._next;
        return o
    }
    ,
    r.tweenTo = function(n, s) {
        s = s || {};
        var o = this, a = $r(o, n), l = s, h = l.startAt, u = l.onStart, c = l.onStartParams, d = l.immediateRender, f, g = ue.to(o, hi({
            ease: s.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: a,
            overwrite: "auto",
            duration: s.duration || Math.abs((a - (h && "time"in h ? h.time : o._time)) / o.timeScale()) || Pt,
            onStart: function() {
                if (o.pause(),
                !f) {
                    var v = s.duration || Math.abs((a - (h && "time"in h ? h.time : o._time)) / o.timeScale());
                    g._dur !== v && ol(g, v, 0, 1).render(g._time, !0, !0),
                    f = 1
                }
                u && u.apply(g, c || [])
            }
        }, s));
        return d ? g.render(0) : g
    }
    ,
    r.tweenFromTo = function(n, s, o) {
        return this.tweenTo(s, hi({
            startAt: {
                time: $r(this, n)
            }
        }, o))
    }
    ,
    r.recent = function() {
        return this._recent
    }
    ,
    r.nextLabel = function(n) {
        return n === void 0 && (n = this._time),
        _w(this, $r(this, n))
    }
    ,
    r.previousLabel = function(n) {
        return n === void 0 && (n = this._time),
        _w(this, $r(this, n), 1)
    }
    ,
    r.currentLabel = function(n) {
        return arguments.length ? this.seek(n, !0) : this.previousLabel(this._time + Pt)
    }
    ,
    r.shiftChildren = function(n, s, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, l = this.labels, h; a; )
            a._start >= o && (a._start += n,
            a._end += n),
            a = a._next;
        if (s)
            for (h in l)
                l[h] >= o && (l[h] += n);
        return xo(this)
    }
    ,
    r.invalidate = function(n) {
        var s = this._first;
        for (this._lock = 0; s; )
            s.invalidate(n),
            s = s._next;
        return e.prototype.invalidate.call(this, n)
    }
    ,
    r.clear = function(n) {
        n === void 0 && (n = !0);
        for (var s = this._first, o; s; )
            o = s._next,
            this.remove(s),
            s = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        n && (this.labels = {}),
        xo(this)
    }
    ,
    r.totalDuration = function(n) {
        var s = 0, o = this, a = o._last, l = Jr, h, u, c;
        if (arguments.length)
            return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -n : n));
        if (o._dirty) {
            for (c = o.parent; a; )
                h = a._prev,
                a._dirty && a.totalDuration(),
                u = a._start,
                u > l && o._sort && a._ts && !o._lock ? (o._lock = 1,
                qi(o, a, u - a._delay, 1)._lock = 0) : l = u,
                u < 0 && a._ts && (s -= u,
                (!c && !o._dp || c && c.smoothChildTiming) && (o._start += u / o._ts,
                o._time -= u,
                o._tTime -= u),
                o.shiftChildren(-u, !1, -1 / 0),
                l = 0),
                a._end > s && a._ts && (s = a._end),
                a = h;
            ol(o, o === Xt && o._time > s ? o._time : s, 1, 1),
            o._dirty = 0
        }
        return o._tDur
    }
    ,
    t.updateRoot = function(n) {
        if (Xt._ts && (QM(Xt, kf(n, Xt)),
        qM = br.frame),
        br.frame >= fw) {
            fw += Lr.autoSleep || 120;
            var s = Xt._first;
            if ((!s || !s._ts) && Lr.autoSleep && br._listeners.length < 2) {
                for (; s && !s._ts; )
                    s = s._next;
                s || br.sleep()
            }
        }
    }
    ,
    t
}(vu);
hi(Qe.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var X7 = function(t, r, i, n, s, o, a) {
    var l = new pr(this._pt,t,r,0,1,bO,null,s), h = 0, u = 0, c, d, f, g, p, v, y, m;
    for (l.b = i,
    l.e = n,
    i += "",
    n += "",
    (y = ~n.indexOf("random(")) && (n = _u(n)),
    o && (m = [i, n],
    o(m, t, r),
    i = m[0],
    n = m[1]),
    d = i.match(_g) || []; c = _g.exec(n); )
        g = c[0],
        p = n.substring(h, c.index),
        f ? f = (f + 1) % 5 : p.substr(-5) === "rgba(" && (f = 1),
        g !== d[u++] && (v = parseFloat(d[u - 1]) || 0,
        l._pt = {
            _next: l._pt,
            p: p || u === 1 ? p : ",",
            s: v,
            c: g.charAt(1) === "=" ? La(v, g) - v : parseFloat(g) - v,
            m: f && f < 4 ? Math.round : 0
        },
        h = _g.lastIndex);
    return l.c = h < n.length ? n.substring(h, n.length) : "",
    l.fp = a,
    (VM.test(n) || y) && (l.e = 0),
    this._pt = l,
    l
}, Xx = function(t, r, i, n, s, o, a, l, h, u) {
    re(n) && (n = n(s || 0, t, o));
    var c = t[r], d = i !== "get" ? i : re(c) ? h ? t[r.indexOf("set") || !re(t["get" + r.substr(3)]) ? r : "get" + r.substr(3)](h) : t[r]() : c, f = re(c) ? h ? Q7 : wO : Kx, g;
    if (Ce(n) && (~n.indexOf("random(") && (n = _u(n)),
    n.charAt(1) === "=" && (g = La(d, n) + ($e(d) || 0),
    (g || g === 0) && (n = g))),
    !u || d !== n || Z_)
        return !isNaN(d * n) && n !== "" ? (g = new pr(this._pt,t,r,+d || 0,n - (d || 0),typeof c == "boolean" ? tj : AO,0,f),
        h && (g.fp = h),
        a && g.modifier(a, this, t),
        this._pt = g) : (!c && !(r in t) && zx(r, n),
        X7.call(this, t, r, d, n, f, l || Lr.stringFilter, h))
}, Y7 = function(t, r, i, n, s) {
    if (re(t) && (t = Th(t, s, r, i, n)),
    !dn(t) || t.style && t.nodeType || Ve(t) || zM(t))
        return Ce(t) ? Th(t, s, r, i, n) : t;
    var o = {}, a;
    for (a in t)
        o[a] = Th(t[a], s, r, i, n);
    return o
}, EO = function(t, r, i, n, s, o) {
    var a, l, h, u;
    if (wr[t] && (a = new wr[t]).init(s, a.rawVars ? r[t] : Y7(r[t], n, s, o, i), i, n, o) !== !1 && (i._pt = l = new pr(i._pt,s,t,0,1,a.render,a,0,a.priority),
    i !== Sa))
        for (h = i._ptLookup[i._targets.indexOf(s)],
        u = a._props.length; u--; )
            h[a._props[u]] = l;
    return a
}, us, Z_, Yx = function e(t, r, i) {
    var n = t.vars, s = n.ease, o = n.startAt, a = n.immediateRender, l = n.lazy, h = n.onUpdate, u = n.onUpdateParams, c = n.callbackScope, d = n.runBackwards, f = n.yoyoEase, g = n.keyframes, p = n.autoRevert, v = t._dur, y = t._startAt, m = t._targets, _ = t.parent, x = _ && _.data === "nested" ? _.vars.targets : m, E = t._overwrite === "auto" && !Ux, S = t.timeline, w, T, C, R, O, N, P, M, V, X, k, L, $;
    if (S && (!g || !s) && (s = "none"),
    t._ease = Eo(s, nl.ease),
    t._yEase = f ? _O(Eo(f === !0 ? s : f, nl.ease)) : 0,
    f && t._yoyo && !t._repeat && (f = t._yEase,
    t._yEase = t._ease,
    t._ease = f),
    t._from = !S && !!n.runBackwards,
    !S || g && !n.stagger) {
        if (M = m[0] ? vo(m[0]).harness : 0,
        L = M && n[M.prop],
        w = Bf(n, Wx),
        y && (y._zTime < 0 && y.progress(1),
        r < 0 && d && a && !p ? y.render(-1, !0) : y.revert(d && v ? bd : T7),
        y._lazy = 0),
        o) {
            if (Ms(t._startAt = ue.set(m, hi({
                data: "isStart",
                overwrite: !1,
                parent: _,
                immediateRender: !0,
                lazy: !y && dr(l),
                startAt: null,
                delay: 0,
                onUpdate: h,
                onUpdateParams: u,
                callbackScope: c,
                stagger: 0
            }, o))),
            t._startAt._dp = 0,
            t._startAt._sat = t,
            r < 0 && (We || !a && !p) && t._startAt.revert(bd),
            a && v && r <= 0 && i <= 0) {
                r && (t._zTime = r);
                return
            }
        } else if (d && v && !y) {
            if (r && (a = !1),
            C = hi({
                overwrite: !1,
                data: "isFromStart",
                lazy: a && !y && dr(l),
                immediateRender: a,
                stagger: 0,
                parent: _
            }, w),
            L && (C[M.prop] = L),
            Ms(t._startAt = ue.set(m, C)),
            t._startAt._dp = 0,
            t._startAt._sat = t,
            r < 0 && (We ? t._startAt.revert(bd) : t._startAt.render(-1, !0)),
            t._zTime = r,
            !a)
                e(t._startAt, Pt, Pt);
            else if (!r)
                return
        }
        for (t._pt = t._ptCache = 0,
        l = v && dr(l) || l && !v,
        T = 0; T < m.length; T++) {
            if (O = m[T],
            P = O._gsap || jx(m)[T]._gsap,
            t._ptLookup[T] = X = {},
            V_[P.id] && ws.length && Df(),
            k = x === m ? T : x.indexOf(O),
            M && (V = new M).init(O, L || w, t, k, x) !== !1 && (t._pt = R = new pr(t._pt,O,V.name,0,1,V.render,V,0,V.priority),
            V._props.forEach(function(I) {
                X[I] = R
            }),
            V.priority && (N = 1)),
            !M || L)
                for (C in w)
                    wr[C] && (V = EO(C, w, t, k, O, x)) ? V.priority && (N = 1) : X[C] = R = Xx.call(t, O, C, "get", w[C], k, x, 0, n.stringFilter);
            t._op && t._op[T] && t.kill(O, t._op[T]),
            E && t._pt && (us = t,
            Xt.killTweensOf(O, X, t.globalTime(r)),
            $ = !t.parent,
            us = 0),
            t._pt && l && (V_[P.id] = 1)
        }
        N && CO(t),
        t._onInit && t._onInit(t)
    }
    t._onUpdate = h,
    t._initted = (!t._op || t._pt) && !$,
    g && r <= 0 && S.render(Jr, !0, !0)
}, K7 = function(t, r, i, n, s, o, a) {
    var l = (t._pt && t._ptCache || (t._ptCache = {}))[r], h, u, c, d;
    if (!l)
        for (l = t._ptCache[r] = [],
        c = t._ptLookup,
        d = t._targets.length; d--; ) {
            if (h = c[d][r],
            h && h.d && h.d._pt)
                for (h = h.d._pt; h && h.p !== r && h.fp !== r; )
                    h = h._next;
            if (!h)
                return Z_ = 1,
                t.vars[r] = "+=0",
                Yx(t, a),
                Z_ = 0,
                1;
            l.push(h)
        }
    for (d = l.length; d--; )
        u = l[d],
        h = u._pt || u,
        h.s = (n || n === 0) && !s ? n : h.s + (n || 0) + o * h.c,
        h.c = i - h.s,
        u.e && (u.e = ne(i) + $e(u.e)),
        u.b && (u.b = h.s + $e(u.b))
}, q7 = function(t, r) {
    var i = t[0] ? vo(t[0]).harness : 0, n = i && i.aliases, s, o, a, l;
    if (!n)
        return r;
    s = No({}, r);
    for (o in n)
        if (o in s)
            for (l = n[o].split(","),
            a = l.length; a--; )
                s[l[a]] = s[o];
    return s
}, Z7 = function(t, r, i, n) {
    var s = r.ease || n || "power1.inOut", o, a;
    if (Ve(r))
        a = i[t] || (i[t] = []),
        r.forEach(function(l, h) {
            return a.push({
                t: h / (r.length - 1) * 100,
                v: l,
                e: s
            })
        });
    else
        for (o in r)
            a = i[o] || (i[o] = []),
            o === "ease" || a.push({
                t: parseFloat(t),
                v: r[o],
                e: s
            })
}, Th = function(t, r, i, n, s) {
    return re(t) ? t.call(r, i, n, s) : Ce(t) && ~t.indexOf("random(") ? _u(t) : t
}, TO = Vx + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", SO = {};
fr(TO + ",id,stagger,delay,duration,paused,scrollTrigger", function(e) {
    return SO[e] = 1
});
var ue = function(e) {
    HM(t, e);
    function t(i, n, s, o) {
        var a;
        typeof n == "number" && (s.duration = n,
        n = s,
        s = null),
        a = e.call(this, o ? n : xh(n)) || this;
        var l = a.vars, h = l.duration, u = l.delay, c = l.immediateRender, d = l.stagger, f = l.overwrite, g = l.keyframes, p = l.defaults, v = l.scrollTrigger, y = l.yoyoEase, m = n.parent || Xt, _ = (Ve(i) || zM(i) ? $n(i[0]) : "length"in n) ? [i] : ti(i), x, E, S, w, T, C, R, O;
        if (a._targets = _.length ? jx(_) : Lf("GSAP target " + i + " not found. https://greensock.com", !Lr.nullTargetWarn) || [],
        a._ptLookup = [],
        a._overwrite = f,
        g || d || Vc(h) || Vc(u)) {
            if (n = a.vars,
            x = a.timeline = new Qe({
                data: "nested",
                defaults: p || {},
                targets: m && m.data === "nested" ? m.vars.targets : _
            }),
            x.kill(),
            x.parent = x._dp = xn(a),
            x._start = 0,
            d || Vc(h) || Vc(u)) {
                if (w = _.length,
                R = d && aO(d),
                dn(d))
                    for (T in d)
                        ~TO.indexOf(T) && (O || (O = {}),
                        O[T] = d[T]);
                for (E = 0; E < w; E++)
                    S = Bf(n, SO),
                    S.stagger = 0,
                    y && (S.yoyoEase = y),
                    O && No(S, O),
                    C = _[E],
                    S.duration = +Th(h, xn(a), E, C, _),
                    S.delay = (+Th(u, xn(a), E, C, _) || 0) - a._delay,
                    !d && w === 1 && S.delay && (a._delay = u = S.delay,
                    a._start += u,
                    S.delay = 0),
                    x.to(C, S, R ? R(E, C, _) : 0),
                    x._ease = gt.none;
                x.duration() ? h = u = 0 : a.timeline = 0
            } else if (g) {
                xh(hi(x.vars.defaults, {
                    ease: "none"
                })),
                x._ease = Eo(g.ease || n.ease || "none");
                var N = 0, P, M, V;
                if (Ve(g))
                    g.forEach(function(X) {
                        return x.to(_, X, ">")
                    }),
                    x.duration();
                else {
                    S = {};
                    for (T in g)
                        T === "ease" || T === "easeEach" || Z7(T, g[T], S, g.easeEach);
                    for (T in S)
                        for (P = S[T].sort(function(X, k) {
                            return X.t - k.t
                        }),
                        N = 0,
                        E = 0; E < P.length; E++)
                            M = P[E],
                            V = {
                                ease: M.e,
                                duration: (M.t - (E ? P[E - 1].t : 0)) / 100 * h
                            },
                            V[T] = M.v,
                            x.to(_, V, N),
                            N += V.duration;
                    x.duration() < h && x.to({}, {
                        duration: h - x.duration()
                    })
                }
            }
            h || a.duration(h = x.duration())
        } else
            a.timeline = 0;
        return f === !0 && !Ux && (us = xn(a),
        Xt.killTweensOf(_),
        us = 0),
        qi(m, xn(a), s),
        n.reversed && a.reverse(),
        n.paused && a.paused(!0),
        (c || !h && !g && a._start === Oe(m._time) && dr(c) && P7(xn(a)) && m.data !== "nested") && (a._tTime = -Pt,
        a.render(Math.max(0, -u) || 0)),
        v && iO(xn(a), v),
        a
    }
    var r = t.prototype;
    return r.render = function(n, s, o) {
        var a = this._time, l = this._tDur, h = this._dur, u = n < 0, c = n > l - Pt && !u ? l : n < Pt ? 0 : n, d, f, g, p, v, y, m, _, x;
        if (!h)
            R7(this, n, s, o);
        else if (c !== this._tTime || !n || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u) {
            if (d = c,
            _ = this.timeline,
            this._repeat) {
                if (p = h + this._rDelay,
                this._repeat < -1 && u)
                    return this.totalTime(p * 100 + n, s, o);
                if (d = Oe(c % p),
                c === l ? (g = this._repeat,
                d = h) : (g = ~~(c / p),
                g && g === c / p && (d = h,
                g--),
                d > h && (d = h)),
                y = this._yoyo && g & 1,
                y && (x = this._yEase,
                d = h - d),
                v = sl(this._tTime, p),
                d === a && !o && this._initted)
                    return this._tTime = c,
                    this;
                g !== v && (_ && this._yEase && yO(_, y),
                this.vars.repeatRefresh && !y && !this._lock && (this._lock = o = 1,
                this.render(Oe(p * g), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (nO(this, u ? n : d, o, s, c))
                    return this._tTime = 0,
                    this;
                if (a !== this._time)
                    return this;
                if (h !== this._dur)
                    return this.render(n, s, o)
            }
            if (this._tTime = c,
            this._time = d,
            !this._act && this._ts && (this._act = 1,
            this._lazy = 0),
            this.ratio = m = (x || this._ease)(d / h),
            this._from && (this.ratio = m = 1 - m),
            d && !a && !s && !g && (ei(this, "onStart"),
            this._tTime !== c))
                return this;
            for (f = this._pt; f; )
                f.r(m, f.d),
                f = f._next;
            _ && _.render(n < 0 ? n : !d && y ? -Pt : _._dur * _._ease(d / this._dur), s, o) || this._startAt && (this._zTime = n),
            this._onUpdate && !s && (u && j_(this, n, s, o),
            ei(this, "onUpdate")),
            this._repeat && g !== v && this.vars.onRepeat && !s && this.parent && ei(this, "onRepeat"),
            (c === this._tDur || !c) && this._tTime === c && (u && !this._onUpdate && j_(this, n, !0, !0),
            (n || !h) && (c === this._tDur && this._ts > 0 || !c && this._ts < 0) && Ms(this, 1),
            !s && !(u && !a) && (c || a || y) && (ei(this, c === l ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(c < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    }
    ,
    r.targets = function() {
        return this._targets
    }
    ,
    r.invalidate = function(n) {
        return (!n || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(n),
        e.prototype.invalidate.call(this, n)
    }
    ,
    r.resetTo = function(n, s, o, a) {
        yu || br.wake(),
        this._ts || this.play();
        var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts), h;
        return this._initted || Yx(this, l),
        h = this._ease(l / this._dur),
        K7(this, n, s, o, a, h, l) ? this.resetTo(n, s, o, a) : (zp(this, 0),
        this.parent || eO(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    r.kill = function(n, s) {
        if (s === void 0 && (s = "all"),
        !n && (!s || s === "all"))
            return this._lazy = this._pt = 0,
            this.parent ? Jl(this) : this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(n, s, us && us.vars.overwrite !== !0)._first || Jl(this),
            this.parent && o !== this.timeline.totalDuration() && ol(this, this._dur * this.timeline._tDur / o, 0, 1),
            this
        }
        var a = this._targets, l = n ? ti(n) : a, h = this._ptLookup, u = this._pt, c, d, f, g, p, v, y;
        if ((!s || s === "all") && b7(a, l))
            return s === "all" && (this._pt = 0),
            Jl(this);
        for (c = this._op = this._op || [],
        s !== "all" && (Ce(s) && (p = {},
        fr(s, function(m) {
            return p[m] = 1
        }),
        s = p),
        s = q7(a, s)),
        y = a.length; y--; )
            if (~l.indexOf(a[y])) {
                d = h[y],
                s === "all" ? (c[y] = s,
                g = d,
                f = {}) : (f = c[y] = c[y] || {},
                g = s);
                for (p in g)
                    v = d && d[p],
                    v && ((!("kill"in v.d) || v.d.kill(p) === !0) && Hp(this, v, "_pt"),
                    delete d[p]),
                    f !== "all" && (f[p] = 1)
            }
        return this._initted && !this._pt && u && Jl(this),
        this
    }
    ,
    t.to = function(n, s) {
        return new t(n,s,arguments[2])
    }
    ,
    t.from = function(n, s) {
        return Eh(1, arguments)
    }
    ,
    t.delayedCall = function(n, s, o, a) {
        return new t(s,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: n,
            onComplete: s,
            onReverseComplete: s,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }
    ,
    t.fromTo = function(n, s, o) {
        return Eh(2, arguments)
    }
    ,
    t.set = function(n, s) {
        return s.duration = 0,
        s.repeatDelay || (s.repeat = 0),
        new t(n,s)
    }
    ,
    t.killTweensOf = function(n, s, o) {
        return Xt.killTweensOf(n, s, o)
    }
    ,
    t
}(vu);
hi(ue.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
fr("staggerTo,staggerFrom,staggerFromTo", function(e) {
    ue[e] = function() {
        var t = new Qe
          , r = Y_.call(arguments, 0);
        return r.splice(e === "staggerFromTo" ? 5 : 4, 0, 0),
        t[e].apply(t, r)
    }
});
var Kx = function(t, r, i) {
    return t[r] = i
}
  , wO = function(t, r, i) {
    return t[r](i)
}
  , Q7 = function(t, r, i, n) {
    return t[r](n.fp, i)
}
  , J7 = function(t, r, i) {
    return t.setAttribute(r, i)
}
  , qx = function(t, r) {
    return re(t[r]) ? wO : Gx(t[r]) && t.setAttribute ? J7 : Kx
}
  , AO = function(t, r) {
    return r.set(r.t, r.p, Math.round((r.s + r.c * t) * 1e6) / 1e6, r)
}
  , tj = function(t, r) {
    return r.set(r.t, r.p, !!(r.s + r.c * t), r)
}
  , bO = function(t, r) {
    var i = r._pt
      , n = "";
    if (!t && r.b)
        n = r.b;
    else if (t === 1 && r.e)
        n = r.e;
    else {
        for (; i; )
            n = i.p + (i.m ? i.m(i.s + i.c * t) : Math.round((i.s + i.c * t) * 1e4) / 1e4) + n,
            i = i._next;
        n += r.c
    }
    r.set(r.t, r.p, n, r)
}
  , Zx = function(t, r) {
    for (var i = r._pt; i; )
        i.r(t, i.d),
        i = i._next
}
  , ej = function(t, r, i, n) {
    for (var s = this._pt, o; s; )
        o = s._next,
        s.p === n && s.modifier(t, r, i),
        s = o
}
  , rj = function(t) {
    for (var r = this._pt, i, n; r; )
        n = r._next,
        r.p === t && !r.op || r.op === t ? Hp(this, r, "_pt") : r.dep || (i = 1),
        r = n;
    return !i
}
  , ij = function(t, r, i, n) {
    n.mSet(t, r, n.m.call(n.tween, i, n.mt), n)
}
  , CO = function(t) {
    for (var r = t._pt, i, n, s, o; r; ) {
        for (i = r._next,
        n = s; n && n.pr > r.pr; )
            n = n._next;
        (r._prev = n ? n._prev : o) ? r._prev._next = r : s = r,
        (r._next = n) ? n._prev = r : o = r,
        r = i
    }
    t._pt = s
}
  , pr = function() {
    function e(r, i, n, s, o, a, l, h, u) {
        this.t = i,
        this.s = s,
        this.c = o,
        this.p = n,
        this.r = a || AO,
        this.d = l || this,
        this.set = h || Kx,
        this.pr = u || 0,
        this._next = r,
        r && (r._prev = this)
    }
    var t = e.prototype;
    return t.modifier = function(i, n, s) {
        this.mSet = this.mSet || this.set,
        this.set = ij,
        this.m = i,
        this.mt = s,
        this.tween = n
    }
    ,
    e
}();
fr(Vx + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(e) {
    return Wx[e] = 1
});
Br.TweenMax = Br.TweenLite = ue;
Br.TimelineLite = Br.TimelineMax = Qe;
Xt = new Qe({
    sortChildren: !1,
    defaults: nl,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
Lr.stringFilter = gO;
var To = []
  , Pd = {}
  , nj = []
  , vw = 0
  , sj = 0
  , Tg = function(t) {
    return (Pd[t] || nj).map(function(r) {
        return r()
    })
}
  , Q_ = function() {
    var t = Date.now()
      , r = [];
    t - vw > 2 && (Tg("matchMediaInit"),
    To.forEach(function(i) {
        var n = i.queries, s = i.conditions, o, a, l, h;
        for (a in n)
            o = zr.matchMedia(n[a]).matches,
            o && (l = 1),
            o !== s[a] && (s[a] = o,
            h = 1);
        h && (i.revert(),
        l && r.push(i))
    }),
    Tg("matchMediaRevert"),
    r.forEach(function(i) {
        return i.onMatch(i)
    }),
    vw = t,
    Tg("matchMedia"))
}
  , PO = function() {
    function e(r, i) {
        this.selector = i && K_(i),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        this.id = sj++,
        r && this.add(r)
    }
    var t = e.prototype;
    return t.add = function(i, n, s) {
        re(i) && (s = n,
        n = i,
        i = re);
        var o = this
          , a = function() {
            var h = ee, u = o.selector, c;
            return h && h !== o && h.data.push(o),
            s && (o.selector = K_(s)),
            ee = o,
            c = n.apply(o, arguments),
            re(c) && o._r.push(c),
            ee = h,
            o.selector = u,
            o.isReverted = !1,
            c
        };
        return o.last = a,
        i === re ? a(o) : i ? o[i] = a : a
    }
    ,
    t.ignore = function(i) {
        var n = ee;
        ee = null,
        i(this),
        ee = n
    }
    ,
    t.getTweens = function() {
        var i = [];
        return this.data.forEach(function(n) {
            return n instanceof e ? i.push.apply(i, n.getTweens()) : n instanceof ue && !(n.parent && n.parent.data === "nested") && i.push(n)
        }),
        i
    }
    ,
    t.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    t.kill = function(i, n) {
        var s = this;
        if (i) {
            var o = this.getTweens();
            this.data.forEach(function(l) {
                l.data === "isFlip" && (l.revert(),
                l.getChildren(!0, !0, !1).forEach(function(h) {
                    return o.splice(o.indexOf(h), 1)
                }))
            }),
            o.map(function(l) {
                return {
                    g: l.globalTime(0),
                    t: l
                }
            }).sort(function(l, h) {
                return h.g - l.g || -1
            }).forEach(function(l) {
                return l.t.revert(i)
            }),
            this.data.forEach(function(l) {
                return l instanceof Qe ? l.data !== "nested" && l.kill() : !(l instanceof ue) && l.revert && l.revert(i)
            }),
            this._r.forEach(function(l) {
                return l(i, s)
            }),
            this.isReverted = !0
        } else
            this.data.forEach(function(l) {
                return l.kill && l.kill()
            });
        if (this.clear(),
        n)
            for (var a = To.length; a--; )
                To[a].id === this.id && To.splice(a, 1)
    }
    ,
    t.revert = function(i) {
        this.kill(i || {})
    }
    ,
    e
}()
  , oj = function() {
    function e(r) {
        this.contexts = [],
        this.scope = r
    }
    var t = e.prototype;
    return t.add = function(i, n, s) {
        dn(i) || (i = {
            matches: i
        });
        var o = new PO(0,s || this.scope), a = o.conditions = {}, l, h, u;
        ee && !o.selector && (o.selector = ee.selector),
        this.contexts.push(o),
        n = o.add("onMatch", n),
        o.queries = i;
        for (h in i)
            h === "all" ? u = 1 : (l = zr.matchMedia(i[h]),
            l && (To.indexOf(o) < 0 && To.push(o),
            (a[h] = l.matches) && (u = 1),
            l.addListener ? l.addListener(Q_) : l.addEventListener("change", Q_)));
        return u && n(o),
        this
    }
    ,
    t.revert = function(i) {
        this.kill(i || {})
    }
    ,
    t.kill = function(i) {
        this.contexts.forEach(function(n) {
            return n.kill(i, !0)
        })
    }
    ,
    e
}()
  , Ff = {
    registerPlugin: function() {
        for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
            r[i] = arguments[i];
        r.forEach(function(n) {
            return fO(n)
        })
    },
    timeline: function(t) {
        return new Qe(t)
    },
    getTweensOf: function(t, r) {
        return Xt.getTweensOf(t, r)
    },
    getProperty: function(t, r, i, n) {
        Ce(t) && (t = ti(t)[0]);
        var s = vo(t || {}).get
          , o = i ? tO : JM;
        return i === "native" && (i = ""),
        t && (r ? o((wr[r] && wr[r].get || s)(t, r, i, n)) : function(a, l, h) {
            return o((wr[a] && wr[a].get || s)(t, a, l, h))
        }
        )
    },
    quickSetter: function(t, r, i) {
        if (t = ti(t),
        t.length > 1) {
            var n = t.map(function(u) {
                return mr.quickSetter(u, r, i)
            })
              , s = n.length;
            return function(u) {
                for (var c = s; c--; )
                    n[c](u)
            }
        }
        t = t[0] || {};
        var o = wr[r]
          , a = vo(t)
          , l = a.harness && (a.harness.aliases || {})[r] || r
          , h = o ? function(u) {
            var c = new o;
            Sa._pt = 0,
            c.init(t, i ? u + i : u, Sa, 0, [t]),
            c.render(1, c),
            Sa._pt && Zx(1, Sa)
        }
        : a.set(t, l);
        return o ? h : function(u) {
            return h(t, l, i ? u + i : u, a, 1)
        }
    },
    quickTo: function(t, r, i) {
        var n, s = mr.to(t, No((n = {},
        n[r] = "+=0.1",
        n.paused = !0,
        n), i || {})), o = function(l, h, u) {
            return s.resetTo(r, l, h, u)
        };
        return o.tween = s,
        o
    },
    isTweening: function(t) {
        return Xt.getTweensOf(t, !0).length > 0
    },
    defaults: function(t) {
        return t && t.ease && (t.ease = Eo(t.ease, nl.ease)),
        pw(nl, t || {})
    },
    config: function(t) {
        return pw(Lr, t || {})
    },
    registerEffect: function(t) {
        var r = t.name
          , i = t.effect
          , n = t.plugins
          , s = t.defaults
          , o = t.extendTimeline;
        (n || "").split(",").forEach(function(a) {
            return a && !wr[a] && !Br[a] && Lf(r + " effect requires " + a + " plugin.")
        }),
        yg[r] = function(a, l, h) {
            return i(ti(a), hi(l || {}, s), h)
        }
        ,
        o && (Qe.prototype[r] = function(a, l, h) {
            return this.add(yg[r](a, dn(l) ? l : (h = l) && {}, this), h)
        }
        )
    },
    registerEase: function(t, r) {
        gt[t] = Eo(r)
    },
    parseEase: function(t, r) {
        return arguments.length ? Eo(t, r) : gt
    },
    getById: function(t) {
        return Xt.getById(t)
    },
    exportRoot: function(t, r) {
        t === void 0 && (t = {});
        var i = new Qe(t), n, s;
        for (i.smoothChildTiming = dr(t.smoothChildTiming),
        Xt.remove(i),
        i._dp = 0,
        i._time = i._tTime = Xt._time,
        n = Xt._first; n; )
            s = n._next,
            (r || !(!n._dur && n instanceof ue && n.vars.onComplete === n._targets[0])) && qi(i, n, n._start - n._delay),
            n = s;
        return qi(Xt, i, 0),
        i
    },
    context: function(t, r) {
        return t ? new PO(t,r) : ee
    },
    matchMedia: function(t) {
        return new oj(t)
    },
    matchMediaRefresh: function() {
        return To.forEach(function(t) {
            var r = t.conditions, i, n;
            for (n in r)
                r[n] && (r[n] = !1,
                i = 1);
            i && t.revert()
        }) || Q_()
    },
    addEventListener: function(t, r) {
        var i = Pd[t] || (Pd[t] = []);
        ~i.indexOf(r) || i.push(r)
    },
    removeEventListener: function(t, r) {
        var i = Pd[t]
          , n = i && i.indexOf(r);
        n >= 0 && i.splice(n, 1)
    },
    utils: {
        wrap: F7,
        wrapYoyo: U7,
        distribute: aO,
        random: hO,
        snap: lO,
        normalize: k7,
        getUnit: $e,
        clamp: N7,
        splitColor: pO,
        toArray: ti,
        selector: K_,
        mapRange: cO,
        pipe: D7,
        unitize: B7,
        interpolate: G7,
        shuffle: oO
    },
    install: YM,
    effects: yg,
    ticker: br,
    updateRoot: Qe.updateRoot,
    plugins: wr,
    globalTimeline: Xt,
    core: {
        PropTween: pr,
        globals: KM,
        Tween: ue,
        Timeline: Qe,
        Animation: vu,
        getCache: vo,
        _removeLinkedListItem: Hp,
        reverting: function() {
            return We
        },
        context: function(t) {
            return t && ee && (ee.data.push(t),
            t._ctx = ee),
            ee
        },
        suppressOverwrites: function(t) {
            return Ux = t
        }
    }
};
fr("to,from,fromTo,delayedCall,set,killTweensOf", function(e) {
    return Ff[e] = ue[e]
});
br.add(Qe.updateRoot);
Sa = Ff.to({}, {
    duration: 0
});
var aj = function(t, r) {
    for (var i = t._pt; i && i.p !== r && i.op !== r && i.fp !== r; )
        i = i._next;
    return i
}
  , lj = function(t, r) {
    var i = t._targets, n, s, o;
    for (n in r)
        for (s = i.length; s--; )
            o = t._ptLookup[s][n],
            o && (o = o.d) && (o._pt && (o = aj(o, n)),
            o && o.modifier && o.modifier(r[n], t, i[s], n))
}
  , Sg = function(t, r) {
    return {
        name: t,
        rawVars: 1,
        init: function(n, s, o) {
            o._onInit = function(a) {
                var l, h;
                if (Ce(s) && (l = {},
                fr(s, function(u) {
                    return l[u] = 1
                }),
                s = l),
                r) {
                    l = {};
                    for (h in s)
                        l[h] = r(s[h]);
                    s = l
                }
                lj(a, s)
            }
        }
    }
}
  , mr = Ff.registerPlugin({
    name: "attr",
    init: function(t, r, i, n, s) {
        var o, a, l;
        this.tween = i;
        for (o in r)
            l = t.getAttribute(o) || "",
            a = this.add(t, "setAttribute", (l || 0) + "", r[o], n, s, 0, 0, o),
            a.op = o,
            a.b = l,
            this._props.push(o)
    },
    render: function(t, r) {
        for (var i = r._pt; i; )
            We ? i.set(i.t, i.p, i.b, i) : i.r(t, i.d),
            i = i._next
    }
}, {
    name: "endArray",
    init: function(t, r) {
        for (var i = r.length; i--; )
            this.add(t, i, t[i] || 0, r[i], 0, 0, 0, 0, 0, 1)
    }
}, Sg("roundProps", q_), Sg("modifiers"), Sg("snap", lO)) || Ff;
ue.version = Qe.version = mr.version = "3.12.1";
XM = 1;
Hx() && al();
gt.Power0;
var xw = gt.Power1
  , Ew = gt.Power2
  , Tw = gt.Power3
  , wg = gt.Power4;
gt.Linear;
gt.Quad;
gt.Cubic;
gt.Quart;
gt.Quint;
gt.Strong;
gt.Elastic;
gt.Back;
gt.SteppedEase;
gt.Bounce;
gt.Sine;
gt.Expo;
gt.Circ;
/*!
 * CSSPlugin 3.12.1
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Sw, cs, Da, Qx, lo, ww, Jx, hj = function() {
    return typeof window < "u"
}, zn = {}, ro = 180 / Math.PI, Ba = Math.PI / 180, Qo = Math.atan2, Aw = 1e8, t1 = /([A-Z])/g, uj = /(left|right|width|margin|padding|x)/i, cj = /[\s,\(]\S/, en = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, J_ = function(t, r) {
    return r.set(r.t, r.p, Math.round((r.s + r.c * t) * 1e4) / 1e4 + r.u, r)
}, dj = function(t, r) {
    return r.set(r.t, r.p, t === 1 ? r.e : Math.round((r.s + r.c * t) * 1e4) / 1e4 + r.u, r)
}, fj = function(t, r) {
    return r.set(r.t, r.p, t ? Math.round((r.s + r.c * t) * 1e4) / 1e4 + r.u : r.b, r)
}, pj = function(t, r) {
    var i = r.s + r.c * t;
    r.set(r.t, r.p, ~~(i + (i < 0 ? -.5 : .5)) + r.u, r)
}, IO = function(t, r) {
    return r.set(r.t, r.p, t ? r.e : r.b, r)
}, RO = function(t, r) {
    return r.set(r.t, r.p, t !== 1 ? r.b : r.e, r)
}, mj = function(t, r, i) {
    return t.style[r] = i
}, gj = function(t, r, i) {
    return t.style.setProperty(r, i)
}, _j = function(t, r, i) {
    return t._gsap[r] = i
}, yj = function(t, r, i) {
    return t._gsap.scaleX = t._gsap.scaleY = i
}, vj = function(t, r, i, n, s) {
    var o = t._gsap;
    o.scaleX = o.scaleY = i,
    o.renderTransform(s, o)
}, xj = function(t, r, i, n, s) {
    var o = t._gsap;
    o[r] = i,
    o.renderTransform(s, o)
}, Kt = "transform", Mi = Kt + "Origin", Ej = function e(t, r) {
    var i = this
      , n = this.target
      , s = n.style;
    if (t in zn && s) {
        if (this.tfm = this.tfm || {},
        t !== "transform")
            t = en[t] || t,
            ~t.indexOf(",") ? t.split(",").forEach(function(o) {
                return i.tfm[o] = wn(n, o)
            }) : this.tfm[t] = n._gsap.x ? n._gsap[t] : wn(n, t);
        else
            return en.transform.split(",").forEach(function(o) {
                return e.call(i, o, r)
            });
        if (this.props.indexOf(Kt) >= 0)
            return;
        n._gsap.svg && (this.svgo = n.getAttribute("data-svg-origin"),
        this.props.push(Mi, r, "")),
        t = Kt
    }
    (s || r) && this.props.push(t, r, s[t])
}, MO = function(t) {
    t.translate && (t.removeProperty("translate"),
    t.removeProperty("scale"),
    t.removeProperty("rotate"))
}, Tj = function() {
    var t = this.props, r = this.target, i = r.style, n = r._gsap, s, o;
    for (s = 0; s < t.length; s += 3)
        t[s + 1] ? r[t[s]] = t[s + 2] : t[s + 2] ? i[t[s]] = t[s + 2] : i.removeProperty(t[s].substr(0, 2) === "--" ? t[s] : t[s].replace(t1, "-$1").toLowerCase());
    if (this.tfm) {
        for (o in this.tfm)
            n[o] = this.tfm[o];
        n.svg && (n.renderTransform(),
        r.setAttribute("data-svg-origin", this.svgo || "")),
        s = Jx(),
        (!s || !s.isStart) && !i[Kt] && (MO(i),
        n.uncache = 1)
    }
}, OO = function(t, r) {
    var i = {
        target: t,
        props: [],
        revert: Tj,
        save: Ej
    };
    return t._gsap || mr.core.getCache(t),
    r && r.split(",").forEach(function(n) {
        return i.save(n)
    }),
    i
}, NO, ty = function(t, r) {
    var i = cs.createElementNS ? cs.createElementNS((r || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : cs.createElement(t);
    return i.style ? i : cs.createElement(t)
}, ln = function e(t, r, i) {
    var n = getComputedStyle(t);
    return n[r] || n.getPropertyValue(r.replace(t1, "-$1").toLowerCase()) || n.getPropertyValue(r) || !i && e(t, ll(r) || r, 1) || ""
}, bw = "O,Moz,ms,Ms,Webkit".split(","), ll = function(t, r, i) {
    var n = r || lo
      , s = n.style
      , o = 5;
    if (t in s && !i)
        return t;
    for (t = t.charAt(0).toUpperCase() + t.substr(1); o-- && !(bw[o] + t in s); )
        ;
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? bw[o] : "") + t
}, ey = function() {
    hj() && window.document && (Sw = window,
    cs = Sw.document,
    Da = cs.documentElement,
    lo = ty("div") || {
        style: {}
    },
    ty("div"),
    Kt = ll(Kt),
    Mi = Kt + "Origin",
    lo.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    NO = !!ll("perspective"),
    Jx = mr.core.reverting,
    Qx = 1)
}, Ag = function e(t) {
    var r = ty("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, n = this.nextSibling, s = this.style.cssText, o;
    if (Da.appendChild(r),
    r.appendChild(this),
    this.style.display = "block",
    t)
        try {
            o = this.getBBox(),
            this._gsapBBox = this.getBBox,
            this.getBBox = e
        } catch {}
    else
        this._gsapBBox && (o = this._gsapBBox());
    return i && (n ? i.insertBefore(this, n) : i.appendChild(this)),
    Da.removeChild(r),
    this.style.cssText = s,
    o
}, Cw = function(t, r) {
    for (var i = r.length; i--; )
        if (t.hasAttribute(r[i]))
            return t.getAttribute(r[i])
}, LO = function(t) {
    var r;
    try {
        r = t.getBBox()
    } catch {
        r = Ag.call(t, !0)
    }
    return r && (r.width || r.height) || t.getBBox === Ag || (r = Ag.call(t, !0)),
    r && !r.width && !r.x && !r.y ? {
        x: +Cw(t, ["x", "cx", "x1"]) || 0,
        y: +Cw(t, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    } : r
}, DO = function(t) {
    return !!(t.getCTM && (!t.parentNode || t.ownerSVGElement) && LO(t))
}, xu = function(t, r) {
    if (r) {
        var i = t.style;
        r in zn && r !== Mi && (r = Kt),
        i.removeProperty ? ((r.substr(0, 2) === "ms" || r.substr(0, 6) === "webkit") && (r = "-" + r),
        i.removeProperty(r.replace(t1, "-$1").toLowerCase())) : i.removeAttribute(r)
    }
}, ds = function(t, r, i, n, s, o) {
    var a = new pr(t._pt,r,i,0,1,o ? RO : IO);
    return t._pt = a,
    a.b = n,
    a.e = s,
    t._props.push(i),
    a
}, Pw = {
    deg: 1,
    rad: 1,
    turn: 1
}, Sj = {
    grid: 1,
    flex: 1
}, Os = function e(t, r, i, n) {
    var s = parseFloat(i) || 0, o = (i + "").trim().substr((s + "").length) || "px", a = lo.style, l = uj.test(r), h = t.tagName.toLowerCase() === "svg", u = (h ? "client" : "offset") + (l ? "Width" : "Height"), c = 100, d = n === "px", f = n === "%", g, p, v, y;
    return n === o || !s || Pw[n] || Pw[o] ? s : (o !== "px" && !d && (s = e(t, r, i, "px")),
    y = t.getCTM && DO(t),
    (f || o === "%") && (zn[r] || ~r.indexOf("adius")) ? (g = y ? t.getBBox()[l ? "width" : "height"] : t[u],
    ne(f ? s / g * c : s / 100 * g)) : (a[l ? "width" : "height"] = c + (d ? o : n),
    p = ~r.indexOf("adius") || n === "em" && t.appendChild && !h ? t : t.parentNode,
    y && (p = (t.ownerSVGElement || {}).parentNode),
    (!p || p === cs || !p.appendChild) && (p = cs.body),
    v = p._gsap,
    v && f && v.width && l && v.time === br.time && !v.uncache ? ne(s / v.width * c) : ((f || o === "%") && !Sj[ln(p, "display")] && (a.position = ln(t, "position")),
    p === t && (a.position = "static"),
    p.appendChild(lo),
    g = lo[u],
    p.removeChild(lo),
    a.position = "absolute",
    l && f && (v = vo(p),
    v.time = br.time,
    v.width = p[u]),
    ne(d ? g * s / c : g && s ? c / g * s : 0))))
}, wn = function(t, r, i, n) {
    var s;
    return Qx || ey(),
    r in en && r !== "transform" && (r = en[r],
    ~r.indexOf(",") && (r = r.split(",")[0])),
    zn[r] && r !== "transform" ? (s = Tu(t, n),
    s = r !== "transformOrigin" ? s[r] : s.svg ? s.origin : Gf(ln(t, Mi)) + " " + s.zOrigin + "px") : (s = t.style[r],
    (!s || s === "auto" || n || ~(s + "").indexOf("calc(")) && (s = Uf[r] && Uf[r](t, r, i) || ln(t, r) || ZM(t, r) || (r === "opacity" ? 1 : 0))),
    i && !~(s + "").trim().indexOf(" ") ? Os(t, r, s, i) + i : s
}, wj = function(t, r, i, n) {
    if (!i || i === "none") {
        var s = ll(r, t, 1)
          , o = s && ln(t, s, 1);
        o && o !== i ? (r = s,
        i = o) : r === "borderColor" && (i = ln(t, "borderTopColor"))
    }
    var a = new pr(this._pt,t.style,r,0,1,bO), l = 0, h = 0, u, c, d, f, g, p, v, y, m, _, x, E;
    if (a.b = i,
    a.e = n,
    i += "",
    n += "",
    n === "auto" && (t.style[r] = n,
    n = ln(t, r) || n,
    t.style[r] = i),
    u = [i, n],
    gO(u),
    i = u[0],
    n = u[1],
    d = i.match(Ta) || [],
    E = n.match(Ta) || [],
    E.length) {
        for (; c = Ta.exec(n); )
            v = c[0],
            m = n.substring(l, c.index),
            g ? g = (g + 1) % 5 : (m.substr(-5) === "rgba(" || m.substr(-5) === "hsla(") && (g = 1),
            v !== (p = d[h++] || "") && (f = parseFloat(p) || 0,
            x = p.substr((f + "").length),
            v.charAt(1) === "=" && (v = La(f, v) + x),
            y = parseFloat(v),
            _ = v.substr((y + "").length),
            l = Ta.lastIndex - _.length,
            _ || (_ = _ || Lr.units[r] || x,
            l === n.length && (n += _,
            a.e += _)),
            x !== _ && (f = Os(t, r, p, _) || 0),
            a._pt = {
                _next: a._pt,
                p: m || h === 1 ? m : ",",
                s: f,
                c: y - f,
                m: g && g < 4 || r === "zIndex" ? Math.round : 0
            });
        a.c = l < n.length ? n.substring(l, n.length) : ""
    } else
        a.r = r === "display" && n === "none" ? RO : IO;
    return VM.test(n) && (a.e = 0),
    this._pt = a,
    a
}, Iw = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, Aj = function(t) {
    var r = t.split(" ")
      , i = r[0]
      , n = r[1] || "50%";
    return (i === "top" || i === "bottom" || n === "left" || n === "right") && (t = i,
    i = n,
    n = t),
    r[0] = Iw[i] || i,
    r[1] = Iw[n] || n,
    r.join(" ")
}, bj = function(t, r) {
    if (r.tween && r.tween._time === r.tween._dur) {
        var i = r.t, n = i.style, s = r.u, o = i._gsap, a, l, h;
        if (s === "all" || s === !0)
            n.cssText = "",
            l = 1;
        else
            for (s = s.split(","),
            h = s.length; --h > -1; )
                a = s[h],
                zn[a] && (l = 1,
                a = a === "transformOrigin" ? Mi : Kt),
                xu(i, a);
        l && (xu(i, Kt),
        o && (o.svg && i.removeAttribute("transform"),
        Tu(i, 1),
        o.uncache = 1,
        MO(n)))
    }
}, Uf = {
    clearProps: function(t, r, i, n, s) {
        if (s.data !== "isFromStart") {
            var o = t._pt = new pr(t._pt,r,i,0,0,bj);
            return o.u = n,
            o.pr = -10,
            o.tween = s,
            t._props.push(i),
            1
        }
    }
}, Eu = [1, 0, 0, 1, 0, 0], BO = {}, kO = function(t) {
    return t === "matrix(1, 0, 0, 1, 0, 0)" || t === "none" || !t
}, Rw = function(t) {
    var r = ln(t, Kt);
    return kO(r) ? Eu : r.substr(7).match(WM).map(ne)
}, e1 = function(t, r) {
    var i = t._gsap || vo(t), n = t.style, s = Rw(t), o, a, l, h;
    return i.svg && t.getAttribute("transform") ? (l = t.transform.baseVal.consolidate().matrix,
    s = [l.a, l.b, l.c, l.d, l.e, l.f],
    s.join(",") === "1,0,0,1,0,0" ? Eu : s) : (s === Eu && !t.offsetParent && t !== Da && !i.svg && (l = n.display,
    n.display = "block",
    o = t.parentNode,
    (!o || !t.offsetParent) && (h = 1,
    a = t.nextElementSibling,
    Da.appendChild(t)),
    s = Rw(t),
    l ? n.display = l : xu(t, "display"),
    h && (a ? o.insertBefore(t, a) : o ? o.appendChild(t) : Da.removeChild(t))),
    r && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
}, ry = function(t, r, i, n, s, o) {
    var a = t._gsap, l = s || e1(t, !0), h = a.xOrigin || 0, u = a.yOrigin || 0, c = a.xOffset || 0, d = a.yOffset || 0, f = l[0], g = l[1], p = l[2], v = l[3], y = l[4], m = l[5], _ = r.split(" "), x = parseFloat(_[0]) || 0, E = parseFloat(_[1]) || 0, S, w, T, C;
    i ? l !== Eu && (w = f * v - g * p) && (T = x * (v / w) + E * (-p / w) + (p * m - v * y) / w,
    C = x * (-g / w) + E * (f / w) - (f * m - g * y) / w,
    x = T,
    E = C) : (S = LO(t),
    x = S.x + (~_[0].indexOf("%") ? x / 100 * S.width : x),
    E = S.y + (~(_[1] || _[0]).indexOf("%") ? E / 100 * S.height : E)),
    n || n !== !1 && a.smooth ? (y = x - h,
    m = E - u,
    a.xOffset = c + (y * f + m * p) - y,
    a.yOffset = d + (y * g + m * v) - m) : a.xOffset = a.yOffset = 0,
    a.xOrigin = x,
    a.yOrigin = E,
    a.smooth = !!n,
    a.origin = r,
    a.originIsAbsolute = !!i,
    t.style[Mi] = "0px 0px",
    o && (ds(o, a, "xOrigin", h, x),
    ds(o, a, "yOrigin", u, E),
    ds(o, a, "xOffset", c, a.xOffset),
    ds(o, a, "yOffset", d, a.yOffset)),
    t.setAttribute("data-svg-origin", x + " " + E)
}, Tu = function(t, r) {
    var i = t._gsap || new xO(t);
    if ("x"in i && !r && !i.uncache)
        return i;
    var n = t.style, s = i.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(t), h = ln(t, Mi) || "0", u, c, d, f, g, p, v, y, m, _, x, E, S, w, T, C, R, O, N, P, M, V, X, k, L, $, I, H, K, ct, rt, Et;
    return u = c = d = p = v = y = m = _ = x = 0,
    f = g = 1,
    i.svg = !!(t.getCTM && DO(t)),
    l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (n[Kt] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[Kt] !== "none" ? l[Kt] : "")),
    n.scale = n.rotate = n.translate = "none"),
    w = e1(t, i.svg),
    i.svg && (i.uncache ? (L = t.getBBox(),
    h = i.xOrigin - L.x + "px " + (i.yOrigin - L.y) + "px",
    k = "") : k = !r && t.getAttribute("data-svg-origin"),
    ry(t, k || h, !!k || i.originIsAbsolute, i.smooth !== !1, w)),
    E = i.xOrigin || 0,
    S = i.yOrigin || 0,
    w !== Eu && (O = w[0],
    N = w[1],
    P = w[2],
    M = w[3],
    u = V = w[4],
    c = X = w[5],
    w.length === 6 ? (f = Math.sqrt(O * O + N * N),
    g = Math.sqrt(M * M + P * P),
    p = O || N ? Qo(N, O) * ro : 0,
    m = P || M ? Qo(P, M) * ro + p : 0,
    m && (g *= Math.abs(Math.cos(m * Ba))),
    i.svg && (u -= E - (E * O + S * P),
    c -= S - (E * N + S * M))) : (Et = w[6],
    ct = w[7],
    I = w[8],
    H = w[9],
    K = w[10],
    rt = w[11],
    u = w[12],
    c = w[13],
    d = w[14],
    T = Qo(Et, K),
    v = T * ro,
    T && (C = Math.cos(-T),
    R = Math.sin(-T),
    k = V * C + I * R,
    L = X * C + H * R,
    $ = Et * C + K * R,
    I = V * -R + I * C,
    H = X * -R + H * C,
    K = Et * -R + K * C,
    rt = ct * -R + rt * C,
    V = k,
    X = L,
    Et = $),
    T = Qo(-P, K),
    y = T * ro,
    T && (C = Math.cos(-T),
    R = Math.sin(-T),
    k = O * C - I * R,
    L = N * C - H * R,
    $ = P * C - K * R,
    rt = M * R + rt * C,
    O = k,
    N = L,
    P = $),
    T = Qo(N, O),
    p = T * ro,
    T && (C = Math.cos(T),
    R = Math.sin(T),
    k = O * C + N * R,
    L = V * C + X * R,
    N = N * C - O * R,
    X = X * C - V * R,
    O = k,
    V = L),
    v && Math.abs(v) + Math.abs(p) > 359.9 && (v = p = 0,
    y = 180 - y),
    f = ne(Math.sqrt(O * O + N * N + P * P)),
    g = ne(Math.sqrt(X * X + Et * Et)),
    T = Qo(V, X),
    m = Math.abs(T) > 2e-4 ? T * ro : 0,
    x = rt ? 1 / (rt < 0 ? -rt : rt) : 0),
    i.svg && (k = t.getAttribute("transform"),
    i.forceCSS = t.setAttribute("transform", "") || !kO(ln(t, Kt)),
    k && t.setAttribute("transform", k))),
    Math.abs(m) > 90 && Math.abs(m) < 270 && (s ? (f *= -1,
    m += p <= 0 ? 180 : -180,
    p += p <= 0 ? 180 : -180) : (g *= -1,
    m += m <= 0 ? 180 : -180)),
    r = r || i.uncache,
    i.x = u - ((i.xPercent = u && (!r && i.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? t.offsetWidth * i.xPercent / 100 : 0) + o,
    i.y = c - ((i.yPercent = c && (!r && i.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-c) ? -50 : 0))) ? t.offsetHeight * i.yPercent / 100 : 0) + o,
    i.z = d + o,
    i.scaleX = ne(f),
    i.scaleY = ne(g),
    i.rotation = ne(p) + a,
    i.rotationX = ne(v) + a,
    i.rotationY = ne(y) + a,
    i.skewX = m + a,
    i.skewY = _ + a,
    i.transformPerspective = x + o,
    (i.zOrigin = parseFloat(h.split(" ")[2]) || 0) && (n[Mi] = Gf(h)),
    i.xOffset = i.yOffset = 0,
    i.force3D = Lr.force3D,
    i.renderTransform = i.svg ? Pj : NO ? FO : Cj,
    i.uncache = 0,
    i
}, Gf = function(t) {
    return (t = t.split(" "))[0] + " " + t[1]
}, bg = function(t, r, i) {
    var n = $e(r);
    return ne(parseFloat(r) + parseFloat(Os(t, "x", i + "px", n))) + n
}, Cj = function(t, r) {
    r.z = "0px",
    r.rotationY = r.rotationX = "0deg",
    r.force3D = 0,
    FO(t, r)
}, Vs = "0deg", Dl = "0px", js = ") ", FO = function(t, r) {
    var i = r || this
      , n = i.xPercent
      , s = i.yPercent
      , o = i.x
      , a = i.y
      , l = i.z
      , h = i.rotation
      , u = i.rotationY
      , c = i.rotationX
      , d = i.skewX
      , f = i.skewY
      , g = i.scaleX
      , p = i.scaleY
      , v = i.transformPerspective
      , y = i.force3D
      , m = i.target
      , _ = i.zOrigin
      , x = ""
      , E = y === "auto" && t && t !== 1 || y === !0;
    if (_ && (c !== Vs || u !== Vs)) {
        var S = parseFloat(u) * Ba, w = Math.sin(S), T = Math.cos(S), C;
        S = parseFloat(c) * Ba,
        C = Math.cos(S),
        o = bg(m, o, w * C * -_),
        a = bg(m, a, -Math.sin(S) * -_),
        l = bg(m, l, T * C * -_ + _)
    }
    v !== Dl && (x += "perspective(" + v + js),
    (n || s) && (x += "translate(" + n + "%, " + s + "%) "),
    (E || o !== Dl || a !== Dl || l !== Dl) && (x += l !== Dl || E ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + js),
    h !== Vs && (x += "rotate(" + h + js),
    u !== Vs && (x += "rotateY(" + u + js),
    c !== Vs && (x += "rotateX(" + c + js),
    (d !== Vs || f !== Vs) && (x += "skew(" + d + ", " + f + js),
    (g !== 1 || p !== 1) && (x += "scale(" + g + ", " + p + js),
    m.style[Kt] = x || "translate(0, 0)"
}, Pj = function(t, r) {
    var i = r || this, n = i.xPercent, s = i.yPercent, o = i.x, a = i.y, l = i.rotation, h = i.skewX, u = i.skewY, c = i.scaleX, d = i.scaleY, f = i.target, g = i.xOrigin, p = i.yOrigin, v = i.xOffset, y = i.yOffset, m = i.forceCSS, _ = parseFloat(o), x = parseFloat(a), E, S, w, T, C;
    l = parseFloat(l),
    h = parseFloat(h),
    u = parseFloat(u),
    u && (u = parseFloat(u),
    h += u,
    l += u),
    l || h ? (l *= Ba,
    h *= Ba,
    E = Math.cos(l) * c,
    S = Math.sin(l) * c,
    w = Math.sin(l - h) * -d,
    T = Math.cos(l - h) * d,
    h && (u *= Ba,
    C = Math.tan(h - u),
    C = Math.sqrt(1 + C * C),
    w *= C,
    T *= C,
    u && (C = Math.tan(u),
    C = Math.sqrt(1 + C * C),
    E *= C,
    S *= C)),
    E = ne(E),
    S = ne(S),
    w = ne(w),
    T = ne(T)) : (E = c,
    T = d,
    S = w = 0),
    (_ && !~(o + "").indexOf("px") || x && !~(a + "").indexOf("px")) && (_ = Os(f, "x", o, "px"),
    x = Os(f, "y", a, "px")),
    (g || p || v || y) && (_ = ne(_ + g - (g * E + p * w) + v),
    x = ne(x + p - (g * S + p * T) + y)),
    (n || s) && (C = f.getBBox(),
    _ = ne(_ + n / 100 * C.width),
    x = ne(x + s / 100 * C.height)),
    C = "matrix(" + E + "," + S + "," + w + "," + T + "," + _ + "," + x + ")",
    f.setAttribute("transform", C),
    m && (f.style[Kt] = C)
}, Ij = function(t, r, i, n, s) {
    var o = 360, a = Ce(s), l = parseFloat(s) * (a && ~s.indexOf("rad") ? ro : 1), h = l - n, u = n + h + "deg", c, d;
    return a && (c = s.split("_")[1],
    c === "short" && (h %= o,
    h !== h % (o / 2) && (h += h < 0 ? o : -o)),
    c === "cw" && h < 0 ? h = (h + o * Aw) % o - ~~(h / o) * o : c === "ccw" && h > 0 && (h = (h - o * Aw) % o - ~~(h / o) * o)),
    t._pt = d = new pr(t._pt,r,i,n,h,dj),
    d.e = u,
    d.u = "deg",
    t._props.push(i),
    d
}, Mw = function(t, r) {
    for (var i in r)
        t[i] = r[i];
    return t
}, Rj = function(t, r, i) {
    var n = Mw({}, i._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", o = i.style, a, l, h, u, c, d, f, g;
    n.svg ? (h = i.getAttribute("transform"),
    i.setAttribute("transform", ""),
    o[Kt] = r,
    a = Tu(i, 1),
    xu(i, Kt),
    i.setAttribute("transform", h)) : (h = getComputedStyle(i)[Kt],
    o[Kt] = r,
    a = Tu(i, 1),
    o[Kt] = h);
    for (l in zn)
        h = n[l],
        u = a[l],
        h !== u && s.indexOf(l) < 0 && (f = $e(h),
        g = $e(u),
        c = f !== g ? Os(i, l, h, g) : parseFloat(h),
        d = parseFloat(u),
        t._pt = new pr(t._pt,a,l,c,d - c,J_),
        t._pt.u = g || 0,
        t._props.push(l));
    Mw(a, n)
};
fr("padding,margin,Width,Radius", function(e, t) {
    var r = "Top"
      , i = "Right"
      , n = "Bottom"
      , s = "Left"
      , o = (t < 3 ? [r, i, n, s] : [r + s, r + i, n + i, n + s]).map(function(a) {
        return t < 2 ? e + a : "border" + a + e
    });
    Uf[t > 1 ? "border" + e : e] = function(a, l, h, u, c) {
        var d, f;
        if (arguments.length < 4)
            return d = o.map(function(g) {
                return wn(a, g, h)
            }),
            f = d.join(" "),
            f.split(d[0]).length === 5 ? d[0] : f;
        d = (u + "").split(" "),
        f = {},
        o.forEach(function(g, p) {
            return f[g] = d[p] = d[p] || d[(p - 1) / 2 | 0]
        }),
        a.init(l, f, c)
    }
});
var UO = {
    name: "css",
    register: ey,
    targetTest: function(t) {
        return t.style && t.nodeType
    },
    init: function(t, r, i, n, s) {
        var o = this._props, a = t.style, l = i.vars.startAt, h, u, c, d, f, g, p, v, y, m, _, x, E, S, w, T;
        Qx || ey(),
        this.styles = this.styles || OO(t),
        T = this.styles.props,
        this.tween = i;
        for (p in r)
            if (p !== "autoRound" && (u = r[p],
            !(wr[p] && EO(p, r, i, n, t, s)))) {
                if (f = typeof u,
                g = Uf[p],
                f === "function" && (u = u.call(i, n, t, s),
                f = typeof u),
                f === "string" && ~u.indexOf("random(") && (u = _u(u)),
                g)
                    g(this, t, p, u, i) && (w = 1);
                else if (p.substr(0, 2) === "--")
                    h = (getComputedStyle(t).getPropertyValue(p) + "").trim(),
                    u += "",
                    As.lastIndex = 0,
                    As.test(h) || (v = $e(h),
                    y = $e(u)),
                    y ? v !== y && (h = Os(t, p, h, y) + y) : v && (u += v),
                    this.add(a, "setProperty", h, u, n, s, 0, 0, p),
                    o.push(p),
                    T.push(p, 0, a[p]);
                else if (f !== "undefined") {
                    if (l && p in l ? (h = typeof l[p] == "function" ? l[p].call(i, n, t, s) : l[p],
                    Ce(h) && ~h.indexOf("random(") && (h = _u(h)),
                    $e(h + "") || (h += Lr.units[p] || $e(wn(t, p)) || ""),
                    (h + "").charAt(1) === "=" && (h = wn(t, p))) : h = wn(t, p),
                    d = parseFloat(h),
                    m = f === "string" && u.charAt(1) === "=" && u.substr(0, 2),
                    m && (u = u.substr(2)),
                    c = parseFloat(u),
                    p in en && (p === "autoAlpha" && (d === 1 && wn(t, "visibility") === "hidden" && c && (d = 0),
                    T.push("visibility", 0, a.visibility),
                    ds(this, a, "visibility", d ? "inherit" : "hidden", c ? "inherit" : "hidden", !c)),
                    p !== "scale" && p !== "transform" && (p = en[p],
                    ~p.indexOf(",") && (p = p.split(",")[0]))),
                    _ = p in zn,
                    _) {
                        if (this.styles.save(p),
                        x || (E = t._gsap,
                        E.renderTransform && !r.parseTransform || Tu(t, r.parseTransform),
                        S = r.smoothOrigin !== !1 && E.smooth,
                        x = this._pt = new pr(this._pt,a,Kt,0,1,E.renderTransform,E,0,-1),
                        x.dep = 1),
                        p === "scale")
                            this._pt = new pr(this._pt,E,"scaleY",E.scaleY,(m ? La(E.scaleY, m + c) : c) - E.scaleY || 0,J_),
                            this._pt.u = 0,
                            o.push("scaleY", p),
                            p += "X";
                        else if (p === "transformOrigin") {
                            T.push(Mi, 0, a[Mi]),
                            u = Aj(u),
                            E.svg ? ry(t, u, 0, S, 0, this) : (y = parseFloat(u.split(" ")[2]) || 0,
                            y !== E.zOrigin && ds(this, E, "zOrigin", E.zOrigin, y),
                            ds(this, a, p, Gf(h), Gf(u)));
                            continue
                        } else if (p === "svgOrigin") {
                            ry(t, u, 1, S, 0, this);
                            continue
                        } else if (p in BO) {
                            Ij(this, E, p, d, m ? La(d, m + u) : u);
                            continue
                        } else if (p === "smoothOrigin") {
                            ds(this, E, "smooth", E.smooth, u);
                            continue
                        } else if (p === "force3D") {
                            E[p] = u;
                            continue
                        } else if (p === "transform") {
                            Rj(this, u, t);
                            continue
                        }
                    } else
                        p in a || (p = ll(p) || p);
                    if (_ || (c || c === 0) && (d || d === 0) && !cj.test(u) && p in a)
                        v = (h + "").substr((d + "").length),
                        c || (c = 0),
                        y = $e(u) || (p in Lr.units ? Lr.units[p] : v),
                        v !== y && (d = Os(t, p, h, y)),
                        this._pt = new pr(this._pt,_ ? E : a,p,d,(m ? La(d, m + c) : c) - d,!_ && (y === "px" || p === "zIndex") && r.autoRound !== !1 ? pj : J_),
                        this._pt.u = y || 0,
                        v !== y && y !== "%" && (this._pt.b = h,
                        this._pt.r = fj);
                    else if (p in a)
                        wj.call(this, t, p, h, m ? m + u : u);
                    else if (p in t)
                        this.add(t, p, h || t[p], m ? m + u : u, n, s);
                    else if (p !== "parseTransform") {
                        zx(p, u);
                        continue
                    }
                    _ || (p in a ? T.push(p, 0, a[p]) : T.push(p, 1, h || t[p])),
                    o.push(p)
                }
            }
        w && CO(this)
    },
    render: function(t, r) {
        if (r.tween._time || !Jx())
            for (var i = r._pt; i; )
                i.r(t, i.d),
                i = i._next;
        else
            r.styles.revert()
    },
    get: wn,
    aliases: en,
    getSetter: function(t, r, i) {
        var n = en[r];
        return n && n.indexOf(",") < 0 && (r = n),
        r in zn && r !== Mi && (t._gsap.x || wn(t, "x")) ? i && ww === i ? r === "scale" ? yj : _j : (ww = i || {}) && (r === "scale" ? vj : xj) : t.style && !Gx(t.style[r]) ? mj : ~r.indexOf("-") ? gj : qx(t, r)
    },
    core: {
        _removeProperty: xu,
        _getMatrix: e1
    }
};
mr.utils.checkPrefix = ll;
mr.core.getStyleSaver = OO;
(function(e, t, r, i) {
    var n = fr(e + "," + t + "," + r, function(s) {
        zn[s] = 1
    });
    fr(t, function(s) {
        Lr.units[s] = "deg",
        BO[s] = 1
    }),
    en[n[13]] = e + "," + t,
    fr(i, function(s) {
        var o = s.split(":");
        en[o[1]] = n[o[0]]
    })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
fr("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(e) {
    Lr.units[e] = "px"
});
mr.registerPlugin(UO);
var ut = mr.registerPlugin(UO) || mr;
ut.core.Tween;
/*!
 * PixiPlugin 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var fs, Ow, Hf, Cr, Sh, GO, iy, HO = function() {
    return typeof window < "u"
}, $O = function() {
    return fs || HO() && (fs = window.gsap) && fs.registerPlugin && fs
}, ny = function(t) {
    return typeof t == "function"
}, zO = function(t) {
    return console.warn(t)
}, Mj = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], Wr = .212671, Vr = .71516, jr = .072169, WO = function(t) {
    return ny(Cr[t]) ? Cr[t] : Cr.filters[t]
}, Wp = function(t, r) {
    var i = [], n = 0, s = 0, o, a;
    for (o = 0; o < 4; o++) {
        for (a = 0; a < 5; a++)
            s = a === 4 ? t[n + 4] : 0,
            i[n + a] = t[n] * r[a] + t[n + 1] * r[a + 5] + t[n + 2] * r[a + 10] + t[n + 3] * r[a + 15] + s;
        n += 5
    }
    return i
}, Nw = function(t, r) {
    var i = 1 - r
      , n = i * Wr
      , s = i * Vr
      , o = i * jr;
    return Wp([n + r, s, o, 0, 0, n, s + r, o, 0, 0, n, s, o + r, 0, 0, 0, 0, 0, 1, 0], t)
}, Lw = function(t, r, i) {
    var n = Hf(r)
      , s = n[0] / 255
      , o = n[1] / 255
      , a = n[2] / 255
      , l = 1 - i;
    return Wp([l + i * s * Wr, i * s * Vr, i * s * jr, 0, 0, i * o * Wr, l + i * o * Vr, i * o * jr, 0, 0, i * a * Wr, i * a * Vr, l + i * a * jr, 0, 0, 0, 0, 0, 1, 0], t)
}, Dw = function(t, r) {
    r *= Math.PI / 180;
    var i = Math.cos(r)
      , n = Math.sin(r);
    return Wp([Wr + i * (1 - Wr) + n * -Wr, Vr + i * -Vr + n * -Vr, jr + i * -jr + n * (1 - jr), 0, 0, Wr + i * -Wr + n * .143, Vr + i * (1 - Vr) + n * .14, jr + i * -jr + n * -.283, 0, 0, Wr + i * -Wr + n * -(1 - Wr), Vr + i * -Vr + n * Vr, jr + i * (1 - jr) + n * jr, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], t)
}, Bw = function(t, r) {
    return Wp([r, 0, 0, 0, .5 * (1 - r), 0, r, 0, 0, .5 * (1 - r), 0, 0, r, 0, .5 * (1 - r), 0, 0, 0, 1, 0], t)
}, VO = function(t, r) {
    var i = WO(r), n = t.filters || [], s = n.length, o;
    for (i || zO(r + " not found. PixiPlugin.registerPIXI(PIXI)"); --s > -1; )
        if (n[s]instanceof i)
            return n[s];
    return o = new i,
    r === "BlurFilter" && (o.blur = 0),
    n.push(o),
    t.filters = n,
    o
}, ve = function(t, r, i, n) {
    r.add(i, t, i[t], n[t]),
    r._props.push(t)
}, kw = function(t, r) {
    var i = WO("ColorMatrixFilter")
      , n = i();
    return n.matrix = r,
    n.brightness(t, !0),
    n.matrix
}, Oj = function(t) {
    var r = {}, i;
    for (i in t)
        r[i] = t[i];
    return r
}, _r = {
    contrast: 1,
    saturation: 1,
    colorizeAmount: 0,
    colorize: "rgb(255,255,255)",
    hue: 0,
    brightness: 1
}, Nj = function(t, r, i) {
    var n = VO(t, "ColorMatrixFilter"), s = t._gsColorMatrixFilter = t._gsColorMatrixFilter || Oj(_r), o = r.combineCMF && !("colorMatrixFilter"in r && !r.colorMatrixFilter), a, l, h;
    for (h = n.matrix,
    r.resolution && (n.resolution = r.resolution),
    r.matrix && r.matrix.length === h.length ? (l = r.matrix,
    s.contrast !== 1 && ve("contrast", i, s, _r),
    s.hue && ve("hue", i, s, _r),
    s.brightness !== 1 && ve("brightness", i, s, _r),
    s.colorizeAmount && (ve("colorize", i, s, _r),
    ve("colorizeAmount", i, s, _r)),
    s.saturation !== 1 && ve("saturation", i, s, _r)) : (l = Mj.slice(),
    r.contrast != null ? (l = Bw(l, +r.contrast),
    ve("contrast", i, s, r)) : s.contrast !== 1 && (o ? l = Bw(l, s.contrast) : ve("contrast", i, s, _r)),
    r.hue != null ? (l = Dw(l, +r.hue),
    ve("hue", i, s, r)) : s.hue && (o ? l = Dw(l, s.hue) : ve("hue", i, s, _r)),
    r.brightness != null ? (l = kw(+r.brightness, l),
    ve("brightness", i, s, r)) : s.brightness !== 1 && (o ? l = kw(s.brightness, l) : ve("brightness", i, s, _r)),
    r.colorize != null ? (r.colorizeAmount = "colorizeAmount"in r ? +r.colorizeAmount : 1,
    l = Lw(l, r.colorize, r.colorizeAmount),
    ve("colorize", i, s, r),
    ve("colorizeAmount", i, s, r)) : s.colorizeAmount && (o ? l = Lw(l, s.colorize, s.colorizeAmount) : (ve("colorize", i, s, _r),
    ve("colorizeAmount", i, s, _r))),
    r.saturation != null ? (l = Nw(l, +r.saturation),
    ve("saturation", i, s, r)) : s.saturation !== 1 && (o ? l = Nw(l, s.saturation) : ve("saturation", i, s, _r))),
    a = l.length; --a > -1; )
        l[a] !== h[a] && i.add(h, a, h[a], l[a], "colorMatrixFilter");
    i._props.push("colorMatrixFilter")
}, Lj = function(t, r) {
    var i = r.t
      , n = r.p
      , s = r.color
      , o = r.set;
    o(i, n, s[0] << 16 | s[1] << 8 | s[2])
}, Dj = function(t, r) {
    var i = r.g;
    i && (i.dirty++,
    i.clearDirty++)
}, Bj = function(t, r) {
    r.t.visible = !!r.t.alpha
}, Fw = function(t, r, i, n) {
    var s = t[r]
      , o = Hf(ny(s) ? t[r.indexOf("set") || !ny(t["get" + r.substr(3)]) ? r : "get" + r.substr(3)]() : s)
      , a = Hf(i);
    n._pt = new Sh(n._pt,t,r,0,0,Lj,{
        t,
        p: r,
        color: o,
        set: GO(t, r)
    }),
    n.add(o, 0, o[0], a[0]),
    n.add(o, 1, o[1], a[1]),
    n.add(o, 2, o[2], a[2])
}, kj = {
    tint: 1,
    lineColor: 1,
    fillColor: 1
}, Uw = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","), sy = {
    x: "position",
    y: "position",
    tileX: "tilePosition",
    tileY: "tilePosition"
}, Fj = {
    colorMatrixFilter: 1,
    saturation: 1,
    contrast: 1,
    hue: 1,
    colorize: 1,
    colorizeAmount: 1,
    brightness: 1,
    combineCMF: 1
}, $f = Math.PI / 180, jO = function(t) {
    return typeof t == "string"
}, Uj = function(t) {
    return jO(t) && t.charAt(1) === "=" ? t.substr(0, 2) + parseFloat(t.substr(2)) * $f : t * $f
}, Gj = function(t, r) {
    return r.set(r.t, r.p, t === 1 ? r.e : Math.round((r.s + r.c * t) * 1e5) / 1e5, r)
}, Hj = function(t, r, i, n, s, o) {
    var a = 360 * (o ? $f : 1), l = jO(s), h = l && s.charAt(1) === "=" ? +(s.charAt(0) + "1") : 0, u = parseFloat(h ? s.substr(2) : s) * (o ? $f : 1), c = h ? u * h : u - n, d = n + c, f, g;
    return l && (f = s.split("_")[1],
    f === "short" && (c %= a,
    c !== c % (a / 2) && (c += c < 0 ? a : -a)),
    f === "cw" && c < 0 ? c = (c + a * 1e10) % a - ~~(c / a) * a : f === "ccw" && c > 0 && (c = (c - a * 1e10) % a - ~~(c / a) * a)),
    t._pt = g = new Sh(t._pt,r,i,n,c,Gj),
    g.e = d,
    g
}, Gw = function() {
    HO() && (Ow = window,
    fs = $O(),
    Cr = Cr || Ow.PIXI,
    iy = Cr && Cr.VERSION && Cr.VERSION.charAt(0) === "4",
    Hf = function(r) {
        return fs.utils.splitColor((r + "").substr(0, 2) === "0x" ? "#" + r.substr(2) : r)
    }
    )
}, jc, Bl;
for (jc = 0; jc < Uw.length; jc++)
    Bl = Uw[jc],
    sy[Bl + "X"] = Bl,
    sy[Bl + "Y"] = Bl;
var oy = {
    version: "3.12.1",
    name: "pixi",
    register: function(t, r, i) {
        fs = t,
        Sh = i,
        GO = r.getSetter,
        Gw()
    },
    registerPIXI: function(t) {
        Cr = t
    },
    init: function(t, r, i, n, s) {
        if (Cr || Gw(),
        !Cr || !(t instanceof Cr.DisplayObject))
            return zO(t),
            !1;
        var o, a, l, h, u, c, d, f, g;
        for (c in r) {
            if (o = sy[c],
            l = r[c],
            o)
                a = ~c.charAt(c.length - 1).toLowerCase().indexOf("x") ? "x" : "y",
                this.add(t[o], a, t[o][a], o === "skew" ? Uj(l) : l, 0, 0, 0, 0, 0, 1);
            else if (c === "scale" || c === "anchor" || c === "pivot" || c === "tileScale")
                this.add(t[c], "x", t[c].x, l),
                this.add(t[c], "y", t[c].y, l);
            else if (c === "rotation" || c === "angle")
                Hj(this, t, c, t[c], l, c === "rotation");
            else if (Fj[c])
                h || (Nj(t, r.colorMatrixFilter || r, this),
                h = !0);
            else if (c === "blur" || c === "blurX" || c === "blurY" || c === "blurPadding") {
                if (u = VO(t, "BlurFilter"),
                this.add(u, c, u[c], l),
                r.blurPadding !== 0)
                    for (d = r.blurPadding || Math.max(u[c], l) * 2,
                    f = t.filters.length; --f > -1; )
                        t.filters[f].padding = Math.max(t.filters[f].padding, d)
            } else if (kj[c])
                if ((c === "lineColor" || c === "fillColor") && t instanceof Cr.Graphics)
                    for (g = (t.geometry || t).graphicsData,
                    this._pt = new Sh(this._pt,t,c,0,0,Dj,{
                        g: t.geometry || t
                    }),
                    f = g.length; --f > -1; )
                        Fw(iy ? g[f] : g[f][c.substr(0, 4) + "Style"], iy ? c : "color", l, this);
                else
                    Fw(t, c, l, this);
            else
                c === "autoAlpha" ? (this._pt = new Sh(this._pt,t,"visible",0,0,Bj),
                this.add(t, "alpha", t.alpha, l),
                this._props.push("alpha", "visible")) : c !== "resolution" && this.add(t, c, "get", l);
            this._props.push(c)
        }
    }
};
$O() && fs.registerPlugin(oy);
const $j = "/assets/public/Rubik-SemiBold-69c8c9bb.woff2"
  , zj = "/assets/public/Rubik-Medium-3cf5cd90.woff2"
  , Wj = {
    gradients: {
        bg: [{
            offset: 0,
            color: "#c2b726"
        }, {
            offset: .0967,
            color: "#90af3d"
        }, {
            offset: .1929,
            color: "#618f34"
        }, {
            offset: .2874,
            color: "#2e7731"
        }, {
            offset: .375,
            color: "#185f3d"
        }, {
            offset: .4703,
            color: "#014545"
        }, {
            offset: .5824,
            color: "#261c54"
        }, {
            offset: 1,
            color: "#090f3f"
        }],
        road: [{
            offset: 0,
            color: "#211d21"
        }, {
            offset: .7411,
            color: "#444139"
        }, {
            offset: 1,
            color: "rgba(106, 91, 65, 0)"
        }]
    },
    assets: {
        flagpole: "/game/v3/skins/halloween/airport/flag/flagpole@2x.webp",
        airportTerminal: "/game/v3/skins/halloween/airport/airport-l1-terminal@2x.webp",
        airportTileGround: "/game/v3/skins/halloween/airport/airport-l1-ground-tile@2x.webp",
        airportL2MountainsL: "/game/v3/skins/halloween/airport/airport-l2-mountains-l@2x.webp",
        airportL2MountainsR: "/game/v3/skins/halloween/airport/airport-l2-mountains-r@2x.webp",
        airportL3Hills: "/game/v3/skins/halloween/airport/airport-l3-hills@2x.webp",
        airportL4Mountains: "/game/v3/skins/halloween/airport/airport-l4-mountains@2x.webp",
        airportL5Mountains: "/game/v3/skins/halloween/airport/airport-l5-mountains@2x.webp",
        airportL6Sky: "/game/v3/skins/halloween/airport/airport-l6-sky@2x.webp",
        airportL6Moon: "/game/v3/skins/halloween/airport/airport-l6-moon@2x.webp",
        airportWindmill: "/game/v3/skins/halloween/airport/windmill/airport-windmill@2x.json",
        cloudsTile: "/game/v3/skins/halloween/clouds/clouds-tile@2x.webp",
        clouds: "/game/v3/skins/halloween/clouds/clouds@2x.json",
        planets: "/game/v3/skins/halloween/space/planets/planets@2x.json"
    },
    clouds: {
        zIndex: 0
    },
    hasRain: !0,
    airport: {
        windmill: {
            isNewPos: !0
        },
        clouds: {
            vel: 2.9
        },
        moon: {
            vel: 1,
            x: 774,
            y: -201
        }
    }
}
  , Vj = {
    gradients: {
        bg: [{
            offset: 0,
            color: "#FE9C6A"
        }, {
            offset: .0339,
            color: "#FDD1AA"
        }, {
            offset: .0591,
            color: "#D3ACB5"
        }, {
            offset: .0843,
            color: "#A585C7"
        }, {
            offset: .1581,
            color: "#765CBB"
        }, {
            offset: .2874,
            color: "#4C3E8B"
        }, {
            offset: .4207,
            color: "#2B2B6B"
        }, {
            offset: .511,
            color: "#272E71"
        }, {
            offset: .5824,
            color: "#261C54"
        }, {
            offset: 1,
            color: "#090f3f"
        }],
        road: [{
            offset: 0,
            color: "#383438"
        }, {
            offset: .7411,
            color: "#4d4347"
        }, {
            offset: 1,
            color: "rgba(87, 78, 86, 0)"
        }]
    },
    assets: {
        flagpole: "/game/v3/skins/f1/airport/flag/flagpole@2x.webp",
        airportTerminal: "/game/v3/skins/f1/airport/airport-l1-terminal@2x.webp",
        airportTileGround: "/game/v3/skins/f1/airport/airport-l1-ground-tile@2x.webp",
        airportL2MountainsL: "/game/v3/skins/f1/airport/airport-l2-mountains-l@2x.webp",
        airportL2MountainsR: "/game/v3/skins/f1/airport/airport-l2-mountains-r@2x.webp",
        airportL3Hills: "/game/v3/skins/f1/airport/airport-l3-hills@2x.webp",
        airportL4Mountains: "/game/v3/skins/f1/airport/airport-l4-mountains@2x.webp",
        airportL5Mountains: "/game/v3/skins/f1/airport/airport-l5-mountains@2x.webp",
        airportL6Sky: "/game/v3/skins/f1/airport/airport-l6-sky@2x.webp",
        airportRoadPaint: "/game/v3/skins/f1/airport/airport-road-paint@2x.webp",
        cloudsTile: "/game/v3/skins/f1/clouds/clouds-tile@2x.webp",
        clouds: "/game/v3/skins/f1/clouds/clouds@2x.json",
        planets: "/game/v3/skins/f1/space/planets/planets@2x.json"
    },
    airport: {
        windmill: {
            disabled: !0
        },
        roadPaint: {
            x: 924,
            y: 0
        },
        sky: {
            vel: 1.5
        }
    }
}
  , jj = {
    gradients: {
        bg: [{
            offset: 0,
            color: "#0F266C"
        }, {
            offset: .0206,
            color: "#6175D9"
        }, {
            offset: .07,
            color: "#312388"
        }, {
            offset: .1039,
            color: "#251678"
        }, {
            offset: .3247,
            color: "#25256F"
        }, {
            offset: .511,
            color: "#111A68"
        }, {
            offset: .5824,
            color: "#261C54"
        }, {
            offset: 1,
            color: "#090f3f"
        }],
        road: [{
            offset: 0,
            color: "#373349"
        }, {
            offset: .7411,
            color: "#434158"
        }, {
            offset: 1,
            color: "rgba(65, 63, 86, 0)"
        }]
    },
    assets: {
        flagpole: "/game/v3/skins/ny-summer/airport/flag/flagpole@2x.json",
        airportTerminal: "/game/v3/skins/ny-summer/airport/airport-l1-terminal@2x.webp",
        airportTileGround: "/game/v3/skins/ny-summer/airport/airport-l1-ground-tile@2x.webp",
        airportL2MountainsL: "/game/v3/skins/ny-summer/airport/airport-l2-mountains-l@2x.webp",
        airportL2MountainsR: "/game/v3/skins/ny-summer/airport/airport-l2-mountains-r@2x.webp",
        airportL3Hills: "/game/v3/skins/ny-summer/airport/airport-l3-hills@2x.webp",
        airportL4Mountains: "/game/v3/skins/ny-summer/airport/airport-l4-mountains@2x.webp",
        airportL5Mountains: "/game/v3/skins/ny-summer/airport/airport-l5-mountains@2x.webp",
        airportL6Sky: "/game/v3/skins/ny-summer/airport/airport-l6-sky@2x.webp",
        airportL6Moon: "/game/v3/skins/ny-summer/airport/airport-l6-moon@2x.webp",
        cloudsTile: "/game/v3/skins/ny-summer/clouds/clouds-tile@2x.webp",
        clouds: "/game/v3/skins/ny-summer/clouds/clouds@2x.json",
        planets: "/game/v3/skins/ny-summer/space/planets/planets@2x.json",
        nyTree: "/game/v3/skins/ny-summer/airport/ny-tree/ny-tree@2x.json"
    },
    airport: {
        windmill: {
            disabled: !0
        },
        nyTree: {},
        moon: {
            vel: 1.86,
            x: 793,
            y: -194,
            zIndex: 3
        },
        sky: {
            vel: 1.8
        }
    },
    skyStars: {
        vel: 1.8,
        items: [["star-1.webp", 5, .3, .65], ["star-2.webp", 2, .2, .48], ["star-3.webp", 1, .2, .48]]
    }
}
  , Xj = {
    gradients: {
        bg: [{
            offset: 0,
            color: "#0C1E56"
        }, {
            offset: .0206,
            color: "#005194"
        }, {
            offset: .07,
            color: "#0E2476"
        }, {
            offset: .1039,
            color: "#091E71"
        }, {
            offset: .3247,
            color: "#0E1454"
        }, {
            offset: .511,
            color: "#0E1453"
        }, {
            offset: .5824,
            color: "#261C54"
        }, {
            offset: 1,
            color: "#090f3f"
        }],
        road: [{
            offset: 0,
            color: "#3d3b4b"
        }, {
            offset: .7091,
            color: "#353954"
        }, {
            offset: 1,
            color: "rgba(59, 61, 75, 0)"
        }]
    },
    assets: {
        flagpole: "/game/v3/skins/ny/airport/flag/flagpole@2x.json",
        airportTerminal: "/game/v3/skins/ny/airport/airport-l1-terminal@2x.webp",
        airportTileGround: "/game/v3/skins/ny/airport/airport-l1-ground-tile@2x.webp",
        airportL2MountainsL: "/game/v3/skins/ny/airport/airport-l2-mountains-l@2x.webp",
        airportL2MountainsR: "/game/v3/skins/ny/airport/airport-l2-mountains-r@2x.webp",
        airportL3Hills: "/game/v3/skins/ny/airport/airport-l3-hills@2x.webp",
        airportL4Mountains: "/game/v3/skins/ny/airport/airport-l4-mountains@2x.webp",
        airportL5Mountains: "/game/v3/skins/ny/airport/airport-l5-mountains@2x.webp",
        airportL6Sky: "/game/v3/skins/ny/airport/airport-l6-sky@2x.webp",
        cloudsTile: "/game/v3/skins/ny/clouds/clouds-tile@2x.webp",
        clouds: "/game/v3/skins/ny/clouds/clouds@2x.json",
        planets: "/game/v3/skins/ny/space/planets/planets@2x.json",
        nyTree: "/game/v3/skins/ny/airport/ny-tree/ny-tree@2x.json",
        snow: "/game/v3/particles/snow/snow@2x.json"
    },
    airport: {
        windmill: {
            disabled: !0
        },
        nyTree: {},
        sky: {
            vel: 1.8
        }
    },
    skyStars: {
        vel: 1.8,
        items: [["star-1.webp", 5, .3, .65], ["star-2.webp", 2, .2, .48], ["star-3.webp", 1, .2, .48]]
    },
    snow: !0
}
  , Yj = {
    gradients: {
        bg: [{
            offset: 0,
            color: "#FE9C6A"
        }, {
            offset: .0281,
            color: "#FFE4C4"
        }, {
            offset: .0414,
            color: "#F0AD6B"
        }, {
            offset: .0657,
            color: "#E78367"
        }, {
            offset: .1136,
            color: "#DE7173"
        }, {
            offset: .1948,
            color: "#9A5493"
        }, {
            offset: .3007,
            color: "#44308B"
        }, {
            offset: .3868,
            color: "#38267E"
        }, {
            offset: .511,
            color: "#21196B"
        }, {
            offset: .5824,
            color: "#261C54"
        }, {
            offset: 1,
            color: "#090f3f"
        }],
        road: [{
            offset: 0,
            color: "#383438"
        }, {
            offset: .7411,
            color: "#4D4347"
        }, {
            offset: 1,
            color: "rgba(87, 78, 86, 0)"
        }]
    },
    assets: {
        flagpole: "/game/v3/skins/brazil-carnival/airport/flag/flagpole@2x.webp",
        airportTerminal: "/game/v3/skins/brazil-carnival/airport/airport-l1-terminal@2x.webp",
        airportTileGround: "/game/v3/skins/brazil-carnival/airport/airport-l1-ground-tile@2x.webp",
        airportL2MountainsL: "/game/v3/skins/brazil-carnival/airport/airport-l2-mountains-l@2x.webp",
        airportL2MountainsR: "/game/v3/skins/brazil-carnival/airport/airport-l2-mountains-r@2x.webp",
        airportL3Hills: "/game/v3/skins/brazil-carnival/airport/airport-l3-hills@2x.webp",
        airportL4Mountains: "/game/v3/skins/brazil-carnival/airport/airport-l4-mountains@2x.webp",
        airportL5Mountains: "/game/v3/skins/brazil-carnival/airport/airport-l5-mountains@2x.webp",
        airportL6Sky: "/game/v3/skins/brazil-carnival/airport/airport-l6-sky@2x.webp",
        cloudsTile: "/game/v3/skins/brazil-carnival/clouds/clouds-tile@2x.webp",
        clouds: "/game/v3/skins/brazil-carnival/clouds/clouds@2x.json",
        planets: "/game/v3/skins/brazil-carnival/space/planets/planets@2x.json"
    },
    airport: {
        windmill: {
            disabled: !0
        },
        sky: {
            vel: 1.86
        }
    }
}
  , Kj = {
    gradients: {
        bg: [{
            offset: 0,
            color: "#FE9C6A"
        }, {
            offset: .0339,
            color: "#C6E7A8"
        }, {
            offset: .0591,
            color: "#AFCC80"
        }, {
            offset: .0843,
            color: "#4DAD7A"
        }, {
            offset: .1581,
            color: "#3A8378"
        }, {
            offset: .2668,
            color: "#3A6B7B"
        }, {
            offset: .4207,
            color: "#303079"
        }, {
            offset: .511,
            color: "#1F1D6D"
        }, {
            offset: .5824,
            color: "#261C54"
        }, {
            offset: 1,
            color: "#090f3f"
        }],
        road: [{
            offset: 0,
            color: "#383438"
        }, {
            offset: .7091,
            color: "#4D4347"
        }, {
            offset: 1,
            color: "rgba(87, 78, 86, 0)"
        }]
    },
    assets: {
        flagpole: "/game/v3/skins/patrick/airport/flag/flagpole@2x.webp",
        airportTerminal: "/game/v3/skins/patrick/airport/airport-l1-terminal@2x.webp",
        airportTileGround: "/game/v3/skins/patrick/airport/airport-l1-ground-tile@2x.webp",
        airportL2MountainsL: "/game/v3/skins/patrick/airport/airport-l2-mountains-l@2x.webp",
        airportL2MountainsR: "/game/v3/skins/patrick/airport/airport-l2-mountains-r@2x.webp",
        airportL3Hills: "/game/v3/skins/patrick/airport/airport-l3-hills@2x.webp",
        airportL4Mountains: "/game/v3/skins/patrick/airport/airport-l4-mountains@2x.webp",
        airportL5Mountains: "/game/v3/skins/patrick/airport/airport-l5-mountains@2x.webp",
        airportL6Sky: "/game/v3/skins/patrick/airport/airport-l6-sky@2x.webp",
        cloudsTile: "/game/v3/skins/patrick/clouds/clouds-tile@2x.webp",
        clouds: "/game/v3/skins/patrick/clouds/clouds@2x.json",
        planets: "/game/v3/skins/patrick/space/planets/planets@2x.json"
    },
    airport: {
        windmill: {
            disabled: !0
        },
        sky: {
            vel: 1.86
        }
    }
}
  , qj = {
    gradients: {
        bg: [{
            offset: 0,
            color: "#FE9C6A"
        }, {
            offset: .0339,
            color: "#A8CFE7"
        }, {
            offset: .0591,
            color: "#8FBCDA"
        }, {
            offset: .0843,
            color: "#62A9CA"
        }, {
            offset: .1581,
            color: "#4884AF"
        }, {
            offset: .2668,
            color: "#426B9C"
        }, {
            offset: .4207,
            color: "#303079"
        }, {
            offset: .511,
            color: "#1F1D6D"
        }, {
            offset: .5824,
            color: "#261C54"
        }, {
            offset: 1,
            color: "#090f3f"
        }],
        road: [{
            offset: 0,
            color: "#383438"
        }, {
            offset: .7091,
            color: "#4D4347"
        }, {
            offset: 1,
            color: "rgba(87, 78, 86, 0)"
        }]
    },
    assets: {
        flagpole: "/game/v3/skins/cricket/airport/flag/flagpole@2x.webp",
        airportTerminal: "/game/v3/skins/cricket/airport/airport-l1-terminal@2x.webp",
        airportTileGround: "/game/v3/skins/cricket/airport/airport-l1-ground-tile@2x.webp",
        airportL2MountainsL: "/game/v3/skins/cricket/airport/airport-l2-mountains-l@2x.webp",
        airportL2MountainsR: "/game/v3/skins/cricket/airport/airport-l2-mountains-r@2x.webp",
        airportL3Hills: "/game/v3/skins/cricket/airport/airport-l3-hills@2x.webp",
        airportL4Mountains: "/game/v3/skins/cricket/airport/airport-l4-mountains@2x.webp",
        airportL5Mountains: "/game/v3/skins/cricket/airport/airport-l5-mountains@2x.webp",
        airportL6Sky: "/game/v3/skins/cricket/airport/airport-l6-sky@2x.webp",
        cloudsTile: "/game/v3/skins/cricket/clouds/clouds-tile@2x.webp",
        clouds: "/game/v3/skins/cricket/clouds/clouds@2x.json",
        planets: "/game/v3/skins/cricket/space/planets/planets@2x.json"
    },
    airport: {
        windmill: {
            disabled: !0
        },
        sky: {
            vel: 1.86
        }
    }
}
  , Zj = {
    gradients: {
        bg: [{
            offset: 0,
            color: "#FE9C6A"
        }, {
            offset: .0339,
            color: "#354191"
        }, {
            offset: .0741,
            color: "#2C3F8A"
        }, {
            offset: .1348,
            color: "#2B3882"
        }, {
            offset: .2327,
            color: "#282675"
        }, {
            offset: .3651,
            color: "#2D1E67"
        }, {
            offset: .4914,
            color: "#281D65"
        }, {
            offset: .5824,
            color: "#261C54"
        }, {
            offset: 1,
            color: "#090f3f"
        }],
        road: [{
            offset: 0,
            color: "#353438"
        }, {
            offset: .7091,
            color: "#3C3C47"
        }, {
            offset: 1,
            color: "rgba(70, 70, 86, 0)"
        }]
    },
    assets: {
        flagpole: "/game/v3/skins/uefa/airport/flag/flagpole@2x.webp",
        airportTerminal: "/game/v3/skins/uefa/airport/airport-l1-terminal@2x.webp",
        airportTileGround: "/game/v3/skins/uefa/airport/airport-l1-ground-tile@2x.webp",
        airportL2MountainsL: "/game/v3/skins/uefa/airport/airport-l2-mountains-l@2x.webp",
        airportL2MountainsR: "/game/v3/skins/uefa/airport/airport-l2-mountains-r@2x.webp",
        airportL3Hills: "/game/v3/skins/uefa/airport/airport-l3-hills@2x.webp",
        airportL4Mountains: "/game/v3/skins/uefa/airport/airport-l4-mountains@2x.webp",
        airportL5Mountains: "/game/v3/skins/uefa/airport/airport-l5-mountains@2x.webp",
        airportL6Sky: "/game/v3/skins/uefa/airport/airport-l6-sky@2x.webp",
        cloudsTile: "/game/v3/skins/uefa/clouds/clouds-tile@2x.webp",
        clouds: "/game/v3/skins/uefa/clouds/clouds@2x.json",
        planets: "/game/v3/skins/uefa/space/planets/planets@2x.json",
        gate: "/game/v3/skins/uefa/airport/gate@2x.webp"
    },
    airport: {
        windmill: {
            disabled: !0
        },
        sky: {
            vel: 1.86
        },
        custom: [{
            asset: "gate",
            x: 1144,
            y: -70.8
        }]
    }
}
  , XO = () => {
    const e = xr(me.RESKIN_HALLOWEEN)
      , t = xr(me.RESKIN_F1)
      , r = xr(me.RESKIN_NY)
      , i = xr(me.RESKIN_NY_SUMMER)
      , n = xr(me.RESKIN_BRAZIL_CARNIVAL)
      , s = xr(me.RESKIN_PATRICK)
      , o = xr(me.RESKIN_CRICKET)
      , a = xr(me.RESKIN_UEFA)
      , l = xr(me.RESKIN_FIFA);
    if (e)
        return Wj;
    if (t)
        return Vj;
    if (r)
        return Xj;
    if (i)
        return jj;
    if (n)
        return Yj;
    if (s)
        return Kj;
    if (o)
        return qj;
    if (a || l)
        return Zj
}
  , r1 = "[ASSETS]"
  , Qj = () => {
    const {logoUrl: e, flagUrl: t} = AH()
      , r = XO();
    return {
        ...{
            flag: t,
            platformLogo: e,
            explosion: "/game/v3/planes-extra/explosion/explosion.json",
            flagpole: "/game/v3/airport/flag/flagpole@2x.webp",
            airportTerminal: "/game/v3/airport/airport-l1-terminal@2x.webp",
            airportTileGround: "/game/v3/airport/airport-l1-ground-tile@2x.webp",
            airportL2MountainsL: "/game/v3/airport/airport-l2-mountains-l@2x.webp",
            airportL2MountainsR: "/game/v3/airport/airport-l2-mountains-r@2x.webp",
            airportL3Hills: "/game/v3/airport/airport-l3-hills@2x.webp",
            airportL4Mountains: "/game/v3/airport/airport-l4-mountains@2x.webp",
            airportL5Mountains: "/game/v3/airport/airport-l5-mountains@2x.webp",
            airportL6Sky: "/game/v3/airport/airport-l6-sky@2x.webp",
            airportWindmill: "/game/v3/airport/windmill/airport-windmill@2x.json",
            cloudsTile: "/game/v3/clouds/clouds-tile@2x.webp",
            clouds: "/game/v3/clouds/clouds@2x.json",
            stars: "/game/v3/space/stars/stars@2x.json",
            planets: "/game/v3/space/planets/planets@2x.json",
            flagFilter: "/game/v3/airport/flag/flag-disp.webp",
            lightBg1: "/game/v3/light/bg-1.jpg",
            lightBg2: "/game/v3/light/bg-2.jpg",
            lightBg3: "/game/v3/light/bg-3.jpg",
            bigWin: "/game/v3/bigwin/big@2x-0.json",
            superWin: "/game/v3/bigwin/super@2x-0.json",
            epicWin: "/game/v3/bigwin/epic@2x-0.json",
            bigWinGlow: "/game/v3/bigwin/glow@2x.webp",
            bigWinBoard: "/game/v3/bigwin/board@2x.webp",
            bigWinCoins: "/game/v3/bigwin/coins@2x.json",
            bigWinLight: "/game/v3/bigwin/light@2x.json",
            hardRain: "/game/v3/particles/hard-rain.png"
        },
        ...r?.assets || {}
    }
}
  , YO = () => {
    const e = Qj();
    return Object.entries(e).reduce( (t, [r,i]) => (t[r] = cn(i),
    t), {})
}
  , Jj = () => {
    const e = YO();
    return {
        bundles: [{
            name: "game",
            assets: ["airportTerminal", "airportTileGround", "airportL2MountainsL", "airportL2MountainsR", "airportL3Hills", "airportL4Mountains", "airportL5Mountains", "airportL6Sky", "airportL6Moon"].map(t => ({
                alias: t,
                src: e[t]
            })).filter(t => !!t.src)
        }, {
            name: "game-more",
            assets: ["clouds", "cloudsTile", "stars", "airportWindmill", "flagpole", "flag", "flagFilter", "explosion", "platformLogo"].map(t => ({
                alias: t,
                src: e[t]
            }))
        }, {
            name: "light-game",
            assets: ["lightBg1", "lightBg2", "lightBg3"].map(t => ({
                alias: t,
                src: e[t]
            }))
        }]
    }
}
  , t9 = e => ({
    mobile: {
        data: {
            family: "Rubik",
            weights: ["600"]
        },
        src: $j
    },
    desktop: {
        data: {
            family: "Rubik",
            weights: ["500"]
        },
        src: zj
    }
})[e]
  , e9 = async () => {
    await vt.init({
        manifest: Jj()
    }),
    logger.info("inited", {
        prefix: r1
    })
}
  , Hw = async e => {
    await vt.load(t9(e ? "mobile" : "desktop")),
    logger.info("fonts", {
        prefix: r1
    })
}
  , r9 = async (e, t) => {
    if (!e?.length)
        return {};
    vt.backgroundLoadBundle(e);
    const r = await vt.loadBundle(e, i => {
        t?.(i)
    }
    );
    return logger.info("bundles loaded", {
        prefix: r1
    }),
    Object.values(r).reduce( (i, n) => ({
        ...i,
        ...n
    }), {})
}
  , Kr = {
    INITIAL: "initial",
    PREPARE: "prepare",
    RUN: "run",
    START: "start",
    FINISH: "finish"
}
  , Xs = {
    IDLE: "idle",
    MOVING_HORIZONTAL: "moving-horizontal",
    MOVING: "moving"
}
  , nr = {
    WAITING: "waiting",
    TAKING_OFF: "taking-off",
    FLYING: "flying",
    LANDING: "landing",
    LANDED: "landed",
    CRASHING: "crashing",
    CRASHED: "crashed"
}
  , i9 = 4.5
  , Vt = {
    BIG: "big",
    SUPER: "super",
    EPIC: "epic",
    DEFAULT: "default"
}
  , la = {
    [Vt.BIG]: 10,
    [Vt.SUPER]: 50,
    [Vt.EPIC]: 100
}
  , KO = 320
  , ay = 160
  , Id = {
    MASK: "mask",
    BACK: "back",
    FRONT: "front"
}
  , n9 = e => e >= la[Vt.BIG] && e < la[Vt.SUPER] ? Vt.BIG : e >= la[Vt.SUPER] && e < la[Vt.EPIC] ? Vt.SUPER : e >= la[Vt.EPIC] ? Vt.EPIC : Vt.DEFAULT
  , s9 = (e, t) => !(e?.level !== t?.level || e?.selectedLevel !== t?.selectedLevel || e?.meta?.primaryColor !== t?.meta?.primaryColor || e?.meta?.secondaryColor !== t?.meta?.secondaryColor || e?.meta?.tertiaryColor !== t?.meta?.tertiaryColor || e?.skinId !== t?.skinId)
  , qO = (e, t) => e?.nftSelectedLevel === t?.nftSelectedLevel && e?.nftMeta?.primaryColor === t?.nftMeta?.primaryColor && e?.nftMeta?.secondaryColor === t?.nftMeta?.secondaryColor
  , ZO = e => e <= 3
  , o9 = {
    roundState: void 0,
    currency: void 0,
    bgMusic: $h.CALM,
    mode: GR(),
    isFlyingHigh: !1,
    activePlane: void 0,
    isPreparing: !1,
    preparingTime: 0,
    playerBets: [],
    myBetIds: [],
    cashoutBets: [],
    players: []
}
  , a9 = {
    odds: void 0
}
  , l9 = {
    progress: 0,
    isGameLoaded: !1,
    isGameLoading: !0
}
  , He = Ap(e => ({
    ...o9,
    setMode: t => e({
        mode: t
    }),
    setBgMusic: t => e({
        bgMusic: t
    }),
    setPlayerBets: t => e({
        playerBets: t
    }),
    setRoundState: t => e({
        roundState: t
    }),
    setActivePlane: t => e({
        activePlane: t
    }),
    setIsPreparing: ({isPreparing: t, preparingTime: r}) => e({
        isPreparing: t,
        preparingTime: r
    }),
    setUserCurrency: t => e({
        currency: t
    }),
    setMyBetIds: t => e({
        myBetIds: t
    }),
    cashoutBet: t => e(r => ({
        cashoutBets: [...r.cashoutBets, t]
    }))
}))
  , zf = Ap(e => ({
    ...a9,
    setOdds: t => e({
        odds: t
    })
}))
  , eh = Ap( () => ({
    ...l9
}))
  , i1 = (e=t => t) => VP(eh, e, AW);
class h9 {
    constructor() {
        b(this, "userPlane");
        b(this, "backgroundLayer");
        b(this, "gameOverlay");
        b(this, "borderCloud")
    }
    setBorderCloud(t) {
        this.borderCloud = t
    }
    getBorderCloud() {
        return this.borderCloud
    }
    setUserPlane(t) {
        this.userPlane = t
    }
    getUserPlane() {
        return this.userPlane
    }
    setBackgroundLayer(t) {
        this.backgroundLayer = t
    }
    getBackgroundLayer() {
        return this.backgroundLayer
    }
    setGameOverlay(t) {
        this.gameOverlay = t
    }
    getGameOverlay() {
        return this.gameOverlay
    }
}
const Rr = new h9
  , u9 = {
    [Vt.BIG]: "bigWin",
    [Vt.SUPER]: "superWin",
    [Vt.EPIC]: "epicWin"
}
  , Cg = {
    [$h.CALM]: "bgCalm",
    [$h.DYNAMIC]: "bg"
};
class c9 {
    constructor() {
        b(this, "engineStartAlias", "propellerStart");
        b(this, "engineFlyAlias", "propellerFly");
        b(this, "engineTakeOffAlias", "propellerTakeOff");
        b(this, "isPropeller", !1);
        b(this, "isMusicPlaying", !1);
        b(this, "bgMusicAlias", Cg[$h.CALM]);
        b(this, "musicStartedAt")
    }
    setupEngineSfx() {
        const {activePlane: t} = He.getState()
          , r = Rr.getUserPlane()
          , i = t?.level || 1;
        this.isPropeller = ZO(i),
        r?.plane?.hasPropeller !== void 0 ? this.isPropeller = !!r?.plane?.hasPropeller : t?.skinRarity === Ar.SKIN_RARITY_LEGENDARY && (this.isPropeller = !1),
        this.engineStartAlias = this.isPropeller ? "propellerStart" : "turbineStart",
        this.engineFlyAlias = this.isPropeller ? "propellerFly" : "turbineFly",
        this.engineTakeOffAlias = this.isPropeller ? "propellerTakeOff" : "turbineTakeOff"
    }
    isNew() {
        return xr(me.NEW_SOUNDS)
    }
    prepare() {
        this.isNew() ? (setTimeout( () => {
            ot.play("start", {
                volume: .9
            })
        }
        , 600),
        ot.play("ambGeneral", {
            loop: !0
        })) : (this.setupEngineSfx(),
        ot.play("ambGeneral", {
            loop: !0
        }),
        ot.play(this.engineStartAlias, {
            complete: () => {
                ot.play(this.engineFlyAlias, {
                    loop: !0
                })
            }
        }))
    }
    start(t) {
        this.isNew() ? (this.setupEngineSfx(),
        ot.play(this.engineStartAlias, {
            end: this.isPropeller ? 2.3 : 1.8,
            complete: () => {
                ot.play(this.engineFlyAlias, {
                    loop: !0,
                    start: .1,
                    end: 7.9
                })
            }
        }),
        this.isMusicPlaying || this.startMusic(t)) : (ot.play("bg", {
            loop: !0
        }),
        ot.play("start"))
    }
    takeOff() {
        ot.play(this.engineTakeOffAlias)
    }
    changeBgMusic(t) {
        if (Cg[t] === this.bgMusicAlias)
            return;
        ot.stop(this.bgMusicAlias);
        let i = 0;
        this.musicStartedAt && (i = (Date.now() - this.musicStartedAt) / 1e3),
        this.startMusic(i)
    }
    startMusic(t=0) {
        const {bgMusic: r} = He.getState();
        this.bgMusicAlias = Cg[r] || "bg",
        this.musicStartedAt || (this.musicStartedAt = Date.now() - t * 1e3),
        ot.play(this.bgMusicAlias, {
            loop: !0,
            start: t || 0
        }),
        this.isMusicPlaying = !0
    }
    crash() {
        const t = this.isNew();
        ot.stop("start"),
        ot.stop("ambWind"),
        ot.stop("ambGeneral"),
        ot.stop(this.engineStartAlias),
        ot.stop(this.engineFlyAlias),
        ot.stop(this.engineTakeOffAlias),
        ot.play("crash"),
        t && (ot.stop(this.bgMusicAlias),
        this.isMusicPlaying = !1,
        this.musicStartedAt = null)
    }
    afterCrash() {
        this.isNew() || ot.stop("bg"),
        ot.stop("crash")
    }
    cashout() {
        ot.play("cashout")
    }
    land() {
        this.isNew() ? ot.play("mainLand") : ot.play("cashout")
    }
    playerLand() {
        ot.play("playerLand")
    }
    running(t) {
        const r = this.isNew();
        this.setupEngineSfx(),
        r ? (this.startMusic(t),
        ot.play("ambGeneral", {
            loop: !0
        }),
        ot.play(this.engineFlyAlias, {
            loop: !0,
            start: .1,
            end: 7.9
        })) : (ot.play("bg", {
            loop: !0,
            start: t
        }),
        ot.play("ambGeneral", {
            loop: !0
        }),
        ot.play(this.engineFlyAlias, {
            loop: !0
        }))
    }
    playWinSound(t) {
        ot.play(u9[t], {
            singleInstance: !1
        })
    }
    flyingHigh() {
        ot.play("ambWind", {
            loop: !0
        })
    }
}
const Ft = new c9
  , Pg = {
    "--players-bar-width": 285,
    "--sidebar-width": 360,
    "--sidebar-width-md": 406,
    "--sidebar-width-xl": 436
}
  , d9 = [U.XS_MEDIUM, U.S_MEDIUM, U.M_MEDIUM, U.S_LARGE, U.XS_LARGE, U.S_X_LARGE, U.XS_X_LARGE, U.MOBILE_S, U.MOBILE, U.TABLET_S, U.TABLET, U.DESKTOP]
  , f9 = [U.XS_X_LARGE, U.MOBILE_S, U.MOBILE, U.TABLET_S, U.TABLET, U.S_X_LARGE]
  , p9 = [U.TABLET_HOR, U.M_LARGE, U.L_LARGE]
  , m9 = [U.L_MIN, U.L_MEDIUM]
  , ri = (e, t) => {
    const r = FR[t] || 0;
    let i = e
      , n = i * .179
      , s = i * .527
      , o = 0
      , a = .12
      , l = .0256;
    if (d9.includes(t)) {
        let d = 0;
        f9.includes(t) && (d = UR[t] - r - 12),
        i = e - d,
        n = i * .2825 + d,
        s = i * .62 + d,
        a = .11
    }
    t === U.DESKTOP ? (n = (e + r) * .3442,
    s = e * .6126,
    a = .13,
    l = .05,
    o = Pg["--sidebar-width-xl"]) : p9.includes(t) ? o = Pg["--sidebar-width"] : m9.includes(t) && (o = Pg["--players-bar-width"]);
    const h = A.width - o;
    let u = 0;
    h > 1003 && (l = .05),
    i <= 281 ? u = -16 : i <= 526 && (u = -8);
    const c = {
        posX: Math.max(h * l, 10),
        posY: Math.max(i * a, 40),
        gapY: u
    };
    return {
        groundPosY: -n,
        gameScreenWidth: h,
        gameScreenHeight: i,
        planeFlightPosY: s,
        rightOffset: o,
        players: c
    }
}
  , g9 = (e, t, r) => {
    const {clientWidth: i, clientHeight: n} = document.documentElement;
    let s = 1;
    return [U.XS_MIN, U.XS_MEDIUM, U.XS_LARGE, U.S_MIN, U.S_MEDIUM, U.S_X_LARGE, U.M_MIN, U.M_MEDIUM].includes(r) ? s = .8 : [U.L_MIN, U.L_MEDIUM].includes(r) ? s = i < 1440 ? .8 : .9 : [U.S_LARGE, U.M_LARGE, U.XS_X_LARGE].includes(r) ? s = .9 : [U.MOBILE_S, U.MOBILE, U.TABLET_S].includes(r) ? n < 620 ? s = .9 : n < 720 ? s = 1 : s = i < 480 ? 1 : 1.2 : [U.L_LARGE].includes(r) ? n < 492 ? s = i < 1440 ? .9 : 1 : n < 576 ? s = i < 1440 ? 1 : 1.2 : s = 1.2 : [U.TABLET_HOR].includes(r) ? s = 1.2 : [U.DESKTOP, U.TABLET].includes(r) && (s = 1.45,
    i > 1440 && (s = Number((e / 990).toFixed(2)))),
    console.log("[GAME SCALE]", s, r),
    s
}
  , $w = {
    duration: 3e3,
    [Vt.BIG]: {
        animSpeed: .4,
        coins: [[{
            type: 1,
            x: 0,
            delay: 250,
            empty: 5
        }, {
            type: 2,
            x: -10,
            delay: 450,
            empty: 3
        }, {
            type: 3,
            x: 0,
            delay: 0,
            empty: 3
        }], [{
            type: 1,
            x: 0,
            delay: 130,
            empty: 5
        }, {
            type: 2,
            x: 10,
            delay: 630,
            empty: 3
        }, {
            type: 3,
            x: 0,
            delay: 380,
            empty: 3
        }]]
    },
    [Vt.SUPER]: {
        animSpeed: .4,
        coins: [[{
            type: 1,
            x: -15,
            delay: 130,
            empty: 5
        }, {
            type: 1,
            x: 35,
            delay: 540,
            empty: 5
        }, {
            type: 2,
            x: -10,
            delay: 420,
            empty: 3
        }, {
            type: 2,
            x: 40,
            delay: 710,
            empty: 3
        }, {
            type: 3,
            x: 0,
            delay: 0,
            empty: 3
        }, {
            type: 3,
            x: -20,
            delay: 250,
            empty: 3
        }], [{
            type: 1,
            x: 14,
            delay: 250,
            empty: 5
        }, {
            type: 1,
            x: -40,
            delay: 620,
            empty: 5
        }, {
            type: 2,
            x: 10,
            delay: 330,
            empty: 3
        }, {
            type: 2,
            x: -35,
            delay: 620,
            empty: 3
        }, {
            type: 3,
            x: 0,
            delay: 130,
            empty: 3
        }, {
            type: 3,
            x: 18,
            delay: 420,
            empty: 3
        }]]
    },
    [Vt.EPIC]: {
        animSpeed: .4,
        coins: [[{
            type: 1,
            x: 15,
            delay: 290,
            empty: 5
        }, {
            type: 1,
            x: 30,
            delay: 420,
            empty: 5
        }, {
            type: 1,
            x: 0,
            delay: 540,
            empty: 5
        }, {
            type: 1,
            x: 31,
            delay: 670,
            empty: 5
        }, {
            type: 2,
            x: -10,
            delay: 130,
            empty: 3
        }, {
            type: 2,
            x: 40,
            delay: 250,
            empty: 3
        }, {
            type: 2,
            x: 2,
            delay: 460,
            empty: 3
        }, {
            type: 3,
            x: 0,
            delay: 0,
            empty: 3
        }, {
            type: 3,
            x: -19,
            delay: 380,
            empty: 3
        }, {
            type: 3,
            x: 0,
            delay: 500,
            empty: 3
        }], [{
            type: 1,
            x: 24,
            delay: 90,
            empty: 5
        }, {
            type: 1,
            x: 9,
            delay: 380,
            empty: 5
        }, {
            type: 1,
            x: -10,
            delay: 250,
            empty: 5
        }, {
            type: 1,
            x: -22,
            delay: 590,
            empty: 5
        }, {
            type: 2,
            x: 20,
            delay: 170,
            empty: 3
        }, {
            type: 2,
            x: -30,
            delay: 340,
            empty: 3
        }, {
            type: 2,
            x: 8,
            delay: 590,
            empty: 3
        }, {
            type: 3,
            x: 10,
            delay: 210,
            empty: 3
        }, {
            type: 3,
            x: 28,
            delay: 460,
            empty: 3
        }, {
            type: 3,
            x: 9,
            delay: 710,
            empty: 3
        }]]
    }
};
class _9 extends J {
    constructor({asset: r, onComplete: i, odds: n, winAmount: s, type: o}) {
        super();
        b(this, "textContainer");
        b(this, "oddsText");
        b(this, "winAmountText");
        b(this, "winAnimation");
        b(this, "lightAnimation");
        b(this, "glow");
        b(this, "board");
        b(this, "boardAnimation");
        b(this, "settings");
        b(this, "coinSprites", []);
        b(this, "isFinished", !1);
        b(this, "odds");
        b(this, "winAmount");
        b(this, "type");
        b(this, "onComplete");
        this.visible = !1,
        this.onComplete = i,
        this.odds = n,
        this.winAmount = s,
        this.type = o,
        this.settings = $w[o],
        this.textContainer = new J;
        const {animations: a={}} = r.data
          , l = Object.keys(a)[0];
        this.winAnimation = Le.fromFrames(a[l]),
        this.winAnimation.anchor.set(.5),
        this.winAnimation.loop = !1,
        this.winAnimation.animationSpeed = this.settings.animSpeed;
        const h = vt.get(A.assetsUrls.bigWinLight)
          , {animations: u={}} = h.data
          , c = Object.keys(u)[0];
        this.lightAnimation = Le.fromFrames(u[c]),
        this.lightAnimation.anchor.set(.5),
        this.lightAnimation.scale.set(0),
        this.lightAnimation.loop = !0,
        this.lightAnimation.animationSpeed = .38;
        const d = vt.get(A.assetsUrls.bigWinGlow);
        this.glow = new at(d),
        this.glow.anchor.set(.5),
        this.glow.scale.set(.75),
        this.glow.alpha = 0;
        const f = vt.get(A.assetsUrls.bigWinBoard);
        this.board = new bM(f,25,8,25,8),
        this.board.alpha = 0,
        this.board.scale.set(0),
        this.board.y = 61,
        this.setPosition(),
        this.addChild(this.glow),
        this.addChild(this.lightAnimation),
        this.addChild(this.winAnimation),
        this.addChild(this.board),
        this.scale.set(A.scale)
    }
    setPosition() {
        const r = ri(A.height, A.breakpoint)
          , i = this.winAnimation.height * A.scale;
        this.x = (A.width - r.rightOffset) / 2,
        this.y = -r.planeFlightPosY - i * .045
    }
    startCoins() {
        const r = vt.get(A.assetsUrls.bigWinCoins)
          , {animations: i} = r.data;
        this.settings.coins.forEach( (s, o) => {
            s.forEach(a => {
                const l = Le.fromFrames(i[`coin-${a.type || 1}`]);
                l.textures = l.textures.concat(Array.from({
                    length: a.empty
                }).map( () => F.EMPTY)),
                l.visible = !1,
                l.anchor.set(.5),
                l.loop = !1,
                l.x = a.x || 0,
                l.animationSpeed = .52,
                o === 1 && (l.scale.x = -1),
                this.coinSprites.push(l),
                this.addChild(l),
                setTimeout( () => {
                    l.visible = !0,
                    l.play()
                }
                , a.delay || 0)
            }
            )
        }
        ),
        this.coinSprites.forEach(s => {
            s.onComplete = () => {
                this.isFinished || s.gotoAndPlay(0)
            }
        }
        )
    }
    playWin() {
        this.visible = !0,
        this.winAnimation.onFrameChange = r => {
            if (this.winAnimation.animationSpeed > 0) {
                r === 7 ? this.startCoins() : r === 11 ? this.showWinAmount() : r === 22 && ut.to(this.winAnimation, {
                    duration: 1.2,
                    repeat: -1,
                    ease: "power1.inOut",
                    yoyo: !0,
                    yoyoEase: !0,
                    pixi: {
                        y: this.winAnimation.y - 4
                    }
                });
                return
            }
            r === 21 ? this.boardAnimation?.reverse() : r === 13 ? ut.to(this.lightAnimation, {
                duration: .52,
                ease: "power1.inOut",
                pixi: {
                    scale: 0
                }
            }) : r === 10 && ut.to(this.glow, {
                duration: .4,
                ease: "power1.inOut",
                pixi: {
                    scale: .75,
                    alpha: 0
                }
            })
        }
        ,
        this.winAnimation.gotoAndPlay(0),
        Ft.playWinSound(this.type),
        ut.to(this.lightAnimation, {
            duration: .52,
            ease: "power1.inOut",
            pixi: {
                scale: 1
            },
            onComplete: () => {
                this.lightAnimation.play()
            }
        }),
        ut.to(this.glow, {
            duration: 8.5,
            ease: "none",
            repeat: -1,
            pixi: {
                angle: 360
            }
        }),
        ut.to(this.glow, {
            duration: .4,
            ease: "power1.inOut",
            pixi: {
                scale: 1,
                alpha: 1
            }
        }),
        setTimeout( () => {
            this.finish()
        }
        , $w.duration)
    }
    finish() {
        this.isFinished = !0,
        ut.killTweensOf(this.winAnimation),
        ut.to(this.winAnimation, {
            duration: 300,
            ease: "power1.inOut",
            pixi: {
                y: this.winAnimation.y
            }
        }),
        this.winAnimation.animationSpeed = -this.winAnimation.animationSpeed * 1.5,
        this.winAnimation.play(),
        this.winAnimation.onComplete = () => {
            this.destroy(),
            this.onComplete()
        }
    }
    resize(r, i, n) {
        this.scale.set(n),
        this.setPosition(),
        this.prepareText()
    }
    prepareText() {
        const r = new Li({
            fontFamily: "Rubik",
            fontSize: 10 * A.scale,
            lineHeight: 14 * A.scale,
            fontWeight: "500",
            fill: "#ffffff",
            align: "center",
            dropShadowColor: "#000000",
            dropShadow: !0,
            dropShadowAlpha: .25,
            dropShadowAngle: 1.5,
            dropShadowDistance: .8
        });
        this.oddsText = new Oo(`${this.odds.toFixed(2)}x`,r),
        this.oddsText.anchor.set(.5, 0),
        this.oddsText.scale.set(this.oddsText.scale.x / A.scale),
        this.winAmountText = new Oo(this.winAmount,{
            ...r,
            fontSize: 18 * A.scale,
            lineHeight: 21 * A.scale,
            fontWeight: "600",
            dropShadowAlpha: .15
        }),
        this.winAmountText.scale.set(this.winAmountText.scale.x / A.scale),
        this.winAmountText.anchor.set(.5, 0),
        this.winAmountText.y = this.oddsText.height - 1,
        this.textContainer.removeChildren(),
        this.textContainer.addChild(this.oddsText),
        this.textContainer.addChild(this.winAmountText)
    }
    showWinAmount() {
        this.prepareText();
        const r = this.board.width
          , i = this.textContainer.width;
        this.board.addChild(this.textContainer),
        this.board.width = Math.max(r, i + 40),
        this.board.pivot.x = this.board.width / 2,
        this.textContainer.x = this.board.width / 2,
        this.textContainer.y = this.board.height / 2 - 1,
        this.textContainer.pivot.y = this.textContainer.height / 2,
        this.boardAnimation = ut.to(this.board, {
            duration: .4,
            repeat: 0,
            ease: "power1.inOut",
            pixi: {
                scale: 1,
                alpha: 1
            }
        })
    }
}
const Yu = () => {
    const e = Mu();
    let t = {};
    if (e.debugParams && !qC) {
        const r = {};
        e.debugParams.split(";").forEach(i => {
            const [n,s] = i.split(":");
            r[n] = s
        }
        ),
        t = Rd.parse(Rd.stringify(r), {
            parseBooleans: !0,
            parseNumbers: !0
        })
    }
    return t
}
  , ly = ({level: e, meta: t, ratio: r, skinId: i, skinRarity: n}) => {
    if (i)
        return e && n !== Ar.SKIN_RARITY_LEGENDARY ? _o(`/game/v3/planes/skins/${i}/${i}-${e}.webp`, r) : _o(`/game/v3/planes/skins/${i}/${i}.webp`, r);
    const s = t?.primaryColor
      , o = t?.secondaryColor
      , a = t?.tertiaryColor;
    if (!s || !o || !a)
        return QO(r);
    let l = [s, o, a];
    const h = s || "red";
    let u = tT[h].detailsColors;
    return u || (u = tT.red.detailsColors),
    u.find( ({primary: d, secondary: f}) => d === o && f === a) || (l = [h, u[0].primary, u[0].secondary]),
    _o(`/game/v3/planes/${l.join("-")}-${e}.webp`, r)
}
  , QO = e => {
    const {gamePlaneUrl: t, isCustomizationEnabled: r} = $v() || {};
    return r && t ? _o(e ? t.replace("@2x", "") : t, e) : JO(e)
}
  , JO = e => _o("/brands/default/gamePlane/game-default-planev3.webp", e)
  , t2 = ({level: e, meta: t, skinId: r, skinRarity: i}) => {
    if (r) {
        const s = i === Ar.SKIN_RARITY_LEGENDARY;
        return cn(`/game/v3/planes/skins/${r}/parts/${s ? "" : `${e}/`}parts@2x.json`)
    }
    const n = t?.primaryColor || "red";
    return cn(`/game/v3/planes-extra/parts/${n}-${e}/parts@2x.json`)
}
  , e2 = (e, t) => _o(`/game/v3/planes-extra/engines/${e}/${e}.json`, t)
  , y9 = e => cn(`/game/v3/planes-extra/airbags/${e}/${e}@2x.json`)
  , r2 = ({level: e, skinId: t, skinRarity: r}) => {
    const i = r === Ar.SKIN_RARITY_LEGENDARY;
    return cn(t && i ? `/game/v3/planes/skins/${t}/parts/${i ? "" : `${e}/`}parts-mask@2x.webp` : `/game/v3/planes-extra/masks/parts-mask-${e}@2x.webp`)
}
  , i2 = (e, t) => cn(`/game/v3/planes/skins/${e}/${t ? `${t}/` : ""}config.json`)
  , v9 = ({skinId: e, level: t, ratio: r, isFull: i}) => _o(`/game/v3/planes/skins/${e}/${t ? `${t}/` : ""}animation/fly ${i ? "-full" : ""}.json`, r)
  , x9 = e => cn(`/game/v3/planes-extra/shadows/${e}@2x.webp`)
  , E9 = async e => vt.cache.has(e) ? vt.get(e) : vt.load(e)
  , ht = async e => {
    let t = 0;
    const r = async () => {
        try {
            return await E9(e)
        } catch (i) {
            if (t < 2)
                return t += 1,
                await rH(100),
                r();
            logger.error(i.message)
        }
    }
    ;
    return r()
}
  , T9 = async (e, t, r) => {
    let i;
    return i = await ht(e),
    !i && e?.includes("skins") && (i = await ht(ly({
        level: t,
        meta: r,
        ratio: e.includes("@2x") ? 2 : null
    }))),
    i || (i = await ht(ly({
        level: t,
        ratio: 2
    }))),
    i || (i = await ht(JO(2))),
    i || logger.error("Fail to load plane texture"),
    i
}
;
class S9 extends J {
    constructor() {
        super();
        b(this, "winAssetsLoading", {});
        b(this, "sceneStack", []);
        b(this, "isPlayingWin", !1);
        b(this, "bigWinContainer");
        b(this, "overlay");
        b(this, "hasDebugOdds", !1);
        b(this, "debugOdds");
        const {bigWinOdds: r, superWinOdds: i, epicWinOdds: n} = Yu();
        this.width = A.width,
        this.height = A.height,
        this.y = -A.height,
        this.debugOdds = {
            [Vt.BIG]: r,
            [Vt.SUPER]: i,
            [Vt.EPIC]: n
        },
        this.hasDebugOdds = Object.values(this.debugOdds).some(s => !!s),
        this.bigWinContainer = new J,
        this.bigWinContainer.width = A.width,
        this.bigWinContainer.height = A.height,
        this.bigWinContainer.y = A.height,
        this.addChild(this.bigWinContainer)
    }
    showOverlay() {
        this.overlay || (this.overlay = new at(F.WHITE),
        this.overlay.tint = "#171022",
        this.overlay.width = A.width,
        this.overlay.height = A.height,
        this.overlay.visible = !0,
        this.overlay.alpha = 0,
        this.overlay.anchor.set(0, 1),
        this.bigWinContainer.addChild(this.overlay),
        ut.to(this.overlay, {
            duration: .16,
            repeat: 0,
            pixi: {
                alpha: .75
            }
        }))
    }
    hideOverlay(r) {
        this.overlay && ut.to(this.overlay, {
            duration: .16,
            repeat: 0,
            pixi: {
                alpha: 0
            },
            onComplete: () => {
                this.overlay?.destroy(),
                this.overlay = void 0,
                r?.()
            }
        })
    }
    resize(r, i, n) {
        this.bigWinContainer.y = i,
        this.overlay && (this.overlay.width = r,
        this.overlay.height = i),
        this.sceneStack.forEach(s => {
            s?.resize(r, i, n)
        }
        )
    }
    onOddsUpdate(r) {
        const {odds: i=0} = r;
        this.hasDebugOdds && Object.entries(this.debugOdds).forEach( ([n,s]) => {
            const o = n;
            s && i > s && (this.debugOdds[o] = void 0,
            this.showWin({
                odds: 48.64,
                type: o,
                winAmount: "$55,478.62"
            }))
        }
        )
    }
    async loadWin(r) {
        this.winAssetsLoading[r] = !0;
        const i = [ht(A.assetsUrls[`${r}Win`]), ht(A.assetsUrls.bigWinGlow), ht(A.assetsUrls.bigWinBoard), ht(A.assetsUrls.bigWinCoins), ht(A.assetsUrls.bigWinLight)]
          , [n] = await Promise.all(i);
        return n && (this.winAssetsLoading[r] = !1),
        n
    }
    async showWin({odds: r=0, winAmount: i, type: n}) {
        if (!r || !i || !A.isActiveTab)
            return;
        const s = n || n9(r);
        if (s === Vt.DEFAULT)
            return;
        const o = await this.loadWin(s);
        if (!o)
            return;
        const a = new _9({
            odds: r,
            winAmount: i,
            asset: o,
            type: s,
            onComplete: () => {
                this.sceneStack.shift(),
                this.hideOverlay( () => this.playWin())
            }
        });
        this.sceneStack.push(a),
        this.isPlayingWin || this.playWin()
    }
    playWin() {
        if (!this.sceneStack.length) {
            this.isPlayingWin = !1;
            return
        }
        this.isPlayingWin = !0;
        const r = this.sceneStack[0];
        this.showOverlay(),
        this.bigWinContainer.addChild(r),
        r.playWin()
    }
}
const An = {
    borderCloud: {
        y: -1690,
        vel: 2
    },
    clouds: {
        x: -104,
        y: -385,
        vel: 3 * 1.125,
        positions: [{
            type: "big",
            x: 173,
            y: -312
        }, {
            type: "big",
            x: 380,
            y: -125
        }, {
            type: "big",
            x: 656,
            y: -484
        }, {
            type: "big",
            x: 920,
            y: -88
        }, {
            type: "big",
            x: 1130,
            y: -370
        }, {
            type: "big",
            x: 1495,
            y: -429
        }, {
            type: "big",
            x: 1610,
            y: -140
        }, {
            type: "big",
            x: 2058,
            y: -240
        }, {
            type: "big",
            x: 2328,
            y: -462
        }, {
            type: "small",
            x: 323,
            y: -460
        }, {
            type: "small",
            x: 643,
            y: -268
        }, {
            type: "small",
            x: 1210,
            y: -154
        }, {
            type: "small",
            x: 1748,
            y: -286
        }, {
            type: "small",
            x: 1965,
            y: -460
        }, {
            type: "small",
            x: 2407,
            y: -90
        }]
    }
}
  , zw = 10
  , Xc = {
    BIG: "big",
    SMALL: "small"
};
class w9 extends J {
    constructor() {
        super();
        b(this, "cloudsGroups", []);
        this.y = 0,
        this.cloudsGroups = [new J, new J],
        this.addClouds()
    }
    async addClouds() {
        const r = await ht(A.assetsUrls.clouds);
        if (!r)
            return;
        const i = Object.keys(r.data.frames)
          , n = i.filter(l => l.includes(Xc.BIG))
          , s = i.filter(l => l.includes(Xc.SMALL))
          , o = An.clouds.positions.filter( ({type: l}) => l === Xc.BIG)
          , a = An.clouds.positions.filter( ({type: l}) => l === Xc.SMALL);
        this.cloudsGroups.forEach( (l, h) => {
            const u = Za(n)
              , c = Za(s);
            l.name = `Clouds ${h + 1}`,
            l.x = An.clouds.x,
            l.y = An.clouds.y - (this.cloudsGroups[h - 1]?.height ? this.cloudsGroups[h - 1].height + 40 : 0),
            o.forEach( (d, f) => {
                const g = f % u.length
                  , p = u[g]
                  , v = r.textures[p];
                this.addCloudToGroup({
                    textureId: p,
                    texture: v,
                    pos: d,
                    group: l
                })
            }
            ),
            a.forEach( (d, f) => {
                const g = f % c.length
                  , p = c[g]
                  , v = r.textures[p];
                this.addCloudToGroup({
                    textureId: p,
                    texture: v,
                    pos: d,
                    group: l
                })
            }
            ),
            this.addChild(l)
        }
        )
    }
    addCloudToGroup({texture: r, group: i, pos: n, textureId: s}) {
        if (!r)
            return;
        const o = new at(r);
        o.anchor.set(.5, .5),
        o.name = s,
        o.x = n.x,
        o.y = n.y,
        i.addChild(o)
    }
    reset() {
        this.cloudsGroups.forEach(r => {
            r.x = An.clouds.x
        }
        )
    }
    scaleAssets(r) {
        this.scale.set(r)
    }
    update(r, i) {
        const n = this.getBounds();
        n.bottom > -zw && n.top + zw < A.height && this.cloudsGroups.forEach(s => {
            s.x -= An.clouds.vel * r * i
        }
        )
    }
}
const On = (e, t) => {
    const r = Math.ceil(e)
      , i = Math.floor(t);
    return Math.floor(Math.random() * (i - r + 1)) + r
}
  , hy = (e, t) => Number((Math.random() * (e - t) + t).toFixed(2))
  , kl = 1.2
  , Ye = {
    y: -2268,
    stars: {
        vel: kl,
        items: [["star-1.webp", 50, .6, .75], ["star-2.webp", 8, .3, .55], ["star-3.webp", 6, .3, .55], ["star-4.webp", 4, .3, .55], ["star-5.webp", 2, .2, .35]]
    },
    planets: {
        vel: kl * 1.7,
        positions: [[{
            x: .26,
            y: -.33
        }, {
            x: .42,
            y: -.75
        }, {
            x: .49,
            y: -.25
        }, {
            x: .65,
            y: -.8
        }], [{
            x: .35,
            y: -.62
        }, {
            x: .4,
            y: -.11
        }, {
            x: .56,
            y: -.69
        }], [{
            x: .31,
            y: -.32
        }, {
            x: .59,
            y: -.4
        }, {
            x: .6,
            y: -.9
        }]]
    },
    asters: {
        vel: kl * 2.73,
        positions: [[{
            x: .32,
            y: -.33
        }, {
            x: .38,
            y: -.79
        }, {
            x: .57,
            y: -.48
        }]]
    },
    hole: {
        vel: kl,
        positions: [[{
            x: .4,
            y: -.67
        }]]
    },
    extra: {
        vel: kl * 5.2
    }
}
  , Ww = 4
  , A9 = 3e3
  , b9 = 6e3
  , C9 = 0
  , P9 = 50;
class I9 extends J {
    constructor() {
        super();
        b(this, "textureIds", []);
        b(this, "objNum", 0);
        b(this, "isStarted", !1);
        b(this, "currentObj");
        b(this, "timeout", null);
        this.setPosition()
    }
    setPosition() {
        const r = ri(A.height, A.breakpoint);
        this.x = Math.min((A.width - r.rightOffset) / 2 + r.gameScreenHeight / 2, A.width) + 240 * A.scale,
        this.y = -A.height
    }
    scaleAssets(r) {
        this.scale.set(r)
    }
    resize() {
        this.setPosition()
    }
    async start() {
        this.isStarted = !0;
        const r = await ht(A.assetsUrls.planets);
        if (!r)
            return;
        const i = Object.keys(r.textures);
        this.textureIds = Za(i.filter(n => n.includes("extra"))),
        this.addObject()
    }
    addObject() {
        const r = this.textureIds.length;
        if (this.objNum > 0 && this.objNum % r === 0) {
            const o = this.textureIds[r - 1]
              , a = this.textureIds.slice(0, r - 1)
              , l = Za(a);
            l.splice(On(1, r - 1), 0, o),
            this.textureIds = l
        }
        const i = this.textureIds[this.objNum % this.textureIds.length]
          , n = vt.get(A.assetsUrls.planets)
          , s = new at(n.textures[i]);
        s.anchor.set(.5, .5),
        s.name = i,
        s.x = On(C9, Math.min(P9, A.width / 2)),
        s.y = 0 - s.height / 2 - 10,
        this.objNum += 1,
        this.timeout = setTimeout( () => {
            this.currentObj = s,
            this.addChild(s)
        }
        , On(A9, b9))
    }
    reset() {
        this.removeChildren(),
        this.timeout && (clearTimeout(this.timeout),
        this.timeout = null),
        this.objNum = 0,
        this.currentObj = void 0,
        this.isStarted = !1
    }
    update(r) {
        if (this.isStarted || this.start(),
        !this.currentObj)
            return;
        const i = this.currentObj.getBounds();
        i.top + Ww < A.height ? (this.currentObj.x -= Ye.extra.vel * r,
        this.currentObj.y += Ye.extra.vel * r * .88) : i.top + Ww > A.height && (this.removeChild(this.currentObj),
        this.currentObj = void 0,
        this.addObject())
    }
}
const n2 = ({height: e, colors: t}) => {
    const r = document.createElement("canvas");
    r.width = 10,
    r.height = e;
    const i = r.getContext("2d");
    if (!i || !t.length)
        return F.EMPTY;
    const n = i.createLinearGradient(0, r.height, 0, 0);
    return t.forEach( ({offset: s, color: o}) => {
        n.addColorStop(s, o)
    }
    ),
    i.fillStyle = n,
    i.fillRect(0, 0, r.width, r.height),
    F.from(r)
}
  , ka = (e, t) => e + (e - e * t) / t
  , xi = (e, t) => e + (e - e * t) / t
  , R9 = 4
  , M9 = 40
  , O9 = 3
  , Yc = {
    PLANET: "planet",
    ASTER: "aster",
    HOLE: "hole"
}
  , Ig = () => {
    const e = A.height / Math.sin(M9 * Math.PI / 180)
      , t = Math.sqrt(e ** 2 - A.height ** 2);
    return {
        height: A.height,
        width: t * 2 + A.width
    }
}
;
class N9 extends J {
    constructor() {
        super();
        b(this, "starTexture", F.EMPTY);
        b(this, "starsTile", null);
        b(this, "planetsContainer");
        b(this, "planets");
        b(this, "stars");
        b(this, "spaceObjects");
        b(this, "distanceY", 0);
        b(this, "patternNum", 0);
        b(this, "emptySprite");
        b(this, "shuffledPlanets", []);
        b(this, "shuffledAsters", []);
        b(this, "holeTextureId", "");
        this.y = 0,
        this.planetsContainer = new J,
        this.planetsContainer.name = "PlanetsContainer",
        this.planetsContainer.y = -A.height,
        this.planets = new J,
        this.planets.name = "Planets",
        this.stars = new J,
        this.stars.name = "Stars";
        const r = Ig();
        this.emptySprite = new at(F.EMPTY),
        this.emptySprite.name = "empty",
        this.emptySprite.width = r.width,
        this.emptySprite.height = r.height,
        this.emptySprite.anchor.set(0, 1),
        this.planetsContainer.addChild(this.emptySprite),
        this.planetsContainer.addChild(this.planets),
        this.spaceObjects = new I9,
        this.addChild(this.stars);
        try {
            this.createStarsTexture()
        } catch {
            logger.info("Stars error:", {
                prefix: "[GAME SCENE]"
            })
        }
        this.addChild(this.planetsContainer),
        this.addPlanets(),
        this.addChild(this.spaceObjects)
    }
    async createStarsTexture() {
        const r = await ht(A.assetsUrls.stars);
        if (!r?.textures)
            return;
        const i = new J
          , n = [];
        Ye.stars.items.forEach( ([s,o,a,l]) => {
            for (let h = 0; h < o; h += 1)
                n.push({
                    starId: s,
                    alpha: hy(a, l)
                })
        }
        ),
        n.forEach( ({starId: s, alpha: o}) => {
            const a = r.textures[s];
            if (a) {
                const l = new at(a);
                l.position = {
                    x: On(0, 600),
                    y: -On(0, 600)
                },
                l.alpha = o,
                i.addChild(l)
            }
        }
        ),
        this.starTexture = Lo.renderer.generateTexture(i),
        i.destroy(),
        this.addStars()
    }
    addStars() {
        this.starsTile = new wi(this.starTexture,xi(A.width, A.scale) + 5,xi(A.height, A.scale) + 5),
        this.starsTile.y = 0,
        this.starsTile.anchor.set(0, 1),
        this.starsTile.width = xi(A.width, A.scale) + 5,
        this.starsTile.height = xi(A.height, A.scale) + 5,
        this.starsTile.scale.set(A.scale),
        this.stars.addChild(this.starsTile)
    }
    async addPlanets() {
        const r = await ht(A.assetsUrls.planets);
        if (!r)
            return;
        const i = Object.keys(r.textures)
          , n = i.filter(f => f.includes(Yc.PLANET))
          , s = i.filter(f => f.includes(Yc.ASTER))
          , o = i.filter(f => f.includes(Yc.HOLE))
          , a = this.patternNum % 3
          , l = Ye.planets.positions[a] || Ye.planets.positions[0]
          , h = Ye.asters.positions[a] || Ye.asters.positions[0]
          , u = Ye.hole.positions[a] || Ye.hole.positions[0];
        this.shuffledPlanets = [...this.shuffledPlanets, ...Za(n.filter(f => !this.shuffledPlanets.includes(f)))],
        this.shuffledAsters = [...this.shuffledAsters, ...Za(s.filter(f => !this.shuffledAsters.includes(f)))],
        this.patternNum % 3 === 0 && u.forEach(f => {
            const g = o.length && o.find(v => v !== this.holeTextureId) || o[0];
            this.holeTextureId = g;
            const p = r.textures[g];
            this.addObjectToGroup({
                textureId: g,
                texture: p,
                pos: f,
                vel: Ye.hole.vel
            })
        }
        );
        const c = this.shuffledPlanets.splice(0, l.length)
          , d = this.shuffledAsters.splice(0, h.length);
        l.forEach( (f, g) => {
            const p = c[g]
              , v = r.textures[p];
            this.addObjectToGroup({
                textureId: p,
                texture: v,
                pos: f,
                vel: Ye.planets.vel
            })
        }
        ),
        h.forEach( (f, g) => {
            const p = d[g]
              , v = r.textures[p];
            this.addObjectToGroup({
                textureId: p,
                texture: v,
                pos: f,
                vel: Ye.asters.vel
            })
        }
        )
    }
    addObjectToGroup({texture: r, pos: i, textureId: n, vel: s}) {
        if (!r)
            return;
        const o = Ig()
          , a = new at(r);
        a.anchor.set(.5, .5),
        a.name = `${this.patternNum % O9 + 1}-${n}`,
        a.scale.set(A.scale),
        a.x = i.x * o.width,
        a.y = i.y * o.height,
        a.vel = s,
        n.includes(Yc.ASTER) && (a.angle = On(-40, 40),
        a.rotationVel = hy(.25, .5)),
        this.planets.addChild(a)
    }
    reset() {
        this.patternNum = 0,
        this.distanceY = 0,
        this.spaceObjects.reset(),
        this.planets.removeChildren(),
        this.addPlanets(),
        this.starsTile && (this.starsTile.tilePosition.x = 0,
        this.starsTile.tilePosition.y = 0)
    }
    scaleAssets(r) {
        this.spaceObjects.scaleAssets(r),
        this.starsTile && this.starsTile.scale.set(r)
    }
    resize(r, i, n) {
        this.spaceObjects.resize(),
        this.planetsContainer.y = -i,
        this.starsTile && (this.starsTile.width = xi(r, n) + 5,
        this.starsTile.height = xi(i, n) + 5);
        const s = Ig();
        this.emptySprite.width = s.width,
        this.emptySprite.height = s.height,
        this.planets.children.forEach(o => {
            o && o.scale.set(n)
        }
        )
    }
    update(r) {
        if (this.spaceObjects.update(r),
        this.distanceY += Ye.planets.vel * r * A.scale * .88,
        this.distanceY > A.height) {
            this.distanceY = 0,
            this.patternNum += 1,
            this.addPlanets();
            return
        }
        this.starsTile && (Math.abs(this.starsTile.tilePosition.x) >= this.starTexture.width && (this.starsTile.tilePosition.x = 0),
        this.starsTile.tilePosition.y >= this.starTexture.height && (this.starsTile.tilePosition.y = 0),
        this.starsTile.tilePosition.x -= Ye.stars.vel * r,
        this.starsTile.tilePosition.y += Ye.stars.vel * r * .88),
        this.planets.children.forEach(i => {
            if (!i)
                return;
            if (i.getBounds().top + R9 > A.height) {
                i.destroy();
                return
            }
            i.x -= (i.vel || 2.1) * r * A.scale,
            i.y += (i.vel || 2.1) * r * A.scale * .88,
            i.rotationVel && (i.angle -= i.rotationVel * r)
        }
        )
    }
}
const L9 = [{
    offset: 0,
    color: "#ffddb2"
}, {
    offset: .0641,
    color: "#efc28c"
}, {
    offset: .0969,
    color: "#dc9185"
}, {
    offset: .1464,
    color: "#b46888"
}, {
    offset: .3204,
    color: "#704183"
}, {
    offset: .5021,
    color: "#462273"
}, {
    offset: .5673,
    color: "#271c53"
}, {
    offset: .7091,
    color: "#141756"
}, {
    offset: 1,
    color: "#090f3f"
}]
  , s2 = [{
    offset: 0,
    color: "#383438"
}, {
    offset: .72,
    color: "#4D4349"
}, {
    offset: 1,
    color: "rgba(87, 78, 86, 0)"
}];
class D9 extends J {
    constructor() {
        super();
        b(this, "displacementSprite");
        b(this, "flagpole");
        b(this, "posX", 878);
        b(this, "posY", -61);
        this.x = this.posX,
        this.y = this.posY,
        this.addFlag()
    }
    async addFlag() {
        if (A.assetsUrls.flagpole?.includes("json")) {
            const o = await ht(A.assetsUrls.flagpole);
            if (!o?.textures)
                return;
            const {textures: a={}} = o
              , l = new Le(Object.values(a));
            l.loop = !0,
            l.animationSpeed = .04,
            l.play(),
            this.flagpole = l
        } else {
            const o = await ht(A.assetsUrls.flagpole);
            if (!o)
                return;
            this.flagpole = new at(o)
        }
        this.flagpole.anchor.set(0, 1);
        let r, i;
        const n = ht(A.assetsUrls.flag)
          , s = ht(A.assetsUrls.platformLogo);
        try {
            r = await n,
            i = await s
        } catch (o) {
            logger.error(o, {
                prefix: "[GAME_FLAG]"
            })
        }
        if (r) {
            const o = new at(r);
            o.anchor.set(.5),
            o.width = 57,
            o.height = 28;
            const a = new J;
            if (a.name = "flagContainer",
            a.x = 25,
            a.pivot.x = o.width / 2,
            a.y = -this.flagpole.height + 26,
            a.addChild(o),
            i) {
                const l = new at(i)
                  , h = A.assetsUrls.platformLogo.match(/__(\d+)-(\d+)\.(png|webp|jpg|jpeg|gif)/);
                if (l.anchor.set(.5),
                h?.[1]) {
                    const u = l.texture.height / l.texture.width;
                    l.width = Math.max(Number(h?.[1]), 54),
                    l.height = h?.[2] ? Number(h?.[2]) : Math.round(l.width * u)
                }
                a.addChild(l)
            }
            try {
                const l = await ht(A.assetsUrls.flagFilter);
                if (l) {
                    this.displacementSprite = new at(l),
                    this.displacementSprite.texture.baseTexture.wrapMode = Ci.REPEAT;
                    const h = new Rx(this.displacementSprite);
                    h.padding = 10,
                    h.scale.x = 1,
                    h.scale.y = 15,
                    this.displacementSprite.position = o.position,
                    a.filters = [h],
                    a.addChild(this.displacementSprite)
                }
            } catch (l) {
                logger.error(l, {
                    prefix: "[GAME_FLAG]"
                })
            }
            this.addChild(this.flagpole),
            this.addChild(a)
        }
    }
    reset() {
        this.visible = !0
    }
    update(r) {
        this.displacementSprite && (this.displacementSprite.x -= 1 * r,
        Math.abs(this.displacementSprite.x) > this.displacementSprite.width && (this.displacementSprite.x = 0))
    }
}
class B9 extends J {
    constructor() {
        super();
        b(this, "tree");
        this.cullable = !0,
        this.x = A.reskin?.airport?.nyTree?.x || 629,
        this.y = A.reskin?.airport?.nyTree?.y || -97,
        this.init()
    }
    async init() {
        const r = await ht(A.assetsUrls.nyTree);
        if (!r?.textures)
            return;
        const {textures: i={}} = r
          , n = Object.values(i)
          , s = [n[0], n[2], n[1], n[2]];
        this.tree = new Le(s),
        this.tree.loop = !0,
        this.tree.anchor.set(0, 1),
        this.tree.animationSpeed = .04,
        this.tree.play(),
        this.addChild(this.tree)
    }
}
const Fl = 2.8
  , Re = {
    l1: {
        x: 0,
        y: 0,
        vel: Fl
    },
    l2: {
        x: -376,
        y: -92,
        vel: Fl * .9
    },
    l3: {
        x: 499,
        y: -90,
        vel: Fl * .85
    },
    l4: {
        x: -370,
        y: -77,
        vel: Fl * .8
    },
    l5: {
        x: 359,
        y: -103,
        vel: Fl * .7
    },
    l6: {
        x: 0,
        y: 0,
        vel: 0
    }
}
  , Kc = 575
  , k9 = () => KO * A.scale;
class F9 extends J {
    constructor() {
        super();
        b(this, "allGroundL1");
        b(this, "hillsL3Container");
        b(this, "backView");
        b(this, "groundGradient");
        b(this, "mountainsL2");
        b(this, "mountainsL2L");
        b(this, "mountainsL2R");
        b(this, "mountainsL4");
        b(this, "mountainsL5");
        b(this, "skyL6");
        b(this, "skyL6Clouds");
        b(this, "skyL6Moon");
        b(this, "flag");
        b(this, "nyTree");
        this.cullable = !0,
        this.pivot.x = Kc,
        this.backView = new J,
        this.backView.name = "BackView",
        this.mountainsL2 = new J,
        this.mountainsL2.name = "Mountains L2",
        this.mountainsL2.sortableChildren = !0,
        this.mountainsL2L = new at(vt.get("airportL2MountainsL")),
        this.mountainsL2L.anchor.set(0, 1),
        this.mountainsL2L.y = -14,
        this.mountainsL2R = new at(vt.get("airportL2MountainsR")),
        this.mountainsL2R.anchor.set(0, 1),
        this.mountainsL2R.x = this.mountainsL2L.width + 365,
        this.mountainsL2R.zIndex = 10,
        this.mountainsL2.addChild(this.mountainsL2L, this.mountainsL2R),
        [1, 2].forEach(g => {
            const p = new at(vt.get("airportL2MountainsL"));
            p.anchor.set(0, 1),
            p.x = this.mountainsL2.width - 70,
            p.zIndex = this.mountainsL2R.zIndex - g,
            this.mountainsL2.addChild(p)
        }
        ),
        this.hillsL3Container = new J,
        this.hillsL3Container.name = "Hills L3";
        const r = new at(vt.get("airportL3Hills"));
        r.anchor.set(0, 1),
        this.hillsL3Container.addChild(r),
        A.reskin?.airport?.windmill?.disabled || this.addWindmills();
        const i = vt.get("airportL4Mountains");
        this.mountainsL4 = new wi(i,i.width * 3,i.height),
        this.mountainsL4.anchor.set(0, 1);
        const n = vt.get("airportL5Mountains");
        this.mountainsL5 = new wi(n,ka(A.width + Kc * A.scale - this.getOffsetX(), A.scale),n.height),
        this.mountainsL5.anchor.set(0, 1),
        this.skyL6 = new J,
        this.skyL6.name = "Sky",
        this.skyL6.sortableChildren = !0;
        const s = vt.get("airportL6Sky");
        this.skyL6Clouds = new wi(s,ka(A.width + Kc * A.scale - this.getOffsetX(), A.scale),s.height),
        this.skyL6Clouds.anchor.set(0, 1),
        this.skyL6Clouds.zIndex = 2,
        A.reskin?.airport?.moon && (this.skyL6Moon = new at(vt.get("airportL6Moon")),
        this.skyL6Moon.anchor.set(0, 1),
        this.skyL6Moon.x = A.reskin?.airport?.moon?.x || 0,
        this.skyL6Moon.y = A.reskin?.airport?.moon?.y || 0,
        this.skyL6Moon.zIndex = A.reskin?.airport?.moon?.zIndex || 1,
        this.skyL6.addChild(this.skyL6Moon)),
        this.skyL6.addChild(this.skyL6Clouds),
        this.allGroundL1 = new J,
        this.allGroundL1.name = "Ground";
        const o = vt.get("airportTerminal")
          , a = vt.get("airportTileGround")
          , l = o.width || 0
          , h = a.height || 0
          , u = a.width || 0
          , c = new wi(a,u * 3,h);
        c.x = l,
        c.anchor.set(0, 1);
        const d = new at(o);
        d.anchor.set(0, 1);
        const f = 145;
        this.groundGradient = new at(n2({
            height: f,
            colors: A.reskin?.gradients?.road || s2
        })),
        this.groundGradient.width = o.width + c.width,
        this.groundGradient.height = f,
        this.groundGradient.y = 100,
        this.groundGradient.anchor.set(0, 1),
        this.groundGradient.name = "GroundGradient",
        this.allGroundL1.addChild(d, c, this.groundGradient),
        A.reskin?.airport?.roadPaint && this.addRoadPaint(),
        A.reskin?.airport?.custom?.length && A.reskin?.airport?.custom.forEach(g => {
            this.addCustomItem(g)
        }
        ),
        this.flag = new D9,
        this.allGroundL1.addChild(this.flag),
        A.reskin?.airport?.nyTree && (this.nyTree = new B9,
        this.allGroundL1.addChild(this.nyTree)),
        this.backView.addChild(this.skyL6, this.mountainsL5, this.mountainsL4, this.hillsL3Container, this.mountainsL2),
        this.addChild(this.backView),
        this.addChild(this.allGroundL1),
        this.scaleAssets(A.scale),
        this.setPosition()
    }
    async addWindmills() {
        const r = await ht(A.assetsUrls.airportWindmill);
        if (!r?.textures)
            return;
        const i = A.reskin?.airport?.windmill?.isNewPos
          , n = new Le(Object.values(r.textures));
        n.name = "Windmill1",
        i ? (n.x = 145,
        n.y = -73) : (n.x = 151,
        n.y = -74),
        n.anchor.set(.5),
        n.animationSpeed = .26,
        n.zIndex = 1,
        n.play();
        const s = new Le(Object.values(r.textures));
        s.name = "Windmill2",
        i ? (s.x = 175,
        s.y = -68) : (s.x = 179,
        s.y = -66),
        s.anchor.set(.5),
        s.animationSpeed = .26,
        s.zIndex = 1,
        s.play(),
        this.hillsL3Container.addChild(n, s)
    }
    async addRoadPaint() {
        const r = await ht(A.assetsUrls.airportRoadPaint);
        if (!r)
            return;
        const {x: i, y: n} = A.reskin?.airport?.roadPaint || {}
          , s = new at(r);
        s.x = i || 0,
        s.y = n || 0,
        s.anchor.set(0, 1),
        this.allGroundL1.addChild(s)
    }
    async addCustomItem(r) {
        const i = await ht(A.assetsUrls[r.asset]);
        if (!i)
            return;
        const n = new at(i);
        n.x = r.x || 0,
        n.y = r.y || 0,
        n.anchor.set(0, 1),
        this.allGroundL1.addChild(n)
    }
    getOffsetX() {
        const r = ri(A.height, A.breakpoint)
          , i = this.pivot.x * this.scale.x;
        return Math.min((A.width - r.rightOffset) / 2 - k9() / 2, i)
    }
    setPosition() {
        this.x = this.getOffsetX(),
        this.allGroundL1.x = Re.l1.x,
        this.allGroundL1.y = Re.l1.y,
        this.mountainsL2.x = Re.l2.x,
        this.mountainsL2.y = Re.l2.y,
        this.hillsL3Container.x = Re.l3.x,
        this.hillsL3Container.y = Re.l3.y,
        this.mountainsL4.x = Re.l4.x,
        this.mountainsL4.y = Re.l4.y,
        this.mountainsL5.tilePosition.x = Re.l5.x,
        this.mountainsL5.y = Re.l5.y,
        this.skyL6.x = Re.l6.x,
        this.skyL6.y = Re.l6.y,
        this.skyL6Clouds.tilePosition.x = 0,
        this.skyL6Moon && (this.skyL6Moon.x = A.reskin?.airport?.moon?.x || 0,
        this.skyL6Clouds.tilePosition.x = 0)
    }
    reset() {
        this.setPosition()
    }
    scaleAssets(r) {
        this.scale.set(r)
    }
    resize(r, i, n) {
        this.scaleAssets(n);
        const s = ka(r + Kc * n - this.getOffsetX(), n);
        this.mountainsL5.width = s,
        this.skyL6Clouds.width = s,
        this.setPosition()
    }
    update(r, i) {
        this.allGroundL1.x -= Re.l1.vel * r * i,
        this.mountainsL2.x -= Re.l2.vel * r * i,
        this.hillsL3Container.x -= Re.l3.vel * r * i,
        this.mountainsL4.x -= Re.l4.vel * r * i,
        this.mountainsL5.tilePosition.x -= Re.l5.vel * r * i,
        A.reskin?.airport?.sky?.vel && (this.skyL6Clouds.tilePosition.x -= (A.reskin?.airport?.sky?.vel || 0) * r * (i || 1)),
        this.skyL6Moon && (this.skyL6Moon.x -= (A.reskin?.airport?.moon?.vel || 0) * r * i)
    }
    updateFromStart(r, i) {
        this.getBounds().top + 10 > A.height || (this.flag.update(r),
        this.skyL6Clouds && A.reskin?.airport?.clouds?.vel && (this.skyL6Clouds.tilePosition.x -= A.reskin.airport.clouds.vel * r * (i || 1)))
    }
}
/*!
 * @pixi/particle-emitter - v5.0.8
 * Compiled Mon, 28 Nov 2022 04:01:38 UTC
 *
 * @pixi/particle-emitter is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
class rn {
    constructor(t, r, i) {
        this.value = t,
        this.time = r,
        this.next = null,
        this.isStepped = !1,
        i ? this.ease = typeof i == "function" ? i : l2(i) : this.ease = null
    }
    static createList(t) {
        if ("list"in t) {
            const i = t.list;
            let n;
            const {value: s, time: o} = i[0]
              , a = n = new rn(typeof s == "string" ? qc(s) : s,o,t.ease);
            if (i.length > 2 || i.length === 2 && i[1].value !== s)
                for (let l = 1; l < i.length; ++l) {
                    const {value: h, time: u} = i[l];
                    n.next = new rn(typeof h == "string" ? qc(h) : h,u),
                    n = n.next
                }
            return a.isStepped = !!t.isStepped,
            a
        }
        const r = new rn(typeof t.start == "string" ? qc(t.start) : t.start,0);
        return t.end !== t.start && (r.next = new rn(typeof t.end == "string" ? qc(t.end) : t.end,1)),
        r
    }
}
let Su = F.from;
const Zi = Math.PI / 180;
function Nn(e, t) {
    if (!e)
        return;
    const r = Math.sin(e)
      , i = Math.cos(e)
      , n = t.x * i - t.y * r
      , s = t.x * r + t.y * i;
    t.x = n,
    t.y = s
}
function Vp(e, t, r) {
    return e << 16 | t << 8 | r
}
function o2(e) {
    return Math.sqrt(e.x * e.x + e.y * e.y)
}
function U9(e) {
    const t = 1 / o2(e);
    e.x *= t,
    e.y *= t
}
function a2(e, t) {
    e.x *= t,
    e.y *= t
}
function qc(e, t) {
    t || (t = {}),
    e.charAt(0) === "#" ? e = e.substr(1) : e.indexOf("0x") === 0 && (e = e.substr(2));
    let r;
    return e.length === 8 && (r = e.substr(0, 2),
    e = e.substr(2)),
    t.r = parseInt(e.substr(0, 2), 16),
    t.g = parseInt(e.substr(2, 2), 16),
    t.b = parseInt(e.substr(4, 2), 16),
    r && (t.a = parseInt(r, 16)),
    t
}
function l2(e) {
    const t = e.length
      , r = 1 / t;
    return function(i) {
        const n = t * i | 0
          , s = (i - n * r) * t
          , o = e[n] || e[t - 1];
        return o.s + s * (2 * (1 - s) * (o.cp - o.s) + s * (o.e - o.s))
    }
}
function G9(e) {
    return e ? (e = e.toUpperCase().replace(/ /g, "_"),
    tt[e] || tt.NORMAL) : tt.NORMAL
}
class Rg extends at {
    constructor(t) {
        super(),
        this.prevChild = this.nextChild = null,
        this.emitter = t,
        this.config = {},
        this.anchor.x = this.anchor.y = .5,
        this.maxLife = 0,
        this.age = 0,
        this.agePercent = 0,
        this.oneOverLife = 0,
        this.next = null,
        this.prev = null,
        this.init = this.init,
        this.kill = this.kill
    }
    init(t) {
        this.maxLife = t,
        this.age = this.agePercent = 0,
        this.rotation = 0,
        this.position.x = this.position.y = 0,
        this.scale.x = this.scale.y = 1,
        this.tint = 16777215,
        this.alpha = 1,
        this.oneOverLife = 1 / this.maxLife,
        this.visible = !0
    }
    kill() {
        this.emitter.recycle(this)
    }
    destroy() {
        this.parent && this.parent.removeChild(this),
        this.emitter = this.next = this.prev = null,
        super.destroy()
    }
}
var Ot;
(function(e) {
    e[e.Spawn = 0] = "Spawn",
    e[e.Normal = 2] = "Normal",
    e[e.Late = 5] = "Late"
}
)(Ot || (Ot = {}));
const Mg = $t.shared
  , Ys = Symbol("Position particle per emitter position");
class Tt {
    constructor(t, r) {
        this.initBehaviors = [],
        this.updateBehaviors = [],
        this.recycleBehaviors = [],
        this.minLifetime = 0,
        this.maxLifetime = 0,
        this.customEase = null,
        this._frequency = 1,
        this.spawnChance = 1,
        this.maxParticles = 1e3,
        this.emitterLifetime = -1,
        this.spawnPos = new st,
        this.particlesPerWave = 1,
        this.rotation = 0,
        this.ownerPos = new st,
        this._prevEmitterPos = new st,
        this._prevPosIsValid = !1,
        this._posChanged = !1,
        this._parent = null,
        this.addAtBack = !1,
        this.particleCount = 0,
        this._emit = !1,
        this._spawnTimer = 0,
        this._emitterLife = -1,
        this._activeParticlesFirst = null,
        this._activeParticlesLast = null,
        this._poolFirst = null,
        this._origConfig = null,
        this._autoUpdate = !1,
        this._destroyWhenComplete = !1,
        this._completeCallback = null,
        this.parent = t,
        r && this.init(r),
        this.recycle = this.recycle,
        this.update = this.update,
        this.rotate = this.rotate,
        this.updateSpawnPos = this.updateSpawnPos,
        this.updateOwnerPos = this.updateOwnerPos
    }
    static registerBehavior(t) {
        Tt.knownBehaviors[t.type] = t
    }
    get frequency() {
        return this._frequency
    }
    set frequency(t) {
        typeof t == "number" && t > 0 ? this._frequency = t : this._frequency = 1
    }
    get parent() {
        return this._parent
    }
    set parent(t) {
        this.cleanup(),
        this._parent = t
    }
    init(t) {
        if (!t)
            return;
        this.cleanup(),
        this._origConfig = t,
        this.minLifetime = t.lifetime.min,
        this.maxLifetime = t.lifetime.max,
        t.ease ? this.customEase = typeof t.ease == "function" ? t.ease : l2(t.ease) : this.customEase = null,
        this.particlesPerWave = 1,
        t.particlesPerWave && t.particlesPerWave > 1 && (this.particlesPerWave = t.particlesPerWave),
        this.frequency = t.frequency,
        this.spawnChance = typeof t.spawnChance == "number" && t.spawnChance > 0 ? t.spawnChance : 1,
        this.emitterLifetime = t.emitterLifetime || -1,
        this.maxParticles = t.maxParticles > 0 ? t.maxParticles : 1e3,
        this.addAtBack = !!t.addAtBack,
        this.rotation = 0,
        this.ownerPos.set(0),
        t.pos ? this.spawnPos.copyFrom(t.pos) : this.spawnPos.set(0),
        this._prevEmitterPos.copyFrom(this.spawnPos),
        this._prevPosIsValid = !1,
        this._spawnTimer = 0,
        this.emit = t.emit === void 0 ? !0 : !!t.emit,
        this.autoUpdate = !!t.autoUpdate;
        const r = t.behaviors.map(i => {
            const n = Tt.knownBehaviors[i.type];
            return n ? new n(i.config) : (console.error(`Unknown behavior: ${i.type}`),
            null)
        }
        ).filter(i => !!i);
        r.push(Ys),
        r.sort( (i, n) => i === Ys ? n.order === Ot.Spawn ? 1 : -1 : n === Ys ? i.order === Ot.Spawn ? -1 : 1 : i.order - n.order),
        this.initBehaviors = r.slice(),
        this.updateBehaviors = r.filter(i => i !== Ys && i.updateParticle),
        this.recycleBehaviors = r.filter(i => i !== Ys && i.recycleParticle)
    }
    getBehavior(t) {
        return Tt.knownBehaviors[t] && this.initBehaviors.find(r => r instanceof Tt.knownBehaviors[t]) || null
    }
    fillPool(t) {
        for (; t > 0; --t) {
            const r = new Rg(this);
            r.next = this._poolFirst,
            this._poolFirst = r
        }
    }
    recycle(t, r=!1) {
        for (let i = 0; i < this.recycleBehaviors.length; ++i)
            this.recycleBehaviors[i].recycleParticle(t, !r);
        t.next && (t.next.prev = t.prev),
        t.prev && (t.prev.next = t.next),
        t === this._activeParticlesLast && (this._activeParticlesLast = t.prev),
        t === this._activeParticlesFirst && (this._activeParticlesFirst = t.next),
        t.prev = null,
        t.next = this._poolFirst,
        this._poolFirst = t,
        t.parent && t.parent.removeChild(t),
        --this.particleCount
    }
    rotate(t) {
        if (this.rotation === t)
            return;
        const r = t - this.rotation;
        this.rotation = t,
        Nn(r, this.spawnPos),
        this._posChanged = !0
    }
    updateSpawnPos(t, r) {
        this._posChanged = !0,
        this.spawnPos.x = t,
        this.spawnPos.y = r
    }
    updateOwnerPos(t, r) {
        this._posChanged = !0,
        this.ownerPos.x = t,
        this.ownerPos.y = r
    }
    resetPositionTracking() {
        this._prevPosIsValid = !1
    }
    get emit() {
        return this._emit
    }
    set emit(t) {
        this._emit = !!t,
        this._emitterLife = this.emitterLifetime
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        this._autoUpdate && !t ? Mg.remove(this.update, this) : !this._autoUpdate && t && Mg.add(this.update, this),
        this._autoUpdate = !!t
    }
    playOnceAndDestroy(t) {
        this.autoUpdate = !0,
        this.emit = !0,
        this._destroyWhenComplete = !0,
        this._completeCallback = t
    }
    playOnce(t) {
        this.emit = !0,
        this._completeCallback = t
    }
    update(t) {
        if (this._autoUpdate && (t = Mg.elapsedMS * .001),
        !this._parent)
            return;
        for (let o = this._activeParticlesFirst, a; o; o = a)
            if (a = o.next,
            o.age += t,
            o.age > o.maxLife || o.age < 0)
                this.recycle(o);
            else {
                let l = o.age * o.oneOverLife;
                this.customEase && (this.customEase.length === 4 ? l = this.customEase(l, 0, 1, 1) : l = this.customEase(l)),
                o.agePercent = l;
                for (let h = 0; h < this.updateBehaviors.length; ++h)
                    if (this.updateBehaviors[h].updateParticle(o, t)) {
                        this.recycle(o);
                        break
                    }
            }
        let r, i;
        this._prevPosIsValid && (r = this._prevEmitterPos.x,
        i = this._prevEmitterPos.y);
        const n = this.ownerPos.x + this.spawnPos.x
          , s = this.ownerPos.y + this.spawnPos.y;
        if (this._emit)
            for (this._spawnTimer -= t < 0 ? 0 : t; this._spawnTimer <= 0; ) {
                if (this._emitterLife >= 0 && (this._emitterLife -= this._frequency,
                this._emitterLife <= 0)) {
                    this._spawnTimer = 0,
                    this._emitterLife = 0,
                    this.emit = !1;
                    break
                }
                if (this.particleCount >= this.maxParticles) {
                    this._spawnTimer += this._frequency;
                    continue
                }
                let o, a;
                if (this._prevPosIsValid && this._posChanged) {
                    const u = 1 + this._spawnTimer / t;
                    o = (n - r) * u + r,
                    a = (s - i) * u + i
                } else
                    o = n,
                    a = s;
                let l = null
                  , h = null;
                for (let u = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), c = 0; c < u; ++c) {
                    if (this.spawnChance < 1 && Math.random() >= this.spawnChance)
                        continue;
                    let d;
                    if (this.minLifetime === this.maxLifetime ? d = this.minLifetime : d = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime,
                    -this._spawnTimer >= d)
                        continue;
                    let f;
                    this._poolFirst ? (f = this._poolFirst,
                    this._poolFirst = this._poolFirst.next,
                    f.next = null) : f = new Rg(this),
                    f.init(d),
                    this.addAtBack ? this._parent.addChildAt(f, 0) : this._parent.addChild(f),
                    l ? (h.next = f,
                    f.prev = h,
                    h = f) : h = l = f,
                    ++this.particleCount
                }
                if (l) {
                    this._activeParticlesLast ? (this._activeParticlesLast.next = l,
                    l.prev = this._activeParticlesLast,
                    this._activeParticlesLast = h) : (this._activeParticlesFirst = l,
                    this._activeParticlesLast = h);
                    for (let u = 0; u < this.initBehaviors.length; ++u) {
                        const c = this.initBehaviors[u];
                        if (c === Ys)
                            for (let d = l, f; d; d = f) {
                                f = d.next,
                                this.rotation !== 0 && (Nn(this.rotation, d.position),
                                d.rotation += this.rotation),
                                d.position.x += o,
                                d.position.y += a,
                                d.age += -this._spawnTimer;
                                let g = d.age * d.oneOverLife;
                                this.customEase && (this.customEase.length === 4 ? g = this.customEase(g, 0, 1, 1) : g = this.customEase(g)),
                                d.agePercent = g
                            }
                        else
                            c.initParticles(l)
                    }
                    for (let u = l, c; u; u = c) {
                        c = u.next;
                        for (let d = 0; d < this.updateBehaviors.length; ++d)
                            if (this.updateBehaviors[d].updateParticle(u, -this._spawnTimer)) {
                                this.recycle(u);
                                break
                            }
                    }
                }
                this._spawnTimer += this._frequency
            }
        if (this._posChanged && (this._prevEmitterPos.x = n,
        this._prevEmitterPos.y = s,
        this._prevPosIsValid = !0,
        this._posChanged = !1),
        !this._emit && !this._activeParticlesFirst) {
            if (this._completeCallback) {
                const o = this._completeCallback;
                this._completeCallback = null,
                o()
            }
            this._destroyWhenComplete && this.destroy()
        }
    }
    emitNow() {
        const t = this.ownerPos.x + this.spawnPos.x
          , r = this.ownerPos.y + this.spawnPos.y;
        let i = null
          , n = null;
        for (let s = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), o = 0; o < s; ++o) {
            if (this.spawnChance < 1 && Math.random() >= this.spawnChance)
                continue;
            let a;
            this._poolFirst ? (a = this._poolFirst,
            this._poolFirst = this._poolFirst.next,
            a.next = null) : a = new Rg(this);
            let l;
            this.minLifetime === this.maxLifetime ? l = this.minLifetime : l = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime,
            a.init(l),
            this.addAtBack ? this._parent.addChildAt(a, 0) : this._parent.addChild(a),
            i ? (n.next = a,
            a.prev = n,
            n = a) : n = i = a,
            ++this.particleCount
        }
        if (i) {
            this._activeParticlesLast ? (this._activeParticlesLast.next = i,
            i.prev = this._activeParticlesLast,
            this._activeParticlesLast = n) : (this._activeParticlesFirst = i,
            this._activeParticlesLast = n);
            for (let s = 0; s < this.initBehaviors.length; ++s) {
                const o = this.initBehaviors[s];
                if (o === Ys)
                    for (let a = i, l; a; a = l)
                        l = a.next,
                        this.rotation !== 0 && (Nn(this.rotation, a.position),
                        a.rotation += this.rotation),
                        a.position.x += t,
                        a.position.y += r;
                else
                    o.initParticles(i)
            }
        }
    }
    cleanup() {
        let t, r;
        for (t = this._activeParticlesFirst; t; t = r)
            r = t.next,
            this.recycle(t, !0);
        this._activeParticlesFirst = this._activeParticlesLast = null,
        this.particleCount = 0
    }
    get destroyed() {
        return !(this._parent && this.initBehaviors.length)
    }
    destroy() {
        this.autoUpdate = !1,
        this.cleanup();
        let t;
        for (let r = this._poolFirst; r; r = t)
            t = r.next,
            r.destroy();
        this._poolFirst = this._parent = this.spawnPos = this.ownerPos = this.customEase = this._completeCallback = null,
        this.initBehaviors.length = this.updateBehaviors.length = this.recycleBehaviors.length = 0
    }
}
Tt.knownBehaviors = {};
class n1 {
    constructor(t) {
        this.x = t.x,
        this.y = t.y,
        this.w = t.w,
        this.h = t.h
    }
    getRandPos(t) {
        t.x = Math.random() * this.w + this.x,
        t.y = Math.random() * this.h + this.y
    }
}
n1.type = "rect";
n1.editorConfig = null;
class jp {
    constructor(t) {
        this.x = t.x || 0,
        this.y = t.y || 0,
        this.radius = t.radius,
        this.innerRadius = t.innerRadius || 0,
        this.rotation = !!t.affectRotation
    }
    getRandPos(t) {
        this.innerRadius !== this.radius ? t.x = Math.random() * (this.radius - this.innerRadius) + this.innerRadius : t.x = this.radius,
        t.y = 0;
        const r = Math.random() * Math.PI * 2;
        this.rotation && (t.rotation += r),
        Nn(r, t.position),
        t.position.x += this.x,
        t.position.y += this.y
    }
}
jp.type = "torus";
jp.editorConfig = null;
class s1 {
    constructor(t) {
        this.segments = [],
        this.countingLengths = [],
        this.totalLength = 0,
        this.init(t)
    }
    init(t) {
        if (!t || !t.length)
            this.segments.push({
                p1: {
                    x: 0,
                    y: 0
                },
                p2: {
                    x: 0,
                    y: 0
                },
                l: 0
            });
        else if (Array.isArray(t[0]))
            for (let r = 0; r < t.length; ++r) {
                const i = t[r];
                let n = i[0];
                for (let s = 1; s < i.length; ++s) {
                    const o = i[s];
                    this.segments.push({
                        p1: n,
                        p2: o,
                        l: 0
                    }),
                    n = o
                }
            }
        else {
            let r = t[0];
            for (let i = 1; i < t.length; ++i) {
                const n = t[i];
                this.segments.push({
                    p1: r,
                    p2: n,
                    l: 0
                }),
                r = n
            }
        }
        for (let r = 0; r < this.segments.length; ++r) {
            const {p1: i, p2: n} = this.segments[r]
              , s = Math.sqrt((n.x - i.x) * (n.x - i.x) + (n.y - i.y) * (n.y - i.y));
            this.segments[r].l = s,
            this.totalLength += s,
            this.countingLengths.push(this.totalLength)
        }
    }
    getRandPos(t) {
        const r = Math.random() * this.totalLength;
        let i, n;
        if (this.segments.length === 1)
            i = this.segments[0],
            n = r;
        else
            for (let a = 0; a < this.countingLengths.length; ++a)
                if (r < this.countingLengths[a]) {
                    i = this.segments[a],
                    n = a === 0 ? r : r - this.countingLengths[a - 1];
                    break
                }
        n /= i.l || 1;
        const {p1: s, p2: o} = i;
        t.x = s.x + n * (o.x - s.x),
        t.y = s.y + n * (o.y - s.y)
    }
}
s1.type = "polygonalChain";
s1.editorConfig = null;
class o1 {
    constructor(t) {
        var r;
        this.order = Ot.Late,
        this.minStart = t.minStart,
        this.maxStart = t.maxStart,
        this.accel = t.accel,
        this.rotate = !!t.rotate,
        this.maxSpeed = (r = t.maxSpeed) !== null && r !== void 0 ? r : 0
    }
    initParticles(t) {
        let r = t;
        for (; r; ) {
            const i = Math.random() * (this.maxStart - this.minStart) + this.minStart;
            r.config.velocity ? r.config.velocity.set(i, 0) : r.config.velocity = new st(i,0),
            Nn(r.rotation, r.config.velocity),
            r = r.next
        }
    }
    updateParticle(t, r) {
        const i = t.config.velocity
          , n = i.x
          , s = i.y;
        if (i.x += this.accel.x * r,
        i.y += this.accel.y * r,
        this.maxSpeed) {
            const o = o2(i);
            o > this.maxSpeed && a2(i, this.maxSpeed / o)
        }
        t.x += (n + i.x) / 2 * r,
        t.y += (s + i.y) / 2 * r,
        this.rotate && (t.rotation = Math.atan2(i.y, i.x))
    }
}
o1.type = "moveAcceleration";
o1.editorConfig = null;
function H9(e) {
    return this.ease && (e = this.ease(e)),
    (this.first.next.value - this.first.value) * e + this.first.value
}
function $9(e) {
    this.ease && (e = this.ease(e));
    const t = this.first.value
      , r = this.first.next.value
      , i = (r.r - t.r) * e + t.r
      , n = (r.g - t.g) * e + t.g
      , s = (r.b - t.b) * e + t.b;
    return Vp(i, n, s)
}
function z9(e) {
    this.ease && (e = this.ease(e));
    let t = this.first
      , r = t.next;
    for (; e > r.time; )
        t = r,
        r = r.next;
    return e = (e - t.time) / (r.time - t.time),
    (r.value - t.value) * e + t.value
}
function W9(e) {
    this.ease && (e = this.ease(e));
    let t = this.first
      , r = t.next;
    for (; e > r.time; )
        t = r,
        r = r.next;
    e = (e - t.time) / (r.time - t.time);
    const i = t.value
      , n = r.value
      , s = (n.r - i.r) * e + i.r
      , o = (n.g - i.g) * e + i.g
      , a = (n.b - i.b) * e + i.b;
    return Vp(s, o, a)
}
function V9(e) {
    this.ease && (e = this.ease(e));
    let t = this.first;
    for (; t.next && e > t.next.time; )
        t = t.next;
    return t.value
}
function j9(e) {
    this.ease && (e = this.ease(e));
    let t = this.first;
    for (; t.next && e > t.next.time; )
        t = t.next;
    const r = t.value;
    return Vp(r.r, r.g, r.b)
}
class Ku {
    constructor(t=!1) {
        this.first = null,
        this.isColor = !!t,
        this.interpolate = null,
        this.ease = null
    }
    reset(t) {
        this.first = t,
        t.next && t.next.time >= 1 ? this.interpolate = this.isColor ? $9 : H9 : t.isStepped ? this.interpolate = this.isColor ? j9 : V9 : this.interpolate = this.isColor ? W9 : z9,
        this.ease = this.first.ease
    }
}
class a1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.list = new Ku(!1),
        this.list.reset(rn.createList(t.alpha))
    }
    initParticles(t) {
        let r = t;
        for (; r; )
            r.alpha = this.list.first.value,
            r = r.next
    }
    updateParticle(t) {
        t.alpha = this.list.interpolate(t.agePercent)
    }
}
a1.type = "alpha";
a1.editorConfig = null;
class l1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.value = t.alpha
    }
    initParticles(t) {
        let r = t;
        for (; r; )
            r.alpha = this.value,
            r = r.next
    }
}
l1.type = "alphaStatic";
l1.editorConfig = null;
function h2(e) {
    const t = [];
    for (let r = 0; r < e.length; ++r) {
        let i = e[r];
        if (typeof i == "string")
            t.push(Su(i));
        else if (i instanceof F)
            t.push(i);
        else {
            let n = i.count || 1;
            for (typeof i.texture == "string" ? i = Su(i.texture) : i = i.texture; n > 0; --n)
                t.push(i)
        }
    }
    return t
}
class h1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.anims = [];
        for (let r = 0; r < t.anims.length; ++r) {
            const i = t.anims[r]
              , n = h2(i.textures)
              , s = i.framerate < 0 ? -1 : i.framerate > 0 ? i.framerate : 60
              , o = {
                textures: n,
                duration: s > 0 ? n.length / s : 0,
                framerate: s,
                loop: s > 0 ? !!i.loop : !1
            };
            this.anims.push(o)
        }
    }
    initParticles(t) {
        let r = t;
        for (; r; ) {
            const i = Math.floor(Math.random() * this.anims.length)
              , n = r.config.anim = this.anims[i];
            r.texture = n.textures[0],
            r.config.animElapsed = 0,
            n.framerate === -1 ? (r.config.animDuration = r.maxLife,
            r.config.animFramerate = n.textures.length / r.maxLife) : (r.config.animDuration = n.duration,
            r.config.animFramerate = n.framerate),
            r = r.next
        }
    }
    updateParticle(t, r) {
        const i = t.config
          , n = i.anim;
        i.animElapsed += r,
        i.animElapsed >= i.animDuration && (i.anim.loop ? i.animElapsed = i.animElapsed % i.animDuration : i.animElapsed = i.animDuration - 1e-6);
        const s = i.animElapsed * i.animFramerate + 1e-7 | 0;
        t.texture = n.textures[s] || n.textures[n.textures.length - 1] || F.EMPTY
    }
}
h1.type = "animatedRandom";
h1.editorConfig = null;
class u1 {
    constructor(t) {
        this.order = Ot.Normal;
        const r = t.anim
          , i = h2(r.textures)
          , n = r.framerate < 0 ? -1 : r.framerate > 0 ? r.framerate : 60;
        this.anim = {
            textures: i,
            duration: n > 0 ? i.length / n : 0,
            framerate: n,
            loop: n > 0 ? !!r.loop : !1
        }
    }
    initParticles(t) {
        let r = t;
        const i = this.anim;
        for (; r; )
            r.texture = i.textures[0],
            r.config.animElapsed = 0,
            i.framerate === -1 ? (r.config.animDuration = r.maxLife,
            r.config.animFramerate = i.textures.length / r.maxLife) : (r.config.animDuration = i.duration,
            r.config.animFramerate = i.framerate),
            r = r.next
    }
    updateParticle(t, r) {
        const i = this.anim
          , n = t.config;
        n.animElapsed += r,
        n.animElapsed >= n.animDuration && (i.loop ? n.animElapsed = n.animElapsed % n.animDuration : n.animElapsed = n.animDuration - 1e-6);
        const s = n.animElapsed * n.animFramerate + 1e-7 | 0;
        t.texture = i.textures[s] || i.textures[i.textures.length - 1] || F.EMPTY
    }
}
u1.type = "animatedSingle";
u1.editorConfig = null;
class c1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.value = t.blendMode
    }
    initParticles(t) {
        let r = t;
        for (; r; )
            r.blendMode = G9(this.value),
            r = r.next
    }
}
c1.type = "blendMode";
c1.editorConfig = null;
class d1 {
    constructor(t) {
        this.order = Ot.Spawn,
        this.spacing = t.spacing * Zi,
        this.start = t.start * Zi,
        this.distance = t.distance
    }
    initParticles(t) {
        let r = 0
          , i = t;
        for (; i; ) {
            let n;
            this.spacing ? n = this.start + this.spacing * r : n = Math.random() * Math.PI * 2,
            i.rotation = n,
            this.distance && (i.position.x = this.distance,
            Nn(n, i.position)),
            i = i.next,
            ++r
        }
    }
}
d1.type = "spawnBurst";
d1.editorConfig = null;
class f1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.list = new Ku(!0),
        this.list.reset(rn.createList(t.color))
    }
    initParticles(t) {
        let r = t;
        const i = this.list.first.value
          , n = Vp(i.r, i.g, i.b);
        for (; r; )
            r.tint = n,
            r = r.next
    }
    updateParticle(t) {
        t.tint = this.list.interpolate(t.agePercent)
    }
}
f1.type = "color";
f1.editorConfig = null;
class p1 {
    constructor(t) {
        this.order = Ot.Normal;
        let r = t.color;
        r.charAt(0) === "#" ? r = r.substr(1) : r.indexOf("0x") === 0 && (r = r.substr(2)),
        this.value = parseInt(r, 16)
    }
    initParticles(t) {
        let r = t;
        for (; r; )
            r.tint = this.value,
            r = r.next
    }
}
p1.type = "colorStatic";
p1.editorConfig = null;
class m1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.index = 0,
        this.textures = t.textures.map(r => typeof r == "string" ? Su(r) : r)
    }
    initParticles(t) {
        let r = t;
        for (; r; )
            r.texture = this.textures[this.index],
            ++this.index >= this.textures.length && (this.index = 0),
            r = r.next
    }
}
m1.type = "textureOrdered";
m1.editorConfig = null;
const Jo = new st
  , u2 = ["E", "LN2", "LN10", "LOG2E", "LOG10E", "PI", "SQRT1_2", "SQRT2", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "cbrt", "ceil", "cos", "cosh", "exp", "expm1", "floor", "fround", "hypot", "log", "log1p", "log10", "log2", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh"]
  , X9 = new RegExp(["[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]"].concat(u2).join("|"),"g");
function Y9(e) {
    const t = e.match(X9);
    for (let r = t.length - 1; r >= 0; --r)
        u2.indexOf(t[r]) >= 0 && (t[r] = `Math.${t[r]}`);
    return e = t.join(""),
    new Function("x",`return ${e};`)
}
class g1 {
    constructor(t) {
        var r;
        if (this.order = Ot.Late,
        t.path)
            if (typeof t.path == "function")
                this.path = t.path;
            else
                try {
                    this.path = Y9(t.path)
                } catch {
                    this.path = null
                }
        else
            this.path = i => i;
        this.list = new Ku(!1),
        this.list.reset(rn.createList(t.speed)),
        this.minMult = (r = t.minMult) !== null && r !== void 0 ? r : 1
    }
    initParticles(t) {
        let r = t;
        for (; r; ) {
            r.config.initRotation = r.rotation,
            r.config.initPosition ? r.config.initPosition.copyFrom(r.position) : r.config.initPosition = new st(r.x,r.y),
            r.config.movement = 0;
            const i = Math.random() * (1 - this.minMult) + this.minMult;
            r.config.speedMult = i,
            r = r.next
        }
    }
    updateParticle(t, r) {
        const i = this.list.interpolate(t.agePercent) * t.config.speedMult;
        t.config.movement += i * r,
        Jo.x = t.config.movement,
        Jo.y = this.path(Jo.x),
        Nn(t.config.initRotation, Jo),
        t.position.x = t.config.initPosition.x + Jo.x,
        t.position.y = t.config.initPosition.y + Jo.y
    }
}
g1.type = "movePath";
g1.editorConfig = null;
class _1 {
    constructor() {
        this.order = Ot.Spawn
    }
    initParticles(t) {}
}
_1.type = "spawnPoint";
_1.editorConfig = null;
class y1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.textures = t.textures.map(r => typeof r == "string" ? Su(r) : r)
    }
    initParticles(t) {
        let r = t;
        for (; r; ) {
            const i = Math.floor(Math.random() * this.textures.length);
            r.texture = this.textures[i],
            r = r.next
        }
    }
}
y1.type = "textureRandom";
y1.editorConfig = null;
class v1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.minStart = t.minStart * Zi,
        this.maxStart = t.maxStart * Zi,
        this.minSpeed = t.minSpeed * Zi,
        this.maxSpeed = t.maxSpeed * Zi,
        this.accel = t.accel * Zi
    }
    initParticles(t) {
        let r = t;
        for (; r; )
            this.minStart === this.maxStart ? r.rotation += this.maxStart : r.rotation += Math.random() * (this.maxStart - this.minStart) + this.minStart,
            r.config.rotSpeed = Math.random() * (this.maxSpeed - this.minSpeed) + this.minSpeed,
            r = r.next
    }
    updateParticle(t, r) {
        if (this.accel) {
            const i = t.config.rotSpeed;
            t.config.rotSpeed += this.accel * r,
            t.rotation += (t.config.rotSpeed + i) / 2 * r
        } else
            t.rotation += t.config.rotSpeed * r
    }
}
v1.type = "rotation";
v1.editorConfig = null;
class x1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.min = t.min * Zi,
        this.max = t.max * Zi
    }
    initParticles(t) {
        let r = t;
        for (; r; )
            this.min === this.max ? r.rotation += this.max : r.rotation += Math.random() * (this.max - this.min) + this.min,
            r = r.next
    }
}
x1.type = "rotationStatic";
x1.editorConfig = null;
class E1 {
    constructor(t) {
        this.order = Ot.Late + 1,
        this.rotation = (t.rotation || 0) * Zi
    }
    initParticles(t) {
        let r = t;
        for (; r; )
            r.rotation = this.rotation,
            r = r.next
    }
}
E1.type = "noRotation";
E1.editorConfig = null;
class T1 {
    constructor(t) {
        var r;
        this.order = Ot.Normal,
        this.list = new Ku(!1),
        this.list.reset(rn.createList(t.scale)),
        this.minMult = (r = t.minMult) !== null && r !== void 0 ? r : 1
    }
    initParticles(t) {
        let r = t;
        for (; r; ) {
            const i = Math.random() * (1 - this.minMult) + this.minMult;
            r.config.scaleMult = i,
            r.scale.x = r.scale.y = this.list.first.value * i,
            r = r.next
        }
    }
    updateParticle(t) {
        t.scale.x = t.scale.y = this.list.interpolate(t.agePercent) * t.config.scaleMult
    }
}
T1.type = "scale";
T1.editorConfig = null;
class S1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.min = t.min,
        this.max = t.max
    }
    initParticles(t) {
        let r = t;
        for (; r; ) {
            const i = Math.random() * (this.max - this.min) + this.min;
            r.scale.x = r.scale.y = i,
            r = r.next
        }
    }
}
S1.type = "scaleStatic";
S1.editorConfig = null;
class Di {
    constructor(t) {
        this.order = Ot.Spawn;
        const r = Di.shapes[t.type];
        if (!r)
            throw new Error(`No shape found with type '${t.type}'`);
        this.shape = new r(t.data)
    }
    static registerShape(t, r) {
        Di.shapes[r || t.type] = t
    }
    initParticles(t) {
        let r = t;
        for (; r; )
            this.shape.getRandPos(r),
            r = r.next
    }
}
Di.type = "spawnShape";
Di.editorConfig = null;
Di.shapes = {};
Di.registerShape(s1);
Di.registerShape(n1);
Di.registerShape(jp);
Di.registerShape(jp, "circle");
class w1 {
    constructor(t) {
        this.order = Ot.Normal,
        this.texture = typeof t.texture == "string" ? Su(t.texture) : t.texture
    }
    initParticles(t) {
        let r = t;
        for (; r; )
            r.texture = this.texture,
            r = r.next
    }
}
w1.type = "textureSingle";
w1.editorConfig = null;
class A1 {
    constructor(t) {
        var r;
        this.order = Ot.Late,
        this.list = new Ku(!1),
        this.list.reset(rn.createList(t.speed)),
        this.minMult = (r = t.minMult) !== null && r !== void 0 ? r : 1
    }
    initParticles(t) {
        let r = t;
        for (; r; ) {
            const i = Math.random() * (1 - this.minMult) + this.minMult;
            r.config.speedMult = i,
            r.config.velocity ? r.config.velocity.set(this.list.first.value * i, 0) : r.config.velocity = new st(this.list.first.value * i,0),
            Nn(r.rotation, r.config.velocity),
            r = r.next
        }
    }
    updateParticle(t, r) {
        const i = this.list.interpolate(t.agePercent) * t.config.speedMult
          , n = t.config.velocity;
        U9(n),
        a2(n, i),
        t.x += n.x * r,
        t.y += n.y * r
    }
}
A1.type = "moveSpeed";
A1.editorConfig = null;
class b1 {
    constructor(t) {
        this.order = Ot.Late,
        this.min = t.min,
        this.max = t.max
    }
    initParticles(t) {
        let r = t;
        for (; r; ) {
            const i = Math.random() * (this.max - this.min) + this.min;
            r.config.velocity ? r.config.velocity.set(i, 0) : r.config.velocity = new st(i,0),
            Nn(r.rotation, r.config.velocity),
            r = r.next
        }
    }
    updateParticle(t, r) {
        const i = t.config.velocity;
        t.x += i.x * r,
        t.y += i.y * r
    }
}
b1.type = "moveSpeedStatic";
b1.editorConfig = null;
Tt.registerBehavior(o1);
Tt.registerBehavior(a1);
Tt.registerBehavior(l1);
Tt.registerBehavior(h1);
Tt.registerBehavior(u1);
Tt.registerBehavior(c1);
Tt.registerBehavior(d1);
Tt.registerBehavior(f1);
Tt.registerBehavior(p1);
Tt.registerBehavior(m1);
Tt.registerBehavior(g1);
Tt.registerBehavior(_1);
Tt.registerBehavior(y1);
Tt.registerBehavior(v1);
Tt.registerBehavior(x1);
Tt.registerBehavior(E1);
Tt.registerBehavior(T1);
Tt.registerBehavior(S1);
Tt.registerBehavior(Di);
Tt.registerBehavior(w1);
Tt.registerBehavior(A1);
Tt.registerBehavior(b1);
const Vw = ({container: e, texture: t, isEnabled: r=!0}) => new Tt(e,{
    lifetime: {
        min: .68,
        max: .68
    },
    frequency: A.width > 1400 ? .0018 : .0038 * Math.max(390 / A.width, .8),
    emitterLifetime: 0,
    maxParticles: 1e3,
    addAtBack: !1,
    emit: r,
    pos: {
        x: 0,
        y: 0
    },
    autoUpdate: !0,
    behaviors: [{
        type: "alpha",
        config: {
            alpha: {
                list: [{
                    value: .2,
                    time: 0
                }, {
                    value: .2,
                    time: .98
                }, {
                    value: 0,
                    time: 1
                }]
            }
        }
    }, {
        type: "moveSpeedStatic",
        config: {
            min: 1300,
            max: 1300
        }
    }, {
        type: "scaleStatic",
        config: {
            min: .35,
            max: .5
        }
    }, {
        type: "rotationStatic",
        config: {
            min: 110,
            max: 110
        }
    }, {
        type: "textureSingle",
        config: {
            texture: t
        }
    }, {
        type: "spawnShape",
        config: {
            type: "rect",
            data: {
                x: 40,
                y: 0,
                w: Math.min(A.width, 500) + 600,
                h: 30
            }
        }
    }]
})
  , Zc = 30;
class K9 extends J {
    constructor() {
        super();
        b(this, "rainTop");
        b(this, "rainBottom");
        b(this, "rainEmitterTop");
        b(this, "rainEmitterBottom");
        b(this, "rainBorder");
        b(this, "texture");
        this.x = 0,
        this.y = 0,
        this.rainBorder = new at,
        this.rainBorder.height = 0,
        this.rainBorder.y = -900,
        this.rainBottom = new If,
        this.rainBottom.y = -900,
        this.rainTop = new If,
        this.rainTop.height = 2,
        this.rainTop.y = -1740,
        this.addChild(this.rainBottom),
        this.addChild(this.rainTop),
        this.addChild(this.rainBorder),
        this.addRain(),
        this.scale.set(A.scale)
    }
    async addRain() {
        const r = await ht(A.assetsUrls.hardRain);
        r && (this.texture = r,
        this.initEmitters())
    }
    initEmitters() {
        if (!this.texture)
            return;
        this.rainEmitterBottom && (this.rainEmitterBottom.emit = !1),
        this.rainEmitterTop && (this.rainEmitterTop.emit = !1);
        const r = this.rainBorder.getBounds().bottom + Zc
          , i = (Rr.borderCloud?.getBounds()?.top || 0) - Zc;
        this.rainEmitterBottom = Vw({
            container: this.rainBottom,
            texture: this.texture,
            isEnabled: i < A.height
        }),
        this.rainEmitterTop = Vw({
            container: this.rainTop,
            texture: this.texture,
            isEnabled: r > 0
        })
    }
    finish() {
        this.rainEmitterBottom && (this.rainEmitterBottom.emit = !0)
    }
    reset() {
        const r = this.rainBorder.getBounds().bottom + Zc;
        this.rainEmitterBottom && (this.rainEmitterBottom.emit = !0),
        this.rainEmitterTop && (this.rainEmitterTop.emit = r > 0)
    }
    scaleAssets(r) {
        this.scale.set(r)
    }
    resize() {
        this.initEmitters()
    }
    update() {
        const r = this.rainBorder.getBounds().bottom + 100;
        if (Rr.borderCloud) {
            const i = Rr.borderCloud.getBounds().top - Zc;
            i > A.height && (this.rainEmitterBottom?.emit || this.rainEmitterTop?.emit) ? (this.rainEmitterBottom && (this.rainEmitterBottom.emit = !1),
            this.rainEmitterTop && (this.rainEmitterTop.emit = !1)) : r > 0 && this.rainEmitterTop && !this.rainEmitterTop?.emit && i < A.height && (this.rainEmitterTop.emit = !0)
        }
    }
}
const jw = 10;
class q9 extends J {
    constructor() {
        super();
        b(this, "tile");
        b(this, "tileOffsetX", 0);
        this.y = 0,
        this.tile = new wi(F.EMPTY,ka(A.width, A.scale),424),
        this.tile.y = An.borderCloud.y,
        this.tile.anchor.set(0, 1),
        this.addChild(this.tile),
        Rr.borderCloud = this.tile,
        this.addTileClouds()
    }
    async addTileClouds() {
        const r = await ht(A.assetsUrls.cloudsTile)
          , i = r?.baseTexture?.height || 424;
        this.tile && this.tile.destroy(),
        this.tile = new wi(r || F.EMPTY,ka(A.width, A.scale),i),
        this.tile.y = An.borderCloud.y,
        this.tile.anchor.set(0, 1),
        this.tile.cullable = !0,
        this.addChild(this.tile),
        Rr.borderCloud = this.tile
    }
    reset() {
        this.tile && (this.tile.tilePosition.x = 0,
        this.tileOffsetX = 0)
    }
    scaleAssets(r) {
        this.scale.set(r)
    }
    resize(r, i, n) {
        this.tile && (this.tile.width = ka(r, n),
        this.tile.tilePosition.x = this.tileOffsetX * n)
    }
    update(r) {
        if (!this.tile)
            return;
        const i = this.tile.getBounds();
        i.bottom > -jw && i.top + jw < A.height && (this.tileOffsetX -= An.borderCloud.vel * r,
        this.tile.tilePosition.x = this.tileOffsetX)
    }
}
class Z9 extends J {
    constructor() {
        super();
        b(this, "starTexture", F.EMPTY);
        b(this, "starsTile", null);
        this.y = 0;
        try {
            this.createStarsTexture()
        } catch {
            logger.info("Stars error:", {
                prefix: "[GAME SCENE]"
            })
        }
    }
    async createStarsTexture() {
        const r = await ht(A.assetsUrls.stars);
        if (!r?.textures)
            return;
        const i = new J
          , n = [];
        A.reskin?.skyStars?.items.forEach( ([s,o,a,l]) => {
            for (let h = 0; h < o; h += 1)
                n.push({
                    starId: s,
                    alpha: hy(a, l)
                })
        }
        ),
        n.forEach( ({starId: s, alpha: o}) => {
            const a = r.textures[s];
            if (a) {
                const l = new at(a);
                l.position = {
                    x: On(0, 600),
                    y: -On(0, 600)
                },
                l.alpha = o,
                i.addChild(l)
            }
        }
        ),
        this.starTexture = Lo.renderer.generateTexture(i),
        i.destroy(),
        this.addStars()
    }
    addStars() {
        this.starsTile = new wi(this.starTexture,xi(A.width, A.scale) + 5,xi(A.height, A.scale) + 5),
        this.starsTile.y = 0,
        this.starsTile.anchor.set(0, 1),
        this.starsTile.width = xi(A.width, A.scale) + 5,
        this.starsTile.height = xi(1200 * A.scale, A.scale),
        this.starsTile.y = -420,
        this.addChild(this.starsTile)
    }
    scaleAssets(r) {
        this.scale.set(r)
    }
    resize(r, i, n) {
        this.starsTile && (this.starsTile.width = xi(r, n) + 5)
    }
    update(r, i) {
        this.starsTile && (this.starsTile.tilePosition.x -= (A.reskin?.skyStars?.vel || 1) * r * i)
    }
}
const Xw = 11
  , uy = 2
  , Q9 = -2
  , J9 = 4
  , tX = 2
  , eX = 800
  , qn = e => Math.floor(Math.random() * e)
  , rX = e => Math.random() > .5 ? Math.max(Q9, e - 1) : Math.min(e + 1, uy);
class iX extends J {
    constructor() {
        super();
        b(this, "snowContainer");
        b(this, "particles");
        b(this, "spaceMask");
        b(this, "textures");
        b(this, "maxFastDelta");
        b(this, "fastDelta");
        b(this, "groundPosY");
        b(this, "isGround", !0);
        b(this, "upperLimit", Xw);
        this.x = 0,
        this.y = -A.height,
        A.width <= 400 && (this.upperLimit = 8),
        this.maxFastDelta = 0,
        this.fastDelta = 1;
        const {groundPosY: r} = ri(A.height, A.breakpoint);
        this.groundPosY = A.height + r,
        this.spaceMask = new at(F.WHITE),
        this.spaceMask.width = A.width,
        this.spaceMask.height = A.height,
        this.spaceMask.y = 0,
        this.mask = this.spaceMask,
        this.addChild(this.spaceMask),
        this.snowContainer = new If,
        this.snowContainer.setProperties({
            scale: !0,
            position: !0,
            rotation: !0,
            uvs: !0,
            alpha: !0
        }),
        this.init(),
        this.addChild(this.snowContainer)
    }
    genParticles(r) {
        const {gameScreenWidth: i} = ri(A.height, A.breakpoint);
        return new Array(eX).fill(null).map( () => {
            const n = qn(J9) + tX
              , s = r[On(0, 1)]
              , o = new at(s);
            return o.size = n,
            o.vx = qn(uy) - uy,
            o.vy = qn(this.upperLimit) + 2,
            o.alpha = Math.random(),
            o.startX = qn(i),
            o.x = o.startX,
            o.startY = n + qn(A.height / 2),
            o.y = o.startY,
            o.height = n,
            o.width = n,
            o.scale.set(o.scale.x * A.scale),
            this.snowContainer.addChild(o),
            o
        }
        )
    }
    resetParticle(r) {
        const {gameScreenWidth: i} = ri(A.height, A.breakpoint);
        r.x = qn(i),
        r.y = -(r.size + qn(A.height / 2)),
        r.vy = qn(this.upperLimit) + 2,
        r.alpha = Math.random(),
        r.height = r.size,
        r.width = r.size,
        r.scale.set(r.scale.x * A.scale)
    }
    async init() {
        const r = await ht(A.assetsUrls.snow);
        r?.textures && (this.textures = Object.values(r.textures),
        this.particles = this.genParticles(this.textures))
    }
    reset() {
        this.spaceMask.y = 0,
        this.maxFastDelta = 0,
        this.fastDelta = 1,
        this.visible = !0,
        this.isGround = !0
    }
    scaleAssets() {}
    onFly() {
        this.maxFastDelta = 1.6,
        this.isGround = !1
    }
    finish() {
        this.maxFastDelta = 0,
        this.fastDelta = 1
    }
    resize() {
        this.y = -A.height,
        this.spaceMask.y = 0,
        this.spaceMask.width = A.width,
        this.spaceMask.height = A.height,
        this.upperLimit = A.width <= 400 ? 8 : Xw;
        const {groundPosY: r} = ri(A.height, A.breakpoint);
        if (this.groundPosY = A.height + r,
        Rr.borderCloud) {
            const i = Rr.borderCloud.getBounds().bottom - 50;
            i > 0 && (this.spaceMask.y = i)
        }
    }
    update(r) {
        if (!Rr.borderCloud)
            return;
        const i = Rr.borderCloud.getBounds().bottom - 50;
        if (this.spaceMask.y > A.height) {
            this.visible = !1;
            return
        }
        i > 0 && (this.spaceMask.y = i),
        this.fastDelta = this.maxFastDelta ? Math.min(this.fastDelta + .02, this.maxFastDelta) : 1,
        this.particles?.forEach(n => {
            n.y > 0 && (n.x += n.vx * r * A.scale * (n.vx < 0 ? this.fastDelta : 1),
            this.isGround && n.y > this.groundPosY - 50 * A.scale && (n.alpha = Math.max(n.alpha - .06, 0))),
            n.y += n.vy * r * A.scale * this.fastDelta,
            Math.random() > .9 && (n.vx = rX(n.vx)),
            (n.x > A.width || n.x < 0 || n.y > A.height) && this.resetParticle(n)
        }
        )
    }
}
const nX = 10
  , Yw = 3
  , sX = 120;
class oX extends J {
    constructor() {
        super();
        b(this, "gradient");
        b(this, "groundColor");
        b(this, "spaceMask");
        b(this, "airport");
        b(this, "clouds");
        b(this, "borderCloud");
        b(this, "space");
        b(this, "skyStars");
        b(this, "background");
        b(this, "bgContainer");
        b(this, "spaceContainer");
        b(this, "weatherContainer");
        b(this, "offsetY", 0);
        b(this, "state", Xs.IDLE);
        b(this, "stopBgPosY");
        b(this, "groundPosY", 0);
        b(this, "stopMoveX");
        b(this, "isBgMoveStopped", !1);
        b(this, "velDelta", 0);
        b(this, "rain");
        b(this, "snow");
        const {stopMoveX: r=!1, bgPosY: i=0} = Yu();
        r && (this.stopMoveX = !!r),
        this.width = A.width,
        this.height = A.height,
        this.bgContainer = new J,
        this.bgContainer.name = "BgContainer",
        this.background = new J,
        this.background.name = "Background",
        this.background.sortableChildren = !0;
        const n = 3624;
        this.gradient = new at(n2({
            height: n,
            colors: A.reskin?.gradients?.bg || L9
        })),
        this.gradient.name = "Gradient",
        this.gradient.width = A.width + 5,
        this.gradient.height = n,
        this.gradient.anchor.set(0, 1),
        this.gradient.cullable = !0,
        this.setPosition(),
        this.addChild(this.gradient),
        this.spaceContainer = new J,
        this.spaceContainer.name = "SpaceContainer",
        this.spaceMask = new at(F.WHITE),
        this.spaceMask.width = A.width,
        this.spaceMask.height = 0,
        this.spaceMask.y = -A.height,
        this.spaceContainer.mask = this.spaceMask,
        this.spaceContainer.addChild(this.spaceMask),
        this.groundColor = new at(F.WHITE),
        this.groundColor.name = "GroundColor",
        this.groundColor.width = A.width + 5,
        this.groundColor.height = -this.background.y,
        this.groundColor.tint = (A.reskin?.gradients?.road || s2)[0].color,
        this.groundColor.anchor.set(0, 1),
        this.bgContainer.addChild(this.groundColor),
        this.space = new N9,
        this.spaceContainer.addChild(this.space),
        this.addChild(this.spaceContainer),
        this.airport = new F9,
        this.airport.zIndex = 1,
        this.background.addChild(this.airport),
        A.reskin?.skyStars && (this.skyStars = new Z9,
        this.background.addChild(this.skyStars)),
        this.clouds = new w9,
        this.clouds.zIndex = A.reskin?.clouds?.zIndex !== void 0 ? A.reskin?.clouds?.zIndex : 2,
        this.background.addChild(this.clouds),
        this.borderCloud = new q9,
        this.borderCloud.zIndex = 4,
        this.background.addChild(this.borderCloud),
        this.bgContainer.addChild(this.background),
        this.addChild(this.bgContainer),
        Rr.setBackgroundLayer(this.bgContainer),
        A.reskin?.hasRain ? (this.rain = new K9,
        this.rain.zIndex = 3,
        this.background.addChild(this.rain)) : A.reskin?.snow && (this.snow = new iX,
        this.snow.zIndex = 3,
        this.addChild(this.snow)),
        this.scaleAssets(A.scale),
        i > 0 && (this.stopBgPosY = i,
        this.bgContainer.y = i,
        this.gradient.y = this.groundPosY + this.bgContainer.y)
    }
    scaleAssets(r) {
        this.gradient.scale.y = r,
        this.airport.scaleAssets(r),
        this.clouds.scaleAssets(r),
        this.borderCloud.scaleAssets(r),
        this.space.scaleAssets(r),
        this.rain?.scaleAssets(r),
        this.snow?.scaleAssets(),
        this.skyStars?.scaleAssets(r)
    }
    changePosition(r) {
        this.stopBgPosY || (this.offsetY = r * Yw,
        this.gradient.y = Math.min(this.groundPosY + this.offsetY * A.scale),
        this.bgContainer.y = this.gradient.y - this.groundPosY)
    }
    setPosition() {
        this.groundPosY = ri(A.height, A.breakpoint).groundPosY,
        this.background.y = this.groundPosY,
        this.gradient.y = this.groundPosY + this.bgContainer.y
    }
    resize(r, i, n) {
        this.setPosition(),
        this.gradient.width = r + 5,
        this.spaceMask.width = r,
        this.spaceMask.y = -i,
        this.groundColor.width = r + 5,
        this.groundColor.height = -this.background.y,
        this.bgContainer.y = this.offsetY * A.scale,
        this.gradient.y = this.groundPosY + this.bgContainer.y,
        this.airport.resize?.(r, i, n),
        this.borderCloud.resize?.(r, i, n),
        this.space.resize?.(r, i, n),
        this.rain?.resize?.(),
        this.snow?.resize?.(),
        this.skyStars?.resize(r, i, n),
        this.scaleAssets(n)
    }
    reset() {
        this.state = Xs.IDLE,
        this.spaceMask.height = 0,
        this.isBgMoveStopped = !1,
        this.velDelta = 0,
        ut.killTweensOf(this),
        this.stopBgPosY || (this.bgContainer.y = 0,
        this.gradient.y = this.groundPosY + this.bgContainer.y,
        this.offsetY = 0),
        this.stopMoveX || (this.setPosition(),
        this.airport.reset(),
        this.clouds.reset(),
        this.borderCloud.reset(),
        this.space.reset()),
        this.rain?.reset(),
        this.snow?.reset()
    }
    stop() {
        this.state = Xs.IDLE,
        this.velDelta = 0
    }
    finish() {
        this.rain?.finish(),
        this.snow?.finish()
    }
    takingOff() {
        this.state = Xs.MOVING_HORIZONTAL,
        this.velDelta = 0
    }
    flying() {
        this.state = Xs.MOVING,
        this.snow?.onFly()
    }
    update(r) {
        if (this.airport.updateFromStart(r, Math.min(.08 + this.velDelta, 1)),
        this.rain?.update(),
        this.snow?.update(r),
        this.state === Xs.IDLE || (this.velDelta = Math.min(this.velDelta + .009 * r, 1),
        this.state === Xs.MOVING && !this.stopBgPosY && !this.isBgMoveStopped && (this.gradient.y - this.gradient.height > 0 ? this.isBgMoveStopped = !0 : (this.offsetY += Yw * r,
        this.bgContainer.y = this.offsetY * A.scale,
        this.gradient.y = this.groundPosY + this.bgContainer.y)),
        this.stopMoveX))
            return;
        this.airport.getBounds().top + nX < A.height && this.airport.update(r, this.velDelta);
        const i = this.borderCloud.getBounds().top + sX * A.scale;
        i > 0 && this.spaceMask.height < A.height && (this.spaceMask.height = Math.min(i, A.height)),
        this.skyStars && this.skyStars.update(r, this.velDelta),
        this.clouds.update(r, this.velDelta),
        this.borderCloud.update(r),
        this.spaceMask.height > 0 && this.space.update(r)
    }
}
const aX = .1
  , lX = 1280
  , hX = 708;
class uX extends J {
    constructor() {
        super();
        b(this, "background");
        this.init()
    }
    async init() {
        const r = await Promise.all([ht(A.assetsUrls.lightBg1), ht(A.assetsUrls.lightBg2), ht(A.assetsUrls.lightBg3)]);
        this.background = new Le(r.filter(i => !!i)),
        this.background.loop = !0,
        this.background.anchor.set(.5, 1),
        this.background.animationSpeed = aX,
        this.background.play(),
        this.addChild(this.background),
        this.resize(A.width, A.height)
    }
    resize(r, i) {
        if (!this.background)
            return;
        const n = r / lX
          , s = i / hX
          , o = Math.max(n, s);
        this.background.scale.set(o),
        this.background.x = r / 2
    }
}
const cX = {
    flyingAngle: 5.74,
    shadow: {
        type: "shadow-1"
    },
    parts: {
        engine: {
            type: "propeller-1",
            layer: "front",
            transform: {
                x: 108.8,
                y: 0,
                anchor: {
                    x: .5,
                    y: .5
                }
            }
        }
    }
}
  , dX = {
    flyingAngle: 5.74,
    shadow: {
        type: "shadow-1"
    },
    parts: {
        engine: {
            type: "propeller-2",
            layer: "front",
            transform: {
                x: 118.5,
                y: -4,
                anchor: {
                    x: .5,
                    y: .5
                }
            }
        }
    }
}
  , fX = {
    flyingAngle: 7.73,
    shadow: {
        type: "shadow-2"
    },
    parts: {
        engine: {
            type: "propeller-3",
            layer: "front",
            transform: {
                x: 62.8,
                y: 18,
                anchor: {
                    x: 0,
                    y: .5
                }
            }
        },
        frontWheel: {
            layer: "back",
            transform: {
                x: 79,
                y: 26,
                pivot: {
                    x: 12,
                    y: 11
                },
                anim: {
                    duration: .38,
                    ease: "power1.out",
                    pixi: {
                        angle: 110
                    }
                },
                final: {
                    visible: !1
                }
            }
        },
        backWheel: {
            layer: "mask",
            transform: {
                x: -19,
                y: 28,
                anim: {
                    duration: .7,
                    ease: "power1.out",
                    pixi: {
                        y: -16
                    }
                },
                final: {
                    visible: !1
                }
            }
        },
        door: {
            layer: "mask",
            transform: {
                x: -22,
                y: 33
            }
        }
    }
}
  , pX = {
    flyingAngle: 8,
    shadow: {
        type: "shadow-1"
    },
    parts: {
        engine: {
            type: "fire",
            layer: "mask",
            transform: {
                x: -21,
                y: 39.5,
                anchor: {
                    x: 1,
                    y: .5
                },
                angle: -5.4
            }
        },
        frontWheel: {
            layer: "mask",
            transform: {
                x: 68,
                y: 22,
                pivot: {
                    x: 20,
                    y: 8
                },
                anim: {
                    keyframes: [{
                        duration: .2,
                        pixi: {
                            scale: .68,
                            angle: 13.5,
                            y: 4
                        }
                    }, {
                        duration: .3,
                        delay: -.1,
                        pixi: {
                            y: -7
                        }
                    }]
                }
            }
        },
        backWheel: {
            layer: "back",
            transform: {
                x: -71,
                y: 47,
                pivot: {
                    x: 19,
                    y: 21
                },
                anim: {
                    duration: .35,
                    pixi: {
                        angle: 59,
                        y: 28
                    }
                },
                final: {
                    visible: !1
                }
            }
        },
        door: {
            layer: "mask",
            transform: {
                x: 53,
                y: 8,
                anim: {
                    delay: .15,
                    duration: .3,
                    pixi: {
                        y: 22
                    }
                },
                final: {
                    y: 22,
                    visible: !0
                }
            }
        }
    }
}
  , mX = {
    flyingAngle: 9.37,
    shadow: {
        type: "shadow-2"
    },
    parts: {
        engine: {
            type: "fire",
            layer: "mask",
            transform: {
                x: -45,
                y: 38,
                anchor: {
                    x: 1,
                    y: .5
                }
            }
        },
        frontWheel: {
            layer: "back",
            transform: {
                x: 65,
                y: 36,
                pivot: {
                    x: 22,
                    y: 15
                },
                anim: {
                    duration: .5,
                    pixi: {
                        angle: 110
                    }
                }
            }
        },
        backWheel: {
            layer: "mask",
            transform: {
                x: -45,
                y: 23,
                anim: {
                    duration: .7,
                    pixi: {
                        y: -34,
                        scale: .8
                    }
                }
            }
        },
        door: {
            layer: "mask",
            transform: {
                x: -43,
                y: 28
            }
        }
    }
}
  , gX = {
    flyingAngle: 9.37,
    y: -10,
    shadow: {
        type: "shadow-2",
        alpha: .62
    },
    parts: {
        engine: {
            type: "fire",
            layer: "back",
            transform: {
                x: -72,
                y: 33,
                anchor: {
                    x: 1,
                    y: .5
                }
            }
        },
        airBag: {
            type: "airbag-1"
        }
    }
}
  , _X = {
    flyingAngle: 12,
    y: -10,
    shadow: {
        type: "shadow-2",
        alpha: .62
    },
    parts: {
        engine: {
            type: "fire",
            layer: "back",
            transform: {
                x: -103,
                y: 16,
                anchor: {
                    x: 1,
                    y: .5
                },
                scale: {
                    x: .85
                }
            }
        },
        airBag: {
            type: "airbag-1"
        }
    }
}
  , yX = {
    flyingAngle: 11,
    y: -10,
    shadow: {
        type: "shadow-2",
        alpha: .62
    },
    parts: {
        engine: {
            type: "fire",
            layer: "back",
            transform: {
                x: -110,
                y: -1,
                anchor: {
                    x: 1,
                    y: .5
                },
                scale: {
                    x: .85
                }
            }
        },
        airBag: {
            type: "airbag-1"
        }
    }
}
  , Mr = {
    engineAnimationSpeed: .75,
    explosionAnimationSpeed: .3,
    flyAnimation: {
        speed: .19,
        speedFull: .4
    },
    phantomAlpha: .6,
    landingAngle: 40,
    planes: {
        level1: cX,
        level2: dX,
        level3: fX,
        level4: pX,
        level5: mX,
        level6: gX,
        level7: _X,
        level8: yX
    }
}
  , sr = (e, t) => typeof e < "u" ? e : t
  , Kw = (e, t) => {
    e.x = sr(t.x, 0),
    e.y = sr(t.y, 0),
    e.anchor.x = sr(t.anchor?.x, 0),
    e.anchor.y = sr(t.anchor?.y, 0),
    e.pivot.x = sr(t.pivot?.x, 0),
    e.pivot.y = sr(t.pivot?.y, 0),
    e.angle = sr(t.angle, 0),
    e.alpha = sr(t.alpha, 1),
    e.zIndex = sr(t.zIndex, 1),
    e.scale.x = sr(t.scale?.y, 1),
    e.scale.y = sr(t.scale?.y, 1),
    e.skew.x = sr(t.skew?.x, 0),
    e.skew.y = sr(t.skew?.y, 0),
    e.visible = sr(t.visible, !0),
    t.size?.width && (e.width = t.size?.width),
    t.size?.height && (e.height = t.size?.height)
}
  , qw = {
    frontWheel: "front-wheel.webp",
    backWheel: "back-wheel.webp",
    door: "door.webp"
}
  , vX = {
    door: {
        repeat: 0,
        delay: .1,
        duration: .5,
        pixi: {
            scaleY: 0,
            angle: -3,
            skewX: .17
        }
    },
    frontWheel: {},
    backWheel: {}
};
class xX extends J {
    constructor({level: r=1, isRunning: i=!1, backViewParts: n, isUserPlane: s, meta: o, skinId: a, skinRarity: l, customSettigs: h}) {
        super();
        b(this, "level");
        b(this, "skinId");
        b(this, "skinRarity");
        b(this, "hasWheels", !1);
        b(this, "isUserPlane", !1);
        b(this, "engine");
        b(this, "maskContainer");
        b(this, "backViewParts");
        b(this, "partsList", Object.keys(qw));
        b(this, "parts", {});
        b(this, "planeSettings");
        b(this, "meta");
        b(this, "hasPropeller");
        this.isUserPlane = !!s,
        this.level = r || 1,
        this.planeSettings = h || Mr.planes[`level${r}`],
        this.hasPropeller = this.planeSettings.parts.engine.type !== "fire",
        this.meta = o,
        this.skinId = a,
        this.skinRarity = l,
        this.backViewParts = n,
        this.backViewParts.name = "BackViewParts",
        Object.values(this.planeSettings.parts || {}).some( ({layer: c}) => c === Id.MASK) && this.addMask(),
        this.setupEngine(i || A.mode === Je.LIGHT),
        this.setupBottomParts(i || A.mode === Je.LIGHT)
    }
    addMask() {
        const r = r2({
            level: this.level,
            skinId: this.skinId,
            skinRarity: this.skinRarity
        })
          , i = vt.get(r);
        if (!i)
            return;
        const n = new at(i);
        n.anchor.set(.5),
        n.name = "PartsMask",
        this.maskContainer = new J,
        this.maskContainer.name = "MaskContainer",
        this.maskContainer.mask = n,
        this.maskContainer.addChild(n),
        this.addChild(this.maskContainer)
    }
    addChildToLayer(r, i) {
        i === Id.MASK && this.maskContainer ? this.maskContainer.addChild(r) : i === Id.BACK ? this.backViewParts.addChild(r) : this.addChild(r)
    }
    setupEngine(r=!1) {
        const i = this.planeSettings.parts.engine
          , n = vt.get(e2(i.type, this.isUserPlane ? 2 : null));
        n?.textures && (this.engine = new Le(Object.values(n?.textures)),
        this.engine.loop = !0,
        this.engine.name = "engine",
        this.engine.animationSpeed = Mr.engineAnimationSpeed,
        Kw(this.engine, i.transform),
        r ? (this.engine.scale.x = i.transform.scale?.x || 1,
        this.engine.scale.y = i.transform.scale?.y || 1,
        this.engine.play()) : this.hasPropeller || this.engine.scale.set(0),
        this.addChildToLayer(this.engine, i.layer))
    }
    setupBottomParts(r) {
        const i = this.planeSettings.parts
          , {frontWheel: n, backWheel: s, door: o} = i;
        if (!n && !s && !o)
            return;
        this.hasWheels = !0;
        const a = t2({
            level: this.level,
            meta: this.meta,
            skinId: this.skinId,
            skinRarity: this.skinRarity
        })
          , l = vt.get(a);
        l && (this.partsList.forEach(h => {
            const u = i[h];
            if (u) {
                const c = new at(l.textures[qw[h]]);
                c.name = h,
                this.addChildToLayer(c, u.layer),
                this.parts[h] = c
            }
        }
        ),
        this.setTranforms(),
        r && this.hideWheels(r))
    }
    setTranforms() {
        const r = this.planeSettings.parts || {};
        this.partsList.forEach(i => {
            const n = this.parts[i]
              , {transform: s} = r[i] || {};
            n && s && Kw(n, s)
        }
        )
    }
    reset() {
        A.mode !== Je.LIGHT && (this.engine && (this.engine.gotoAndStop(0),
        this.hasPropeller || this.engine.scale.set(0),
        ut.killTweensOf(this.engine)),
        Object.values(this.parts).forEach(r => {
            ut.killTweensOf(r)
        }
        ),
        this.setTranforms())
    }
    startEngine(r=!1, i=Mr.engineAnimationSpeed) {
        if (!this.engine)
            return;
        this.engine.animationSpeed = i;
        const n = this.planeSettings.parts.engine;
        if (this.engine.playing)
            return;
        if (r) {
            this.engine.scale.x = n.transform.scale?.x || 1,
            this.engine.scale.y = n.transform.scale?.y || 1,
            this.engine.play();
            return
        }
        let s = 0;
        this.hasPropeller ? (this.engine.animationSpeed = i / 2.5,
        this.engine.play(),
        this.engine.onLoop = () => {
            s += 1,
            s === 1 ? this.engine.animationSpeed = i / 1.4 : s >= 3 && this.engine.animationSpeed !== i && (this.engine.animationSpeed = i)
        }
        ) : (this.engine.play(),
        ut.to(this.engine, {
            repeat: 0,
            keyframes: [{
                duration: .4,
                pixi: {
                    scaleX: n.transform.scale?.x || 1 * 1.22,
                    scaleY: n.transform.scale?.y || 1 * 1.34
                }
            }, {
                duration: .5,
                pixi: {
                    scaleX: n.transform.scale?.x || 1,
                    scaleY: n.transform.scale?.y || 1
                }
            }],
            ...n.transform.anim || {}
        }))
    }
    hideWheels(r=!1) {
        const i = this.planeSettings.parts || {};
        if (r) {
            this.partsList.forEach(n => {
                const s = this.parts[n]
                  , {transform: o} = i[n] || {};
                s && o && (s.visible = !!o.final?.visible,
                s.y = o.final?.y || s.y)
            }
            );
            return
        }
        this.partsList.forEach(n => {
            const s = this.parts[n]
              , {transform: o} = i[n] || {};
            s && o && ut.to(s, {
                repeat: 0,
                ...vX[n] || {},
                ...o.anim || {},
                onComplete: () => {
                    s && (s.visible = !!o?.final?.visible,
                    s.y = o?.final?.y || s.y)
                }
            })
        }
        )
    }
}
class cy extends J {
    constructor({texture: r, level: i, isRunning: n=!1, isUserPlane: s=!1, meta: o, skinId: a, skinRarity: l, customSettigs: h}) {
        super();
        b(this, "plane");
        b(this, "parts");
        b(this, "backViewParts");
        b(this, "flyAnim");
        b(this, "skinId");
        b(this, "isUserPlane");
        b(this, "hasPropeller");
        b(this, "skinRarity");
        b(this, "planeSettings");
        this.plane = new at(r),
        this.plane.anchor.set(.5),
        this.plane.name = "PlaneSprite",
        this.skinId = a,
        this.skinRarity = l,
        this.isUserPlane = s,
        this.planeSettings = h || Mr.planes[`level${i}`],
        this.hasPropeller = this.planeSettings?.parts.engine.type !== "fire",
        this.backViewParts = new J,
        this.parts = new xX({
            level: i,
            isRunning: n,
            backViewParts: this.backViewParts,
            meta: o,
            isUserPlane: s,
            skinId: a,
            skinRarity: l,
            customSettigs: h
        }),
        this.addChild(this.backViewParts),
        this.addChild(this.plane),
        this.addChild(this.parts)
    }
    reset() {
        this.parts.reset(),
        this.flyAnim && (this.flyAnim.visible = !1,
        this.flyAnim.stop()),
        this.showPlane()
    }
    startup(r=!1) {
        this.parts.startEngine(r)
    }
    hideWheels(r=!1) {
        this.parts.hideWheels(r)
    }
    async startFlyAnim(r) {
        if (!this.skinId || this.skinRarity !== Ar.SKIN_RARITY_LEGENDARY)
            return;
        const i = this.isUserPlane
          , n = r?.currentFrame || (i ? 9 : 4)
          , s = i ? this.planeSettings?.flyAnimation?.speedFull || Mr.flyAnimation.speedFull : this.planeSettings?.flyAnimation?.speed || Mr.flyAnimation.speed
          , o = r?.animationSpeed || s;
        if (this.flyAnim) {
            this.hidePlane(),
            this.flyAnim && (this.flyAnim.animationSpeed = o,
            this.flyAnim.stop(),
            this.flyAnim.gotoAndPlay(n),
            this.flyAnim.visible = !0);
            return
        }
        const a = await ht(v9({
            skinId: this.skinId,
            ratio: this.isUserPlane ? 2 : null,
            isFull: i
        }));
        if (!a)
            return;
        const l = Object.values(a.textures);
        this.flyAnim = new Le(l),
        this.flyAnim.name = "FlyAnim",
        this.flyAnim.anchor.set(.5, .5),
        this.flyAnim.loop = !1,
        this.flyAnim.visible = !0,
        this.flyAnim.animationSpeed = o,
        this.flyAnim.zIndex = 2,
        this.hidePlane(),
        this.addChild(this.flyAnim),
        this.flyAnim.gotoAndPlay(n),
        this.flyAnim.onComplete = () => {
            this.flyAnim && (this.flyAnim.animationSpeed = -(this.flyAnim?.animationSpeed || s),
            this.flyAnim.visible && this.flyAnim?.play())
        }
    }
    hidePlane() {
        this.backViewParts.visible = !1,
        this.plane.visible = !1,
        this.parts.visible = !1
    }
    showPlane() {
        this.backViewParts.visible = !0,
        this.plane.visible = !0,
        this.parts.visible = !0
    }
}
class dy {
    constructor({level: t, meta: r, isUserPlane: i=!1, skinId: n, skinRarity: s, customSettigs: o}) {
        b(this, "level");
        b(this, "settings");
        b(this, "meta");
        b(this, "planeUrl");
        b(this, "partsUrl");
        b(this, "partsMaskUrl");
        b(this, "engineUrl");
        b(this, "shadowUrl");
        b(this, "airBagUrl");
        b(this, "skinId");
        const {isDemo: a, enableRandomPlane: l} = Mu();
        this.level = t,
        this.skinId = n,
        this.meta = r,
        this.settings = o || Mr.planes[`level${t}`],
        this.planeUrl = i && a && !l && t === 1 ? QO(i ? 2 : null) : ly({
            level: t,
            meta: r,
            ratio: i ? 2 : null,
            skinId: n,
            skinRarity: s
        }),
        this.engineUrl = e2(this.settings.parts.engine.type, i ? 2 : null),
        this.shadowUrl = x9(this.settings.shadow.type);
        const {parts: {frontWheel: h, backWheel: u, door: c, airBag: d}={}} = this.settings;
        (h || u || c) && (this.partsUrl = t2({
            level: t,
            meta: r,
            skinId: n,
            skinRarity: s
        })),
        Object.values(this.settings.parts || {}).some( ({layer: g}) => g === Id.MASK) && (this.partsMaskUrl = r2({
            level: t,
            skinId: n,
            skinRarity: s
        })),
        d?.type && (this.airBagUrl = y9(d.type))
    }
    async loadTextures() {
        const t = [T9(this.planeUrl, this.level, this.meta), this.engineUrl ? ht(this.engineUrl) : void 0, this.partsUrl ? ht(this.partsUrl) : void 0, this.partsMaskUrl ? ht(this.partsMaskUrl) : void 0]
          , r = await Promise.all(t);
        return {
            plane: r[0],
            engine: r[1],
            parts: r[2],
            partsMask: r[3]
        }
    }
}
class EX extends J {
    constructor({level: r, meta: i, skinId: n, skinRarity: s}) {
        super();
        b(this, "planeWrapper");
        b(this, "phantomPlane");
        b(this, "shadow");
        b(this, "planeManager");
        b(this, "plane");
        b(this, "bottom");
        b(this, "explosion");
        b(this, "airBag");
        b(this, "state", nr.WAITING);
        b(this, "foldWheelsTimeout", null);
        b(this, "flyAnimTimeout", null);
        b(this, "planeAnimation");
        b(this, "idleAnimation");
        b(this, "planeWrapperAlpha", new Ix(1));
        b(this, "planeSettings");
        b(this, "heightAboutGround", 0);
        b(this, "isPrepared", !1);
        b(this, "initPosY", 0);
        b(this, "startAnimPosY", 0);
        b(this, "prevAnimPosY", 0);
        b(this, "level");
        b(this, "skinId");
        b(this, "skinRarity");
        this.level = r,
        this.skinId = n,
        this.skinRarity = s,
        this.planeManager = new dy({
            level: r,
            meta: i,
            isUserPlane: !0,
            skinId: n,
            skinRarity: s
        }),
        this.planeWrapper = new J,
        this.planeWrapper.name = "PlaneWrapper",
        this.planeWrapper.filters = [this.planeWrapperAlpha],
        this.planeWrapperAlpha.resolution = 0,
        this.planeWrapperAlpha.multisample = null;
        const o = new at(F.EMPTY);
        o.width = KO,
        o.height = ay,
        o.anchor.set(.5),
        this.planeWrapper.addChild(o),
        this.shadow = new J,
        this.shadow.name = "Shadow",
        this.bottom = new J,
        this.bottom.y = ay / 2,
        this.bottom.name = "Bottom",
        this.scaleAssets(A.scale),
        this.setPosition(),
        this.heightAboutGround = this.getFlyingPosition(),
        this.addChild(this.planeWrapper, this.bottom),
        this.initPlane({
            level: r,
            meta: i,
            skinId: n,
            skinRarity: s
        }),
        this.addExplosion()
    }
    async initPlane({level: r, meta: i, skinId: n, skinRarity: s}) {
        let o;
        n && s === Ar.SKIN_RARITY_LEGENDARY && (o = await ht(i2(n))),
        this.planeManager = new dy({
            isUserPlane: !0,
            level: r,
            meta: i,
            skinId: n,
            skinRarity: s,
            customSettigs: o
        }),
        this.planeSettings = o || Mr.planes[`level${r}`];
        const {plane: a} = await this.planeManager.loadTextures()
          , l = He.getState()
          , h = l.roundState === Kr.RUN;
        ut.killTweensOf(this.shadow),
        this.idleAnimation && (this.idleAnimation.kill(),
        this.idleAnimation = null),
        this.bottom.removeChildren(),
        this.airBag?.destroy(),
        this.airBag = void 0,
        this.plane = new cy({
            level: r,
            texture: a,
            isRunning: h,
            meta: i,
            isUserPlane: !0,
            skinId: n,
            skinRarity: s,
            customSettigs: o
        }),
        this.phantomPlane = new cy({
            level: r,
            texture: a,
            isRunning: !0,
            meta: i,
            isUserPlane: !0,
            skinId: n,
            skinRarity: s,
            customSettigs: o
        }),
        this.planeWrapper.removeChildren(),
        A.mode === Je.FULL && (this.planeWrapper.y = this.planeSettings.y || 0),
        (h || A.mode === Je.LIGHT) && this.setFlightState(),
        this.planeWrapper.addChild(this.plane),
        this.addShadow(),
        this.planeSettings.parts.airBag && (this.addAirBag(),
        (l.roundState && !h || l.isPreparing) && this.startIdleAnimation())
    }
    async addAirBag() {
        const r = this.planeManager.airBagUrl;
        if (!r)
            return;
        this.airBag && this.bottom.removeChild(this.airBag);
        const i = await vt.load(r)
          , n = Object.values(i.textures);
        this.airBag = new Le(n),
        this.airBag.anchor.set(.5, 1),
        this.airBag.name = "AirBag",
        this.airBag.animationSpeed = .2,
        this.airBag.visible = !1,
        this.airBag.loop = !0,
        this.bottom.addChild(this.airBag)
    }
    startIdleAnimation() {
        if (this.isPrepared || this.idleAnimation || !this.plane)
            return;
        const r = ut.timeline();
        this.startAnimPosY = 0,
        this.prevAnimPosY = 0,
        this.idleAnimation = r.to(this.plane, {
            duration: .9,
            repeat: -1,
            ease: "power1.inOut",
            yoyo: !0,
            yoyoEase: !0,
            pixi: {
                y: this.startAnimPosY + 5
            },
            onUpdate: () => {
                if (!this.plane)
                    return;
                this.airBag && !this.airBag?.playing && (this.airBag.visible = !0,
                this.airBag.gotoAndPlay(0));
                const i = Math.round(this.plane.y);
                this.prevAnimPosY = i,
                this.isPrepared && i === Math.round(this.startAnimPosY) && (this.plane.y = this.startAnimPosY,
                this.idleAnimation && (this.idleAnimation.kill(),
                this.idleAnimation = null))
            }
        }),
        r.to(this.shadow, {
            duration: .9,
            repeat: -1,
            ease: "power1.inOut",
            yoyo: !0,
            yoyoEase: !0,
            pixi: {
                scale: 1.03
            }
        }, "<")
    }
    async addShadow() {
        const r = this.planeManager.shadowUrl
          , i = await ht(r);
        if (!i)
            return;
        const n = new at(i);
        n.anchor.set(.5, 1),
        this.shadow.removeChildren(),
        this.shadow.alpha = this.planeSettings?.shadow.alpha || 1,
        this.shadow.addChild(n),
        this.bottom.addChild(this.shadow)
    }
    setPosition() {
        const r = ri(A.height, A.breakpoint);
        this.initPosY = r.groundPosY - this.planeWrapper.height * A.scale / 2 + 8 * A.scale,
        this.x = (A.width - r.rightOffset) / 2,
        this.y = this.initPosY
    }
    getFlyingPosition() {
        return -((this.initPosY + ri(A.height, A.breakpoint).planeFlightPosY) / A.scale)
    }
    getPlaneGlobalTop() {
        return this.planeWrapper.getBounds().top
    }
    async addExplosion() {
        const r = await ht(A.assetsUrls.explosion);
        if (!r)
            return;
        const {animations: i={}} = r.data
          , n = Object.keys(i)[0];
        this.explosion = Le.fromFrames(i[n]),
        this.explosion.anchor.set(.5, .5),
        this.explosion.loop = !1,
        this.explosion.visible = !1,
        this.explosion.animationSpeed = Mr.explosionAnimationSpeed,
        this.explosion.zIndex = 3,
        this.addChild(this.explosion),
        this.sortChildren()
    }
    scaleAssets(r) {
        this.scale.set(r)
    }
    takeOff(r) {
        if (this.state = nr.TAKING_OFF,
        setTimeout( () => {
            [nr.CRASHING, nr.CRASHED, nr.WAITING].includes(this.state) || r?.()
        }
        , 1200),
        A.mode === Je.LIGHT) {
            this.state = nr.FLYING;
            return
        }
        this.startTakeOffAnimation()
    }
    startTakeOffAnimation(r=0) {
        const i = ut.timeline();
        this.planeAnimation = i.to(this.planeWrapper, {
            duration: 3 - r,
            ease: Ew.easeInOut,
            pixi: {
                y: this.heightAboutGround,
                angle: -(this.planeSettings?.flyingAngle || 5.74)
            },
            onComplete: () => {
                this.state = nr.FLYING,
                this.idleAnimation && (this.idleAnimation.kill(),
                this.idleAnimation = null)
            }
        }).to(this.bottom, {
            duration: Math.max(1.5 - r, 0),
            ease: Ew.easeIn,
            pixi: {
                scale: .4,
                alpha: 0
            },
            onComplete: () => {
                this.bottom.visible = !1,
                this.airBag?.gotoAndStop(0)
            }
        }, "<"),
        this.plane?.parts?.hasWheels && (this.foldWheelsTimeout = setTimeout( () => {
            this.plane?.hideWheels()
        }
        , 1e3)),
        this.flyAnimTimeout = setTimeout( () => {
            this.plane?.startFlyAnim()
        }
        , 2e3)
    }
    crash(r) {
        this.state = nr.CRASHING,
        ut.killTweensOf(this.planeWrapper),
        this.explosion && (this.explosion.visible = !0,
        this.explosion.y = this.planeWrapper.y,
        this.explosion.gotoAndPlay(0)),
        this.bottom.visible = !1,
        this.airBag?.stop(),
        ut.to(this.planeWrapperAlpha, {
            duration: .16,
            repeat: 0,
            alpha: 0
        }),
        setTimeout( () => {
            this.state = nr.CRASHED,
            this.explosion && (this.explosion.visible = !1,
            this.explosion.stop()),
            this.visible = !1,
            r?.()
        }
        , 1e3)
    }
    async land(r) {
        this.state = nr.LANDED,
        this.planeWrapperAlpha.alpha = Mr.phantomAlpha,
        this.bottom.visible = !1,
        this.airBag?.stop(),
        this.phantomPlane && (this.phantomPlane.x = this.planeWrapper.x,
        this.phantomPlane.y = this.planeWrapper.y,
        this.phantomPlane.angle = this.planeWrapper.angle,
        this.plane?.flyAnim?.playing && this.phantomPlane?.startFlyAnim(this.plane?.flyAnim),
        this.addChild(this.phantomPlane),
        ut.to(this.phantomPlane, {
            duration: 1.3,
            repeat: 0,
            ease: xw.easeIn,
            pixi: {
                y: 300,
                x: 650
            },
            onComplete: () => {
                this.phantomPlane && (this.phantomPlane.visible = !1),
                r?.()
            }
        }),
        ut.to(this.phantomPlane, {
            duration: 1.3,
            repeat: 0,
            ease: xw.easeOut,
            pixi: {
                angle: Mr.landingAngle
            }
        }))
    }
    setFlightState() {
        const {flyingAngle: r=5.74} = this.planeSettings || {};
        this.isPrepared = !0,
        this.planeWrapper.angle = -r,
        this.planeWrapper.y = this.heightAboutGround,
        this.plane?.startup(!0),
        this.plane?.hideWheels(!0),
        this.plane?.startFlyAnim(),
        this.bottom.visible = !1
    }
    isWaiting() {
        return this.state === nr.WAITING
    }
    reset() {
        this.state = nr.WAITING,
        this.isPrepared = !1,
        ut.killTweensOf(this.planeWrapper),
        ut.killTweensOf(this.planeWrapperAlpha),
        ut.killTweensOf(this.shadow),
        ut.killTweensOf(this.bottom),
        this.airBag && ut.killTweensOf(this.airBag),
        this.plane && ut.killTweensOf(this.plane),
        this.idleAnimation && (this.idleAnimation = null),
        A.mode === Je.FULL && (this.bottom.y = this.planeWrapper.height / 2,
        this.bottom.visible = !0,
        this.bottom.scale.set(1),
        this.bottom.alpha = 1,
        this.shadow.alpha = this.planeSettings?.shadow.alpha || 1,
        this.shadow.scale.set(1),
        this.airBag && (this.airBag.visible = !0,
        this.airBag.alpha = 1),
        this.planeWrapper.y = this.planeSettings?.y || 0,
        this.planeWrapper.angle = 0,
        this.planeSettings?.parts.airBag && this.startIdleAnimation(),
        this.foldWheelsTimeout && (clearTimeout(this.foldWheelsTimeout),
        this.foldWheelsTimeout = null),
        this.flyAnimTimeout && (clearTimeout(this.flyAnimTimeout),
        this.flyAnimTimeout = null)),
        this.visible = !0,
        this.planeWrapper.visible = !0,
        this.planeWrapper.x = 0,
        this.planeWrapperAlpha.alpha = 1,
        this.plane?.reset(),
        this.setPosition(),
        this.phantomPlane && (this.removeChild(this.phantomPlane),
        this.phantomPlane.visible = !0)
    }
    prepare() {
        this.isPrepared = !0,
        this.plane?.startup(!1)
    }
    resize(r, i, n) {
        if (this.scaleAssets(n),
        this.setPosition(),
        this.heightAboutGround = this.getFlyingPosition(),
        this.planeAnimation?.isActive()) {
            const s = this.planeAnimation.totalTime();
            this.planeAnimation.kill(),
            this.startTakeOffAnimation(s)
        } else
            [nr.WAITING, nr.TAKING_OFF].includes(this.state) || (this.planeWrapper.y = this.heightAboutGround)
    }
    update() {
        if (this.bottom.visible) {
            const r = Rr.getBackgroundLayer()?.y;
            r && (this.bottom.y = this.planeWrapper.height / 2 + r)
        }
    }
}
const Zw = 10
  , Qw = 50
  , Jw = [40, 32]
  , TX = [83, 67]
  , tA = [48, 38]
  , SX = 40
  , wX = 500
  , eA = 1.45
  , AX = e => {
    const t = []
      , r = e[0];
    if (r) {
        t.push(r);
        const i = e.find(n => !qO(n, r));
        i && t.push(i)
    }
    return t
}
;
class bX extends J {
    constructor() {
        super();
        b(this, "initialTimeout");
        b(this, "initialShowPLayerTimeouts", []);
        b(this, "planes");
        b(this, "textScale");
        b(this, "allPlayers", []);
        b(this, "activePlayers", []);
        b(this, "explosions", []);
        this.planes = [],
        this.textScale = Math.min(A.scale, eA),
        this.y = -A.height,
        this.addExplosion()
    }
    renderInitialPlayers(r=!1) {
        this.initialTimeout = setTimeout( () => {
            He.getState().roundState === Kr.RUN && (this.allPlayers = He.getState().playerBets.filter( ({status: s}) => s !== QE.CASHOUT),
            this.activePlayers = AX(this.allPlayers),
            this.activePlayers.forEach( (s, o) => {
                this.initialShowPLayerTimeouts.push(setTimeout( () => {
                    this.activePlayers[o] && this.addPlayer(this.activePlayers[o], o)
                }
                , wX * o))
            }
            ))
        }
        , r ? 0 : 3e3)
    }
    onStoreUpdate(r) {
        if (!r.playerBets.length || !this.allPlayers.length)
            return;
        const i = r.playerBets.filter( ({status: s}) => s === QE.CASHOUT);
        if (!i.length)
            return;
        const n = i.map( ({betId: s}) => s);
        this.allPlayers = this.allPlayers.filter( ({betId: s}) => !n.includes(s)),
        i.forEach(s => {
            this.activePlayers.forEach( (o, a) => {
                s.betId === o?.betId && this.cashout(s, a)
            }
            )
        }
        )
    }
    calculatePositions(r) {
        const i = ri(A.height, A.breakpoint).players;
        let n = i.posX
          , s = i.posY;
        return r === 1 && (n += Qw * A.scale,
        s += i.gapY * A.scale + this.planes[0].height),
        {
            x: n,
            y: s
        }
    }
    async addPlayer(r, i) {
        if (!(He.getState().roundState === Kr.RUN))
            return;
        const {gamePlayersLvl: o, gamePlayersSkinId: a} = Yu()
          , l = o ? String(o).split(",") : null
          , h = a ? String(a).split(",") : null
          , u = Number(l?.length ? l[i] || l[0] : r?.nftSelectedLevel || r?.nftLevel) || 1
          , c = r?.nftMeta
          , d = h?.length ? h[i] || h[0] : r.skinId;
        let f;
        d && r.skinRarity === Ar.SKIN_RARITY_LEGENDARY && (f = await ht(i2(d)));
        const g = new dy({
            level: u,
            meta: c,
            skinId: d,
            skinRarity: r.skinRarity,
            customSettigs: f
        })
          , {plane: p} = await g.loadTextures()
          , v = new cy({
            level: u,
            texture: p,
            isRunning: !0,
            meta: c,
            skinId: d,
            skinRarity: r.skinRarity,
            customSettigs: f
        })
          , y = new J;
        y.name = `Player ${i + 1}`,
        y.addChild(v),
        v.angle = -Mr.planes[`level${u}`].flyingAngle,
        this.planes[i] = y,
        this.setScaleAndPosition(y, i);
        const m = y.y;
        y.y = 0,
        this.addChild(y),
        ut.to(y, {
            duration: 1,
            repeat: 0,
            ease: wg.easeOut,
            pixi: {
                y: m
            },
            onComplete: () => {
                v.startFlyAnim()
            }
        })
    }
    setScaleAndPosition(r, i) {
        const s = Jw[i] / ay * A.scale
          , o = r.children[0]
          , a = TX[i]
          , l = tA[i];
        o.scale.set(s);
        const h = ri(A.height, A.breakpoint).players;
        let u = h.posX + a * A.scale / 2
          , c = h.posY + l * A.scale / 2;
        i === 1 && (u += Qw * A.scale,
        c += (h.gapY + tA[0]) * A.scale),
        r.x = u,
        r.y = c
    }
    async addExplosion() {
        const r = await ht(A.assetsUrls.explosion);
        if (!r)
            return;
        const {animations: i={}} = r.data
          , n = Object.keys(i)[0];
        this.explosions = Array.from({
            length: 2
        }, () => {
            const s = Le.fromFrames(i[n]);
            return s.anchor.set(.5, .5),
            s.loop = !1,
            s.visible = !1,
            s.animationSpeed = Mr.explosionAnimationSpeed,
            s.zIndex = 3,
            s
        }
        ),
        this.addChild(...this.explosions),
        this.sortChildren()
    }
    cashout(r, i) {
        this.activePlayers[i] = null,
        this.landPlayer({
            num: i,
            nftName: r.nftName,
            winAmount: UW(r.amount || 0, r.odds)
        }, () => {
            setTimeout( () => {
                const s = He.getState().roundState === Kr.RUN;
                if (!this.allPlayers.length || !s)
                    return;
                const o = this.activePlayers.map(h => h?.betId)
                  , l = this.allPlayers.filter( ({betId: h}) => ![r.betId, ...o].includes(h)).find(h => !this.activePlayers.some(u => qO(h, u)));
                if (l) {
                    this.activePlayers[i] = l;
                    const h = this.children.filter(u => u.name === `Player ${i + 1}`);
                    this.removeChild(...h),
                    this.addPlayer(l, i)
                }
            }
            , 100)
        }
        )
    }
    landPlayer({num: r, nftName: i, winAmount: n}, s) {
        if (!this.planes[r])
            return;
        const o = this.planes[r].position;
        this.showParticipantInfo({
            positionX: o.x,
            positionY: o.y,
            nftName: i,
            winAmount: n
        });
        const a = ut.timeline();
        Ft.isNew() && Ft.playerLand(),
        a.to(this.planes[r].children[0], {
            duration: 2,
            repeat: 0,
            ease: Tw.easeOut,
            pixi: {
                angle: SX
            },
            onComplete: () => {
                this.removeChild(this.planes[r]),
                s?.()
            }
        }).to(this.planes[r], {
            duration: 2,
            repeat: 0,
            ease: Tw.easeOut,
            pixi: {
                y: A.height * 1.5 + Jw[r],
                x: A.width / 2
            }
        }, "<")
    }
    showParticipantInfo({positionX: r, positionY: i, nftName: n, winAmount: s}) {
        const o = _v()
          , a = kU(o.formatMessage({
            id: "participant-name.anonymous"
        }))
          , l = new J;
        l.scale.set(this.textScale);
        const h = new Li({
            fontFamily: "Rubik",
            fontSize: 12 * this.textScale,
            lineHeight: 18 * this.textScale,
            fontWeight: "500",
            fill: "#ffffff",
            align: "left"
        })
          , u = n || a
          , c = u.length > Zw ? `${u.substring(0, Zw).trim()}…` : u
          , d = new Oo(c,h);
        d.position.y = 0,
        d.alpha = .6,
        d.scale.set(1 / this.textScale);
        const f = new Oo(`+${s}`,{
            ...h,
            fill: "#a8d080"
        });
        f.scale.set(1 / this.textScale),
        f.y = d.height - 5,
        l.addChild(d),
        l.addChild(f),
        l.position.x = r,
        l.position.y = i + A.scale * 30,
        l.alpha = 0,
        l.pivot.x = l.width / 2 / this.textScale,
        l.pivot.y = l.height / 2 / this.textScale,
        this.addChild(l),
        ut.to(l, {
            duration: .2,
            repeat: 0,
            ease: wg.easeIn,
            pixi: {
                y: i,
                alpha: 1
            }
        }),
        ut.to(l, {
            delay: 1.5,
            duration: .2,
            repeat: 0,
            ease: wg.easeOut,
            pixi: {
                alpha: 0
            },
            onComplete: () => {
                this.removeChild(l)
            }
        })
    }
    crash() {
        !!this.explosions?.length && (this.planes.forEach( (i, n) => {
            i && (ut.killTweensOf(i),
            this.explosions[n].x = i.x,
            this.explosions[n].y = i.y,
            this.explosions[n].scale.set(i.children[0].scale.x, i.children[0].scale.y),
            this.explosions[n].visible = !0,
            this.explosions[n].gotoAndPlay(0),
            ut.to(this.planes[n], {
                duration: .16,
                repeat: 0,
                alpha: 0
            }))
        }
        ),
        setTimeout( () => {
            this.planes.forEach( (i, n) => {
                i && (this.explosions[n].visible = !1,
                this.explosions[n].stop())
            }
            ),
            this.visible = !1
        }
        , 1e3))
    }
    reset() {
        this.initialTimeout && clearTimeout(this.initialTimeout),
        this.initialShowPLayerTimeouts.length && (this.initialShowPLayerTimeouts.forEach(r => {
            clearTimeout(r)
        }
        ),
        this.initialShowPLayerTimeouts = []),
        this.planes.length && (this.removeChild(...this.planes),
        this.planes = []),
        this.visible = !0,
        this.allPlayers = [],
        this.activePlayers = []
    }
    scaleAssets() {
        this.planes.forEach( (r, i) => {
            this.setScaleAndPosition(r, i)
        }
        )
    }
    resize(r, i, n) {
        this.y = -i,
        this.scaleAssets(),
        this.textScale = Math.min(n, eA)
    }
}
const c2 = 700
  , gn = "[GAME SCENE]"
  , CX = c2 + 1200
  , PX = 500
  , IX = 30;
class fy extends J {
    constructor() {
        super();
        b(this, "isPrepared", !1);
        b(this, "isStarted", !1);
        b(this, "bigWinContainer");
        b(this, "plane");
        b(this, "activePlaneNFT");
        b(this, "backgroundLayer");
        b(this, "backgroundLayerLight");
        b(this, "players");
        b(this, "takeOfTimer", null);
        this.y = A.height,
        A.mode === Je.FULL ? (this.backgroundLayer = new oX,
        this.addChild(this.backgroundLayer)) : (this.backgroundLayerLight = new uX,
        this.addChild(this.backgroundLayerLight)),
        this.players = new bX,
        this.addChild(this.players);
        const r = He.getState()
          , i = Ft.isNew();
        if (this.renderPlane(),
        i && r.isPreparing && (Ft.startMusic(r.preparingTime ? r.preparingTime / 1e3 : 0),
        logger.info(`preparing from init ${new Date().toISOString()}`, {
            prefix: gn
        })),
        r.roundState === Kr.RUN) {
            const {odds: n} = zf.getState();
            n && this.setRunning(n)
        }
        this.bigWinContainer = new S9,
        this.addChild(this.bigWinContainer)
    }
    onStoreUpdate(r, i) {
        const n = Ft.isNew();
        if (r.roundState && r.roundState !== i.roundState && (r.roundState === Kr.PREPARE || (r.roundState === Kr.START ? this.startGame() : r.roundState === Kr.FINISH && this.finishGame()),
        logger.info(`${r.roundState} ${new Date().toISOString()}`, {
            prefix: gn
        })),
        !r.roundState && i.roundState && (this.resetGame(),
        logger.info(`reset ${new Date().toISOString()}`, {
            prefix: gn
        })),
        r.cashoutBets.length && !V0(r.cashoutBets, i.cashoutBets)) {
            const s = r.cashoutBets[r.cashoutBets.length - 1];
            this.cashout({
                odds: s.odds,
                withLanding: r.cashoutBets.length >= r.myBetIds.length,
                winAmount: s.winAmount
            })
        }
        n && (r.isPreparing && !i.isPreparing ? (Ft.startMusic(r.preparingTime ? r.preparingTime / 1e3 : 0),
        logger.info(`preparing ${new Date().toISOString()}`, {
            prefix: gn
        })) : !r.isPreparing && i.isPreparing && Ft.prepare(),
        r.bgMusic !== i.bgMusic && this.onBgMusicChange(r.bgMusic)),
        this.players.onStoreUpdate(r)
    }
    onOddsUpdate(r) {
        const {odds: i=0} = r
          , {roundState: n, isFlyingHigh: s} = He.getState();
        n !== Kr.RUN && i && (He.setState({
            roundState: Kr.RUN
        }),
        this.isStarted || (logger.info(`not started yet, set is running ${new Date().toISOString()}`, {
            prefix: gn
        }),
        this.setRunning(i))),
        !s && i > i9 && (He.setState({
            isFlyingHigh: !0
        }),
        Ft.flyingHigh(),
        logger.info(`flying high ${new Date().toISOString()}`, {
            prefix: gn
        })),
        this.bigWinContainer?.onOddsUpdate(r)
    }
    async renderPlane() {
        const i = He.getState().activePlane || {
            level: 1
        };
        if (s9(this.activePlaneNFT, i))
            return;
        this.activePlaneNFT = i;
        const n = i.level || 1;
        this.plane ? this.plane.initPlane({
            level: n,
            meta: i.meta,
            skinId: i.skinId,
            skinRarity: i.skinRarity
        }) : (this.plane = new EX({
            level: n,
            meta: i.meta,
            skinId: i.skinId,
            skinRarity: i.skinRarity
        }),
        this.addChild(this.plane)),
        Rr.setUserPlane(this.plane),
        this.sortChildren()
    }
    resize(r, i, n) {
        this.y = i,
        this.backgroundLayer?.resize(r, i, n),
        this.backgroundLayerLight?.resize(r, i),
        this.plane?.resize(r, i, n),
        this.players.resize(r, i, n)
    }
    resetGame() {
        this.isStarted = !1,
        this.backgroundLayer?.reset(),
        this.plane?.reset(),
        this.players.reset(),
        He.setState({
            cashoutBets: [],
            playerBets: [],
            isFlyingHigh: !1
        })
    }
    prepareGame() {
        this.isPrepared = !0,
        Ft.prepare(),
        this.plane?.prepare()
    }
    startGame() {
        const r = Ft.isNew();
        r ? this.plane?.prepare() : this.isPrepared || this.prepareGame(),
        this.isStarted = !0,
        this.isPrepared = !1,
        Ft.start(r ? 5 : 0);
        let i = ZO(this.plane?.level || 1);
        this.plane?.plane?.hasPropeller !== void 0 ? i = !!this.plane?.plane?.hasPropeller : this.plane?.skinRarity === Ar.SKIN_RARITY_LEGENDARY && (i = !1),
        r && this.plane && i && Ft.takeOff(),
        this.backgroundLayer?.takingOff(),
        this.takeOfTimer = setTimeout( () => {
            r ? this.plane && !i && Ft.takeOff() : Ft.takeOff(),
            this.plane?.takeOff( () => {
                this.backgroundLayer?.flying(),
                this.players.renderInitialPlayers()
            }
            )
        }
        , c2)
    }
    setRunning(r) {
        const i = Ft.isNew();
        logger.info(`running from: ${r} ${new Date().toISOString()}`, {
            prefix: gn
        }),
        this.isStarted = !0;
        const n = KS(r);
        if (Ft.running(n / 1e3 + (i ? 5 : 0)),
        this.players.renderInitialPlayers(!0),
        A.mode === Je.LIGHT)
            return;
        const s = Math.max(0, (n - CX) / PX * IX);
        this.backgroundLayer?.changePosition(s),
        this.plane?.setFlightState(),
        this.backgroundLayer?.flying()
    }
    onBgMusicChange(r) {
        const {odds: i} = zf.getState()
          , n = i ? KS(i) : 0;
        Ft.changeBgMusic(r),
        logger.info(`bg music change: ${r}, start ${n} ${new Date().toISOString()}`, {
            prefix: gn
        })
    }
    finishGame() {
        this.backgroundLayer?.stop(),
        this.backgroundLayer?.finish();
        const r = () => {
            Ft.afterCrash(),
            this.resetGame(),
            this.renderPlane()
        }
        ;
        this.takeOfTimer && (clearTimeout(this.takeOfTimer),
        this.takeOfTimer = null),
        Ft.crash(),
        this.players?.crash(),
        this.plane ? this.plane.crash(r) : r()
    }
    cashout({odds: r, withLanding: i, winAmount: n}) {
        const s = Ft.isNew();
        r >= la[Vt.BIG] ? this.bigWinContainer.showWin({
            odds: r,
            winAmount: n
        }) : s ? Ft.cashout() : Ft.land(),
        i && (s && Ft.land(),
        this.plane?.land()),
        logger.info(`cashout odds: ${r} ${new Date().toISOString()}`, {
            prefix: gn
        })
    }
    update(r) {
        this.plane?.update(),
        this.backgroundLayer?.update(r)
    }
}
b(fy, "assetBundlesByMode", {
    [Je.FULL]: {
        main: ["game"],
        preload: ["game-more"]
    },
    [Je.LIGHT]: {
        preload: ["light-game"]
    }
});
class RX {
    constructor() {
        b(this, "storeSubscr");
        b(this, "oddsSubscr");
        this.onStoreUpdate && (this.storeSubscr = He.subscribe(this.onStoreUpdate.bind(this))),
        this.onOddsUpdate && (this.oddsSubscr = zf.subscribe(this.onOddsUpdate.bind(this)))
    }
    storeUnsubscribe() {
        this.storeSubscr?.()
    }
    oddsUnsubscribe() {
        this.oddsSubscr?.()
    }
}
const MX = async () => {
    let e;
    return await y2( () => import("./gamestats.module-c8f0d36f.js"), []).then( ({default: t}) => {
        e = new t,
        e.dom.style.top = "0%",
        e.dom.style.left = "0%",
        document.body.appendChild(e.dom)
    }
    ),
    e
}
  , Qc = "[GAME]";
class OX extends RX {
    constructor() {
        super();
        b(this, "scene");
        b(this, "assets", {});
        b(this, "assetsUrls");
        b(this, "stats");
        b(this, "mode");
        b(this, "reskin");
        b(this, "width", 0);
        b(this, "height", 0);
        b(this, "diagonal", 0);
        b(this, "scale", 0);
        b(this, "breakpoint");
        b(this, "isMobile", !1);
        b(this, "isActiveTab", !document.hidden);
        const r = lu();
        this.isMobile = r.common.includes(jS.DOWN_SM),
        this.breakpoint = r.main,
        console.log(`${Qc}: inited`, {
            isMobile: this.isMobile,
            breakpoint: this.breakpoint
        })
    }
    async showScene(r=!0) {
        const {mode: i} = He.getState()
          , n = Yu();
        eh.setState({
            isGameLoading: !0
        }),
        this.mode = i,
        this.assetsUrls = YO(),
        this.reskin = XO();
        const s = fy.assetBundlesByMode[i];
        try {
            const o = r9(s?.main || [], a => {
                eh.setState({
                    progress: a * 100
                })
            }
            );
            s.preload && vt.backgroundLoadBundle(s.preload),
            await o,
            Hw(this.isMobile),
            this.scene = new fy,
            console.log(`${Qc}: scene created`),
            r && Lo.ticker.add(a => this.update(a)),
            Lo.stage.addChild(this.scene),
            eh.setState({
                isGameLoaded: !0,
                isGameLoading: !1
            }),
            !this.stats && n.stats && (this.stats = await MX())
        } catch (o) {
            eh.setState({
                isGameLoaded: !0,
                isGameLoading: !1
            }),
            console.error(`${Qc}: show scene error`, o)
        }
    }
    resize(r, i) {
        this.width = r,
        this.height = i,
        this.diagonal = Math.sqrt(r ** 2 + i ** 2);
        const n = lu()
          , s = n.common.includes(jS.DOWN_SM);
        s !== this.isMobile && (console.log(`${Qc}: reinit fonts`, {
            isMobile: s,
            breakpoint: n
        }),
        Hw(s)),
        this.isMobile = s,
        this.breakpoint = n.main,
        this.scale = g9(r, i, this.breakpoint),
        this.scene?.resize?.(r, i, this.scale)
    }
    onStoreUpdate(r, i) {
        this.scene?.onStoreUpdate?.(r, i),
        r.mode !== i.mode && this.onModeChange()
    }
    onOddsUpdate(r, i) {
        this.scene?.onOddsUpdate?.(r, i)
    }
    async onModeChange() {
        this.scene?.destroy(),
        this.showScene(!1)
    }
    update(r) {
        this.stats && this.stats.begin(),
        this.scene?.update?.(r),
        this.stats && this.stats.end()
    }
    visibilityChange(r) {
        this.isActiveTab = !r,
        this.scene?.visibilityChange?.(r)
    }
}
const A = new OX
  , Yn = He.getState()
  , NX = zf.getState()
  , pK = Yn.setMyBetIds
  , mK = Yn.cashoutBet
  , gK = Yn.setPlayerBets
  , _K = Yn.setActivePlane
  , yK = Yn.setIsPreparing;
Yn.setUserCurrency;
const vK = Yn.setMode
  , xK = Yn.setBgMusic
  , C1 = Yn.setRoundState
  , EK = NX.setOdds
  , TK = () => i1(e => e.isGameLoaded)
  , SK = () => i1(e => e.isGameLoading)
  , wK = () => i1(e => e.progress)
  , AK = () => {
    C1(Kr.START)
}
  , bK = () => {
    C1(Kr.FINISH)
}
  , CK = () => {
    C1(void 0)
}
;
let rA = !1;
const Lo = new Ox({
    resolution: window.devicePixelRatio || 1,
    antialias: !1,
    autoDensity: !0,
    backgroundColor: "#090f3f"
})
  , d2 = () => {
    const {width: e, height: t} = mW();
    Lo.renderer.resize(e, t),
    A.resize(e, t)
}
  , LX = qB(300, d2)
  , DX = async () => {
    A.visibilityChange(document.hidden)
}
  , PK = async () => {
    if (rA)
        return;
    rA = !0;
    const {pixiDevtools: e} = Yu();
    document.getElementById("game")?.prepend(Lo.view),
    window.addEventListener("resize", LX),
    document.addEventListener("visibilitychange", DX),
    ut.registerPlugin(oy),
    oy.registerPIXI(g7),
    await e9(),
    d2(),
    await A.showScene(),
    e && (window.__PIXI_APP__ = Lo)
}
;
export {xY as $, sY as A, NB as B, DY as C, _p as D, ci as E, Md as F, rY as G, Fn as H, BT as I, $X as J, OY as K, me as L, HB as M, zX as N, jY as O, nY as P, FB as Q, QX as R, zB as S, UB as T, qB as U, FY as V, Rd as W, qC as X, kB as Y, RB as Z, y2 as _, VL as a, qX as a$, ZC as a0, kX as a1, FX as a2, IH as a3, L5 as a4, ot as a5, UX as a6, U as a7, sK as a8, lu as a9, Yu as aA, yY as aB, Ar as aC, _o as aD, tT as aE, ce as aF, WB as aG, LY as aH, WR as aI, QE as aJ, gv as aK, kU as aL, Px as aM, UW as aN, LR as aO, DR as aP, BR as aQ, ye as aR, GY as aS, UY as aT, Pg as aU, YX as aV, EK as aW, AK as aX, bK as aY, CK as aZ, rH as a_, kR as aa, kp as ab, wY as ac, fK as ad, xr as ae, TY as af, Xa as ag, bY as ah, AW as ai, V0 as aj, Yo as ak, KX as al, Je as am, eK as an, rK as ao, Am as ap, zR as aq, VX as ar, JE as as, BY as at, FW as au, jR as av, mK as aw, la as ax, Vt as ay, hK as az, mH as b, tK as b$, DB as b0, gY as b1, aY as b2, SH as b3, _Y as b4, JX as b5, tY as b6, jX as b7, eY as b8, dK as b9, QY as bA, PY as bB, wK as bC, TK as bD, CY as bE, wH as bF, WX as bG, ZY as bH, hY as bI, WY as bJ, pY as bK, GX as bL, _K as bM, yK as bN, PK as bO, vK as bP, xK as bQ, pK as bR, gK as bS, SK as bT, VY as bU, KY as bV, XY as bW, IY as bX, ZS as bY, eT as bZ, bH as b_, XX as ba, yW as bb, cn as bc, HY as bd, uK as be, Af as bf, bm as bg, Cm as bh, lY as bi, SY as bj, fY as bk, $h as bl, RY as bm, cK as bn, KS as bo, ZX as bp, kW as bq, AY as br, EY as bs, oY as bt, oK as bu, cY as bv, uY as bw, QC as bx, dY as by, vY as bz, rh as c, $Y as c0, mY as c1, ek as c2, iK as c3, zY as c4, Z as c5, aK as c6, lK as c7, kY as c8, yH as d, JY as e, HX as f, hl as g, yv as h, QB as i, Mu as j, Cp as k, CH as l, jP as m, NY as n, MY as o, LB as p, YY as q, ae as r, eD as s, qY as t, nK as u, $v as v, AH as w, iY as x, _c as y, BB as z};
//# sourceMappingURL=game-725de4f9.js.map
